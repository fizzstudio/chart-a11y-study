var xhtml = "http://www.w3.org/1999/xhtml";

const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name;
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function selection_selectAll(select) {
  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant(x) {
  return function() {
    return x;
  };
}

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);
    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
      exit[i] = node;
    }
  }
}

function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) { data[++j] = d; });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

function selection_exit() {
  return new Selection(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null) update = onupdate(update);
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(selection) {

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() { nodes[++i] = this; });
  return nodes;
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  var size = 0;
  this.each(function() { ++size; });
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)
      : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove : typeof value === "function"
            ? styleFunction
            : styleConstant)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction
          : textConstant)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

var filterEvents = {};

var event = null;

if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = {mouseenter: "mouseover", mouseleave: "mouseout"};
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function(event) {
    var related = event.relatedTarget;
    if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function(event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).
    event = event1;
    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, capture: capture};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));
  return this;
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

var root = [null];

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection([[document.querySelector(selector)]], [document.documentElement])
      : new Selection([[selector]], root);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire();
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var visaChartsUtils_umd = createCommonjsModule(function (module, exports) {
(function (global, factory) {
    module.exports = factory() ;
}(commonjsGlobal, (function () {
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";
    var namespaces = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace (name) {
        var prefix = name += "", i = prefix.indexOf(":");
        if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
            name = name.slice(i + 1);
        return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
    }

    function creatorInherit(name) {
        return function () {
            var document = this.ownerDocument, uri = this.namespaceURI;
            return uri === xhtml && document.documentElement.namespaceURI === xhtml
                ? document.createElement(name)
                : document.createElementNS(uri, name);
        };
    }
    function creatorFixed(fullname) {
        return function () {
            return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
    }
    function creator (name) {
        var fullname = namespace(name);
        return (fullname.local
            ? creatorFixed
            : creatorInherit)(fullname);
    }

    function none() { }
    function selector (selector) {
        return selector == null ? none : function () {
            return this.querySelector(selector);
        };
    }

    function selection_select (select) {
        if (typeof select !== "function")
            select = selector(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                }
            }
        }
        return new Selection(subgroups, this._parents);
    }

    function empty() {
        return [];
    }
    function selectorAll (selector) {
        return selector == null ? empty : function () {
            return this.querySelectorAll(selector);
        };
    }

    function selection_selectAll (select) {
        if (typeof select !== "function")
            select = selectorAll(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    subgroups.push(select.call(node, node.__data__, i, group));
                    parents.push(node);
                }
            }
        }
        return new Selection(subgroups, parents);
    }

    function matcher (selector) {
        return function () {
            return this.matches(selector);
        };
    }

    function selection_filter (match) {
        if (typeof match !== "function")
            match = matcher(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Selection(subgroups, this._parents);
    }

    function sparse (update) {
        return new Array(update.length);
    }

    function selection_enter () {
        return new Selection(this._enter || this._groups.map(sparse), this._parents);
    }
    function EnterNode(parent, datum) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum;
    }
    EnterNode.prototype = {
        constructor: EnterNode,
        appendChild: function (child) { return this._parent.insertBefore(child, this._next); },
        insertBefore: function (child, next) { return this._parent.insertBefore(child, next); },
        querySelector: function (selector) { return this._parent.querySelector(selector); },
        querySelectorAll: function (selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant (x) {
        return function () {
            return x;
        };
    }

    var keyPrefix = "$"; // Protect against keys like “__proto__”.
    function bindIndex(parent, group, enter, update, exit, data) {
        var i = 0, node, groupLength = group.length, dataLength = data.length;
        // Put any non-null nodes that fit into update.
        // Put any null nodes into enter.
        // Put any remaining data into enter.
        for (; i < dataLength; ++i) {
            if (node = group[i]) {
                node.__data__ = data[i];
                update[i] = node;
            }
            else {
                enter[i] = new EnterNode(parent, data[i]);
            }
        }
        // Put any non-null nodes that don’t fit into exit.
        for (; i < groupLength; ++i) {
            if (node = group[i]) {
                exit[i] = node;
            }
        }
    }
    function bindKey(parent, group, enter, update, exit, data, key) {
        var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
        // Compute the key for each node.
        // If multiple nodes have the same key, the duplicates are added to exit.
        for (i = 0; i < groupLength; ++i) {
            if (node = group[i]) {
                keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);
                if (keyValue in nodeByKeyValue) {
                    exit[i] = node;
                }
                else {
                    nodeByKeyValue[keyValue] = node;
                }
            }
        }
        // Compute the key for each datum.
        // If there a node associated with this key, join and add it to update.
        // If there is not (or the key is a duplicate), add it to enter.
        for (i = 0; i < dataLength; ++i) {
            keyValue = keyPrefix + key.call(parent, data[i], i, data);
            if (node = nodeByKeyValue[keyValue]) {
                update[i] = node;
                node.__data__ = data[i];
                nodeByKeyValue[keyValue] = null;
            }
            else {
                enter[i] = new EnterNode(parent, data[i]);
            }
        }
        // Add any remaining nodes that were not bound to data to exit.
        for (i = 0; i < groupLength; ++i) {
            if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
                exit[i] = node;
            }
        }
    }
    function selection_data (value, key) {
        if (!value) {
            data = new Array(this.size()), j = -1;
            this.each(function (d) { data[++j] = d; });
            return data;
        }
        var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
        if (typeof value !== "function")
            value = constant(value);
        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
            var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
            bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
            // Now connect the enter nodes to their following update node, such that
            // appendChild can insert the materialized enter node before this node,
            // rather than at the end of the parent node.
            for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
                if (previous = enterGroup[i0]) {
                    if (i0 >= i1)
                        i1 = i0 + 1;
                    while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                        ;
                    previous._next = next || null;
                }
            }
        }
        update = new Selection(update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
    }

    function selection_exit () {
        return new Selection(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join (onenter, onupdate, onexit) {
        var enter = this.enter(), update = this, exit = this.exit();
        enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
        if (onupdate != null)
            update = onupdate(update);
        if (onexit == null)
            exit.remove();
        else
            onexit(exit);
        return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge (selection) {
        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Selection(merges, this._parents);
    }

    function selection_order () {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
            for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && node.compareDocumentPosition(next) ^ 4)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    }

    function selection_sort (compare) {
        if (!compare)
            compare = ascending;
        function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    sortgroup[i] = node;
                }
            }
            sortgroup.sort(compareNode);
        }
        return new Selection(sortgroups, this._parents).order();
    }
    function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call () {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
    }

    function selection_nodes () {
        var nodes = new Array(this.size()), i = -1;
        this.each(function () { nodes[++i] = this; });
        return nodes;
    }

    function selection_node () {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    }

    function selection_size () {
        var size = 0;
        this.each(function () { ++size; });
        return size;
    }

    function selection_empty () {
        return !this.node();
    }

    function selection_each (callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
                if (node = group[i])
                    callback.call(node, node.__data__, i, group);
            }
        }
        return this;
    }

    function attrRemove(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant(name, value) {
        return function () {
            this.setAttribute(name, value);
        };
    }
    function attrConstantNS(fullname, value) {
        return function () {
            this.setAttributeNS(fullname.space, fullname.local, value);
        };
    }
    function attrFunction(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, v);
        };
    }
    function attrFunctionNS(fullname, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttributeNS(fullname.space, fullname.local);
            else
                this.setAttributeNS(fullname.space, fullname.local, v);
        };
    }
    function selection_attr (name, value) {
        var fullname = namespace(name);
        if (arguments.length < 2) {
            var node = this.node();
            return fullname.local
                ? node.getAttributeNS(fullname.space, fullname.local)
                : node.getAttribute(fullname);
        }
        return this.each((value == null
            ? (fullname.local ? attrRemoveNS : attrRemove) : (typeof value === "function"
            ? (fullname.local ? attrFunctionNS : attrFunction)
            : (fullname.local ? attrConstantNS : attrConstant)))(fullname, value));
    }

    function defaultView (node) {
        return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
            || (node.document && node) // node is a Window
            || node.defaultView; // node is a Document
    }

    function styleRemove(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant(name, value, priority) {
        return function () {
            this.style.setProperty(name, value, priority);
        };
    }
    function styleFunction(name, value, priority) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, v, priority);
        };
    }
    function selection_style (name, value, priority) {
        return arguments.length > 1
            ? this.each((value == null
                ? styleRemove : typeof value === "function"
                ? styleFunction
                : styleConstant)(name, value, priority == null ? "" : priority))
            : styleValue(this.node(), name);
    }
    function styleValue(node, name) {
        return node.style.getPropertyValue(name)
            || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
        return function () {
            delete this[name];
        };
    }
    function propertyConstant(name, value) {
        return function () {
            this[name] = value;
        };
    }
    function propertyFunction(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                delete this[name];
            else
                this[name] = v;
        };
    }
    function selection_property (name, value) {
        return arguments.length > 1
            ? this.each((value == null
                ? propertyRemove : typeof value === "function"
                ? propertyFunction
                : propertyConstant)(name, value))
            : this.node()[name];
    }

    function classArray(string) {
        return string.trim().split(/^|\s+/);
    }
    function classList(node) {
        return node.classList || new ClassList(node);
    }
    function ClassList(node) {
        this._node = node;
        this._names = classArray(node.getAttribute("class") || "");
    }
    ClassList.prototype = {
        add: function (name) {
            var i = this._names.indexOf(name);
            if (i < 0) {
                this._names.push(name);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        remove: function (name) {
            var i = this._names.indexOf(name);
            if (i >= 0) {
                this._names.splice(i, 1);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        contains: function (name) {
            return this._names.indexOf(name) >= 0;
        }
    };
    function classedAdd(node, names) {
        var list = classList(node), i = -1, n = names.length;
        while (++i < n)
            list.add(names[i]);
    }
    function classedRemove(node, names) {
        var list = classList(node), i = -1, n = names.length;
        while (++i < n)
            list.remove(names[i]);
    }
    function classedTrue(names) {
        return function () {
            classedAdd(this, names);
        };
    }
    function classedFalse(names) {
        return function () {
            classedRemove(this, names);
        };
    }
    function classedFunction(names, value) {
        return function () {
            (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
        };
    }
    function selection_classed (name, value) {
        var names = classArray(name + "");
        if (arguments.length < 2) {
            var list = classList(this.node()), i = -1, n = names.length;
            while (++i < n)
                if (!list.contains(names[i]))
                    return false;
            return true;
        }
        return this.each((typeof value === "function"
            ? classedFunction : value
            ? classedTrue
            : classedFalse)(names, value));
    }

    function textRemove() {
        this.textContent = "";
    }
    function textConstant(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        };
    }
    function selection_text (value) {
        return arguments.length
            ? this.each(value == null
                ? textRemove : (typeof value === "function"
                ? textFunction
                : textConstant)(value))
            : this.node().textContent;
    }

    function htmlRemove() {
        this.innerHTML = "";
    }
    function htmlConstant(value) {
        return function () {
            this.innerHTML = value;
        };
    }
    function htmlFunction(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        };
    }
    function selection_html (value) {
        return arguments.length
            ? this.each(value == null
                ? htmlRemove : (typeof value === "function"
                ? htmlFunction
                : htmlConstant)(value))
            : this.node().innerHTML;
    }

    function raise() {
        if (this.nextSibling)
            this.parentNode.appendChild(this);
    }
    function selection_raise () {
        return this.each(raise);
    }

    function lower() {
        if (this.previousSibling)
            this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower () {
        return this.each(lower);
    }

    function selection_append (name) {
        var create = typeof name === "function" ? name : creator(name);
        return this.select(function () {
            return this.appendChild(create.apply(this, arguments));
        });
    }

    function constantNull() {
        return null;
    }
    function selection_insert (name, before) {
        var create = typeof name === "function" ? name : creator(name), select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
        return this.select(function () {
            return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        });
    }

    function remove() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    function selection_remove () {
        return this.each(remove);
    }

    function selection_cloneShallow() {
        var clone = this.cloneNode(false), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep() {
        var clone = this.cloneNode(true), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone (deep) {
        return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum (value) {
        return arguments.length
            ? this.property("__data__", value)
            : this.node().__data__;
    }

    var filterEvents = {};
    var event = null;
    if (typeof document !== "undefined") {
        var element = document.documentElement;
        if (!("onmouseenter" in element)) {
            filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
        }
    }
    function filterContextListener(listener, index, group) {
        listener = contextListener(listener, index, group);
        return function (event) {
            var related = event.relatedTarget;
            if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
                listener.call(this, event);
            }
        };
    }
    function contextListener(listener, index, group) {
        return function (event1) {
            var event0 = event; // Events can be reentrant (e.g., focus).
            event = event1;
            try {
                listener.call(this, this.__data__, index, group);
            }
            finally {
                event = event0;
            }
        };
    }
    function parseTypenames(typenames) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            return { type: t, name: name };
        });
    }
    function onRemove(typename) {
        return function () {
            var on = this.__on;
            if (!on)
                return;
            for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
                if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                    this.removeEventListener(o.type, o.listener, o.capture);
                }
                else {
                    on[++i] = o;
                }
            }
            if (++i)
                on.length = i;
            else
                delete this.__on;
        };
    }
    function onAdd(typename, value, capture) {
        var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
        return function (d, i, group) {
            var on = this.__on, o, listener = wrap(value, i, group);
            if (on)
                for (var j = 0, m = on.length; j < m; ++j) {
                    if ((o = on[j]).type === typename.type && o.name === typename.name) {
                        this.removeEventListener(o.type, o.listener, o.capture);
                        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                        o.value = value;
                        return;
                    }
                }
            this.addEventListener(typename.type, listener, capture);
            o = { type: typename.type, name: typename.name, value: value, listener: listener, capture: capture };
            if (!on)
                this.__on = [o];
            else
                on.push(o);
        };
    }
    function selection_on (typename, value, capture) {
        var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
        if (arguments.length < 2) {
            var on = this.node().__on;
            if (on)
                for (var j = 0, m = on.length, o; j < m; ++j) {
                    for (i = 0, o = on[j]; i < n; ++i) {
                        if ((t = typenames[i]).type === o.type && t.name === o.name) {
                            return o.value;
                        }
                    }
                }
            return;
        }
        on = value ? onAdd : onRemove;
        if (capture == null)
            capture = false;
        for (i = 0; i < n; ++i)
            this.each(on(typenames[i], value, capture));
        return this;
    }
    function customEvent(event1, listener, that, args) {
        var event0 = event;
        event1.sourceEvent = event;
        event = event1;
        try {
            return listener.apply(that, args);
        }
        finally {
            event = event0;
        }
    }

    function dispatchEvent(node, type, params) {
        var window = defaultView(node), event = window.CustomEvent;
        if (typeof event === "function") {
            event = new event(type, params);
        }
        else {
            event = window.document.createEvent("Event");
            if (params)
                event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
            else
                event.initEvent(type, false, false);
        }
        node.dispatchEvent(event);
    }
    function dispatchConstant(type, params) {
        return function () {
            return dispatchEvent(this, type, params);
        };
    }
    function dispatchFunction(type, params) {
        return function () {
            return dispatchEvent(this, type, params.apply(this, arguments));
        };
    }
    function selection_dispatch (type, params) {
        return this.each((typeof params === "function"
            ? dispatchFunction
            : dispatchConstant)(type, params));
    }

    var root = [null];
    function Selection(groups, parents) {
        this._groups = groups;
        this._parents = parents;
    }
    function selection() {
        return new Selection([[document.documentElement]], root);
    }
    Selection.prototype = selection.prototype = {
        constructor: Selection,
        select: selection_select,
        selectAll: selection_selectAll,
        filter: selection_filter,
        data: selection_data,
        enter: selection_enter,
        exit: selection_exit,
        join: selection_join,
        merge: selection_merge,
        order: selection_order,
        sort: selection_sort,
        call: selection_call,
        nodes: selection_nodes,
        node: selection_node,
        size: selection_size,
        empty: selection_empty,
        each: selection_each,
        attr: selection_attr,
        style: selection_style,
        property: selection_property,
        classed: selection_classed,
        text: selection_text,
        html: selection_html,
        raise: selection_raise,
        lower: selection_lower,
        append: selection_append,
        insert: selection_insert,
        remove: selection_remove,
        clone: selection_clone,
        datum: selection_datum,
        on: selection_on,
        dispatch: selection_dispatch
    };

    function select (selector) {
        return typeof selector === "string"
            ? new Selection([[document.querySelector(selector)]], [document.documentElement])
            : new Selection([[selector]], root);
    }

    function sourceEvent () {
        var current = event, source;
        while (source = current.sourceEvent)
            current = source;
        return current;
    }

    function point (node, event) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            point.x = event.clientX, point.y = event.clientY;
            point = point.matrixTransform(node.getScreenCTM().inverse());
            return [point.x, point.y];
        }
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }

    function mouse (node) {
        var event = sourceEvent();
        if (event.changedTouches)
            event = event.changedTouches[0];
        return point(node, event);
    }

    function selectAll (selector) {
        return typeof selector === "string"
            ? new Selection([document.querySelectorAll(selector)], [document.documentElement])
            : new Selection([selector == null ? [] : selector], root);
    }

    function touch (node, touches, identifier) {
        if (arguments.length < 3)
            identifier = touches, touches = sourceEvent().changedTouches;
        for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
                return point(node, touch);
            }
        }
        return null;
    }

    var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var uaParser = createCommonjsModule(function (module, exports) {
        /////////////////////////////////////////////////////////////////////////////////
        /* UAParser.js v0.7.31
           Copyright © 2012-2021 Faisal Salman <f@faisalman.com>
           MIT License */ /*
        Detect Browser, Engine, OS, CPU, and Device type/model from User-Agent data.
        Supports browser & node.js environment.
        Demo   : https://faisalman.github.io/ua-parser-js
        Source : https://github.com/faisalman/ua-parser-js */
        /////////////////////////////////////////////////////////////////////////////////
        (function (window, undefined$1) {
            //////////////
            // Constants
            /////////////
            var LIBVERSION = '0.7.31', EMPTY = '', UNKNOWN = '?', FUNC_TYPE = 'function', UNDEF_TYPE = 'undefined', OBJ_TYPE = 'object', STR_TYPE = 'string', MAJOR = 'major', MODEL = 'model', NAME = 'name', TYPE = 'type', VENDOR = 'vendor', VERSION = 'version', ARCHITECTURE = 'architecture', CONSOLE = 'console', MOBILE = 'mobile', TABLET = 'tablet', SMARTTV = 'smarttv', WEARABLE = 'wearable', EMBEDDED = 'embedded', UA_MAX_LENGTH = 255;
            var AMAZON = 'Amazon', APPLE = 'Apple', ASUS = 'ASUS', BLACKBERRY = 'BlackBerry', BROWSER = 'Browser', CHROME = 'Chrome', EDGE = 'Edge', FIREFOX = 'Firefox', GOOGLE = 'Google', HUAWEI = 'Huawei', LG = 'LG', MICROSOFT = 'Microsoft', MOTOROLA = 'Motorola', OPERA = 'Opera', SAMSUNG = 'Samsung', SONY = 'Sony', XIAOMI = 'Xiaomi', ZEBRA = 'Zebra', FACEBOOK = 'Facebook';
            ///////////
            // Helper
            //////////
            var extend = function (regexes, extensions) {
                var mergedRegexes = {};
                for (var i in regexes) {
                    if (extensions[i] && extensions[i].length % 2 === 0) {
                        mergedRegexes[i] = extensions[i].concat(regexes[i]);
                    }
                    else {
                        mergedRegexes[i] = regexes[i];
                    }
                }
                return mergedRegexes;
            }, enumerize = function (arr) {
                var enums = {};
                for (var i = 0; i < arr.length; i++) {
                    enums[arr[i].toUpperCase()] = arr[i];
                }
                return enums;
            }, has = function (str1, str2) {
                return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
            }, lowerize = function (str) {
                return str.toLowerCase();
            }, majorize = function (version) {
                return typeof (version) === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split('.')[0] : undefined$1;
            }, trim = function (str, len) {
                if (typeof (str) === STR_TYPE) {
                    str = str.replace(/^\s\s*/, EMPTY).replace(/\s\s*$/, EMPTY);
                    return typeof (len) === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
                }
            };
            ///////////////
            // Map helper
            //////////////
            var rgxMapper = function (ua, arrays) {
                var i = 0, j, k, p, q, matches, match;
                // loop through all regexes maps
                while (i < arrays.length && !matches) {
                    var regex = arrays[i], // even sequence (0,2,4,..)
                    props = arrays[i + 1]; // odd sequence (1,3,5,..)
                    j = k = 0;
                    // try matching uastring with regexes
                    while (j < regex.length && !matches) {
                        matches = regex[j++].exec(ua);
                        if (!!matches) {
                            for (p = 0; p < props.length; p++) {
                                match = matches[++k];
                                q = props[p];
                                // check if given property is actually array
                                if (typeof q === OBJ_TYPE && q.length > 0) {
                                    if (q.length === 2) {
                                        if (typeof q[1] == FUNC_TYPE) {
                                            // assign modified match
                                            this[q[0]] = q[1].call(this, match);
                                        }
                                        else {
                                            // assign given value, ignore regex match
                                            this[q[0]] = q[1];
                                        }
                                    }
                                    else if (q.length === 3) {
                                        // check whether function or regex
                                        if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                                            // call function (usually string mapper)
                                            this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined$1;
                                        }
                                        else {
                                            // sanitize match using given regex
                                            this[q[0]] = match ? match.replace(q[1], q[2]) : undefined$1;
                                        }
                                    }
                                    else if (q.length === 4) {
                                        this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined$1;
                                    }
                                }
                                else {
                                    this[q] = match ? match : undefined$1;
                                }
                            }
                        }
                    }
                    i += 2;
                }
            }, strMapper = function (str, map) {
                for (var i in map) {
                    // check if current value is array
                    if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
                        for (var j = 0; j < map[i].length; j++) {
                            if (has(map[i][j], str)) {
                                return (i === UNKNOWN) ? undefined$1 : i;
                            }
                        }
                    }
                    else if (has(map[i], str)) {
                        return (i === UNKNOWN) ? undefined$1 : i;
                    }
                }
                return str;
            };
            ///////////////
            // String map
            //////////////
            // Safari < 3.0
            var oldSafariMap = {
                '1.0': '/8',
                '1.2': '/1',
                '1.3': '/3',
                '2.0': '/412',
                '2.0.2': '/416',
                '2.0.3': '/417',
                '2.0.4': '/419',
                '?': '/'
            }, windowsVersionMap = {
                'ME': '4.90',
                'NT 3.11': 'NT3.51',
                'NT 4.0': 'NT4.0',
                '2000': 'NT 5.0',
                'XP': ['NT 5.1', 'NT 5.2'],
                'Vista': 'NT 6.0',
                '7': 'NT 6.1',
                '8': 'NT 6.2',
                '8.1': 'NT 6.3',
                '10': ['NT 6.4', 'NT 10.0'],
                'RT': 'ARM'
            };
            //////////////
            // Regex map
            /////////////
            var regexes = {
                browser: [[
                        /\b(?:crmo|crios)\/([\w\.]+)/i // Chrome for Android/iOS
                    ], [VERSION, [NAME, 'Chrome']], [
                        /edg(?:e|ios|a)?\/([\w\.]+)/i // Microsoft Edge
                    ], [VERSION, [NAME, 'Edge']], [
                        // Presto based
                        /(opera mini)\/([-\w\.]+)/i,
                        /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
                        /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i // Opera
                    ], [NAME, VERSION], [
                        /opios[\/ ]+([\w\.]+)/i // Opera mini on iphone >= 8.0
                    ], [VERSION, [NAME, OPERA + ' Mini']], [
                        /\bopr\/([\w\.]+)/i // Opera Webkit
                    ], [VERSION, [NAME, OPERA]], [
                        // Mixed
                        /(kindle)\/([\w\.]+)/i,
                        /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
                        // Trident based
                        /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,
                        /(ba?idubrowser)[\/ ]?([\w\.]+)/i,
                        /(?:ms|\()(ie) ([\w\.]+)/i,
                        // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
                        /(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale|qqbrowserlite|qq)\/([-\w\.]+)/i,
                        // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
                        /(weibo)__([\d\.]+)/i // Weibo
                    ], [NAME, VERSION], [
                        /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i // UCBrowser
                    ], [VERSION, [NAME, 'UC' + BROWSER]], [
                        /\bqbcore\/([\w\.]+)/i // WeChat Desktop for Windows Built-in Browser
                    ], [VERSION, [NAME, 'WeChat(Win) Desktop']], [
                        /micromessenger\/([\w\.]+)/i // WeChat
                    ], [VERSION, [NAME, 'WeChat']], [
                        /konqueror\/([\w\.]+)/i // Konqueror
                    ], [VERSION, [NAME, 'Konqueror']], [
                        /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i // IE11
                    ], [VERSION, [NAME, 'IE']], [
                        /yabrowser\/([\w\.]+)/i // Yandex
                    ], [VERSION, [NAME, 'Yandex']], [
                        /(avast|avg)\/([\w\.]+)/i // Avast/AVG Secure Browser
                    ], [[NAME, /(.+)/, '$1 Secure ' + BROWSER], VERSION], [
                        /\bfocus\/([\w\.]+)/i // Firefox Focus
                    ], [VERSION, [NAME, FIREFOX + ' Focus']], [
                        /\bopt\/([\w\.]+)/i // Opera Touch
                    ], [VERSION, [NAME, OPERA + ' Touch']], [
                        /coc_coc\w+\/([\w\.]+)/i // Coc Coc Browser
                    ], [VERSION, [NAME, 'Coc Coc']], [
                        /dolfin\/([\w\.]+)/i // Dolphin
                    ], [VERSION, [NAME, 'Dolphin']], [
                        /coast\/([\w\.]+)/i // Opera Coast
                    ], [VERSION, [NAME, OPERA + ' Coast']], [
                        /miuibrowser\/([\w\.]+)/i // MIUI Browser
                    ], [VERSION, [NAME, 'MIUI ' + BROWSER]], [
                        /fxios\/([-\w\.]+)/i // Firefox for iOS
                    ], [VERSION, [NAME, FIREFOX]], [
                        /\bqihu|(qi?ho?o?|360)browser/i // 360
                    ], [[NAME, '360 ' + BROWSER]], [
                        /(oculus|samsung|sailfish)browser\/([\w\.]+)/i
                    ], [[NAME, /(.+)/, '$1 ' + BROWSER], VERSION], [
                        /(comodo_dragon)\/([\w\.]+)/i // Comodo Dragon
                    ], [[NAME, /_/g, ' '], VERSION], [
                        /(electron)\/([\w\.]+) safari/i,
                        /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
                        /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i // QQBrowser/Baidu App/2345 Browser
                    ], [NAME, VERSION], [
                        /(metasr)[\/ ]?([\w\.]+)/i,
                        /(lbbrowser)/i // LieBao Browser
                    ], [NAME], [
                        // WebView
                        /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i // Facebook App for iOS & Android
                    ], [[NAME, FACEBOOK], VERSION], [
                        /safari (line)\/([\w\.]+)/i,
                        /\b(line)\/([\w\.]+)\/iab/i,
                        /(chromium|instagram)[\/ ]([-\w\.]+)/i // Chromium/Instagram
                    ], [NAME, VERSION], [
                        /\bgsa\/([\w\.]+) .*safari\//i // Google Search Appliance on iOS
                    ], [VERSION, [NAME, 'GSA']], [
                        /headlesschrome(?:\/([\w\.]+)| )/i // Chrome Headless
                    ], [VERSION, [NAME, CHROME + ' Headless']], [
                        / wv\).+(chrome)\/([\w\.]+)/i // Chrome WebView
                    ], [[NAME, CHROME + ' WebView'], VERSION], [
                        /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i // Android Browser
                    ], [VERSION, [NAME, 'Android ' + BROWSER]], [
                        /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i // Chrome/OmniWeb/Arora/Tizen/Nokia
                    ], [NAME, VERSION], [
                        /version\/([\w\.]+) .*mobile\/\w+ (safari)/i // Mobile Safari
                    ], [VERSION, [NAME, 'Mobile Safari']], [
                        /version\/([\w\.]+) .*(mobile ?safari|safari)/i // Safari & Safari Mobile
                    ], [VERSION, NAME], [
                        /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i // Safari < 3.0
                    ], [NAME, [VERSION, strMapper, oldSafariMap]], [
                        /(webkit|khtml)\/([\w\.]+)/i
                    ], [NAME, VERSION], [
                        // Gecko based
                        /(navigator|netscape\d?)\/([-\w\.]+)/i // Netscape
                    ], [[NAME, 'Netscape'], VERSION], [
                        /mobile vr; rv:([\w\.]+)\).+firefox/i // Firefox Reality
                    ], [VERSION, [NAME, FIREFOX + ' Reality']], [
                        /ekiohf.+(flow)\/([\w\.]+)/i,
                        /(swiftfox)/i,
                        /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
                        // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
                        /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
                        // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
                        /(firefox)\/([\w\.]+)/i,
                        /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
                        // Other
                        /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
                        // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
                        /(links) \(([\w\.]+)/i // Links
                    ], [NAME, VERSION]
                ],
                cpu: [[
                        /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i // AMD64 (x64)
                    ], [[ARCHITECTURE, 'amd64']], [
                        /(ia32(?=;))/i // IA32 (quicktime)
                    ], [[ARCHITECTURE, lowerize]], [
                        /((?:i[346]|x)86)[;\)]/i // IA32 (x86)
                    ], [[ARCHITECTURE, 'ia32']], [
                        /\b(aarch64|arm(v?8e?l?|_?64))\b/i // ARM64
                    ], [[ARCHITECTURE, 'arm64']], [
                        /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i // ARMHF
                    ], [[ARCHITECTURE, 'armhf']], [
                        // PocketPC mistakenly identified as PowerPC
                        /windows (ce|mobile); ppc;/i
                    ], [[ARCHITECTURE, 'arm']], [
                        /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i // PowerPC
                    ], [[ARCHITECTURE, /ower/, EMPTY, lowerize]], [
                        /(sun4\w)[;\)]/i // SPARC
                    ], [[ARCHITECTURE, 'sparc']], [
                        /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
                        // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
                    ], [[ARCHITECTURE, lowerize]]
                ],
                device: [[
                        //////////////////////////
                        // MOBILES & TABLETS
                        // Ordered by popularity
                        /////////////////////////
                        // Samsung
                        /\b(sch-i[89]0\d|shw-m380s|sm-[pt]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
                    ], [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]], [
                        /\b((?:s[cgp]h|gt|sm)-\w+|galaxy nexus)/i,
                        /samsung[- ]([-\w]+)/i,
                        /sec-(sgh\w+)/i
                    ], [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]], [
                        // Apple
                        /\((ip(?:hone|od)[\w ]*);/i // iPod/iPhone
                    ], [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]], [
                        /\((ipad);[-\w\),; ]+apple/i,
                        /applecoremedia\/[\w\.]+ \((ipad)/i,
                        /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
                    ], [MODEL, [VENDOR, APPLE], [TYPE, TABLET]], [
                        // Huawei
                        /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
                    ], [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]], [
                        /(?:huawei|honor)([-\w ]+)[;\)]/i,
                        /\b(nexus 6p|\w{2,4}-[atu]?[ln][01259x][012359][an]?)\b(?!.+d\/s)/i
                    ], [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]], [
                        // Xiaomi
                        /\b(poco[\w ]+)(?: bui|\))/i,
                        /\b; (\w+) build\/hm\1/i,
                        /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
                        /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
                        /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i // Xiaomi Mi
                    ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, MOBILE]], [
                        /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i // Mi Pad tablets
                    ], [[MODEL, /_/g, ' '], [VENDOR, XIAOMI], [TYPE, TABLET]], [
                        // OPPO
                        /; (\w+) bui.+ oppo/i,
                        /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
                    ], [MODEL, [VENDOR, 'OPPO'], [TYPE, MOBILE]], [
                        // Vivo
                        /vivo (\w+)(?: bui|\))/i,
                        /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
                    ], [MODEL, [VENDOR, 'Vivo'], [TYPE, MOBILE]], [
                        // Realme
                        /\b(rmx[12]\d{3})(?: bui|;|\))/i
                    ], [MODEL, [VENDOR, 'Realme'], [TYPE, MOBILE]], [
                        // Motorola
                        /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
                        /\bmot(?:orola)?[- ](\w*)/i,
                        /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
                    ], [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]], [
                        /\b(mz60\d|xoom[2 ]{0,2}) build\//i
                    ], [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]], [
                        // LG
                        /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
                    ], [MODEL, [VENDOR, LG], [TYPE, TABLET]], [
                        /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
                        /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
                        /\blg-?([\d\w]+) bui/i
                    ], [MODEL, [VENDOR, LG], [TYPE, MOBILE]], [
                        // Lenovo
                        /(ideatab[-\w ]+)/i,
                        /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
                    ], [MODEL, [VENDOR, 'Lenovo'], [TYPE, TABLET]], [
                        // Nokia
                        /(?:maemo|nokia).*(n900|lumia \d+)/i,
                        /nokia[-_ ]?([-\w\.]*)/i
                    ], [[MODEL, /_/g, ' '], [VENDOR, 'Nokia'], [TYPE, MOBILE]], [
                        // Google
                        /(pixel c)\b/i // Google Pixel C
                    ], [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]], [
                        /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i // Google Pixel
                    ], [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]], [
                        // Sony
                        /droid.+ ([c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
                    ], [MODEL, [VENDOR, SONY], [TYPE, MOBILE]], [
                        /sony tablet [ps]/i,
                        /\b(?:sony)?sgp\w+(?: bui|\))/i
                    ], [[MODEL, 'Xperia Tablet'], [VENDOR, SONY], [TYPE, TABLET]], [
                        // OnePlus
                        / (kb2005|in20[12]5|be20[12][59])\b/i,
                        /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
                    ], [MODEL, [VENDOR, 'OnePlus'], [TYPE, MOBILE]], [
                        // Amazon
                        /(alexa)webm/i,
                        /(kf[a-z]{2}wi)( bui|\))/i,
                        /(kf[a-z]+)( bui|\)).+silk\//i // Kindle Fire HD
                    ], [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]], [
                        /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i // Fire Phone
                    ], [[MODEL, /(.+)/g, 'Fire Phone $1'], [VENDOR, AMAZON], [TYPE, MOBILE]], [
                        // BlackBerry
                        /(playbook);[-\w\),; ]+(rim)/i // BlackBerry PlayBook
                    ], [MODEL, VENDOR, [TYPE, TABLET]], [
                        /\b((?:bb[a-f]|st[hv])100-\d)/i,
                        /\(bb10; (\w+)/i // BlackBerry 10
                    ], [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]], [
                        // Asus
                        /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
                    ], [MODEL, [VENDOR, ASUS], [TYPE, TABLET]], [
                        / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
                    ], [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]], [
                        // HTC
                        /(nexus 9)/i // HTC Nexus 9
                    ], [MODEL, [VENDOR, 'HTC'], [TYPE, TABLET]], [
                        /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
                        // ZTE
                        /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
                        /(alcatel|geeksphone|nexian|panasonic|sony)[-_ ]?([-\w]*)/i // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
                    ], [VENDOR, [MODEL, /_/g, ' '], [TYPE, MOBILE]], [
                        // Acer
                        /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
                    ], [MODEL, [VENDOR, 'Acer'], [TYPE, TABLET]], [
                        // Meizu
                        /droid.+; (m[1-5] note) bui/i,
                        /\bmz-([-\w]{2,})/i
                    ], [MODEL, [VENDOR, 'Meizu'], [TYPE, MOBILE]], [
                        // Sharp
                        /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
                    ], [MODEL, [VENDOR, 'Sharp'], [TYPE, MOBILE]], [
                        // MIXED
                        /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,
                        // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
                        /(hp) ([\w ]+\w)/i,
                        /(asus)-?(\w+)/i,
                        /(microsoft); (lumia[\w ]+)/i,
                        /(lenovo)[-_ ]?([-\w]+)/i,
                        /(jolla)/i,
                        /(oppo) ?([\w ]+) bui/i // OPPO
                    ], [VENDOR, MODEL, [TYPE, MOBILE]], [
                        /(archos) (gamepad2?)/i,
                        /(hp).+(touchpad(?!.+tablet)|tablet)/i,
                        /(kindle)\/([\w\.]+)/i,
                        /(nook)[\w ]+build\/(\w+)/i,
                        /(dell) (strea[kpr\d ]*[\dko])/i,
                        /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
                        /(trinity)[- ]*(t\d{3}) bui/i,
                        /(gigaset)[- ]+(q\w{1,9}) bui/i,
                        /(vodafone) ([\w ]+)(?:\)| bui)/i // Vodafone
                    ], [VENDOR, MODEL, [TYPE, TABLET]], [
                        /(surface duo)/i // Surface Duo
                    ], [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]], [
                        /droid [\d\.]+; (fp\du?)(?: b|\))/i // Fairphone
                    ], [MODEL, [VENDOR, 'Fairphone'], [TYPE, MOBILE]], [
                        /(u304aa)/i // AT&T
                    ], [MODEL, [VENDOR, 'AT&T'], [TYPE, MOBILE]], [
                        /\bsie-(\w*)/i // Siemens
                    ], [MODEL, [VENDOR, 'Siemens'], [TYPE, MOBILE]], [
                        /\b(rct\w+) b/i // RCA Tablets
                    ], [MODEL, [VENDOR, 'RCA'], [TYPE, TABLET]], [
                        /\b(venue[\d ]{2,7}) b/i // Dell Venue Tablets
                    ], [MODEL, [VENDOR, 'Dell'], [TYPE, TABLET]], [
                        /\b(q(?:mv|ta)\w+) b/i // Verizon Tablet
                    ], [MODEL, [VENDOR, 'Verizon'], [TYPE, TABLET]], [
                        /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i // Barnes & Noble Tablet
                    ], [MODEL, [VENDOR, 'Barnes & Noble'], [TYPE, TABLET]], [
                        /\b(tm\d{3}\w+) b/i
                    ], [MODEL, [VENDOR, 'NuVision'], [TYPE, TABLET]], [
                        /\b(k88) b/i // ZTE K Series Tablet
                    ], [MODEL, [VENDOR, 'ZTE'], [TYPE, TABLET]], [
                        /\b(nx\d{3}j) b/i // ZTE Nubia
                    ], [MODEL, [VENDOR, 'ZTE'], [TYPE, MOBILE]], [
                        /\b(gen\d{3}) b.+49h/i // Swiss GEN Mobile
                    ], [MODEL, [VENDOR, 'Swiss'], [TYPE, MOBILE]], [
                        /\b(zur\d{3}) b/i // Swiss ZUR Tablet
                    ], [MODEL, [VENDOR, 'Swiss'], [TYPE, TABLET]], [
                        /\b((zeki)?tb.*\b) b/i // Zeki Tablets
                    ], [MODEL, [VENDOR, 'Zeki'], [TYPE, TABLET]], [
                        /\b([yr]\d{2}) b/i,
                        /\b(dragon[- ]+touch |dt)(\w{5}) b/i // Dragon Touch Tablet
                    ], [[VENDOR, 'Dragon Touch'], MODEL, [TYPE, TABLET]], [
                        /\b(ns-?\w{0,9}) b/i // Insignia Tablets
                    ], [MODEL, [VENDOR, 'Insignia'], [TYPE, TABLET]], [
                        /\b((nxa|next)-?\w{0,9}) b/i // NextBook Tablets
                    ], [MODEL, [VENDOR, 'NextBook'], [TYPE, TABLET]], [
                        /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i // Voice Xtreme Phones
                    ], [[VENDOR, 'Voice'], MODEL, [TYPE, MOBILE]], [
                        /\b(lvtel\-)?(v1[12]) b/i // LvTel Phones
                    ], [[VENDOR, 'LvTel'], MODEL, [TYPE, MOBILE]], [
                        /\b(ph-1) /i // Essential PH-1
                    ], [MODEL, [VENDOR, 'Essential'], [TYPE, MOBILE]], [
                        /\b(v(100md|700na|7011|917g).*\b) b/i // Envizen Tablets
                    ], [MODEL, [VENDOR, 'Envizen'], [TYPE, TABLET]], [
                        /\b(trio[-\w\. ]+) b/i // MachSpeed Tablets
                    ], [MODEL, [VENDOR, 'MachSpeed'], [TYPE, TABLET]], [
                        /\btu_(1491) b/i // Rotor Tablets
                    ], [MODEL, [VENDOR, 'Rotor'], [TYPE, TABLET]], [
                        /(shield[\w ]+) b/i // Nvidia Shield Tablets
                    ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, TABLET]], [
                        /(sprint) (\w+)/i // Sprint Phones
                    ], [VENDOR, MODEL, [TYPE, MOBILE]], [
                        /(kin\.[onetw]{3})/i // Microsoft Kin
                    ], [[MODEL, /\./g, ' '], [VENDOR, MICROSOFT], [TYPE, MOBILE]], [
                        /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i // Zebra
                    ], [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]], [
                        /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
                    ], [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]], [
                        ///////////////////
                        // CONSOLES
                        ///////////////////
                        /(ouya)/i,
                        /(nintendo) ([wids3utch]+)/i // Nintendo
                    ], [VENDOR, MODEL, [TYPE, CONSOLE]], [
                        /droid.+; (shield) bui/i // Nvidia
                    ], [MODEL, [VENDOR, 'Nvidia'], [TYPE, CONSOLE]], [
                        /(playstation [345portablevi]+)/i // Playstation
                    ], [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]], [
                        /\b(xbox(?: one)?(?!; xbox))[\); ]/i // Microsoft Xbox
                    ], [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]], [
                        ///////////////////
                        // SMARTTVS
                        ///////////////////
                        /smart-tv.+(samsung)/i // Samsung
                    ], [VENDOR, [TYPE, SMARTTV]], [
                        /hbbtv.+maple;(\d+)/i
                    ], [[MODEL, /^/, 'SmartTV'], [VENDOR, SAMSUNG], [TYPE, SMARTTV]], [
                        /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i // LG SmartTV
                    ], [[VENDOR, LG], [TYPE, SMARTTV]], [
                        /(apple) ?tv/i // Apple TV
                    ], [VENDOR, [MODEL, APPLE + ' TV'], [TYPE, SMARTTV]], [
                        /crkey/i // Google Chromecast
                    ], [[MODEL, CHROME + 'cast'], [VENDOR, GOOGLE], [TYPE, SMARTTV]], [
                        /droid.+aft(\w)( bui|\))/i // Fire TV
                    ], [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]], [
                        /\(dtv[\);].+(aquos)/i // Sharp
                    ], [MODEL, [VENDOR, 'Sharp'], [TYPE, SMARTTV]], [
                        /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
                        /hbbtv\/\d+\.\d+\.\d+ +\([\w ]*; *(\w[^;]*);([^;]*)/i // HbbTV devices
                    ], [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]], [
                        /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i // SmartTV from Unidentified Vendors
                    ], [[TYPE, SMARTTV]], [
                        ///////////////////
                        // WEARABLES
                        ///////////////////
                        /((pebble))app/i // Pebble
                    ], [VENDOR, MODEL, [TYPE, WEARABLE]], [
                        /droid.+; (glass) \d/i // Google Glass
                    ], [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]], [
                        /droid.+; (wt63?0{2,3})\)/i
                    ], [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]], [
                        /(quest( 2)?)/i // Oculus Quest
                    ], [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]], [
                        ///////////////////
                        // EMBEDDED
                        ///////////////////
                        /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i // Tesla
                    ], [VENDOR, [TYPE, EMBEDDED]], [
                        ////////////////////
                        // MIXED (GENERIC)
                        ///////////////////
                        /droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i // Android Phones from Unidentified Vendors
                    ], [MODEL, [TYPE, MOBILE]], [
                        /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i // Android Tablets from Unidentified Vendors
                    ], [MODEL, [TYPE, TABLET]], [
                        /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i // Unidentifiable Tablet
                    ], [[TYPE, TABLET]], [
                        /(phone|mobile(?:[;\/]| safari)|pda(?=.+windows ce))/i // Unidentifiable Mobile
                    ], [[TYPE, MOBILE]], [
                        /(android[-\w\. ]{0,9});.+buil/i // Generic Android Device
                    ], [MODEL, [VENDOR, 'Generic']]
                ],
                engine: [[
                        /windows.+ edge\/([\w\.]+)/i // EdgeHTML
                    ], [VERSION, [NAME, EDGE + 'HTML']], [
                        /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i // Blink
                    ], [VERSION, [NAME, 'Blink']], [
                        /(presto)\/([\w\.]+)/i,
                        /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
                        /ekioh(flow)\/([\w\.]+)/i,
                        /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
                        /(icab)[\/ ]([23]\.[\d\.]+)/i // iCab
                    ], [NAME, VERSION], [
                        /rv\:([\w\.]{1,9})\b.+(gecko)/i // Gecko
                    ], [VERSION, NAME]
                ],
                os: [[
                        // Windows
                        /microsoft (windows) (vista|xp)/i // Windows (iTunes)
                    ], [NAME, VERSION], [
                        /(windows) nt 6\.2; (arm)/i,
                        /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,
                        /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i
                    ], [NAME, [VERSION, strMapper, windowsVersionMap]], [
                        /(win(?=3|9|n)|win 9x )([nt\d\.]+)/i
                    ], [[NAME, 'Windows'], [VERSION, strMapper, windowsVersionMap]], [
                        // iOS/macOS
                        /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
                        /cfnetwork\/.+darwin/i
                    ], [[VERSION, /_/g, '.'], [NAME, 'iOS']], [
                        /(mac os x) ?([\w\. ]*)/i,
                        /(macintosh|mac_powerpc\b)(?!.+haiku)/i // Mac OS
                    ], [[NAME, 'Mac OS'], [VERSION, /_/g, '.']], [
                        // Mobile OSes
                        /droid ([\w\.]+)\b.+(android[- ]x86)/i // Android-x86
                    ], [VERSION, NAME], [
                        /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
                        /(blackberry)\w*\/([\w\.]*)/i,
                        /(tizen|kaios)[\/ ]([\w\.]+)/i,
                        /\((series40);/i // Series 40
                    ], [NAME, VERSION], [
                        /\(bb(10);/i // BlackBerry 10
                    ], [VERSION, [NAME, BLACKBERRY]], [
                        /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i // Symbian
                    ], [VERSION, [NAME, 'Symbian']], [
                        /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i // Firefox OS
                    ], [VERSION, [NAME, FIREFOX + ' OS']], [
                        /web0s;.+rt(tv)/i,
                        /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i // WebOS
                    ], [VERSION, [NAME, 'webOS']], [
                        // Google Chromecast
                        /crkey\/([\d\.]+)/i // Google Chromecast
                    ], [VERSION, [NAME, CHROME + 'cast']], [
                        /(cros) [\w]+ ([\w\.]+\w)/i // Chromium OS
                    ], [[NAME, 'Chromium OS'], VERSION], [
                        // Console
                        /(nintendo|playstation) ([wids345portablevuch]+)/i,
                        /(xbox); +xbox ([^\);]+)/i,
                        // Other
                        /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
                        /(mint)[\/\(\) ]?(\w*)/i,
                        /(mageia|vectorlinux)[; ]/i,
                        /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
                        // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
                        /(hurd|linux) ?([\w\.]*)/i,
                        /(gnu) ?([\w\.]*)/i,
                        /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
                        /(haiku) (\w+)/i // Haiku
                    ], [NAME, VERSION], [
                        /(sunos) ?([\w\.\d]*)/i // Solaris
                    ], [[NAME, 'Solaris'], VERSION], [
                        /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
                        /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
                        /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,
                        /(unix) ?([\w\.]*)/i // UNIX
                    ], [NAME, VERSION]
                ]
            };
            /////////////////
            // Constructor
            ////////////////
            var UAParser = function (ua, extensions) {
                if (typeof ua === OBJ_TYPE) {
                    extensions = ua;
                    ua = undefined$1;
                }
                if (!(this instanceof UAParser)) {
                    return new UAParser(ua, extensions).getResult();
                }
                var _ua = ua || ((typeof window !== UNDEF_TYPE && window.navigator && window.navigator.userAgent) ? window.navigator.userAgent : EMPTY);
                var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
                this.getBrowser = function () {
                    var _browser = {};
                    _browser[NAME] = undefined$1;
                    _browser[VERSION] = undefined$1;
                    rgxMapper.call(_browser, _ua, _rgxmap.browser);
                    _browser.major = majorize(_browser.version);
                    return _browser;
                };
                this.getCPU = function () {
                    var _cpu = {};
                    _cpu[ARCHITECTURE] = undefined$1;
                    rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
                    return _cpu;
                };
                this.getDevice = function () {
                    var _device = {};
                    _device[VENDOR] = undefined$1;
                    _device[MODEL] = undefined$1;
                    _device[TYPE] = undefined$1;
                    rgxMapper.call(_device, _ua, _rgxmap.device);
                    return _device;
                };
                this.getEngine = function () {
                    var _engine = {};
                    _engine[NAME] = undefined$1;
                    _engine[VERSION] = undefined$1;
                    rgxMapper.call(_engine, _ua, _rgxmap.engine);
                    return _engine;
                };
                this.getOS = function () {
                    var _os = {};
                    _os[NAME] = undefined$1;
                    _os[VERSION] = undefined$1;
                    rgxMapper.call(_os, _ua, _rgxmap.os);
                    return _os;
                };
                this.getResult = function () {
                    return {
                        ua: this.getUA(),
                        browser: this.getBrowser(),
                        engine: this.getEngine(),
                        os: this.getOS(),
                        device: this.getDevice(),
                        cpu: this.getCPU()
                    };
                };
                this.getUA = function () {
                    return _ua;
                };
                this.setUA = function (ua) {
                    _ua = (typeof ua === STR_TYPE && ua.length > UA_MAX_LENGTH) ? trim(ua, UA_MAX_LENGTH) : ua;
                    return this;
                };
                this.setUA(_ua);
                return this;
            };
            UAParser.VERSION = LIBVERSION;
            UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
            UAParser.CPU = enumerize([ARCHITECTURE]);
            UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
            UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
            ///////////
            // Export
            //////////
            // check js environment
            {
                // nodejs env
                if ( module.exports) {
                    exports = module.exports = UAParser;
                }
                exports.UAParser = UAParser;
            }
            // jQuery/Zepto specific (optional)
            // Note:
            //   In AMD env the global scope should be kept clean, but jQuery is an exception.
            //   jQuery always exports to global scope, unless jQuery.noConflict(true) is used,
            //   and we should catch that.
            var $ = typeof window !== UNDEF_TYPE && (window.jQuery || window.Zepto);
            if ($ && !$.ua) {
                var parser = new UAParser();
                $.ua = parser.getResult();
                $.ua.get = function () {
                    return parser.getUA();
                };
                $.ua.set = function (ua) {
                    parser.setUA(ua);
                    var result = parser.getResult();
                    for (var prop in result) {
                        $.ua[prop] = result[prop];
                    }
                };
            }
        })(typeof window === 'object' ? window : commonjsGlobal$1);
    });

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var ua = uaParser(window.navigator.userAgent);
    var getBrowser = function () {
        return ua.browser.name;
    };
    var getOS = function () {
        return ua.os.name;
    };

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var browser = getBrowser();
    var isIE11 = browser === 'IE'; // ua.includes('rv:11.0');
    var isIEEdge = browser === 'Edge'; // ua.includes('Edge');
    var initializeElementAccess = function (node) {
        select(node)
            .attr('tabindex', -1)
            .attr('role', 'presentation')
            .attr('focusable', false);
    };
    var hideNonessentialGroups = function (rootNode, exception) {
        var childrenG = rootNode.childNodes.length > 1 ? rootNode.childNodes : rootNode.firstElementChild.childNodes;
        if (childrenG) {
            selectAll(childrenG).each(function (_, i, n) {
                if (!(n[i] === exception)) {
                    hideNode(n[i]);
                }
            });
        }
    };
    var setTooltipAccess = function (el) {
        el.setAttribute('role', 'tooltip'); // AT tooltip
        el.setAttribute('aria-hidden', 'true');
        el.setAttribute('tabindex', null);
    };
    var setLegendAccess = function (root, id) {
        hideNode(root);
        hideNode(root.parentNode, true);
        select(root).classed('vcl-svg', true);
        if (isIE11 || isIEEdge) {
            handleContrast(null, id);
        }
    };
    var hideNode = function (node, excludeFocusable) {
        select(node)
            .attr('aria-hidden', 'true')
            .attr('role', 'presentation')
            .attr('focusable', !excludeFocusable ? 'false' : null)
            .attr('tabindex', null);
    };
    var createUrl = function (id) {
        var path = window.location.pathname;
        if (path[path.length - 1] === '/') {
            path = path.substring(0, path.length - 1);
        }
        var ending = id ? id + ')' : '';
        return 'url(#' + ending;
    };
    var setHighContrastListener = function (root, id) {
        select(root).classed('vcl-svg', true);
        var filter = select(root).select('.vcl-inversion-filter');
        if (!filter.size()) {
            var defs = select(root).select('defs');
            if (!defs.size()) {
                defs = select(root).append('defs');
            }
            filter = defs
                .append('filter')
                .attr('class', 'vcl-inversion-filter')
                .attr('color-interpolation-filters', 'sRGB');
            // this operation will "invert" every color: dark blue becomes light orange,
            // pink becomes dark green, etc. This ensures the new luminance is fully inverted
            filter
                .append('feColorMatrix')
                .attr('in', 'SourceGraphic')
                .attr('type', 'matrix')
                .attr('values', "-1 0 0 0 1 \n        0 -1 0 0 1 \n        0 0 -1 0 1\n        0 0 0 1 0");
            // once luminance is inverted, we can rotate the hue back to its original
            // this means that the dark blue is now a light blue instead of light orange
            filter
                .append('feColorMatrix')
                .attr('type', 'hueRotate')
                .attr('values', '180');
        }
        filter.attr('id', 'inversion-' + id);
        var passMediaEventToHandler = function (a) {
            handleContrast(a, id);
        };
        var runContrastHandler = function () {
            handleContrast(null, id);
        };
        if (isIE11 || isIEEdge) {
            // here we are listening to contrast mode being turned on or off as well as
            // listening to the contrast modes being switched between types
            matchMedia('(-ms-high-contrast: active)').addListener(passMediaEventToHandler);
            matchMedia('(-ms-high-contrast: black-on-white)').addListener(runContrastHandler);
            passMediaEventToHandler(matchMedia('(-ms-high-contrast: active)'));
        }
    };
    var handleContrast = function (a, id) {
        var contrastStatus = a || matchMedia('(-ms-high-contrast: active)');
        if (contrastStatus.matches && !matchMedia('(-ms-high-contrast: black-on-white)').matches) {
            var url = createUrl('inversion-' + id);
            // we will always structure our SVG elements to have a single g that contains
            // all of our elements, so we only need to select the first g element for
            // every SVG within our component space (legend, chart, etc)
            select('#' + id)
                .selectAll('.vcl-svg')
                .select('g')
                .attr('filter', url);
        }
        else {
            select('#' + id)
                .selectAll('.vcl-svg')
                .select('g')
                .attr('filter', null);
        }
    };

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    /*! @preserve
     * numeral.js
     * version : 2.0.6
     * author : Adam Draper
     * license : MIT
     * http://adamwdraper.github.com/Numeral-js/
     */
    /************************************
        Variables
    ************************************/
    var numeral, _, VERSION = '2.0.6', formats = {}, locales = {}, defaults = {
        currentLocale: 'en',
        zeroFormat: null,
        nullFormat: null,
        defaultFormat: '0,0',
        scalePercentBy100: true
    }, options = {
        currentLocale: defaults.currentLocale,
        zeroFormat: defaults.zeroFormat,
        nullFormat: defaults.nullFormat,
        defaultFormat: defaults.defaultFormat,
        scalePercentBy100: defaults.scalePercentBy100
    };
    /************************************
        Constructors
    ************************************/
    // Numeral prototype object
    function Numeral(input, number) {
        this._input = input;
        this._value = number;
    }
    numeral = function (input) {
        var value, kind, unformatFunction, regexp;
        if (numeral.isNumeral(input)) {
            value = input.value();
        }
        else if (input === 0 || typeof input === 'undefined') {
            value = 0;
        }
        else if (input === null || _.isNaN(input)) {
            value = null;
        }
        else if (typeof input === 'string') {
            if (options.zeroFormat && input === options.zeroFormat) {
                value = 0;
            }
            else if ((options.nullFormat && input === options.nullFormat) || !input.replace(/[^0-9]+/g, '').length) {
                value = null;
            }
            else {
                for (kind in formats) {
                    regexp =
                        typeof formats[kind].regexps.unformat === 'function'
                            ? formats[kind].regexps.unformat()
                            : formats[kind].regexps.unformat;
                    if (regexp && input.match(regexp)) {
                        unformatFunction = formats[kind].unformat;
                        break;
                    }
                }
                unformatFunction = unformatFunction || numeral._.stringToNumber;
                value = unformatFunction(input);
            }
        }
        else {
            value = Number(input) || null;
        }
        return new Numeral(input, value);
    };
    // version number
    numeral.version = VERSION;
    // compare numeral object
    numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };
    // helper functions
    numeral._ = _ = {
        // formats numbers separators, decimals places, signs, abbreviations
        numberToFormat: function (value, format, roundingFunction) {
            var locale = locales[numeral.options.currentLocale], negP = false, optDec = false, leadingCount = 0, abbr = '', trillion = 1000000000000, billion = 1000000000, million = 1000000, thousand = 1000, decimal = '', neg = false, abbrForce, // force abbreviation
            abs, int, precision, signed, thousands, output;
            // make sure we never format a null value
            value = value || 0;
            abs = Math.abs(value);
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (numeral._.includes(format, '(')) {
                negP = true;
                format = format.replace(/[\(|\)]/g, '');
            }
            else if (numeral._.includes(format, '+') || numeral._.includes(format, '-')) {
                signed = numeral._.includes(format, '+') ? format.indexOf('+') : value < 0 ? format.indexOf('-') : -1;
                format = format.replace(/[\+|\-]/g, '');
            }
            // see if abbreviation is wanted
            if (numeral._.includes(format, 'a')) {
                abbrForce = format.match(/a(k|m|b|t)?/);
                abbrForce = abbrForce ? abbrForce[1] : false;
                // check for space before abbreviation
                if (numeral._.includes(format, ' a')) {
                    abbr = ' ';
                }
                format = format.replace(new RegExp(abbr + 'a[kmbt]?'), '');
                if ((abs >= trillion && !abbrForce) || abbrForce === 't') {
                    // trillion
                    abbr += locale.abbreviations.trillion;
                    value = value / trillion;
                }
                else if ((abs < trillion && abs >= billion && !abbrForce) || abbrForce === 'b') {
                    // billion
                    abbr += locale.abbreviations.billion;
                    value = value / billion;
                }
                else if ((abs < billion && abs >= million && !abbrForce) || abbrForce === 'm') {
                    // million
                    abbr += locale.abbreviations.million;
                    value = value / million;
                }
                else if ((abs < million && abs >= thousand && !abbrForce) || abbrForce === 'k') {
                    // thousand
                    abbr += locale.abbreviations.thousand;
                    value = value / thousand;
                }
            }
            // check for optional decimals
            if (numeral._.includes(format, '[.]')) {
                optDec = true;
                format = format.replace('[.]', '.');
            }
            // break number and format
            int = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');
            leadingCount = (format
                .split('.')[0]
                .split(',')[0]
                .match(/0/g) || []).length;
            if (precision) {
                if (numeral._.includes(precision, '[')) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    decimal = numeral._.toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
                }
                else {
                    decimal = numeral._.toFixed(value, precision.length, roundingFunction);
                }
                int = decimal.split('.')[0];
                if (numeral._.includes(decimal, '.')) {
                    decimal = locale.delimiters.decimal + decimal.split('.')[1];
                }
                else {
                    decimal = '';
                }
                if (optDec && Number(decimal.slice(1)) === 0) {
                    decimal = '';
                }
            }
            else {
                int = numeral._.toFixed(value, 0, roundingFunction);
            }
            // check abbreviation again after rounding
            if (abbr && !abbrForce && Number(int) >= 1000 && abbr !== locale.abbreviations.trillion) {
                int = String(Number(int) / 1000);
                switch (abbr) {
                    case locale.abbreviations.thousand:
                        abbr = locale.abbreviations.million;
                        break;
                    case locale.abbreviations.million:
                        abbr = locale.abbreviations.billion;
                        break;
                    case locale.abbreviations.billion:
                        abbr = locale.abbreviations.trillion;
                        break;
                }
            }
            // format number
            if (numeral._.includes(int, '-')) {
                int = int.slice(1);
                neg = true;
            }
            if (int.length < leadingCount) {
                for (var i = leadingCount - int.length; i > 0; i--) {
                    int = '0' + int;
                }
            }
            if (thousands > -1) {
                int = int.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + locale.delimiters.thousands);
            }
            if (format.indexOf('.') === 0) {
                int = '';
            }
            output = int + decimal + (abbr ? abbr : '');
            if (negP) {
                output = (negP && neg ? '(' : '') + output + (negP && neg ? ')' : '');
            }
            else {
                if (signed >= 0) {
                    output = signed === 0 ? (neg ? '-' : '+') + output : output + (neg ? '-' : '+');
                }
                else if (neg) {
                    output = '-' + output;
                }
            }
            return output;
        },
        // unformats numbers separators, decimals places, signs, abbreviations
        stringToNumber: function (string) {
            var locale = locales[options.currentLocale], stringOriginal = string, abbreviations = {
                thousand: 3,
                million: 6,
                billion: 9,
                trillion: 12
            }, abbreviation, value, regexp;
            if (options.zeroFormat && string === options.zeroFormat) {
                value = 0;
            }
            else if ((options.nullFormat && string === options.nullFormat) || !string.replace(/[^0-9]+/g, '').length) {
                value = null;
            }
            else {
                value = 1;
                if (locale.delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(locale.delimiters.decimal, '.');
                }
                for (abbreviation in abbreviations) {
                    regexp = new RegExp('[^a-zA-Z]' + locale.abbreviations[abbreviation] + '(?:\\)|(\\' + locale.currency.symbol + ')?(?:\\))?)?$');
                    if (stringOriginal.match(regexp)) {
                        value *= Math.pow(10, abbreviations[abbreviation]);
                        break;
                    }
                }
                // check for negative number
                value *=
                    (string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1;
                // remove non numbers
                string = string.replace(/[^0-9\.]+/g, '');
                value *= Number(string);
            }
            return value;
        },
        isNaN: function (value) {
            return typeof value === 'number' && isNaN(value);
        },
        includes: function (string, search) {
            return string.indexOf(search) !== -1;
        },
        insert: function (string, subString, start) {
            return string.slice(0, start) + subString + string.slice(start);
        },
        reduce: function (array, callback /*, initialValue*/) {
            if (this === null) {
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }
            if (typeof callback !== 'function') {
                throw new TypeError(callback + ' is not a function');
            }
            var t = Object(array), len = t.length >>> 0, k = 0, value;
            if (arguments.length === 3) {
                value = arguments[2];
            }
            else {
                while (k < len && !(k in t)) {
                    k++;
                }
                if (k >= len) {
                    throw new TypeError('Reduce of empty array with no initial value');
                }
                value = t[k++];
            }
            for (; k < len; k++) {
                if (k in t) {
                    value = callback(value, t[k], k, t);
                }
            }
            return value;
        },
        /**
         * Computes the multiplier necessary to make x >= 1,
         * effectively eliminating miscalculations caused by
         * finite precision.
         */
        multiplier: function (x) {
            var parts = x.toString().split('.');
            return parts.length < 2 ? 1 : Math.pow(10, parts[1].length);
        },
        /**
         * Given a variable number of arguments, returns the maximum
         * multiplier that must be used to normalize an operation involving
         * all of them.
         */
        correctionFactor: function () {
            var args = Array.prototype.slice.call(arguments);
            return args.reduce(function (accum, next) {
                var mn = _.multiplier(next);
                return accum > mn ? accum : mn;
            }, 1);
        },
        /**
         * Implementation of toFixed() that treats floats more like decimals
         *
         * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
         * problems for accounting- and finance-related software.
         */
        toFixed: function (value, maxDecimals, roundingFunction, optionals) {
            var splitValue = value.toString().split('.'), minDecimals = maxDecimals - (optionals || 0), boundedPrecision, optionalsRegExp, power, output;
            // Use the smallest precision value possible to avoid errors from floating point representation
            if (splitValue.length === 2) {
                boundedPrecision = Math.min(Math.max(splitValue[1].length, minDecimals), maxDecimals);
            }
            else {
                boundedPrecision = minDecimals;
            }
            power = Math.pow(10, boundedPrecision);
            // Multiply up by precision, round accurately, then divide and use native toFixed():
            output = (roundingFunction(value + 'e+' + boundedPrecision) / power).toFixed(boundedPrecision);
            if (optionals > maxDecimals - boundedPrecision) {
                optionalsRegExp = new RegExp('\\.?0{1,' + (optionals - (maxDecimals - boundedPrecision)) + '}$');
                output = output.replace(optionalsRegExp, '');
            }
            return output;
        }
    };
    // avaliable options
    numeral.options = options;
    // avaliable formats
    numeral.formats = formats;
    // avaliable formats
    numeral.locales = locales;
    // This function sets the current locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    numeral.locale = function (key) {
        if (key) {
            options.currentLocale = key.toLowerCase();
        }
        return options.currentLocale;
    };
    // This function provides access to the loaded locale data.  If
    // no arguments are passed in, it will simply return the current
    // global locale object.
    numeral.localeData = function (key) {
        if (!key) {
            return locales[options.currentLocale];
        }
        key = key.toLowerCase();
        if (!locales[key]) {
            throw new Error('Unknown locale : ' + key);
        }
        return locales[key];
    };
    numeral.reset = function () {
        for (var property in defaults) {
            options[property] = defaults[property];
        }
    };
    numeral.zeroFormat = function (format) {
        options.zeroFormat = typeof format === 'string' ? format : null;
    };
    numeral.nullFormat = function (format) {
        options.nullFormat = typeof format === 'string' ? format : null;
    };
    numeral.defaultFormat = function (format) {
        options.defaultFormat = typeof format === 'string' ? format : '0.0';
    };
    numeral.register = function (type, name, format) {
        name = name.toLowerCase();
        if (this[type + 's'][name]) {
            throw new TypeError(name + ' ' + type + ' already registered.');
        }
        this[type + 's'][name] = format;
        return format;
    };
    numeral.validate = function (val, culture) {
        var _decimalSep, _thousandSep, _currSymbol, _valArray, _abbrObj, _thousandRegEx, localeData, temp;
        //coerce val to string
        if (typeof val !== 'string') {
            val += '';
            if (console.warn) {
                console.warn('Numeral.js: Value is not string. It has been co-erced to: ', val);
            }
        }
        //trim whitespaces from either sides
        val = val.trim();
        //if val is just digits return true
        if (!!val.match(/^\d+$/)) {
            return true;
        }
        //if val is empty return false
        if (val === '') {
            return false;
        }
        //get the decimal and thousands separator from numeral.localeData
        try {
            //check if the culture is understood by numeral. if not, default it to current locale
            localeData = numeral.localeData(culture);
        }
        catch (e) {
            localeData = numeral.localeData(numeral.locale());
        }
        //setup the delimiters and currency symbol based on culture/locale
        _currSymbol = localeData.currency.symbol;
        _abbrObj = localeData.abbreviations;
        _decimalSep = localeData.delimiters.decimal;
        if (localeData.delimiters.thousands === '.') {
            _thousandSep = '\\.';
        }
        else {
            _thousandSep = localeData.delimiters.thousands;
        }
        // validating currency symbol
        temp = val.match(/^[^\d]+/);
        if (temp !== null) {
            val = val.substr(1);
            if (temp[0] !== _currSymbol) {
                return false;
            }
        }
        //validating abbreviation symbol
        temp = val.match(/[^\d]+$/);
        if (temp !== null) {
            val = val.slice(0, -1);
            if (temp[0] !== _abbrObj.thousand &&
                temp[0] !== _abbrObj.million &&
                temp[0] !== _abbrObj.billion &&
                temp[0] !== _abbrObj.trillion) {
                return false;
            }
        }
        _thousandRegEx = new RegExp(_thousandSep + '{2}');
        if (!val.match(/[^\d.,]/g)) {
            _valArray = val.split(_decimalSep);
            if (_valArray.length > 2) {
                return false;
            }
            else {
                if (_valArray.length < 2) {
                    return !!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx);
                }
                else {
                    if (_valArray[0].length === 1) {
                        return !!_valArray[0].match(/^\d+$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/);
                    }
                    else {
                        return (!!_valArray[0].match(/^\d+.*\d$/) && !_valArray[0].match(_thousandRegEx) && !!_valArray[1].match(/^\d+$/));
                    }
                }
            }
        }
        return false;
    };
    /************************************
        Numeral Prototype
    ************************************/
    numeral.fn = Numeral.prototype = {
        clone: function () {
            return numeral(this);
        },
        format: function (inputString, roundingFunction) {
            var value = this._value, format = inputString || options.defaultFormat, kind, output, formatFunction;
            // make sure we have a roundingFunction
            roundingFunction = roundingFunction || Math.round;
            // format based on value
            if (value === 0 && options.zeroFormat !== null) {
                output = options.zeroFormat;
            }
            else if (value === null && options.nullFormat !== null) {
                output = options.nullFormat;
            }
            else {
                for (kind in formats) {
                    if (format.match(formats[kind].regexps.format)) {
                        formatFunction = formats[kind].format;
                        break;
                    }
                }
                formatFunction = formatFunction || numeral._.numberToFormat;
                output = formatFunction(value, format, roundingFunction);
            }
            return output;
        },
        value: function () {
            return this._value;
        },
        input: function () {
            return this._input;
        },
        set: function (value) {
            this._value = Number(value);
            return this;
        },
        add: function (value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + Math.round(corrFactor * curr);
            }
            this._value = _.reduce([this._value, value], cback, 0) / corrFactor;
            return this;
        },
        subtract: function (value) {
            var corrFactor = _.correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - Math.round(corrFactor * curr);
            }
            this._value = _.reduce([value], cback, Math.round(this._value * corrFactor)) / corrFactor;
            return this;
        },
        multiply: function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return (Math.round(accum * corrFactor) * Math.round(curr * corrFactor)) / Math.round(corrFactor * corrFactor);
            }
            this._value = _.reduce([this._value, value], cback, 1);
            return this;
        },
        divide: function (value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = _.correctionFactor(accum, curr);
                return Math.round(accum * corrFactor) / Math.round(curr * corrFactor);
            }
            this._value = _.reduce([this._value, value], cback);
            return this;
        },
        difference: function (value) {
            return Math.abs(numeral(this._value)
                .subtract(value)
                .value());
        }
    };
    /************************************
        Default Locale && Format
    ************************************/
    numeral.register('locale', 'en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function (number) {
            var b = number % 10;
            return ~~((number % 100) / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });
    (function () {
        numeral.register('format', 'bps', {
            regexps: {
                format: /(BPS)/,
                unformat: /(BPS)/
            },
            format: function (value, format, roundingFunction) {
                var space = numeral._.includes(format, ' BPS') ? ' ' : '', output;
                value = value * 10000;
                // check for space before BPS
                format = format.replace(/\s?BPS/, '');
                output = numeral._.numberToFormat(value, format, roundingFunction);
                if (numeral._.includes(output, ')')) {
                    output = output.split('');
                    output.splice(-1, 0, space + 'BPS');
                    output = output.join('');
                }
                else {
                    output = output + space + 'BPS';
                }
                return output;
            },
            unformat: function (string) {
                return +(numeral._.stringToNumber(string) * 0.0001).toFixed(15);
            }
        });
    })();
    (function () {
        var decimal = {
            base: 1000,
            suffixes: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
        }, binary = {
            base: 1024,
            suffixes: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB']
        };
        var allSuffixes = decimal.suffixes.concat(binary.suffixes.filter(function (item) {
            return decimal.suffixes.indexOf(item) < 0;
        }));
        var unformatRegex = allSuffixes.join('|');
        // Allow support for BPS (http://www.investopedia.com/terms/b/basispoint.asp)
        unformatRegex = '(' + unformatRegex.replace('B', 'B(?!PS)') + ')';
        numeral.register('format', 'bytes', {
            regexps: {
                format: /([0\s]i?b)/,
                unformat: new RegExp(unformatRegex)
            },
            format: function (value, format, roundingFunction) {
                var output, bytes = numeral._.includes(format, 'ib') ? binary : decimal, suffix = numeral._.includes(format, ' b') || numeral._.includes(format, ' ib') ? ' ' : '', power, min, max;
                // check for space before
                format = format.replace(/\s?i?b/, '');
                for (power = 0; power <= bytes.suffixes.length; power++) {
                    min = Math.pow(bytes.base, power);
                    max = Math.pow(bytes.base, power + 1);
                    if (value === null || value === 0 || (value >= min && value < max)) {
                        suffix += bytes.suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
                output = numeral._.numberToFormat(value, format, roundingFunction);
                return output + suffix;
            },
            unformat: function (string) {
                var value = numeral._.stringToNumber(string), power, bytesMultiplier;
                if (value) {
                    for (power = decimal.suffixes.length - 1; power >= 0; power--) {
                        if (numeral._.includes(string, decimal.suffixes[power])) {
                            bytesMultiplier = Math.pow(decimal.base, power);
                            break;
                        }
                        if (numeral._.includes(string, binary.suffixes[power])) {
                            bytesMultiplier = Math.pow(binary.base, power);
                            break;
                        }
                    }
                    value *= bytesMultiplier || 1;
                }
                return value;
            }
        });
    })();
    (function () {
        numeral.register('format', 'currency', {
            regexps: {
                format: /(\$)/
            },
            format: function (value, format, roundingFunction) {
                var locale = numeral.locales[numeral.options.currentLocale], symbols = {
                    before: format.match(/^([\+|\-|\(|\s|\$]*)/)[0],
                    after: format.match(/([\+|\-|\)|\s|\$]*)$/)[0]
                }, output, symbol, i;
                // strip format of spaces and $
                format = format.replace(/\s?\$\s?/, '');
                // format the number
                output = numeral._.numberToFormat(value, format, roundingFunction);
                // update the before and after based on value
                if (value >= 0) {
                    symbols.before = symbols.before.replace(/[\-\(]/, '');
                    symbols.after = symbols.after.replace(/[\-\)]/, '');
                }
                else if (value < 0 && (!numeral._.includes(symbols.before, '-') && !numeral._.includes(symbols.before, '('))) {
                    symbols.before = '-' + symbols.before;
                }
                // loop through each before symbol
                for (i = 0; i < symbols.before.length; i++) {
                    symbol = symbols.before[i];
                    switch (symbol) {
                        case '$':
                            output = numeral._.insert(output, locale.currency.symbol, i);
                            break;
                        case ' ':
                            output = numeral._.insert(output, ' ', i + locale.currency.symbol.length - 1);
                            break;
                    }
                }
                // loop through each after symbol
                for (i = symbols.after.length - 1; i >= 0; i--) {
                    symbol = symbols.after[i];
                    switch (symbol) {
                        case '$':
                            output =
                                i === symbols.after.length - 1
                                    ? output + locale.currency.symbol
                                    : numeral._.insert(output, locale.currency.symbol, -(symbols.after.length - (1 + i)));
                            break;
                        case ' ':
                            output =
                                i === symbols.after.length - 1
                                    ? output + ' '
                                    : numeral._.insert(output, ' ', -(symbols.after.length - (1 + i) + locale.currency.symbol.length - 1));
                            break;
                    }
                }
                return output;
            }
        });
    })();
    (function () {
        numeral.register('format', 'exponential', {
            regexps: {
                format: /(e\+|e-)/,
                unformat: /(e\+|e-)/
            },
            format: function (value, format, roundingFunction) {
                var output, exponential = typeof value === 'number' && !numeral._.isNaN(value) ? value.toExponential() : '0e+0', parts = exponential.split('e');
                format = format.replace(/e[\+|\-]{1}0/, '');
                output = numeral._.numberToFormat(Number(parts[0]), format, roundingFunction);
                return output + 'e' + parts[1];
            },
            unformat: function (string) {
                var parts = numeral._.includes(string, 'e+') ? string.split('e+') : string.split('e-'), value = Number(parts[0]), power = Number(parts[1]);
                power = numeral._.includes(string, 'e-') ? (power *= -1) : power;
                function cback(accum, curr, currI, O) {
                    var corrFactor = numeral._.correctionFactor(accum, curr), num = (accum * corrFactor * (curr * corrFactor)) / (corrFactor * corrFactor);
                    return num;
                }
                return numeral._.reduce([value, Math.pow(10, power)], cback, 1);
            }
        });
    })();
    (function () {
        numeral.register('format', 'ordinal', {
            regexps: {
                format: /(o)/
            },
            format: function (value, format, roundingFunction) {
                var locale = numeral.locales[numeral.options.currentLocale], output, ordinal = numeral._.includes(format, ' o') ? ' ' : '';
                // check for space before
                format = format.replace(/\s?o/, '');
                ordinal += locale.ordinal(value);
                output = numeral._.numberToFormat(value, format, roundingFunction);
                return output + ordinal;
            }
        });
    })();
    (function () {
        numeral.register('format', 'percentage', {
            regexps: {
                format: /(%)/,
                unformat: /(%)/
            },
            format: function (value, format, roundingFunction) {
                var space = numeral._.includes(format, ' %') ? ' ' : '', output;
                if (numeral.options.scalePercentBy100) {
                    value = value * 100;
                }
                // check for space before %
                format = format.replace(/\s?\%/, '');
                output = numeral._.numberToFormat(value, format, roundingFunction);
                if (numeral._.includes(output, ')')) {
                    output = output.split('');
                    output.splice(-1, 0, space + '%');
                    output = output.join('');
                }
                else {
                    output = output + space + '%';
                }
                return output;
            },
            unformat: function (string) {
                var number = numeral._.stringToNumber(string);
                if (numeral.options.scalePercentBy100) {
                    return number * 0.01;
                }
                return number;
            }
        });
    })();
    (function () {
        numeral.register('format', 'time', {
            regexps: {
                format: /(:)/,
                unformat: /(:)/
            },
            format: function (value, format, roundingFunction) {
                var hours = Math.floor(value / 60 / 60), minutes = Math.floor((value - hours * 60 * 60) / 60), seconds = Math.round(value - hours * 60 * 60 - minutes * 60);
                return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
            },
            unformat: function (string) {
                var timeArray = string.split(':'), seconds = 0;
                // turn hours and minutes into seconds and add them all up
                if (timeArray.length === 3) {
                    // hours
                    seconds = seconds + Number(timeArray[0]) * 60 * 60;
                    // minutes
                    seconds = seconds + Number(timeArray[1]) * 60;
                    // seconds
                    seconds = seconds + Number(timeArray[2]);
                }
                else if (timeArray.length === 2) {
                    // minutes
                    seconds = seconds + Number(timeArray[0]) * 60;
                    // seconds
                    seconds = seconds + Number(timeArray[1]);
                }
                return Number(seconds);
            }
        });
    })();
    var numeral$1 = numeral;

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    function formatStats(val, format) {
        if (val === void 0) { val = '0'; }
        if (format === void 0) { format = '(0.00a)'; }
        return numeral$1(val).format(format);
        // this type of code would be needed if we abstract the formatting into an api for the users
        // for now we can just force the users to provide the relevant format for numeral to work correctly
        // switch(true) {
        //   //for currency with auto decimal point(s)
        //   case type == 'currency' && decimal == 'auto':
        //     return numeral(val).format('$0.00a');
        //   //for currency with 1 decimal point(s)
        //   case type == 'currency' && decimal == 1:
        //     return numeral(val).format('$0.0a');
        //   //for currency with 1 decimal point(s)
        //   case type == 'number' && decimal == 1:
        //     return numeral(val).format('$0.0a');
        //     //for percent with round-off to next
        //   case type == 'percent':
        //     var t = numeral(val).format('0.00%');
        //     t = Math.ceil(t.substring(0, t.indexOf('%')));
        //     return t + '%';
        // }
    }
    function roundTo(value, decimals) {
        var scale = Math.pow(10, decimals || 0);
        return Math.round((value + Number.EPSILON) * scale) / scale;
    }

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    function leastSquares(xSeries, ySeries) {
        var reduceSumFunc = function (prev, cur) {
            return prev + cur;
        };
        var xBar = (xSeries.reduce(reduceSumFunc) * 1.0) / xSeries.length;
        var yBar = (ySeries.reduce(reduceSumFunc) * 1.0) / ySeries.length;
        var ssXX = xSeries
            .map(function (d) {
            return Math.pow(d - xBar, 2);
        })
            .reduce(reduceSumFunc);
        var ssYY = ySeries
            .map(function (d) {
            return Math.pow(d - yBar, 2);
        })
            .reduce(reduceSumFunc);
        var ssXY = xSeries
            .map(function (d, i) {
            return (d - xBar) * (ySeries[i] - yBar);
        })
            .reduce(reduceSumFunc);
        var slope = ssXY / ssXX;
        var intercept = yBar - xBar * slope;
        var rSquare = Math.pow(ssXY, 2) / (ssXX * ssYY);
        return [slope, intercept, rSquare];
    }
    function capitalized(str) {
        return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function ascending$1 (a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector (compare) {
        if (compare.length === 1)
            compare = ascendingComparator(compare);
        return {
            left: function (a, x, lo, hi) {
                if (lo == null)
                    lo = 0;
                if (hi == null)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                        lo = mid + 1;
                    else
                        hi = mid;
                }
                return lo;
            },
            right: function (a, x, lo, hi) {
                if (lo == null)
                    lo = 0;
                if (hi == null)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                        hi = mid;
                    else
                        lo = mid + 1;
                }
                return lo;
            }
        };
    }
    function ascendingComparator(f) {
        return function (d, x) {
            return ascending$1(f(d), x);
        };
    }

    var ascendingBisect = bisector(ascending$1);
    var bisectRight = ascendingBisect.right;

    function range (start, stop, step) {
        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
        var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
        while (++i < n) {
            range[i] = start + i * step;
        }
        return range;
    }

    var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
    function ticks (start, stop, count) {
        var reverse, i = -1, n, ticks, step;
        stop = +stop, start = +start, count = +count;
        if (start === stop && count > 0)
            return [start];
        if (reverse = stop < start)
            n = start, start = stop, stop = n;
        if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step))
            return [];
        if (step > 0) {
            start = Math.ceil(start / step);
            stop = Math.floor(stop / step);
            ticks = new Array(n = Math.ceil(stop - start + 1));
            while (++i < n)
                ticks[i] = (start + i) * step;
        }
        else {
            start = Math.floor(start * step);
            stop = Math.ceil(stop * step);
            ticks = new Array(n = Math.ceil(start - stop + 1));
            while (++i < n)
                ticks[i] = (start - i) / step;
        }
        if (reverse)
            ticks.reverse();
        return ticks;
    }
    function tickIncrement(start, stop, count) {
        var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
        return power >= 0
            ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
            : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }
    function tickStep(start, stop, count) {
        var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
        if (error >= e10)
            step1 *= 10;
        else if (error >= e5)
            step1 *= 5;
        else if (error >= e2)
            step1 *= 2;
        return stop < start ? -step1 : step1;
    }

    function max (values, valueof) {
        var n = values.length, i = -1, value, max;
        if (valueof == null) {
            while (++i < n) { // Find the first comparable value.
                if ((value = values[i]) != null && value >= value) {
                    max = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = values[i]) != null && value > max) {
                            max = value;
                        }
                    }
                }
            }
        }
        else {
            while (++i < n) { // Find the first comparable value.
                if ((value = valueof(values[i], i, values)) != null && value >= value) {
                    max = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = valueof(values[i], i, values)) != null && value > max) {
                            max = value;
                        }
                    }
                }
            }
        }
        return max;
    }

    function merge (arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n)
            j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    }

    function min (values, valueof) {
        var n = values.length, i = -1, value, min;
        if (valueof == null) {
            while (++i < n) { // Find the first comparable value.
                if ((value = values[i]) != null && value >= value) {
                    min = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = values[i]) != null && min > value) {
                            min = value;
                        }
                    }
                }
            }
        }
        else {
            while (++i < n) { // Find the first comparable value.
                if ((value = valueof(values[i], i, values)) != null && value >= value) {
                    min = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = valueof(values[i], i, values)) != null && min > value) {
                            min = value;
                        }
                    }
                }
            }
        }
        return min;
    }

    function sum (values, valueof) {
        var n = values.length, i = -1, value, sum = 0;
        if (valueof == null) {
            while (++i < n) {
                if (value = +values[i])
                    sum += value; // Note: zero and null are equivalent.
            }
        }
        else {
            while (++i < n) {
                if (value = +valueof(values[i], i, values))
                    sum += value;
            }
        }
        return sum;
    }

    function initRange(domain, range) {
        switch (arguments.length) {
            case 0: break;
            case 1:
                this.range(domain);
                break;
            default:
                this.range(range).domain(domain);
                break;
        }
        return this;
    }

    var prefix = "$";
    function Map$1() { }
    Map$1.prototype = map.prototype = {
        constructor: Map$1,
        has: function (key) {
            return (prefix + key) in this;
        },
        get: function (key) {
            return this[prefix + key];
        },
        set: function (key, value) {
            this[prefix + key] = value;
            return this;
        },
        remove: function (key) {
            var property = prefix + key;
            return property in this && delete this[property];
        },
        clear: function () {
            for (var property in this)
                if (property[0] === prefix)
                    delete this[property];
        },
        keys: function () {
            var keys = [];
            for (var property in this)
                if (property[0] === prefix)
                    keys.push(property.slice(1));
            return keys;
        },
        values: function () {
            var values = [];
            for (var property in this)
                if (property[0] === prefix)
                    values.push(this[property]);
            return values;
        },
        entries: function () {
            var entries = [];
            for (var property in this)
                if (property[0] === prefix)
                    entries.push({ key: property.slice(1), value: this[property] });
            return entries;
        },
        size: function () {
            var size = 0;
            for (var property in this)
                if (property[0] === prefix)
                    ++size;
            return size;
        },
        empty: function () {
            for (var property in this)
                if (property[0] === prefix)
                    return false;
            return true;
        },
        each: function (f) {
            for (var property in this)
                if (property[0] === prefix)
                    f(this[property], property.slice(1), this);
        }
    };
    function map(object, f) {
        var map = new Map$1;
        // Copy constructor.
        if (object instanceof Map$1)
            object.each(function (value, key) { map.set(key, value); });
        // Index array by numeric index or specified key function.
        else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (f == null)
                while (++i < n)
                    map.set(i, object[i]);
            else
                while (++i < n)
                    map.set(f(o = object[i], i, object), o);
        }
        // Convert object to map.
        else if (object)
            for (var key in object)
                map.set(key, object[key]);
        return map;
    }

    var array = Array.prototype;
    var map$1 = array.map;
    var slice = array.slice;

    var implicit = { name: "implicit" };
    function ordinal() {
        var index = map(), domain = [], range = [], unknown = implicit;
        function scale(d) {
            var key = d + "", i = index.get(key);
            if (!i) {
                if (unknown !== implicit)
                    return unknown;
                index.set(key, i = domain.push(d));
            }
            return range[(i - 1) % range.length];
        }
        scale.domain = function (_) {
            if (!arguments.length)
                return domain.slice();
            domain = [], index = map();
            var i = -1, n = _.length, d, key;
            while (++i < n)
                if (!index.has(key = (d = _[i]) + ""))
                    index.set(key, domain.push(d));
            return scale;
        };
        scale.range = function (_) {
            return arguments.length ? (range = slice.call(_), scale) : range.slice();
        };
        scale.unknown = function (_) {
            return arguments.length ? (unknown = _, scale) : unknown;
        };
        scale.copy = function () {
            return ordinal(domain, range).unknown(unknown);
        };
        initRange.apply(scale, arguments);
        return scale;
    }

    function define (constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
    }
    function extend(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition)
            prototype[key] = definition[key];
        return prototype;
    }

    function Color() { }
    var darker = 0.7;
    var brighter = 1 / darker;
    var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
    var named = {
        aliceblue: 0xf0f8ff,
        antiquewhite: 0xfaebd7,
        aqua: 0x00ffff,
        aquamarine: 0x7fffd4,
        azure: 0xf0ffff,
        beige: 0xf5f5dc,
        bisque: 0xffe4c4,
        black: 0x000000,
        blanchedalmond: 0xffebcd,
        blue: 0x0000ff,
        blueviolet: 0x8a2be2,
        brown: 0xa52a2a,
        burlywood: 0xdeb887,
        cadetblue: 0x5f9ea0,
        chartreuse: 0x7fff00,
        chocolate: 0xd2691e,
        coral: 0xff7f50,
        cornflowerblue: 0x6495ed,
        cornsilk: 0xfff8dc,
        crimson: 0xdc143c,
        cyan: 0x00ffff,
        darkblue: 0x00008b,
        darkcyan: 0x008b8b,
        darkgoldenrod: 0xb8860b,
        darkgray: 0xa9a9a9,
        darkgreen: 0x006400,
        darkgrey: 0xa9a9a9,
        darkkhaki: 0xbdb76b,
        darkmagenta: 0x8b008b,
        darkolivegreen: 0x556b2f,
        darkorange: 0xff8c00,
        darkorchid: 0x9932cc,
        darkred: 0x8b0000,
        darksalmon: 0xe9967a,
        darkseagreen: 0x8fbc8f,
        darkslateblue: 0x483d8b,
        darkslategray: 0x2f4f4f,
        darkslategrey: 0x2f4f4f,
        darkturquoise: 0x00ced1,
        darkviolet: 0x9400d3,
        deeppink: 0xff1493,
        deepskyblue: 0x00bfff,
        dimgray: 0x696969,
        dimgrey: 0x696969,
        dodgerblue: 0x1e90ff,
        firebrick: 0xb22222,
        floralwhite: 0xfffaf0,
        forestgreen: 0x228b22,
        fuchsia: 0xff00ff,
        gainsboro: 0xdcdcdc,
        ghostwhite: 0xf8f8ff,
        gold: 0xffd700,
        goldenrod: 0xdaa520,
        gray: 0x808080,
        green: 0x008000,
        greenyellow: 0xadff2f,
        grey: 0x808080,
        honeydew: 0xf0fff0,
        hotpink: 0xff69b4,
        indianred: 0xcd5c5c,
        indigo: 0x4b0082,
        ivory: 0xfffff0,
        khaki: 0xf0e68c,
        lavender: 0xe6e6fa,
        lavenderblush: 0xfff0f5,
        lawngreen: 0x7cfc00,
        lemonchiffon: 0xfffacd,
        lightblue: 0xadd8e6,
        lightcoral: 0xf08080,
        lightcyan: 0xe0ffff,
        lightgoldenrodyellow: 0xfafad2,
        lightgray: 0xd3d3d3,
        lightgreen: 0x90ee90,
        lightgrey: 0xd3d3d3,
        lightpink: 0xffb6c1,
        lightsalmon: 0xffa07a,
        lightseagreen: 0x20b2aa,
        lightskyblue: 0x87cefa,
        lightslategray: 0x778899,
        lightslategrey: 0x778899,
        lightsteelblue: 0xb0c4de,
        lightyellow: 0xffffe0,
        lime: 0x00ff00,
        limegreen: 0x32cd32,
        linen: 0xfaf0e6,
        magenta: 0xff00ff,
        maroon: 0x800000,
        mediumaquamarine: 0x66cdaa,
        mediumblue: 0x0000cd,
        mediumorchid: 0xba55d3,
        mediumpurple: 0x9370db,
        mediumseagreen: 0x3cb371,
        mediumslateblue: 0x7b68ee,
        mediumspringgreen: 0x00fa9a,
        mediumturquoise: 0x48d1cc,
        mediumvioletred: 0xc71585,
        midnightblue: 0x191970,
        mintcream: 0xf5fffa,
        mistyrose: 0xffe4e1,
        moccasin: 0xffe4b5,
        navajowhite: 0xffdead,
        navy: 0x000080,
        oldlace: 0xfdf5e6,
        olive: 0x808000,
        olivedrab: 0x6b8e23,
        orange: 0xffa500,
        orangered: 0xff4500,
        orchid: 0xda70d6,
        palegoldenrod: 0xeee8aa,
        palegreen: 0x98fb98,
        paleturquoise: 0xafeeee,
        palevioletred: 0xdb7093,
        papayawhip: 0xffefd5,
        peachpuff: 0xffdab9,
        peru: 0xcd853f,
        pink: 0xffc0cb,
        plum: 0xdda0dd,
        powderblue: 0xb0e0e6,
        purple: 0x800080,
        rebeccapurple: 0x663399,
        red: 0xff0000,
        rosybrown: 0xbc8f8f,
        royalblue: 0x4169e1,
        saddlebrown: 0x8b4513,
        salmon: 0xfa8072,
        sandybrown: 0xf4a460,
        seagreen: 0x2e8b57,
        seashell: 0xfff5ee,
        sienna: 0xa0522d,
        silver: 0xc0c0c0,
        skyblue: 0x87ceeb,
        slateblue: 0x6a5acd,
        slategray: 0x708090,
        slategrey: 0x708090,
        snow: 0xfffafa,
        springgreen: 0x00ff7f,
        steelblue: 0x4682b4,
        tan: 0xd2b48c,
        teal: 0x008080,
        thistle: 0xd8bfd8,
        tomato: 0xff6347,
        turquoise: 0x40e0d0,
        violet: 0xee82ee,
        wheat: 0xf5deb3,
        white: 0xffffff,
        whitesmoke: 0xf5f5f5,
        yellow: 0xffff00,
        yellowgreen: 0x9acd32
    };
    define(Color, color, {
        copy: function (channels) {
            return Object.assign(new this.constructor, this, channels);
        },
        displayable: function () {
            return this.rgb().displayable();
        },
        hex: color_formatHex,
        formatHex: color_formatHex,
        formatHsl: color_formatHsl,
        formatRgb: color_formatRgb,
        toString: color_formatRgb
    });
    function color_formatHex() {
        return this.rgb().formatHex();
    }
    function color_formatHsl() {
        return hslConvert(this).formatHsl();
    }
    function color_formatRgb() {
        return this.rgb().formatRgb();
    }
    function color(format) {
        var m, l;
        format = (format + "").trim().toLowerCase();
        return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
            : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
                : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
                    : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
                        : null) // invalid hex
            : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
                : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
                    : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
                        : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
                            : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
                                : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
                                    : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
                                        : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
                                            : null;
    }
    function rgbn(n) {
        return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }
    function rgba(r, g, b, a) {
        if (a <= 0)
            r = g = b = NaN;
        return new Rgb(r, g, b, a);
    }
    function rgbConvert(o) {
        if (!(o instanceof Color))
            o = color(o);
        if (!o)
            return new Rgb;
        o = o.rgb();
        return new Rgb(o.r, o.g, o.b, o.opacity);
    }
    function rgb(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
    }
    define(Rgb, rgb, extend(Color, {
        brighter: function (k) {
            k = k == null ? brighter : Math.pow(brighter, k);
            return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker : Math.pow(darker, k);
            return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function () {
            return this;
        },
        displayable: function () {
            return (-0.5 <= this.r && this.r < 255.5)
                && (-0.5 <= this.g && this.g < 255.5)
                && (-0.5 <= this.b && this.b < 255.5)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        hex: rgb_formatHex,
        formatHex: rgb_formatHex,
        formatRgb: rgb_formatRgb,
        toString: rgb_formatRgb
    }));
    function rgb_formatHex() {
        return "#" + hex(this.r) + hex(this.g) + hex(this.b);
    }
    function rgb_formatRgb() {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "rgb(" : "rgba(")
            + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.b) || 0))
            + (a === 1 ? ")" : ", " + a + ")");
    }
    function hex(value) {
        value = Math.max(0, Math.min(255, Math.round(value) || 0));
        return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla(h, s, l, a) {
        if (a <= 0)
            h = s = l = NaN;
        else if (l <= 0 || l >= 1)
            h = s = NaN;
        else if (s <= 0)
            h = NaN;
        return new Hsl(h, s, l, a);
    }
    function hslConvert(o) {
        if (o instanceof Hsl)
            return new Hsl(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color))
            o = color(o);
        if (!o)
            return new Hsl;
        if (o instanceof Hsl)
            return o;
        o = o.rgb();
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
        if (s) {
            if (r === max)
                h = (g - b) / s + (g < b) * 6;
            else if (g === max)
                h = (b - r) / s + 2;
            else
                h = (r - g) / s + 4;
            s /= l < 0.5 ? max + min : 2 - max - min;
            h *= 60;
        }
        else {
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl(h, s, l, o.opacity);
    }
    function hsl(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }
    function Hsl(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define(Hsl, hsl, extend(Color, {
        brighter: function (k) {
            k = k == null ? brighter : Math.pow(brighter, k);
            return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker : Math.pow(darker, k);
            return new Hsl(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
            return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
        },
        displayable: function () {
            return (0 <= this.s && this.s <= 1 || isNaN(this.s))
                && (0 <= this.l && this.l <= 1)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        formatHsl: function () {
            var a = this.opacity;
            a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
            return (a === 1 ? "hsl(" : "hsla(")
                + (this.h || 0) + ", "
                + (this.s || 0) * 100 + "%, "
                + (this.l || 0) * 100 + "%"
                + (a === 1 ? ")" : ", " + a + ")");
        }
    }));
    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60
            : h < 180 ? m2
                : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
                    : m1) * 255;
    }

    var deg2rad = Math.PI / 180;
    var rad2deg = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    var K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0 = 4 / 29, t1 = 6 / 29, t2 = 3 * t1 * t1, t3 = t1 * t1 * t1;
    function labConvert(o) {
        if (o instanceof Lab)
            return new Lab(o.l, o.a, o.b, o.opacity);
        if (o instanceof Hcl)
            return hcl2lab(o);
        if (!(o instanceof Rgb))
            o = rgbConvert(o);
        var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
        if (r === g && g === b)
            x = z = y;
        else {
            x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
            z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
        }
        return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }
    function lab(l, a, b, opacity) {
        return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }
    function Lab(l, a, b, opacity) {
        this.l = +l;
        this.a = +a;
        this.b = +b;
        this.opacity = +opacity;
    }
    define(Lab, lab, extend(Color, {
        brighter: function (k) {
            return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        darker: function (k) {
            return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        rgb: function () {
            var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
            x = Xn * lab2xyz(x);
            y = Yn * lab2xyz(y);
            z = Zn * lab2xyz(z);
            return new Rgb(lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
        }
    }));
    function xyz2lab(t) {
        return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
    }
    function lab2xyz(t) {
        return t > t1 ? t * t * t : t2 * (t - t0);
    }
    function lrgb2rgb(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }
    function rgb2lrgb(x) {
        return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }
    function hclConvert(o) {
        if (o instanceof Hcl)
            return new Hcl(o.h, o.c, o.l, o.opacity);
        if (!(o instanceof Lab))
            o = labConvert(o);
        if (o.a === 0 && o.b === 0)
            return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
        var h = Math.atan2(o.b, o.a) * rad2deg;
        return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }
    function hcl(h, c, l, opacity) {
        return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }
    function Hcl(h, c, l, opacity) {
        this.h = +h;
        this.c = +c;
        this.l = +l;
        this.opacity = +opacity;
    }
    function hcl2lab(o) {
        if (isNaN(o.h))
            return new Lab(o.l, 0, 0, o.opacity);
        var h = o.h * deg2rad;
        return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }
    define(Hcl, hcl, extend(Color, {
        brighter: function (k) {
            return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
        },
        darker: function (k) {
            return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
        },
        rgb: function () {
            return hcl2lab(this).rgb();
        }
    }));

    var A = -0.14861, B = +1.78277, C = -0.29227, D = -0.90649, E = +1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
    function cubehelixConvert(o) {
        if (o instanceof Cubehelix)
            return new Cubehelix(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Rgb))
            o = rgbConvert(o);
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
        return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }
    function cubehelix(h, s, l, opacity) {
        return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }
    function Cubehelix(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define(Cubehelix, cubehelix, extend(Color, {
        brighter: function (k) {
            k = k == null ? brighter : Math.pow(brighter, k);
            return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker : Math.pow(darker, k);
            return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
            return new Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
        }
    }));

    function constant$1 (x) {
        return function () {
            return x;
        };
    }

    function linear(a, d) {
        return function (t) {
            return a + t * d;
        };
    }
    function exponential(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
            return Math.pow(a + t * b, y);
        };
    }
    function gamma(y) {
        return (y = +y) === 1 ? nogamma : function (a, b) {
            return b - a ? exponential(a, b, y) : constant$1(isNaN(a) ? b : a);
        };
    }
    function nogamma(a, b) {
        var d = b - a;
        return d ? linear(a, d) : constant$1(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
        var color = gamma(y);
        function rgb$1(start, end) {
            var r = color((start = rgb(start)).r, (end = rgb(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
            return function (t) {
                start.r = r(t);
                start.g = g(t);
                start.b = b(t);
                start.opacity = opacity(t);
                return start + "";
            };
        }
        rgb$1.gamma = rgbGamma;
        return rgb$1;
    })(1);

    function numberArray (a, b) {
        if (!b)
            b = [];
        var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
        return function (t) {
            for (i = 0; i < n; ++i)
                c[i] = a[i] * (1 - t) + b[i] * t;
            return c;
        };
    }
    function isNumberArray(x) {
        return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function genericArray(a, b) {
        var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
        for (i = 0; i < na; ++i)
            x[i] = interpolate(a[i], b[i]);
        for (; i < nb; ++i)
            c[i] = b[i];
        return function (t) {
            for (i = 0; i < na; ++i)
                c[i] = x[i](t);
            return c;
        };
    }

    function date (a, b) {
        var d = new Date;
        return a = +a, b = +b, function (t) {
            return d.setTime(a * (1 - t) + b * t), d;
        };
    }

    function interpolateNumber (a, b) {
        return a = +a, b = +b, function (t) {
            return a * (1 - t) + b * t;
        };
    }

    function object (a, b) {
        var i = {}, c = {}, k;
        if (a === null || typeof a !== "object")
            a = {};
        if (b === null || typeof b !== "object")
            b = {};
        for (k in b) {
            if (k in a) {
                i[k] = interpolate(a[k], b[k]);
            }
            else {
                c[k] = b[k];
            }
        }
        return function (t) {
            for (k in i)
                c[k] = i[k](t);
            return c;
        };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
    function zero(b) {
        return function () {
            return b;
        };
    }
    function one(b) {
        return function (t) {
            return b(t) + "";
        };
    }
    function interpolateString (a, b) {
        var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators
        // Coerce inputs to strings.
        a = a + "", b = b + "";
        // Interpolate pairs of numbers in a & b.
        while ((am = reA.exec(a))
            && (bm = reB.exec(b))) {
            if ((bs = bm.index) > bi) { // a string precedes the next number in b
                bs = b.slice(bi, bs);
                if (s[i])
                    s[i] += bs; // coalesce with previous string
                else
                    s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
                if (s[i])
                    s[i] += bm; // coalesce with previous string
                else
                    s[++i] = bm;
            }
            else { // interpolate non-matching numbers
                s[++i] = null;
                q.push({ i: i, x: interpolateNumber(am, bm) });
            }
            bi = reB.lastIndex;
        }
        // Add remains of b.
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
                s[i] += bs; // coalesce with previous string
            else
                s[++i] = bs;
        }
        // Special optimization for only a single match.
        // Otherwise, interpolate each of the numbers and rejoin the string.
        return s.length < 2 ? (q[0]
            ? one(q[0].x)
            : zero(b))
            : (b = q.length, function (t) {
                for (var i = 0, o; i < b; ++i)
                    s[(o = q[i]).i] = o.x(t);
                return s.join("");
            });
    }

    function interpolate (a, b) {
        var t = typeof b, c;
        return b == null || t === "boolean" ? constant$1(b)
            : (t === "number" ? interpolateNumber
                : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
                    : b instanceof color ? interpolateRgb
                        : b instanceof Date ? date
                            : isNumberArray(b) ? numberArray
                                : Array.isArray(b) ? genericArray
                                    : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object
                                        : interpolateNumber)(a, b);
    }

    function interpolateRound (a, b) {
        return a = +a, b = +b, function (t) {
            return Math.round(a * (1 - t) + b * t);
        };
    }

    var degrees = 180 / Math.PI;
    var identity = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        scaleX: 1,
        scaleY: 1
    };
    function decompose (a, b, c, d, e, f) {
        var scaleX, scaleY, skewX;
        if (scaleX = Math.sqrt(a * a + b * b))
            a /= scaleX, b /= scaleX;
        if (skewX = a * c + b * d)
            c -= a * skewX, d -= b * skewX;
        if (scaleY = Math.sqrt(c * c + d * d))
            c /= scaleY, d /= scaleY, skewX /= scaleY;
        if (a * d < b * c)
            a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
        return {
            translateX: e,
            translateY: f,
            rotate: Math.atan2(b, a) * degrees,
            skewX: Math.atan(skewX) * degrees,
            scaleX: scaleX,
            scaleY: scaleY
        };
    }

    var cssNode, cssRoot, cssView, svgNode;
    function parseCss(value) {
        if (value === "none")
            return identity;
        if (!cssNode)
            cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
        cssNode.style.transform = value;
        value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
        cssRoot.removeChild(cssNode);
        value = value.slice(7, -1).split(",");
        return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
    }
    function parseSvg(value) {
        if (value == null)
            return identity;
        if (!svgNode)
            svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svgNode.setAttribute("transform", value);
        if (!(value = svgNode.transform.baseVal.consolidate()))
            return identity;
        value = value.matrix;
        return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {
        function pop(s) {
            return s.length ? s.pop() + " " : "";
        }
        function translate(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push("translate(", null, pxComma, null, pxParen);
                q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
            }
            else if (xb || yb) {
                s.push("translate(" + xb + pxComma + yb + pxParen);
            }
        }
        function rotate(a, b, s, q) {
            if (a !== b) {
                if (a - b > 180)
                    b += 360;
                else if (b - a > 180)
                    a += 360; // shortest path
                q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
            }
            else if (b) {
                s.push(pop(s) + "rotate(" + b + degParen);
            }
        }
        function skewX(a, b, s, q) {
            if (a !== b) {
                q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
            }
            else if (b) {
                s.push(pop(s) + "skewX(" + b + degParen);
            }
        }
        function scale(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push(pop(s) + "scale(", null, ",", null, ")");
                q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
            }
            else if (xb !== 1 || yb !== 1) {
                s.push(pop(s) + "scale(" + xb + "," + yb + ")");
            }
        }
        return function (a, b) {
            var s = [], // string constants and placeholders
            q = []; // number interpolators
            a = parse(a), b = parse(b);
            translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
            rotate(a.rotate, b.rotate, s, q);
            skewX(a.skewX, b.skewX, s, q);
            scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
            a = b = null; // gc
            return function (t) {
                var i = -1, n = q.length, o;
                while (++i < n)
                    s[(o = q[i]).i] = o.x(t);
                return s.join("");
            };
        };
    }
    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var rho = Math.SQRT2, rho2 = 2, rho4 = 4, epsilon2 = 1e-12;
    function cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    // p0 = [ux0, uy0, w0]
    // p1 = [ux1, uy1, w1]
    function interpolateZoom (p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        // Special case for u0 ≅ u1.
        if (d2 < epsilon2) {
            S = Math.log(w1 / w0) / rho;
            i = function (t) {
                return [
                    ux0 + t * dx,
                    uy0 + t * dy,
                    w0 * Math.exp(rho * t * S)
                ];
            };
        }
        // General case.
        else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / rho;
            i = function (t) {
                var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
                return [
                    ux0 + u * dx,
                    uy0 + u * dy,
                    w0 * coshr0 / cosh(rho * s + r0)
                ];
            };
        }
        i.duration = S * 1000;
        return i;
    }

    function constant$2 (x) {
        return function () {
            return x;
        };
    }

    function number (x) {
        return +x;
    }

    var unit = [0, 1];
    function identity$1(x) {
        return x;
    }
    function normalize(a, b) {
        return (b -= (a = +a))
            ? function (x) { return (x - a) / b; }
            : constant$2(isNaN(b) ? NaN : 0.5);
    }
    function clamper(domain) {
        var a = domain[0], b = domain[domain.length - 1], t;
        if (a > b)
            t = a, a = b, b = t;
        return function (x) { return Math.max(a, Math.min(b, x)); };
    }
    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
        var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
        if (d1 < d0)
            d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
        else
            d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
        return function (x) { return r0(d0(x)); };
    }
    function polymap(domain, range, interpolate) {
        var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
        // Reverse descending domains.
        if (domain[j] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++i < j) {
            d[i] = normalize(domain[i], domain[i + 1]);
            r[i] = interpolate(range[i], range[i + 1]);
        }
        return function (x) {
            var i = bisectRight(domain, x, 1, j) - 1;
            return r[i](d[i](x));
        };
    }
    function copy(source, target) {
        return target
            .domain(source.domain())
            .range(source.range())
            .interpolate(source.interpolate())
            .clamp(source.clamp())
            .unknown(source.unknown());
    }
    function transformer() {
        var domain = unit, range = unit, interpolate$1 = interpolate, transform, untransform, unknown, clamp = identity$1, piecewise, output, input;
        function rescale() {
            piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
            output = input = null;
            return scale;
        }
        function scale(x) {
            return isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate$1)))(transform(clamp(x)));
        }
        scale.invert = function (y) {
            return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
        };
        scale.domain = function (_) {
            return arguments.length ? (domain = map$1.call(_, number), clamp === identity$1 || (clamp = clamper(domain)), rescale()) : domain.slice();
        };
        scale.range = function (_) {
            return arguments.length ? (range = slice.call(_), rescale()) : range.slice();
        };
        scale.rangeRound = function (_) {
            return range = slice.call(_), interpolate$1 = interpolateRound, rescale();
        };
        scale.clamp = function (_) {
            return arguments.length ? (clamp = _ ? clamper(domain) : identity$1, scale) : clamp !== identity$1;
        };
        scale.interpolate = function (_) {
            return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
        };
        scale.unknown = function (_) {
            return arguments.length ? (unknown = _, scale) : unknown;
        };
        return function (t, u) {
            transform = t, untransform = u;
            return rescale();
        };
    }
    function continuous(transform, untransform) {
        return transformer()(transform, untransform);
    }

    function formatDecimal (x) {
        return Math.abs(x = Math.round(x)) >= 1e21
            ? x.toLocaleString("en").replace(/,/g, "")
            : x.toString(10);
    }
    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
        if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
            return null; // NaN, ±Infinity
        var i, coefficient = x.slice(0, i);
        // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
        // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
        return [
            coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
            +x.slice(i + 1)
        ];
    }

    function exponent (x) {
        return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup (grouping, thousands) {
        return function (value, width) {
            var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
            while (i > 0 && g > 0) {
                if (length + g + 1 > width)
                    g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width)
                    break;
                g = grouping[j = (j + 1) % grouping.length];
            }
            return t.reverse().join(thousands);
        };
    }

    function formatNumerals (numerals) {
        return function (value) {
            return value.replace(/[0-9]/g, function (i) {
                return numerals[+i];
            });
        };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier(specifier) {
        if (!(match = re.exec(specifier)))
            throw new Error("invalid format: " + specifier);
        var match;
        return new FormatSpecifier({
            fill: match[1],
            align: match[2],
            sign: match[3],
            symbol: match[4],
            zero: match[5],
            width: match[6],
            comma: match[7],
            precision: match[8] && match[8].slice(1),
            trim: match[9],
            type: match[10]
        });
    }
    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof
    function FormatSpecifier(specifier) {
        this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
        this.align = specifier.align === undefined ? ">" : specifier.align + "";
        this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
        this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
        this.zero = !!specifier.zero;
        this.width = specifier.width === undefined ? undefined : +specifier.width;
        this.comma = !!specifier.comma;
        this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
        this.trim = !!specifier.trim;
        this.type = specifier.type === undefined ? "" : specifier.type + "";
    }
    FormatSpecifier.prototype.toString = function () {
        return this.fill
            + this.align
            + this.sign
            + this.symbol
            + (this.zero ? "0" : "")
            + (this.width === undefined ? "" : Math.max(1, this.width | 0))
            + (this.comma ? "," : "")
            + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
            + (this.trim ? "~" : "")
            + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim (s) {
        out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
            switch (s[i]) {
                case ".":
                    i0 = i1 = i;
                    break;
                case "0":
                    if (i0 === 0)
                        i0 = i;
                    i1 = i;
                    break;
                default:
                    if (!+s[i])
                        break out;
                    if (i0 > 0)
                        i0 = 0;
                    break;
            }
        }
        return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;
    function formatPrefixAuto (x, p) {
        var d = formatDecimalParts(x, p);
        if (!d)
            return x + "";
        var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
        return i === n ? coefficient
            : i > n ? coefficient + new Array(i - n + 1).join("0")
                : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
                    : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded (x, p) {
        var d = formatDecimalParts(x, p);
        if (!d)
            return x + "";
        var coefficient = d[0], exponent = d[1];
        return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
            : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
                : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
        "%": function (x, p) { return (x * 100).toFixed(p); },
        "b": function (x) { return Math.round(x).toString(2); },
        "c": function (x) { return x + ""; },
        "d": formatDecimal,
        "e": function (x, p) { return x.toExponential(p); },
        "f": function (x, p) { return x.toFixed(p); },
        "g": function (x, p) { return x.toPrecision(p); },
        "o": function (x) { return Math.round(x).toString(8); },
        "p": function (x, p) { return formatRounded(x * 100, p); },
        "r": formatRounded,
        "s": formatPrefixAuto,
        "X": function (x) { return Math.round(x).toString(16).toUpperCase(); },
        "x": function (x) { return Math.round(x).toString(16); }
    };

    function identity$2 (x) {
        return x;
    }

    var map$2 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale (locale) {
        var group = locale.grouping === undefined || locale.thousands === undefined ? identity$2 : formatGroup(map$2.call(locale.grouping, Number), locale.thousands + ""), currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "", currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "", decimal = locale.decimal === undefined ? "." : locale.decimal + "", numerals = locale.numerals === undefined ? identity$2 : formatNumerals(map$2.call(locale.numerals, String)), percent = locale.percent === undefined ? "%" : locale.percent + "", minus = locale.minus === undefined ? "-" : locale.minus + "", nan = locale.nan === undefined ? "NaN" : locale.nan + "";
        function newFormat(specifier) {
            specifier = formatSpecifier(specifier);
            var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
            // The "n" type is an alias for ",g".
            if (type === "n")
                comma = true, type = "g";
            // The "" type, and any invalid type, is an alias for ".12~g".
            else if (!formatTypes[type])
                precision === undefined && (precision = 12), trim = true, type = "g";
            // If zero fill is specified, padding goes after sign and before digits.
            if (zero || (fill === "0" && align === "="))
                zero = true, fill = "0", align = "=";
            // Compute the prefix and suffix.
            // For SI-prefix, the suffix is lazily computed.
            var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
            // What format function should we use?
            // Is this an integer type?
            // Can this type generate exponential notation?
            var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
            // Set the default precision if not specified,
            // or clamp the specified precision to the supported range.
            // For significant precision, it must be in [1, 21].
            // For fixed precision, it must be in [0, 20].
            precision = precision === undefined ? 6
                : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
                    : Math.max(0, Math.min(20, precision));
            function format(value) {
                var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
                if (type === "c") {
                    valueSuffix = formatType(value) + valueSuffix;
                    value = "";
                }
                else {
                    value = +value;
                    // Determine the sign. -0 is not less than 0, but 1 / -0 is!
                    var valueNegative = value < 0 || 1 / value < 0;
                    // Perform the initial formatting.
                    value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                    // Trim insignificant zeros.
                    if (trim)
                        value = formatTrim(value);
                    // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
                    if (valueNegative && +value === 0 && sign !== "+")
                        valueNegative = false;
                    // Compute the prefix and suffix.
                    valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                    valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                    // Break the formatted value into the integer “value” part that can be
                    // grouped, and fractional or exponential “suffix” part that is not.
                    if (maybeSuffix) {
                        i = -1, n = value.length;
                        while (++i < n) {
                            if (c = value.charCodeAt(i), 48 > c || c > 57) {
                                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                                value = value.slice(0, i);
                                break;
                            }
                        }
                    }
                }
                // If the fill character is not "0", grouping is applied before padding.
                if (comma && !zero)
                    value = group(value, Infinity);
                // Compute the padding.
                var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
                // If the fill character is "0", grouping is applied after padding.
                if (comma && zero)
                    value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
                // Reconstruct the final output based on the desired alignment.
                switch (align) {
                    case "<":
                        value = valuePrefix + value + valueSuffix + padding;
                        break;
                    case "=":
                        value = valuePrefix + padding + value + valueSuffix;
                        break;
                    case "^":
                        value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                        break;
                    default:
                        value = padding + valuePrefix + value + valueSuffix;
                        break;
                }
                return numerals(value);
            }
            format.toString = function () {
                return specifier + "";
            };
            return format;
        }
        function formatPrefix(specifier, value) {
            var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
            return function (value) {
                return f(k * value) + prefix;
            };
        }
        return {
            format: newFormat,
            formatPrefix: formatPrefix
        };
    }

    var locale;
    var format;
    var formatPrefix;
    defaultLocale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        minus: "-"
    });
    function defaultLocale(definition) {
        locale = formatLocale(definition);
        format = locale.format;
        formatPrefix = locale.formatPrefix;
        return locale;
    }

    function precisionFixed (step) {
        return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix (step, value) {
        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound (step, max) {
        step = Math.abs(step), max = Math.abs(max) - step;
        return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    function tickFormat (start, stop, count, specifier) {
        var step = tickStep(start, stop, count), precision;
        specifier = formatSpecifier(specifier == null ? ",f" : specifier);
        switch (specifier.type) {
            case "s": {
                var value = Math.max(Math.abs(start), Math.abs(stop));
                if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
                    specifier.precision = precision;
                return formatPrefix(specifier, value);
            }
            case "":
            case "e":
            case "g":
            case "p":
            case "r": {
                if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)))))
                    specifier.precision = precision - (specifier.type === "e");
                break;
            }
            case "f":
            case "%": {
                if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
                    specifier.precision = precision - (specifier.type === "%") * 2;
                break;
            }
        }
        return format(specifier);
    }

    function linearish(scale) {
        var domain = scale.domain;
        scale.ticks = function (count) {
            var d = domain();
            return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
        };
        scale.tickFormat = function (count, specifier) {
            var d = domain();
            return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
        };
        scale.nice = function (count) {
            if (count == null)
                count = 10;
            var d = domain(), i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], step;
            if (stop < start) {
                step = start, start = stop, stop = step;
                step = i0, i0 = i1, i1 = step;
            }
            step = tickIncrement(start, stop, count);
            if (step > 0) {
                start = Math.floor(start / step) * step;
                stop = Math.ceil(stop / step) * step;
                step = tickIncrement(start, stop, count);
            }
            else if (step < 0) {
                start = Math.ceil(start * step) / step;
                stop = Math.floor(stop * step) / step;
                step = tickIncrement(start, stop, count);
            }
            if (step > 0) {
                d[i0] = Math.floor(start / step) * step;
                d[i1] = Math.ceil(stop / step) * step;
                domain(d);
            }
            else if (step < 0) {
                d[i0] = Math.ceil(start * step) / step;
                d[i1] = Math.floor(stop * step) / step;
                domain(d);
            }
            return scale;
        };
        return scale;
    }
    function linear$1() {
        var scale = continuous(identity$1, identity$1);
        scale.copy = function () {
            return copy(scale, linear$1());
        };
        initRange.apply(scale, arguments);
        return linearish(scale);
    }

    function transformPow(exponent) {
        return function (x) {
            return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
        };
    }
    function transformSqrt(x) {
        return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }
    function transformSquare(x) {
        return x < 0 ? -x * x : x * x;
    }
    function powish(transform) {
        var scale = transform(identity$1, identity$1), exponent = 1;
        function rescale() {
            return exponent === 1 ? transform(identity$1, identity$1)
                : exponent === 0.5 ? transform(transformSqrt, transformSquare)
                    : transform(transformPow(exponent), transformPow(1 / exponent));
        }
        scale.exponent = function (_) {
            return arguments.length ? (exponent = +_, rescale()) : exponent;
        };
        return linearish(scale);
    }
    function pow() {
        var scale = powish(transformer());
        scale.copy = function () {
            return copy(scale, pow()).exponent(scale.exponent());
        };
        initRange.apply(scale, arguments);
        return scale;
    }
    function sqrt() {
        return pow.apply(null, arguments).exponent(0.5);
    }

    function quantize() {
        var x0 = 0, x1 = 1, n = 1, domain = [0.5], range = [0, 1], unknown;
        function scale(x) {
            return x <= x ? range[bisectRight(domain, x, 0, n)] : unknown;
        }
        function rescale() {
            var i = -1;
            domain = new Array(n);
            while (++i < n)
                domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
            return scale;
        }
        scale.domain = function (_) {
            return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
        };
        scale.range = function (_) {
            return arguments.length ? (n = (range = slice.call(_)).length - 1, rescale()) : range.slice();
        };
        scale.invertExtent = function (y) {
            var i = range.indexOf(y);
            return i < 0 ? [NaN, NaN]
                : i < 1 ? [x0, domain[0]]
                    : i >= n ? [domain[n - 1], x1]
                        : [domain[i - 1], domain[i]];
        };
        scale.unknown = function (_) {
            return arguments.length ? (unknown = _, scale) : scale;
        };
        scale.thresholds = function () {
            return domain.slice();
        };
        scale.copy = function () {
            return quantize()
                .domain([x0, x1])
                .range(range)
                .unknown(unknown);
        };
        return initRange.apply(linearish(scale), arguments);
    }

    var t0$1 = new Date, t1$1 = new Date;
    function newInterval(floori, offseti, count, field) {
        function interval(date) {
            return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
        }
        interval.floor = function (date) {
            return floori(date = new Date(+date)), date;
        };
        interval.ceil = function (date) {
            return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
        };
        interval.round = function (date) {
            var d0 = interval(date), d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1;
        };
        interval.offset = function (date, step) {
            return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
        };
        interval.range = function (start, stop, step) {
            var range = [], previous;
            start = interval.ceil(start);
            step = step == null ? 1 : Math.floor(step);
            if (!(start < stop) || !(step > 0))
                return range; // also handles Invalid Date
            do
                range.push(previous = new Date(+start)), offseti(start, step), floori(start);
            while (previous < start && start < stop);
            return range;
        };
        interval.filter = function (test) {
            return newInterval(function (date) {
                if (date >= date)
                    while (floori(date), !test(date))
                        date.setTime(date - 1);
            }, function (date, step) {
                if (date >= date) {
                    if (step < 0)
                        while (++step <= 0) {
                            while (offseti(date, -1), !test(date)) { } // eslint-disable-line no-empty
                        }
                    else
                        while (--step >= 0) {
                            while (offseti(date, +1), !test(date)) { } // eslint-disable-line no-empty
                        }
                }
            });
        };
        if (count) {
            interval.count = function (start, end) {
                t0$1.setTime(+start), t1$1.setTime(+end);
                floori(t0$1), floori(t1$1);
                return Math.floor(count(t0$1, t1$1));
            };
            interval.every = function (step) {
                step = Math.floor(step);
                return !isFinite(step) || !(step > 0) ? null
                    : !(step > 1) ? interval
                        : interval.filter(field
                            ? function (d) { return field(d) % step === 0; }
                            : function (d) { return interval.count(0, d) % step === 0; });
            };
        }
        return interval;
    }

    var millisecond = newInterval(function () {
        // noop
    }, function (date, step) {
        date.setTime(+date + step);
    }, function (start, end) {
        return end - start;
    });
    // An optimized implementation for this simple case.
    millisecond.every = function (k) {
        k = Math.floor(k);
        if (!isFinite(k) || !(k > 0))
            return null;
        if (!(k > 1))
            return millisecond;
        return newInterval(function (date) {
            date.setTime(Math.floor(date / k) * k);
        }, function (date, step) {
            date.setTime(+date + step * k);
        }, function (start, end) {
            return (end - start) / k;
        });
    };

    var durationSecond = 1e3;
    var durationMinute = 6e4;
    var durationHour = 36e5;
    var durationDay = 864e5;
    var durationWeek = 6048e5;

    newInterval(function (date) {
        date.setTime(date - date.getMilliseconds());
    }, function (date, step) {
        date.setTime(+date + step * durationSecond);
    }, function (start, end) {
        return (end - start) / durationSecond;
    }, function (date) {
        return date.getUTCSeconds();
    });

    newInterval(function (date) {
        date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function (date, step) {
        date.setTime(+date + step * durationMinute);
    }, function (start, end) {
        return (end - start) / durationMinute;
    }, function (date) {
        return date.getMinutes();
    });

    newInterval(function (date) {
        date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function (date, step) {
        date.setTime(+date + step * durationHour);
    }, function (start, end) {
        return (end - start) / durationHour;
    }, function (date) {
        return date.getHours();
    });

    var day = newInterval(function (date) {
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setDate(date.getDate() + step);
    }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
    }, function (date) {
        return date.getDate() - 1;
    });

    function weekday(i) {
        return newInterval(function (date) {
            date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
            date.setHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setDate(date.getDate() + step * 7);
        }, function (start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
        });
    }
    var sunday = weekday(0);
    var monday = weekday(1);
    weekday(2);
    weekday(3);
    var thursday = weekday(4);
    weekday(5);
    weekday(6);

    newInterval(function (date) {
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setMonth(date.getMonth() + step);
    }, function (start, end) {
        return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function (date) {
        return date.getMonth();
    });

    var year = newInterval(function (date) {
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setFullYear(date.getFullYear() + step);
    }, function (start, end) {
        return end.getFullYear() - start.getFullYear();
    }, function (date) {
        return date.getFullYear();
    });
    // An optimized implementation for this simple case.
    year.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
            date.setFullYear(Math.floor(date.getFullYear() / k) * k);
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setFullYear(date.getFullYear() + step * k);
        });
    };

    newInterval(function (date) {
        date.setUTCSeconds(0, 0);
    }, function (date, step) {
        date.setTime(+date + step * durationMinute);
    }, function (start, end) {
        return (end - start) / durationMinute;
    }, function (date) {
        return date.getUTCMinutes();
    });

    newInterval(function (date) {
        date.setUTCMinutes(0, 0, 0);
    }, function (date, step) {
        date.setTime(+date + step * durationHour);
    }, function (start, end) {
        return (end - start) / durationHour;
    }, function (date) {
        return date.getUTCHours();
    });

    var utcDay = newInterval(function (date) {
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCDate(date.getUTCDate() + step);
    }, function (start, end) {
        return (end - start) / durationDay;
    }, function (date) {
        return date.getUTCDate() - 1;
    });

    function utcWeekday(i) {
        return newInterval(function (date) {
            date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
            date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setUTCDate(date.getUTCDate() + step * 7);
        }, function (start, end) {
            return (end - start) / durationWeek;
        });
    }
    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    utcWeekday(2);
    utcWeekday(3);
    var utcThursday = utcWeekday(4);
    utcWeekday(5);
    utcWeekday(6);

    newInterval(function (date) {
        date.setUTCDate(1);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCMonth(date.getUTCMonth() + step);
    }, function (start, end) {
        return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function (date) {
        return date.getUTCMonth();
    });

    var utcYear = newInterval(function (date) {
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function (start, end) {
        return end.getUTCFullYear() - start.getUTCFullYear();
    }, function (date) {
        return date.getUTCFullYear();
    });
    // An optimized implementation for this simple case.
    utcYear.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function (date) {
            date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step * k);
        });
    };

    function localDate(d) {
        if (0 <= d.y && d.y < 100) {
            var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
            date.setFullYear(d.y);
            return date;
        }
        return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }
    function utcDate(d) {
        if (0 <= d.y && d.y < 100) {
            var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
            date.setUTCFullYear(d.y);
            return date;
        }
        return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }
    function newDate(y, m, d) {
        return { y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0 };
    }
    function formatLocale$1(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_weekdays = locale.days, locale_shortWeekdays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
        var formats = {
            "a": formatShortWeekday,
            "A": formatWeekday,
            "b": formatShortMonth,
            "B": formatMonth,
            "c": null,
            "d": formatDayOfMonth,
            "e": formatDayOfMonth,
            "f": formatMicroseconds,
            "g": formatYearISO,
            "G": formatFullYearISO,
            "H": formatHour24,
            "I": formatHour12,
            "j": formatDayOfYear,
            "L": formatMilliseconds,
            "m": formatMonthNumber,
            "M": formatMinutes,
            "p": formatPeriod,
            "q": formatQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatSeconds,
            "u": formatWeekdayNumberMonday,
            "U": formatWeekNumberSunday,
            "V": formatWeekNumberISO,
            "w": formatWeekdayNumberSunday,
            "W": formatWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatYear,
            "Y": formatFullYear,
            "Z": formatZone,
            "%": formatLiteralPercent
        };
        var utcFormats = {
            "a": formatUTCShortWeekday,
            "A": formatUTCWeekday,
            "b": formatUTCShortMonth,
            "B": formatUTCMonth,
            "c": null,
            "d": formatUTCDayOfMonth,
            "e": formatUTCDayOfMonth,
            "f": formatUTCMicroseconds,
            "g": formatUTCYearISO,
            "G": formatUTCFullYearISO,
            "H": formatUTCHour24,
            "I": formatUTCHour12,
            "j": formatUTCDayOfYear,
            "L": formatUTCMilliseconds,
            "m": formatUTCMonthNumber,
            "M": formatUTCMinutes,
            "p": formatUTCPeriod,
            "q": formatUTCQuarter,
            "Q": formatUnixTimestamp,
            "s": formatUnixTimestampSeconds,
            "S": formatUTCSeconds,
            "u": formatUTCWeekdayNumberMonday,
            "U": formatUTCWeekNumberSunday,
            "V": formatUTCWeekNumberISO,
            "w": formatUTCWeekdayNumberSunday,
            "W": formatUTCWeekNumberMonday,
            "x": null,
            "X": null,
            "y": formatUTCYear,
            "Y": formatUTCFullYear,
            "Z": formatUTCZone,
            "%": formatLiteralPercent
        };
        var parses = {
            "a": parseShortWeekday,
            "A": parseWeekday,
            "b": parseShortMonth,
            "B": parseMonth,
            "c": parseLocaleDateTime,
            "d": parseDayOfMonth,
            "e": parseDayOfMonth,
            "f": parseMicroseconds,
            "g": parseYear,
            "G": parseFullYear,
            "H": parseHour24,
            "I": parseHour24,
            "j": parseDayOfYear,
            "L": parseMilliseconds,
            "m": parseMonthNumber,
            "M": parseMinutes,
            "p": parsePeriod,
            "q": parseQuarter,
            "Q": parseUnixTimestamp,
            "s": parseUnixTimestampSeconds,
            "S": parseSeconds,
            "u": parseWeekdayNumberMonday,
            "U": parseWeekNumberSunday,
            "V": parseWeekNumberISO,
            "w": parseWeekdayNumberSunday,
            "W": parseWeekNumberMonday,
            "x": parseLocaleDate,
            "X": parseLocaleTime,
            "y": parseYear,
            "Y": parseFullYear,
            "Z": parseZone,
            "%": parseLiteralPercent
        };
        // These recursive directive definitions must be deferred.
        formats.x = newFormat(locale_date, formats);
        formats.X = newFormat(locale_time, formats);
        formats.c = newFormat(locale_dateTime, formats);
        utcFormats.x = newFormat(locale_date, utcFormats);
        utcFormats.X = newFormat(locale_time, utcFormats);
        utcFormats.c = newFormat(locale_dateTime, utcFormats);
        function newFormat(specifier, formats) {
            return function (date) {
                var string = [], i = -1, j = 0, n = specifier.length, c, pad, format;
                if (!(date instanceof Date))
                    date = new Date(+date);
                while (++i < n) {
                    if (specifier.charCodeAt(i) === 37) {
                        string.push(specifier.slice(j, i));
                        if ((pad = pads[c = specifier.charAt(++i)]) != null)
                            c = specifier.charAt(++i);
                        else
                            pad = c === "e" ? " " : "0";
                        if (format = formats[c])
                            c = format(date, pad);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(specifier.slice(j, i));
                return string.join("");
            };
        }
        function newParse(specifier, Z) {
            return function (string) {
                var d = newDate(1900, undefined, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day$1;
                if (i != string.length)
                    return null;
                // If a UNIX timestamp is specified, return it.
                if ("Q" in d)
                    return new Date(d.Q);
                if ("s" in d)
                    return new Date(d.s * 1000 + ("L" in d ? d.L : 0));
                // If this is utcParse, never use the local timezone.
                if (Z && !("Z" in d))
                    d.Z = 0;
                // The am-pm flag is 0 for AM, and 1 for PM.
                if ("p" in d)
                    d.H = d.H % 12 + d.p * 12;
                // If the month was not specified, inherit from the quarter.
                if (d.m === undefined)
                    d.m = "q" in d ? d.q : 0;
                // Convert day-of-week and week-of-year to day-of-year.
                if ("V" in d) {
                    if (d.V < 1 || d.V > 53)
                        return null;
                    if (!("w" in d))
                        d.w = 1;
                    if ("Z" in d) {
                        week = utcDate(newDate(d.y, 0, 1)), day$1 = week.getUTCDay();
                        week = day$1 > 4 || day$1 === 0 ? utcMonday.ceil(week) : utcMonday(week);
                        week = utcDay.offset(week, (d.V - 1) * 7);
                        d.y = week.getUTCFullYear();
                        d.m = week.getUTCMonth();
                        d.d = week.getUTCDate() + (d.w + 6) % 7;
                    }
                    else {
                        week = localDate(newDate(d.y, 0, 1)), day$1 = week.getDay();
                        week = day$1 > 4 || day$1 === 0 ? monday.ceil(week) : monday(week);
                        week = day.offset(week, (d.V - 1) * 7);
                        d.y = week.getFullYear();
                        d.m = week.getMonth();
                        d.d = week.getDate() + (d.w + 6) % 7;
                    }
                }
                else if ("W" in d || "U" in d) {
                    if (!("w" in d))
                        d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
                    day$1 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
                    d.m = 0;
                    d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day$1 + 5) % 7 : d.w + d.U * 7 - (day$1 + 6) % 7;
                }
                // If a time zone is specified, all fields are interpreted as UTC and then
                // offset according to the specified time zone.
                if ("Z" in d) {
                    d.H += d.Z / 100 | 0;
                    d.M += d.Z % 100;
                    return utcDate(d);
                }
                // Otherwise, all fields are in local time.
                return localDate(d);
            };
        }
        function parseSpecifier(d, specifier, string, j) {
            var i = 0, n = specifier.length, m = string.length, c, parse;
            while (i < n) {
                if (j >= m)
                    return -1;
                c = specifier.charCodeAt(i++);
                if (c === 37) {
                    c = specifier.charAt(i++);
                    parse = parses[c in pads ? specifier.charAt(i++) : c];
                    if (!parse || ((j = parse(d, string, j)) < 0))
                        return -1;
                }
                else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        function parsePeriod(d, string, i) {
            var n = periodRe.exec(string.slice(i));
            return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseShortWeekday(d, string, i) {
            var n = shortWeekdayRe.exec(string.slice(i));
            return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseWeekday(d, string, i) {
            var n = weekdayRe.exec(string.slice(i));
            return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseShortMonth(d, string, i) {
            var n = shortMonthRe.exec(string.slice(i));
            return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseMonth(d, string, i) {
            var n = monthRe.exec(string.slice(i));
            return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseLocaleDateTime(d, string, i) {
            return parseSpecifier(d, locale_dateTime, string, i);
        }
        function parseLocaleDate(d, string, i) {
            return parseSpecifier(d, locale_date, string, i);
        }
        function parseLocaleTime(d, string, i) {
            return parseSpecifier(d, locale_time, string, i);
        }
        function formatShortWeekday(d) {
            return locale_shortWeekdays[d.getDay()];
        }
        function formatWeekday(d) {
            return locale_weekdays[d.getDay()];
        }
        function formatShortMonth(d) {
            return locale_shortMonths[d.getMonth()];
        }
        function formatMonth(d) {
            return locale_months[d.getMonth()];
        }
        function formatPeriod(d) {
            return locale_periods[+(d.getHours() >= 12)];
        }
        function formatQuarter(d) {
            return 1 + ~~(d.getMonth() / 3);
        }
        function formatUTCShortWeekday(d) {
            return locale_shortWeekdays[d.getUTCDay()];
        }
        function formatUTCWeekday(d) {
            return locale_weekdays[d.getUTCDay()];
        }
        function formatUTCShortMonth(d) {
            return locale_shortMonths[d.getUTCMonth()];
        }
        function formatUTCMonth(d) {
            return locale_months[d.getUTCMonth()];
        }
        function formatUTCPeriod(d) {
            return locale_periods[+(d.getUTCHours() >= 12)];
        }
        function formatUTCQuarter(d) {
            return 1 + ~~(d.getUTCMonth() / 3);
        }
        return {
            format: function (specifier) {
                var f = newFormat(specifier += "", formats);
                f.toString = function () { return specifier; };
                return f;
            },
            parse: function (specifier) {
                var p = newParse(specifier += "", false);
                p.toString = function () { return specifier; };
                return p;
            },
            utcFormat: function (specifier) {
                var f = newFormat(specifier += "", utcFormats);
                f.toString = function () { return specifier; };
                return f;
            },
            utcParse: function (specifier) {
                var p = newParse(specifier += "", true);
                p.toString = function () { return specifier; };
                return p;
            }
        };
    }
    var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
    function pad(value, fill, width) {
        var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function requote(s) {
        return s.replace(requoteRe, "\\$&");
    }
    function formatRe(names) {
        return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }
    function formatLookup(names) {
        var map = {}, i = -1, n = names.length;
        while (++i < n)
            map[names[i].toLowerCase()] = i;
        return map;
    }
    function parseWeekdayNumberSunday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? (d.w = +n[0], i + n[0].length) : -1;
    }
    function parseWeekdayNumberMonday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? (d.u = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberSunday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.U = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberISO(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.V = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberMonday(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.W = +n[0], i + n[0].length) : -1;
    }
    function parseFullYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 4));
        return n ? (d.y = +n[0], i + n[0].length) : -1;
    }
    function parseYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }
    function parseZone(d, string, i) {
        var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
        return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }
    function parseQuarter(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 1));
        return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }
    function parseMonthNumber(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }
    function parseDayOfMonth(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.d = +n[0], i + n[0].length) : -1;
    }
    function parseDayOfYear(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }
    function parseHour24(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.H = +n[0], i + n[0].length) : -1;
    }
    function parseMinutes(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.M = +n[0], i + n[0].length) : -1;
    }
    function parseSeconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 2));
        return n ? (d.S = +n[0], i + n[0].length) : -1;
    }
    function parseMilliseconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 3));
        return n ? (d.L = +n[0], i + n[0].length) : -1;
    }
    function parseMicroseconds(d, string, i) {
        var n = numberRe.exec(string.slice(i, i + 6));
        return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }
    function parseLiteralPercent(d, string, i) {
        var n = percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function parseUnixTimestamp(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }
    function parseUnixTimestampSeconds(d, string, i) {
        var n = numberRe.exec(string.slice(i));
        return n ? (d.s = +n[0], i + n[0].length) : -1;
    }
    function formatDayOfMonth(d, p) {
        return pad(d.getDate(), p, 2);
    }
    function formatHour24(d, p) {
        return pad(d.getHours(), p, 2);
    }
    function formatHour12(d, p) {
        return pad(d.getHours() % 12 || 12, p, 2);
    }
    function formatDayOfYear(d, p) {
        return pad(1 + day.count(year(d), d), p, 3);
    }
    function formatMilliseconds(d, p) {
        return pad(d.getMilliseconds(), p, 3);
    }
    function formatMicroseconds(d, p) {
        return formatMilliseconds(d, p) + "000";
    }
    function formatMonthNumber(d, p) {
        return pad(d.getMonth() + 1, p, 2);
    }
    function formatMinutes(d, p) {
        return pad(d.getMinutes(), p, 2);
    }
    function formatSeconds(d, p) {
        return pad(d.getSeconds(), p, 2);
    }
    function formatWeekdayNumberMonday(d) {
        var day = d.getDay();
        return day === 0 ? 7 : day;
    }
    function formatWeekNumberSunday(d, p) {
        return pad(sunday.count(year(d) - 1, d), p, 2);
    }
    function dISO(d) {
        var day = d.getDay();
        return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    }
    function formatWeekNumberISO(d, p) {
        d = dISO(d);
        return pad(thursday.count(year(d), d) + (year(d).getDay() === 4), p, 2);
    }
    function formatWeekdayNumberSunday(d) {
        return d.getDay();
    }
    function formatWeekNumberMonday(d, p) {
        return pad(monday.count(year(d) - 1, d), p, 2);
    }
    function formatYear(d, p) {
        return pad(d.getFullYear() % 100, p, 2);
    }
    function formatYearISO(d, p) {
        d = dISO(d);
        return pad(d.getFullYear() % 100, p, 2);
    }
    function formatFullYear(d, p) {
        return pad(d.getFullYear() % 10000, p, 4);
    }
    function formatFullYearISO(d, p) {
        var day = d.getDay();
        d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
        return pad(d.getFullYear() % 10000, p, 4);
    }
    function formatZone(d) {
        var z = d.getTimezoneOffset();
        return (z > 0 ? "-" : (z *= -1, "+"))
            + pad(z / 60 | 0, "0", 2)
            + pad(z % 60, "0", 2);
    }
    function formatUTCDayOfMonth(d, p) {
        return pad(d.getUTCDate(), p, 2);
    }
    function formatUTCHour24(d, p) {
        return pad(d.getUTCHours(), p, 2);
    }
    function formatUTCHour12(d, p) {
        return pad(d.getUTCHours() % 12 || 12, p, 2);
    }
    function formatUTCDayOfYear(d, p) {
        return pad(1 + utcDay.count(utcYear(d), d), p, 3);
    }
    function formatUTCMilliseconds(d, p) {
        return pad(d.getUTCMilliseconds(), p, 3);
    }
    function formatUTCMicroseconds(d, p) {
        return formatUTCMilliseconds(d, p) + "000";
    }
    function formatUTCMonthNumber(d, p) {
        return pad(d.getUTCMonth() + 1, p, 2);
    }
    function formatUTCMinutes(d, p) {
        return pad(d.getUTCMinutes(), p, 2);
    }
    function formatUTCSeconds(d, p) {
        return pad(d.getUTCSeconds(), p, 2);
    }
    function formatUTCWeekdayNumberMonday(d) {
        var dow = d.getUTCDay();
        return dow === 0 ? 7 : dow;
    }
    function formatUTCWeekNumberSunday(d, p) {
        return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
    }
    function UTCdISO(d) {
        var day = d.getUTCDay();
        return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }
    function formatUTCWeekNumberISO(d, p) {
        d = UTCdISO(d);
        return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
    }
    function formatUTCWeekdayNumberSunday(d) {
        return d.getUTCDay();
    }
    function formatUTCWeekNumberMonday(d, p) {
        return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
    }
    function formatUTCYear(d, p) {
        return pad(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCYearISO(d, p) {
        d = UTCdISO(d);
        return pad(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCFullYear(d, p) {
        return pad(d.getUTCFullYear() % 10000, p, 4);
    }
    function formatUTCFullYearISO(d, p) {
        var day = d.getUTCDay();
        d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
        return pad(d.getUTCFullYear() % 10000, p, 4);
    }
    function formatUTCZone() {
        return "+0000";
    }
    function formatLiteralPercent() {
        return "%";
    }
    function formatUnixTimestamp(d) {
        return +d;
    }
    function formatUnixTimestampSeconds(d) {
        return Math.floor(+d / 1000);
    }

    var locale$1;
    var timeFormat;
    var utcFormat;
    var utcParse;
    defaultLocale$1({
        dateTime: "%x, %X",
        date: "%-m/%-d/%Y",
        time: "%-I:%M:%S %p",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale$1(definition) {
        locale$1 = formatLocale$1(definition);
        timeFormat = locale$1.format;
        utcFormat = locale$1.utcFormat;
        utcParse = locale$1.utcParse;
        return locale$1;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
    function formatIsoNative(date) {
        return date.toISOString();
    }
    Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    function parseIsoNative(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    }
    +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    var pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
    function Path() {
        this._x0 = this._y0 = // start of current subpath
            this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
    }
    function path() {
        return new Path;
    }
    Path.prototype = path.prototype = {
        constructor: Path,
        moveTo: function (x, y) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
        },
        closePath: function () {
            if (this._x1 !== null) {
                this._x1 = this._x0, this._y1 = this._y0;
                this._ += "Z";
            }
        },
        lineTo: function (x, y) {
            this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        quadraticCurveTo: function (x1, y1, x, y) {
            this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        bezierCurveTo: function (x1, y1, x2, y2, x, y) {
            this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        arcTo: function (x1, y1, x2, y2, r) {
            x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
            var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
            // Is the radius negative? Error.
            if (r < 0)
                throw new Error("negative radius: " + r);
            // Is this path empty? Move to (x1,y1).
            if (this._x1 === null) {
                this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
            }
            // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
            else if (!(l01_2 > epsilon))
                ;
            // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
            // Equivalently, is (x1,y1) coincident with (x2,y2)?
            // Or, is the radius zero? Line to (x1,y1).
            else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
                this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
            }
            // Otherwise, draw an arc!
            else {
                var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
                // If the start tangent is not coincident with (x0,y0), line to.
                if (Math.abs(t01 - 1) > epsilon) {
                    this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
                }
                this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
            }
        },
        arc: function (x, y, r, a0, a1, ccw) {
            x = +x, y = +y, r = +r, ccw = !!ccw;
            var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
            // Is the radius negative? Error.
            if (r < 0)
                throw new Error("negative radius: " + r);
            // Is this path empty? Move to (x0,y0).
            if (this._x1 === null) {
                this._ += "M" + x0 + "," + y0;
            }
            // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
            else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
                this._ += "L" + x0 + "," + y0;
            }
            // Is this arc empty? We’re done.
            if (!r)
                return;
            // Does the angle go the wrong way? Flip the direction.
            if (da < 0)
                da = da % tau + tau;
            // Is this a complete circle? Draw two arcs to complete the circle.
            if (da > tauEpsilon) {
                this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
            }
            // Is this arc non-empty? Draw an arc!
            else if (da > epsilon) {
                this._ += "A" + r + "," + r + ",0," + (+(da >= pi)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
            }
        },
        rect: function (x, y, w, h) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
        },
        toString: function () {
            return this._;
        }
    };

    function constant$3 (x) {
        return function constant() {
            return x;
        };
    }

    var pi$1 = Math.PI;
    var tau$1 = 2 * pi$1;

    function x(p) {
        return p[0];
    }
    function y(p) {
        return p[1];
    }

    var slice$1 = Array.prototype.slice;

    function linkSource(d) {
        return d.source;
    }
    function linkTarget(d) {
        return d.target;
    }
    function link(curve) {
        var source = linkSource, target = linkTarget, x$1 = x, y$1 = y, context = null;
        function link() {
            var buffer, argv = slice$1.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
            if (!context)
                context = buffer = path();
            curve(context, +x$1.apply(this, (argv[0] = s, argv)), +y$1.apply(this, argv), +x$1.apply(this, (argv[0] = t, argv)), +y$1.apply(this, argv));
            if (buffer)
                return context = null, buffer + "" || null;
        }
        link.source = function (_) {
            return arguments.length ? (source = _, link) : source;
        };
        link.target = function (_) {
            return arguments.length ? (target = _, link) : target;
        };
        link.x = function (_) {
            return arguments.length ? (x$1 = typeof _ === "function" ? _ : constant$3(+_), link) : x$1;
        };
        link.y = function (_) {
            return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$3(+_), link) : y$1;
        };
        link.context = function (_) {
            return arguments.length ? ((context = _ == null ? null : _), link) : context;
        };
        return link;
    }
    function curveHorizontal(context, x0, y0, x1, y1) {
        context.moveTo(x0, y0);
        context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
    }
    function linkHorizontal() {
        return link(curveHorizontal);
    }

    var symbolCircle = {
        draw: function (context, size) {
            var r = Math.sqrt(size / pi$1);
            context.moveTo(r, 0);
            context.arc(0, 0, r, 0, tau$1);
        }
    };

    var symbolCross = {
        draw: function (context, size) {
            var r = Math.sqrt(size / 5) / 2;
            context.moveTo(-3 * r, -r);
            context.lineTo(-r, -r);
            context.lineTo(-r, -3 * r);
            context.lineTo(r, -3 * r);
            context.lineTo(r, -r);
            context.lineTo(3 * r, -r);
            context.lineTo(3 * r, r);
            context.lineTo(r, r);
            context.lineTo(r, 3 * r);
            context.lineTo(-r, 3 * r);
            context.lineTo(-r, r);
            context.lineTo(-3 * r, r);
            context.closePath();
        }
    };

    var tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2;
    var symbolDiamond = {
        draw: function (context, size) {
            var y = Math.sqrt(size / tan30_2), x = y * tan30;
            context.moveTo(0, -y);
            context.lineTo(x, 0);
            context.lineTo(0, y);
            context.lineTo(-x, 0);
            context.closePath();
        }
    };

    var ka = 0.89081309152928522810, kr = Math.sin(pi$1 / 10) / Math.sin(7 * pi$1 / 10), kx = Math.sin(tau$1 / 10) * kr, ky = -Math.cos(tau$1 / 10) * kr;
    var symbolStar = {
        draw: function (context, size) {
            var r = Math.sqrt(size * ka), x = kx * r, y = ky * r;
            context.moveTo(0, -r);
            context.lineTo(x, y);
            for (var i = 1; i < 5; ++i) {
                var a = tau$1 * i / 5, c = Math.cos(a), s = Math.sin(a);
                context.lineTo(s * r, -c * r);
                context.lineTo(c * x - s * y, s * x + c * y);
            }
            context.closePath();
        }
    };

    var symbolSquare = {
        draw: function (context, size) {
            var w = Math.sqrt(size), x = -w / 2;
            context.rect(x, x, w, w);
        }
    };

    var sqrt3 = Math.sqrt(3);
    var symbolTriangle = {
        draw: function (context, size) {
            var y = -Math.sqrt(size / (sqrt3 * 3));
            context.moveTo(0, y * 2);
            context.lineTo(-sqrt3 * y, -y);
            context.lineTo(sqrt3 * y, -y);
            context.closePath();
        }
    };

    function sign(x) {
        return x < 0 ? -1 : 1;
    }
    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
        var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
        return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }
    // Calculate a one-sided slope.
    function slope2(that, t) {
        var h = that._x1 - that._x0;
        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }
    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point$1(that, t0, t1) {
        var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }
    function MonotoneX(context) {
        this._context = context;
    }
    MonotoneX.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 =
                this._y0 = this._y1 =
                    this._t0 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 2:
                    this._context.lineTo(this._x1, this._y1);
                    break;
                case 3:
                    point$1(this, this._t0, slope2(this, this._t0));
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            var t1 = NaN;
            x = +x, y = +y;
            if (x === this._x1 && y === this._y1)
                return; // Ignore coincident points.
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3;
                    point$1(this, slope2(this, t1 = slope3(this, x, y)), t1);
                    break;
                default:
                    point$1(this, this._t0, t1 = slope3(this, x, y));
                    break;
            }
            this._x0 = this._x1, this._x1 = x;
            this._y0 = this._y1, this._y1 = y;
            this._t0 = t1;
        }
    };
    (Object.create(MonotoneX.prototype)).point = function (x, y) {
        MonotoneX.prototype.point.call(this, y, x);
    };

    /**
     * Copyright (c) 2020, 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    function getTextWidth(text, fontSize, noPadding, fontFamily) {
        // this gets garbage collected after this function scope closes, since we do not append
        var padding = !noPadding ? 1.1 : 1; // for a11y we add padding, up to 10% of the text's dimensions
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        context.font = fontSize + 'px ' + (fontFamily || 'OpenSans');
        return context.measureText(text).width * padding;
    }
    var verifyTextHasSpace = function (_a) {
        var text = _a.text, dimensions = _a.dimensions, fontSize = _a.fontSize, noPadding = _a.noPadding;
        // dimensions = { width: 97, height: 29 }
        var canvas = document.createElement('canvas');
        var context = canvas.getContext('2d');
        context.font = fontSize + 'px OpenSans';
        var measurementData = context.measureText(text);
        var padding = !noPadding ? 1.1 : 1; // for a11y we add padding, up to 10% of the text's dimensions
        var keys = Object.keys(dimensions);
        var textHasRoom = true;
        var i = 0;
        while (textHasRoom && i < keys.length) {
            if (!(keys[i] === 'height')) {
                textHasRoom = measurementData[keys[i]] * padding <= dimensions[keys[i]];
            }
            else {
                textHasRoom = fontSize * padding <= dimensions[keys[i]];
            }
            i++;
        }
        return textHasRoom;
    };
    var manuallyWrapText = function (_a) {
        var text = _a.text, width = _a.width, fontSize = _a.fontSize, noPadding = _a.noPadding, wholeWords = _a.wholeWords;
        // split into words
        var words = text.split(/\s+/).reverse();
        // turn words into lines
        var lines = [];
        var lineNumber = 0;
        var word = words.pop();
        while (word) {
            var line = lines[lineNumber];
            if (!line) {
                lines.push([]);
                line = lines[lineNumber];
            }
            // add current word to line
            line.push(word);
            var lineWidth = getTextWidth(line.join(' '), fontSize);
            // check if line has 1 word but is too long, if so:
            if (line.length === 1 && lineWidth > width) {
                // check if we aren't forcing whole words
                if (!wholeWords) {
                    // if we aren't: split word, add hyphen, put split word ending at front of words array
                    var splitWord = splitStringAtWidth(word, width, fontSize, noPadding);
                    // remove whole word
                    line.pop();
                    // add first word plus hyphen
                    line.push(splitWord[0] + (splitWord[1] ? '-' : ''));
                    // use the second half of the word in the next iteration, if it exists
                    if (splitWord[1]) {
                        word = splitWord[1];
                    }
                    else {
                        word = words.pop();
                    }
                }
                else {
                    // proceed with a line overlapping
                    // prepare the next word for iteration
                    word = words.pop();
                }
                // line is done, create single string
                lines[lineNumber] = line.join(' ');
                // start a new line
                lineNumber++;
            }
            else if (lineWidth > width) {
                // check if line is too long
                // - remove the word that just pushed the line over length
                line.pop();
                // line is done, create single string
                lines[lineNumber] = line.join(' ');
                // start a new line
                lineNumber++;
            }
            else {
                // prepare the next word for iteration
                word = words.pop();
                if (!word) {
                    // no words left? line is done, create single string
                    lines[lineNumber] = line.join(' ');
                }
            }
        }
        return lines;
    };
    var splitStringAtWidth = function (string, width, fontSize, noPadding) {
        if (string.length <= 1) {
            return [string, ''];
        }
        var index = string.length - 1;
        var start = string.substring(0, index);
        var end = string.substring(index);
        while (getTextWidth(start + '-', fontSize, noPadding) > width && index > 1) {
            index--;
            start = string.substring(0, index);
            end = string.substring(index);
        }
        return [start, end];
    };

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    /* This file includes code covered by the following notice */
    /**
     * Copyright (c) 2016, University of Washington Interactive Data Lab
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its contributors
     *   may be used to endorse or promote products derived from this software
     *   without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     **/
    // Path parsing and rendering code adapted from fabric.js -- Thanks!
    var cmdlen = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, regexp = [/([MLHVCSQTAZmlhvcsqtaz])/g, /###/, /(\.\d+)(\.\d)/g, /(\d)([-+])/g, /\s|,|###/];
    function pathParse (pathstr) {
        var result = [];
        var curr, chunks, parsed, param, cmd, len, i, j, n, m;
        // First, break path into command sequence
        var path = pathstr
            .slice()
            .replace(regexp[0], '###$1')
            .split(regexp[1])
            .slice(1);
        // Next, parse each command in turn
        for (i = 0, n = path.length; i < n; ++i) {
            curr = path[i];
            chunks = curr
                .slice(1)
                .trim()
                .replace(regexp[2], '$1###$2')
                .replace(regexp[3], '$1###$2')
                .split(regexp[4]);
            cmd = curr.charAt(0);
            parsed = [cmd];
            for (j = 0, m = chunks.length; j < m; ++j) {
                if ((param = +chunks[j]) === param) {
                    // not NaN
                    parsed.push(param);
                }
            }
            len = cmdlen[cmd.toLowerCase()];
            if (parsed.length - 1 > len) {
                var m_1 = parsed.length;
                j = 1;
                result.push([cmd].concat(parsed.slice(j, (j += len))));
                // handle implicit lineTo (#2803)
                cmd = cmd === 'M' ? 'L' : cmd === 'm' ? 'l' : cmd;
                for (; j < m_1; j += len) {
                    result.push([cmd].concat(parsed.slice(j, j + len)));
                }
            }
            else {
                result.push(parsed);
            }
        }
        return result;
    }

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    /* This file includes code covered by the following notice */
    /**
     * Copyright (c) 2016, University of Washington Interactive Data Lab
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its contributors
     *   may be used to endorse or promote products derived from this software
     *   without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     **/
    var DegToRad = Math.PI / 180;
    // const Epsilon = 1e-14;
    var HalfPi = Math.PI / 2;
    var Tau = Math.PI * 2;
    // const HalfSqrt3 = Math.sqrt(3) / 2;
    var segmentCache = {};
    var bezierCache = {};
    var join = [].join;
    // Copied from Inkscape svgtopdf, thanks!
    function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
        var key = join.call(arguments);
        if (segmentCache[key]) {
            return segmentCache[key];
        }
        var th = rotateX * DegToRad;
        var sin_th = Math.sin(th);
        var cos_th = Math.cos(th);
        rx = Math.abs(rx);
        ry = Math.abs(ry);
        var px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
        var py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
        var pl = (px * px) / (rx * rx) + (py * py) / (ry * ry);
        if (pl > 1) {
            pl = Math.sqrt(pl);
            rx *= pl;
            ry *= pl;
        }
        var a00 = cos_th / rx;
        var a01 = sin_th / rx;
        var a10 = -sin_th / ry;
        var a11 = cos_th / ry;
        var x0 = a00 * ox + a01 * oy;
        var y0 = a10 * ox + a11 * oy;
        var x1 = a00 * x + a01 * y;
        var y1 = a10 * x + a11 * y;
        var d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
        var sfactor_sq = 1 / d - 0.25;
        if (sfactor_sq < 0)
            sfactor_sq = 0;
        var sfactor = Math.sqrt(sfactor_sq);
        if (sweep == large)
            sfactor = -sfactor;
        var xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
        var yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
        var th0 = Math.atan2(y0 - yc, x0 - xc);
        var th1 = Math.atan2(y1 - yc, x1 - xc);
        var th_arc = th1 - th0;
        if (th_arc < 0 && sweep === 1) {
            th_arc += Tau;
        }
        else if (th_arc > 0 && sweep === 0) {
            th_arc -= Tau;
        }
        var segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));
        var result = [];
        for (var i = 0; i < segs; ++i) {
            var th2 = th0 + (i * th_arc) / segs;
            var th3 = th0 + ((i + 1) * th_arc) / segs;
            result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
        }
        return (segmentCache[key] = result);
    }
    function bezier(params) {
        var key = join.call(params);
        if (bezierCache[key]) {
            return bezierCache[key];
        }
        var cx = params[0], cy = params[1], th0 = params[2], th1 = params[3], rx = params[4], ry = params[5], sin_th = params[6], cos_th = params[7];
        var a00 = cos_th * rx;
        var a01 = -sin_th * ry;
        var a10 = sin_th * rx;
        var a11 = cos_th * ry;
        var cos_th0 = Math.cos(th0);
        var sin_th0 = Math.sin(th0);
        var cos_th1 = Math.cos(th1);
        var sin_th1 = Math.sin(th1);
        var th_half = 0.5 * (th1 - th0);
        var sin_th_h2 = Math.sin(th_half * 0.5);
        var t = ((8 / 3) * sin_th_h2 * sin_th_h2) / Math.sin(th_half);
        var x1 = cx + cos_th0 - t * sin_th0;
        var y1 = cy + sin_th0 + t * cos_th0;
        var x3 = cx + cos_th1;
        var y3 = cy + sin_th1;
        var x2 = x3 + t * sin_th1;
        var y2 = y3 - t * cos_th1;
        return (bezierCache[key] = [
            a00 * x1 + a01 * y1,
            a10 * x1 + a11 * y1,
            a00 * x2 + a01 * y2,
            a10 * x2 + a11 * y2,
            a00 * x3 + a01 * y3,
            a10 * x3 + a11 * y3
        ]);
    }

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var temp = ['l', 0, 0, 0, 0, 0, 0, 0];
    function scale(current, sX, sY) {
        var c = (temp[0] = current[0]);
        if (c === 'a' || c === 'A') {
            temp[1] = sX * current[1];
            temp[2] = sY * current[2];
            temp[3] = current[3];
            temp[4] = current[4];
            temp[5] = current[5];
            temp[6] = sX * current[6];
            temp[7] = sY * current[7];
        }
        else if (c === 'h' || c === 'H') {
            temp[1] = sX * current[1];
        }
        else if (c === 'v' || c === 'V') {
            temp[1] = sY * current[1];
        }
        else {
            for (var i = 1, n = current.length; i < n; ++i) {
                temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
            }
        }
        return temp;
    }
    function pathRender (context, path, l, t, sX, sY) {
        var current, // current instruction
        previous = null, x = 0, // current x
        y = 0, // current y
        controlX = 0, // current control point x
        controlY = 0, // current control point y
        tempX, tempY, tempControlX, tempControlY;
        if (l == null)
            l = 0;
        if (t == null)
            t = 0;
        if (sX == null)
            sX = 1;
        if (sY == null)
            sY = sX;
        if (context.beginPath)
            context.beginPath();
        for (var i = 0, len = path.length; i < len; ++i) {
            current = path[i];
            if (sX !== 1 || sY !== 1) {
                current = scale(current, sX, sY);
            }
            switch (current[0] // first letter
            ) {
                case 'l': // lineto, relative
                    x += current[1];
                    y += current[2];
                    context.lineTo(x + l, y + t);
                    break;
                case 'L': // lineto, absolute
                    x = current[1];
                    y = current[2];
                    context.lineTo(x + l, y + t);
                    break;
                case 'h': // horizontal lineto, relative
                    x += current[1];
                    context.lineTo(x + l, y + t);
                    break;
                case 'H': // horizontal lineto, absolute
                    x = current[1];
                    context.lineTo(x + l, y + t);
                    break;
                case 'v': // vertical lineto, relative
                    y += current[1];
                    context.lineTo(x + l, y + t);
                    break;
                case 'V': // verical lineto, absolute
                    y = current[1];
                    context.lineTo(x + l, y + t);
                    break;
                case 'm': // moveTo, relative
                    x += current[1];
                    y += current[2];
                    context.moveTo(x + l, y + t);
                    break;
                case 'M': // moveTo, absolute
                    x = current[1];
                    y = current[2];
                    context.moveTo(x + l, y + t);
                    break;
                case 'c': // bezierCurveTo, relative
                    tempX = x + current[5];
                    tempY = y + current[6];
                    controlX = x + current[3];
                    controlY = y + current[4];
                    context.bezierCurveTo(x + current[1] + l, // x1
                    y + current[2] + t, // y1
                    controlX + l, // x2
                    controlY + t, // y2
                    tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    break;
                case 'C': // bezierCurveTo, absolute
                    x = current[5];
                    y = current[6];
                    controlX = current[3];
                    controlY = current[4];
                    context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
                    break;
                case 's': // shorthand cubic bezierCurveTo, relative
                    // transform to absolute x,y
                    tempX = x + current[3];
                    tempY = y + current[4];
                    // calculate reflection of previous control points
                    controlX = 2 * x - controlX;
                    controlY = 2 * y - controlY;
                    context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t);
                    // set control point to 2nd one of this command
                    // the first control point is assumed to be the reflection of
                    // the second control point on the previous command relative
                    // to the current point.
                    controlX = x + current[1];
                    controlY = y + current[2];
                    x = tempX;
                    y = tempY;
                    break;
                case 'S': // shorthand cubic bezierCurveTo, absolute
                    tempX = current[3];
                    tempY = current[4];
                    // calculate reflection of previous control points
                    controlX = 2 * x - controlX;
                    controlY = 2 * y - controlY;
                    context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    // set control point to 2nd one of this command
                    // the first control point is assumed to be the reflection of
                    // the second control point on the previous command relative
                    // to the current point.
                    controlX = current[1];
                    controlY = current[2];
                    break;
                case 'q': // quadraticCurveTo, relative
                    // transform to absolute x,y
                    tempX = x + current[3];
                    tempY = y + current[4];
                    controlX = x + current[1];
                    controlY = y + current[2];
                    context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    break;
                case 'Q': // quadraticCurveTo, absolute
                    tempX = current[3];
                    tempY = current[4];
                    context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    controlX = current[1];
                    controlY = current[2];
                    break;
                case 't': // shorthand quadraticCurveTo, relative
                    // transform to absolute x,y
                    tempX = x + current[1];
                    tempY = y + current[2];
                    if (previous[0].match(/[QqTt]/) === null) {
                        // If there is no previous command or if the previous command was not a Q, q, T or t,
                        // assume the control point is coincident with the current point
                        controlX = x;
                        controlY = y;
                    }
                    else if (previous[0] === 't') {
                        // calculate reflection of previous control points for t
                        controlX = 2 * x - tempControlX;
                        controlY = 2 * y - tempControlY;
                    }
                    else if (previous[0] === 'q') {
                        // calculate reflection of previous control points for q
                        controlX = 2 * x - controlX;
                        controlY = 2 * y - controlY;
                    }
                    tempControlX = controlX;
                    tempControlY = controlY;
                    context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    controlX = x + current[1];
                    controlY = y + current[2];
                    break;
                case 'T':
                    tempX = current[1];
                    tempY = current[2];
                    // calculate reflection of previous control points
                    controlX = 2 * x - controlX;
                    controlY = 2 * y - controlY;
                    context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
                    x = tempX;
                    y = tempY;
                    break;
                case 'a':
                    drawArc(context, x + l, y + t, [
                        current[1],
                        current[2],
                        current[3],
                        current[4],
                        current[5],
                        current[6] + x + l,
                        current[7] + y + t
                    ]);
                    x += current[6];
                    y += current[7];
                    break;
                case 'A':
                    drawArc(context, x + l, y + t, [
                        current[1],
                        current[2],
                        current[3],
                        current[4],
                        current[5],
                        current[6] + l,
                        current[7] + t
                    ]);
                    x = current[6];
                    y = current[7];
                    break;
                case 'z':
                case 'Z':
                    context.closePath();
                    break;
            }
            previous = current;
        }
    }
    function drawArc(context, x, y, coords) {
        var seg = segments(coords[5], // end x
        coords[6], // end y
        coords[0], // radius x
        coords[1], // radius y
        coords[3], // large flag
        coords[4], // sweep flag
        coords[2], // rotation
        x, y);
        for (var i = 0; i < seg.length; ++i) {
            var bez = bezier(seg[i]);
            context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
        }
    }

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var DIV = 0x5;
    var MOD = 0x1f;
    var SIZE = 0x20;
    var right0 = new Uint32Array(SIZE + 1);
    var right1 = new Uint32Array(SIZE + 1);
    right1[0] = 0x0;
    right0[0] = ~right1[0];
    for (var i = 1; i <= SIZE; i++) {
        right1[i] = (right1[i - 1] << 0x1) | 0x1;
        right0[i] = ~right1[i];
    }
    function applyMark(array, index, mask) {
        array[index] |= mask;
    }
    function applyUnmark(array, index, mask) {
        array[index] &= mask;
    }
    var BitMap = /** @class */ (function () {
        function BitMap(width, height, padding) {
            this.pixelRatio = Math.sqrt((width * height) / 1000000.0);
            // bound pixelRatio to be not less than 1
            if (this.pixelRatio < 1) {
                this.pixelRatio = 1;
            }
            this.padding = padding;
            this.width = ~~((width + 2 * padding + this.pixelRatio) / this.pixelRatio);
            this.height = ~~((height + 2 * padding + this.pixelRatio) / this.pixelRatio);
            this.array = new Uint32Array(~~((this.width * this.height + SIZE) / SIZE));
        }
        /**
         * Get pixel ratio between real size and bitmap size
         * @returns pixel ratio between real size and bitmap size
         */
        BitMap.prototype.getPixelRatio = function () {
            return this.pixelRatio;
        };
        /**
         * Scale real pixel in the chart into bitmap pixel
         * @param realPixel the real pixel to be scaled down
         * @returns scaled pixel
         */
        BitMap.prototype.scalePixel = function (realPixel) {
            return ~~((realPixel + this.padding) / this.pixelRatio);
        };
        BitMap.prototype.markScaled = function (x, y) {
            var mapIndex = y * this.width + x;
            applyMark(this.array, mapIndex >>> DIV, 1 << (mapIndex & MOD));
        };
        BitMap.prototype.mark = function (x, y) {
            this.markScaled(this.scalePixel(x), this.scalePixel(y));
        };
        BitMap.prototype.unmarkScaled = function (x, y) {
            var mapIndex = y * this.width + x;
            applyUnmark(this.array, mapIndex >>> DIV, ~(1 << (mapIndex & MOD)));
        };
        BitMap.prototype.unmark = function (x, y) {
            this.unmarkScaled(this.scalePixel(x), this.scalePixel(y));
        };
        BitMap.prototype.getScaled = function (x, y) {
            var mapIndex = y * this.width + x;
            return this.array[mapIndex >>> DIV] & (1 << (mapIndex & MOD));
        };
        BitMap.prototype.get = function (x, y) {
            return this.getScaled(this.scalePixel(x), this.scalePixel(y));
        };
        BitMap.prototype.markInRangeScaled = function (x, y, x2, y2) {
            var start, end, indexStart, indexEnd;
            for (; y <= y2; y++) {
                start = y * this.width + x;
                end = y * this.width + x2;
                indexStart = start >>> DIV;
                indexEnd = end >>> DIV;
                if (indexStart === indexEnd) {
                    applyMark(this.array, indexStart, right0[start & MOD] & right1[(end & MOD) + 1]);
                }
                else {
                    applyMark(this.array, indexStart, right0[start & MOD]);
                    applyMark(this.array, indexEnd, right1[(end & MOD) + 1]);
                    for (var i = indexStart + 1; i < indexEnd; i++) {
                        applyMark(this.array, i, 0xffffffff);
                    }
                }
            }
        };
        BitMap.prototype.markInRange = function (x, y, x2, y2) {
            return this.markInRangeScaled(this.scalePixel(x), this.scalePixel(y), this.scalePixel(x2), this.scalePixel(y2));
        };
        BitMap.prototype.unmarkInRangeScaled = function (x, y, x2, y2) {
            var start, end, indexStart, indexEnd;
            for (; y <= y2; y++) {
                start = y * this.width + x;
                end = y * this.width + x2;
                indexStart = start >>> DIV;
                indexEnd = end >>> DIV;
                if (indexStart === indexEnd) {
                    applyUnmark(this.array, indexStart, right1[start & MOD] | right0[(end & MOD) + 1]);
                }
                else {
                    applyUnmark(this.array, indexStart, right1[start & MOD]);
                    applyUnmark(this.array, indexEnd, right0[(end & MOD) + 1]);
                    for (var i = indexStart + 1; i < indexEnd; i++) {
                        applyUnmark(this.array, i, 0x0);
                    }
                }
            }
        };
        BitMap.prototype.unmarkInRange = function (x, y, x2, y2) {
            return this.unmarkInRangeScaled(this.scalePixel(x), this.scalePixel(y), this.scalePixel(x2), this.scalePixel(y2));
        };
        BitMap.prototype.getInRangeScaled = function (x, y, x2, y2) {
            var start, end, indexStart, indexEnd;
            for (; y <= y2; y++) {
                start = y * this.width + x;
                end = y * this.width + x2;
                indexStart = start >>> DIV;
                indexEnd = end >>> DIV;
                if (indexStart === indexEnd) {
                    if (this.array[indexStart] & right0[start & MOD] & right1[(end & MOD) + 1]) {
                        return true;
                    }
                }
                else {
                    if (this.array[indexStart] & right0[start & MOD]) {
                        return true;
                    }
                    if (this.array[indexEnd] & right1[(end & MOD) + 1]) {
                        return true;
                    }
                    for (var i = indexStart + 1; i < indexEnd; i++) {
                        if (this.array[i]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        BitMap.prototype.getInRange = function (x, y, x2, y2) {
            return this.getInRangeScaled(this.scalePixel(x), this.scalePixel(y), this.scalePixel(x2), this.scalePixel(y2));
        };
        BitMap.prototype.searchOutOfBound = function (x, y, x2, y2) {
            return x < 0 || y < 0 || y2 >= this.height || x2 >= this.width;
        };
        return BitMap;
    }());
    // static function
    // bit mask for getting first 2 bytes of alpha value
    var ALPHA_MASK = 0xff000000;
    // alpha value equivalent to opacity 0.0625
    var INSIDE_OPACITY_IN_ALPHA = 0x10000000;
    var INSIDE_OPACITY = 0.0625;
    /**
     * Get bitmaps and fill the with mark information from data
     * @param {array} data data of labels to be placed
     * @param {array} size size of chart in format [width, height]
     * @param {string} marktype marktype of the base mark
     * @param {bool} avoidBaseMark a flag if base mark is to be avoided
     * @param {array} avoidMarks array of mark data to be avoided
     * @param {bool} labelInside a flag if label to be placed inside mark or not
     * @param {number} padding padding from the boundary of the chart
     *
     * @returns array of 2 bitmaps:
     *          - first bitmap is filled with all the avoiding marks
     *          - second bitmap is filled with borders of all the avoiding marks (second bit map can be
     *            undefined if checking border of base mark is not needed when not avoiding any mark)
     */
    function prepareBitmap(data, size, marktype, avoidBaseMark, avoidMarks, labelInside, padding) {
        var isGroupArea = false; // VCC does not have group/area - marktype === 'group' && data[0].datum.datum.items[0].marktype === 'area';
        var width = size[0];
        var height = size[1];
        var n = data.length;
        // for VCC we do not need these step as marks are already passed into this function
        // vs pulled from the Vega spec
        // extract data information from base mark when base mark is to be avoid
        // or base mark is implicitly avoid when base mark is group area
        // if (marktype && (avoidBaseMark || isGroupArea)) {
        //   const items = new Array(n);
        //   for (let i = 0; i < n; i++) {
        //     items[i] = data[i].datum.datum;
        //   }
        //   avoidMarks.push(items);
        // }
        if (avoidMarks.length) {
            // when there is at least one mark to be avoided
            var context = writeToCanvas(avoidMarks, width, height, labelInside || isGroupArea);
            return writeToBitMaps(context, width, height, labelInside, isGroupArea, padding);
        }
        else {
            var bitMap = new BitMap(width, height, padding);
            if (avoidBaseMark) {
                // when there is no base mark but data points are to be avoided
                for (var i = 0; i < n; i++) {
                    var d = data[i];
                    bitMap.mark(d.markBound[0], d.markBound[3]);
                }
            }
            return [bitMap, undefined];
        }
    }
    /**
     * Get bitmaps and fill the with mark information from data
     * @param {array} bitmaps pre-created bitmaps to specifically add content too
     * @param {array} data data of labels to be placed
     * @param {array} size size of chart in format [width, height]
     * @param {string} marktype marktype of the base mark
     * @param {bool} avoidBaseMark a flag if base mark is to be avoided
     * @param {array} avoidMarks array of mark data to be avoided
     * @param {bool} labelInside a flag if label to be placed inside mark or not
     * @param {number} padding padding from the boundary of the chart
     *
     * @returns array of 2 bitmaps:
     *          - first bitmap is filled with all the avoiding marks
     *          - second bitmap is filled with borders of all the avoiding marks (second bit map can be
     *            undefined if checking border of base mark is not needed when not avoiding any mark)
     */
    function addToBitmap(bitmaps, data, size, marktype, avoidBaseMark, avoidMarks, labelInside, padding) {
        var isGroupArea = false; // VCC does not have group/area - marktype === 'group' && data[0].datum.datum.items[0].marktype === 'area';
        var width = size[0];
        var height = size[1];
        var n = data.length;
        if (avoidMarks.length) {
            // when there is at least one mark to be avoided
            var context = writeToCanvas(avoidMarks, width, height, labelInside || isGroupArea);
            return writeToPassedBitMaps(context, bitmaps, width, height, labelInside, isGroupArea);
        }
        else {
            if (avoidBaseMark) {
                // when there is no base mark but data points are to be avoided
                for (var i = 0; i < n; i++) {
                    var d = data[i];
                    bitmaps[0].mark(d.markBound[0], d.markBound[3]);
                }
            }
            return bitmaps;
        }
    }
    /**
     * Write avoid marks from drawn canvas to bitmap
     * @param {object} context canvas context, to which all avoiding marks are drawn
     * @param {array} bitmaps pre-created bitmaps to specifically add content too
     * @param {number} width width of the chart
     * @param {number} height height of the chart
     * @param {bool} labelInside a flag if label to be placed inside mark or not
     * @param {bool} isGroupArea a flag if the base mark if group area
     * @param {number} padding padding from the boundary of the chart
     *
     * @returns array of 2 bitmaps:
     *          - first bitmap is filled with all the avoiding marks
     *          - second bitmap is filled with borders of all the avoiding marks
     */
    function writeToPassedBitMaps(context, bitmaps, width, height, labelInside, isGroupArea, padding) {
        var imageData = context.getImageData(0, 0, width, height);
        var canvasBuffer = new Uint32Array(imageData.data.buffer);
        var x, y, alpha;
        if (isGroupArea) {
            for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                    alpha = canvasBuffer[y * width + x] & ALPHA_MASK;
                    // only fill second layer for group area because labels are only not allowed to place over
                    // border of area
                    if (alpha && alpha ^ INSIDE_OPACITY_IN_ALPHA) {
                        bitmaps[1].mark(x, y);
                    }
                }
            }
        }
        else {
            for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                    alpha = canvasBuffer[y * width + x] & ALPHA_MASK;
                    if (alpha) {
                        // fill first layer if there is something in canvas in that location
                        bitmaps[0].mark(x, y);
                        // fill second layer if there is a border in canvas in that location
                        // and label can be placed inside
                        if (labelInside && alpha ^ INSIDE_OPACITY_IN_ALPHA) {
                            bitmaps[1].mark(x, y);
                        }
                    }
                }
            }
        }
        return bitmaps;
    }
    /**
     * Write marks to be avoided to canvas to be written to bitmap later
     * @param {array} avoidMarks array of mark data to be avoided
     * @param {number} width width of the chart
     * @param {number} height height of the chart
     * @param {bool} labelInside a flag if label to be placed inside mark or not
     *
     * @returns canvas context, to which all avoiding marks are drawn
     */
    function writeToCanvas(avoidMarks, width, height, labelInside) {
        var m = avoidMarks.length;
        // const c = document.getElementById('canvas-render'); // debugging canvas
        var c = document.createElement('canvas');
        var context = c.getContext('2d');
        var originalItems, itemsLen;
        c.setAttribute('width', width);
        c.setAttribute('height', height);
        // draw every avoiding marks into canvas
        for (var i = 0; i < m; i++) {
            originalItems = avoidMarks[i];
            itemsLen = originalItems.length;
            if (!itemsLen) {
                continue;
            }
            // need to update this to work off VCC polyfill of Vega specification
            // if (originalItems[0].mark.marktype !== 'group') {
            if (originalItems[0].nodeName !== 'group') {
                drawMark(context, originalItems, labelInside);
            }
            else {
                drawGroup(context, originalItems, labelInside);
            }
        }
        return context;
    }
    /**
     * Write avoid marks from drawn canvas to bitmap
     * @param {object} context canvas context, to which all avoiding marks are drawn
     * @param {number} width width of the chart
     * @param {number} height height of the chart
     * @param {bool} labelInside a flag if label to be placed inside mark or not
     * @param {bool} isGroupArea a flag if the base mark if group area
     * @param {number} padding padding from the boundary of the chart
     *
     * @returns array of 2 bitmaps:
     *          - first bitmap is filled with all the avoiding marks
     *          - second bitmap is filled with borders of all the avoiding marks
     */
    function writeToBitMaps(context, width, height, labelInside, isGroupArea, padding) {
        var layer1 = new BitMap(width, height, padding);
        var layer2 = (labelInside || isGroupArea) && new BitMap(width, height, padding);
        var imageData = context.getImageData(0, 0, width, height);
        var canvasBuffer = new Uint32Array(imageData.data.buffer);
        var x, y, alpha;
        if (isGroupArea) {
            for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                    alpha = canvasBuffer[y * width + x] & ALPHA_MASK;
                    // only fill second layer for group area because labels are only not allowed to place over
                    // border of area
                    if (alpha && alpha ^ INSIDE_OPACITY_IN_ALPHA) {
                        layer2.mark(x, y);
                    }
                }
            }
        }
        else {
            for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                    alpha = canvasBuffer[y * width + x] & ALPHA_MASK;
                    if (alpha) {
                        // fill first layer if there is something in canvas in that location
                        layer1.mark(x, y);
                        // fill second layer if there is a border in canvas in that location
                        // and label can be placed inside
                        if (labelInside && alpha ^ INSIDE_OPACITY_IN_ALPHA) {
                            layer2.mark(x, y);
                        }
                    }
                }
            }
        }
        return [layer1, layer2];
    }
    /**
     * Draw mark into canvas
     * @param {object} context canvas context, to which all avoiding marks are drawn
     * @param {array} originalItems mark to be drawn into canvas
     * @param {bool} labelInside a flag if label to be placed inside mark or not
     */
    function drawMark(context, originalItems, labelInside) {
        var n = originalItems.length;
        var items;
        if (labelInside) {
            items = new Array(n);
            for (var i = 0; i < n; i++) {
                items[i] = prepareMarkItem(originalItems[i]);
            }
        }
        else {
            items = originalItems;
        }
        // draw items into canvas
        items.forEach(function (item) { return drawCanvasShape(context, item); });
        // Marks[items[0].mark.marktype].draw(context, {items: items}, null);
    }
    /**
     * draw group of marks into canvas
     * @param {object} context canvas context, to which all avoiding marks are drawn
     * @param {array} groups group of marks to be drawn into canvas
     * @param {bool} labelInside a flag if label to be placed inside mark or not
     */
    function drawGroup(context, groups, labelInside) {
        var n = groups.length;
        var marks;
        for (var i = 0; i < n; i++) {
            marks = groups[i].items;
            for (var j = 0; j < marks.length; j++) {
                var g = marks[j];
                if (g.marktype !== 'group') {
                    drawMark(context, g.items, labelInside);
                }
                else {
                    // recursivly draw group of marks
                    drawGroup(context, g.items, labelInside);
                }
            }
        }
    }
    /**
     * Prepare item before drawing into canvas (setting stroke and opacity)
     * @param {object} originalItem item to be prepared
     *
     * @returns prepared item
     */
    function prepareMarkItem(originalItem) {
        var item = {};
        for (var key in originalItem) {
            item[key] = originalItem[key];
        }
        if (item.stroke) {
            item.strokeOpacity = 1;
        }
        if (item.fill) {
            item.fillOpacity = INSIDE_OPACITY;
            item.stroke = '#000';
            item.strokeOpacity = 1;
            item.strokeWidth = 2;
        }
        return item;
    }
    // VCC replacement for vega-label's Marks[items[0].mark.marktype].draw(context, {items: items}, null);
    // this is where we are different than Vega and can simplify drawing shapes on canvas
    function drawCanvasShape(context, item) {
        var translateX = !+item['data-translate-x'] ? 0 : +item['data-translate-x'];
        var translateY = !+item['data-translate-y'] ? 0 : +item['data-translate-y'];
        var dx = item['data-use-dx'] === 'true' && +item['dx'] ? +item['dx'] : 0;
        var dy = item['data-use-dy'] === 'true' && +item['dy'] ? +item['dy'] : 0;
        context.beginPath();
        // hoping we can just pass labels as rects as well for the time being?
        if (item.nodeName === 'rect') {
            // console.log('drawing rect to canvas', item, translateX, translateY);
            context.rect(+item['data-x'] + translateX, +item['data-y'] + translateY, +item['data-width'], +item['data-height']);
            context.stroke();
            if (item['data-fill'] && item['data-fill'] === 'true')
                context.fill();
        }
        else if (item.nodeName === 'text') {
            // when drawing to canvas, we need to take into account text anchor
            var translateTextAnchor = item['text-anchor']
                ? !item['text-anchor'] || item['text-anchor'] === 'start'
                    ? 0
                    : item['text-anchor'] === 'middle'
                        ? item['data-width'] / 2
                        : item['data-width']
                : 0;
            // when drawing canvas, we need to take into account the baseline set by vega-label
            var translateTextHeight = item['baseline'] && false
                ? item['baseline'] === 'top'
                    ? +item['data-height']
                    : item['baseline'] === 'middle'
                        ? +item['data-height'] / 3
                        : 0
                : 0;
            // console.log('drawing text to canvas', item, translateX, translateTextAnchor, dx, translateY, dy);
            context.rect(+item['data-x'] + translateX - translateTextAnchor + dx, +item['data-y'] + translateY + translateTextHeight + dy, +item['data-width'], +item['data-height']);
            context.stroke();
            if (item['data-fill'] && item['data-fill'] === 'true')
                context.fill();
        }
        else if (item.nodeName === 'circle') {
            context.arc(+item['data-cx'] + translateX, +item['data-cy'] + translateY, +item['data-r'], 0, 2 * Math.PI);
            context.stroke();
            if (item['data-fill'] && item['data-fill'] === 'true')
                context.fill();
        }
        else if (item.nodeName === 'line') {
            context.moveTo(+item['data-x1'] + translateX, +item['data-y1'] + translateY);
            context.lineTo(+item['data-x2'] + translateX, +item['data-y2'] + translateY);
            context.stroke();
        }
        else if (item.nodeName === 'path') {
            var parsed = pathParse(item['data-d']);
            var l = (+item['data-x'] || 0) + translateX;
            var t = (+item['data-y'] || 0) + translateY;
            var sX = +item['data-r'] || 1;
            var sY = sX;
            // console.log('drawing path to canvas', item, translateX, translateY, parsed);
            pathRender(context, parsed, l, t, sX, sY); // Math.sqrt(size) / 2);
            context.stroke();
            if (item['data-fill'] && item['data-fill'] === 'true')
                context.fill();
        }
        context.closePath();
    }

    function domCanvas(w, h) {
        if (typeof document !== 'undefined' && document.createElement) {
            var c = document.createElement('canvas');
            if (c && c.getContext) {
                c.width = w;
                c.height = h;
                return c;
            }
        }
        return null;
    }

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    /* This file includes code covered by the following notice */
    /**
     * Copyright (c) 2016, University of Washington Interactive Data Lab
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its contributors
     *   may be used to endorse or promote products derived from this software
     *   without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     **/
    /*eslint no-console: "warn"*/
    /*eslint no-empty: "warn"*/
    /**
     * Calculate width of `text` with font size `fontSize` and font `font`
     * @param {object} context 2d-context of canvas
     * @param {string} text the string, which width to be calculated
     * @param {number} fontSize font size of `text`
     * @param {string} font font of `text`
     */
    function labelWidth(context, text, fontSize, font) {
        // TODO: support other font properties
        context.font = fontSize + 'px ' + font;
        return context.measureText(text).width;
    }
    function checkCollision(x1, y1, x2, y2, bitMap) {
        return !bitMap || bitMap.getInRangeScaled(x1, y2, x2, y2) || bitMap.getInRangeScaled(x1, y1, x2, y2 - 1);
    }

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var SIZE_FACTOR = 0.707106781186548; // this is 1 over square root of 2
    // Options for align
    var ALIGN = ['right', 'center', 'left'];
    // Options for baseline
    var BASELINE = ['bottom', 'middle', 'top'];
    var LabelPlacer = /** @class */ (function () {
        function LabelPlacer(bitmaps, size, anchors, offsets) {
            this.bm0 = bitmaps[0];
            this.bm1 = bitmaps[1];
            this.width = size[0];
            this.height = size[1];
            this.anchors = anchors;
            this.offsets = offsets;
        }
        LabelPlacer.prototype.place = function (d) {
            // do we need this check for VCC?
            var mb = d.markBound;
            // can not be placed if the mark is not visible in the graph bound
            if (mb[2] < 0 || mb[5] < 0 || mb[0] > this.width || mb[3] > this.height) {
                return false;
            }
            var context = domCanvas().getContext('2d');
            var n = this.offsets.length;
            var textHeight = d.textHeight;
            var markBound = d.markBound;
            var text = d.text;
            var font = d.font;
            var textWidth = d.textWidth;
            var dx, dy, isInside, sizeFactor, insideFactor;
            var x, x1, xc, x2, y1, yc, y2;
            var _x1, _x2, _y1, _y2;
            // for each anchor and offset
            for (var i = 0; i < n; i++) {
                dx = (this.anchors[i] & 0x3) - 1; // this is used to pick anchor position x
                dy = ((this.anchors[i] >>> 0x2) & 0x3) - 1; // this is used to pick anchor position y
                isInside = this.bm1 && ((dx === 0 && dy === 0) || this.offsets[i] < 0);
                sizeFactor = dx && dy ? SIZE_FACTOR : 1;
                insideFactor = this.offsets[i] < 0 ? -1 : 1;
                yc = markBound[4 + dy] + (insideFactor * textHeight * dy) / 2.0 + this.offsets[i] * dy * sizeFactor;
                x = markBound[1 + dx] + this.offsets[i] * dx * sizeFactor;
                y1 = yc - textHeight / 2.0;
                y2 = yc + textHeight / 2.0;
                _y1 = this.bm0.scalePixel(y1);
                _y2 = this.bm0.scalePixel(y2);
                _x1 = this.bm0.scalePixel(x);
                // we are setting text width in our call, so this is not
                // really ever going to be used
                if (!textWidth) {
                    // to avoid finding width of text label,
                    if (!isLabelPlacable(_x1, _x1, _y1, _y2, this.bm0, this.bm1, x, x, y1, y2, markBound, isInside)) {
                        // skip this anchor/offset option if fail to place the label with 1px width
                        continue;
                    }
                    else {
                        // Otherwise, find the label width
                        textWidth = labelWidth(context, text, textHeight, font);
                    }
                }
                xc = x + (insideFactor * textWidth * dx) / 2.0;
                x1 = xc - textWidth / 2.0;
                x2 = xc + textWidth / 2.0;
                _x1 = this.bm0.scalePixel(x1);
                _x2 = this.bm0.scalePixel(x2);
                // place label if the position is placable
                // VCC moves this outside of the below if statement as we need write placement
                // even if we hide label for better interactivity and transition/lifecycle experience
                d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;
                d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;
                d.align = ALIGN[dx * insideFactor + 1];
                d.baseline = BASELINE[dy * insideFactor + 1];
                if (isLabelPlacable(_x1, _x2, _y1, _y2, this.bm0, this.bm1, x1, x2, y1, y2, markBound, isInside)) {
                    this.bm0.markInRangeScaled(_x1, _y1, _x2, _y2);
                    return true;
                }
                // else { // debugging of failed positions
                //   this.bm0.markInRangeScaled(_x1, _y1, _x2, _y2);
                // }
            }
            return false;
        };
        LabelPlacer.prototype.unplace = function (d) {
            var n = this.offsets.length;
            var textHeight = d.textHeight;
            var markBound = d.markBound;
            var textWidth = d.textWidth;
            var dx, dy, sizeFactor, insideFactor;
            var x, x1, xc, x2, y1, yc, y2;
            var _x1, _x2, _y1, _y2;
            // for each anchor and offset
            for (var i = 0; i < n; i++) {
                dx = (this.anchors[i] & 0x3) - 1; // this is used to pick anchor position x
                dy = ((this.anchors[i] >>> 0x2) & 0x3) - 1; // this is used to pick anchor position y
                sizeFactor = dx && dy ? SIZE_FACTOR : 1;
                insideFactor = this.offsets[i] < 0 ? -1 : 1;
                yc = markBound[4 + dy] + (insideFactor * textHeight * dy) / 2.0 + this.offsets[i] * dy * sizeFactor;
                x = markBound[1 + dx] + this.offsets[i] * dx * sizeFactor;
                y1 = yc - textHeight / 2.0;
                y2 = yc + textHeight / 2.0;
                _y1 = this.bm0.scalePixel(y1);
                _y2 = this.bm0.scalePixel(y2);
                _x1 = this.bm0.scalePixel(x);
                xc = x + (insideFactor * textWidth * dx) / 2.0;
                x1 = xc - textWidth / 2.0;
                x2 = xc + textWidth / 2.0;
                _x1 = this.bm0.scalePixel(x1);
                _x2 = this.bm0.scalePixel(x2);
                this.bm0.unmarkInRangeScaled(_x1, _y1, _x2, _y2 + 3);
            }
            return true;
        };
        return LabelPlacer;
    }());
    function isLabelPlacable(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, markBound, isInside) {
        return !(bm0.searchOutOfBound(_x1, _y1, _x2, _y2) ||
            (isInside
                ? checkCollision(_x1, _y1, _x2, _y2, bm1) || !isInMarkBound(x1, y1, x2, y2, markBound)
                : checkCollision(_x1, _y1, _x2, _y2, bm0)));
    }
    function isInMarkBound(x1, y1, x2, y2, markBound) {
        return markBound[0] <= x1 && x2 <= markBound[2] && markBound[3] <= y1 && y2 <= markBound[5];
    }

    /**
     * Copyright (c) 2020, 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var polyfillMouseEvents = function (window) {
        // Polyfills DOM4 MouseEvent
        var MouseEventPolyfill = function (eventType, params) {
            params = params || { bubbles: false, cancelable: false };
            var mouseEvent = document.createEvent('MouseEvent');
            mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, params.screenX || 0, params.screenY || 0, params.clientX || 0, params.clientY || 0, params.ctrlKey || false, params.altKey || false, params.shiftKey || false, params.metaKey || false, params.button || 0, params.relatedTarget || null);
            return mouseEvent;
        };
        MouseEventPolyfill.prototype = Event.prototype;
        window.MouseEvent = MouseEventPolyfill;
    };
    var polyfillGetAttributeNames = function () {
        if (Element.prototype.getAttributeNames == undefined) {
            Element.prototype.getAttributeNames = function () {
                var attributes = this.attributes;
                var length = attributes.length;
                var result = new Array(length);
                for (var i = 0; i < length; i++) {
                    result[i] = attributes[i].name;
                }
                return result;
            };
        }
    };

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var browser$1 = getBrowser();
    var isIE11$1 = browser$1 === 'IE'; // ua.includes('rv:11.0');
    if (isIE11$1) {
        polyfillGetAttributeNames();
    }
    // 8-bit representation of anchors
    // obtained from vega-label
    var TOP = 0x0, MIDDLE = 0x1 << 0x2, BOTTOM = 0x2 << 0x2, LEFT = 0x0, CENTER = 0x1, RIGHT = 0x2;
    // Dictionary mapping from text anchor to its number representation
    // obtained from vega-label
    var anchorTextToNumber = {
        'top-left': TOP + LEFT,
        top: TOP + CENTER,
        'top-right': TOP + RIGHT,
        left: MIDDLE + LEFT,
        middle: MIDDLE + CENTER,
        right: MIDDLE + RIGHT,
        'bottom-left': BOTTOM + LEFT,
        bottom: BOTTOM + CENTER,
        'bottom-right': BOTTOM + RIGHT
    };
    var findCollision = function (bbox1, bbox2) {
        return bbox1.x <= bbox2.x + bbox2.width &&
            bbox2.x <= bbox1.x + bbox1.width &&
            bbox2.y <= bbox1.y + bbox1.height &&
            bbox1.y <= bbox2.y + bbox2.height;
    };
    // NOTE: resolveCollision assumes a TRANSITION selection (aka selection.transition().duration()... etc)
    // results outside of a transition are untested!
    var resolveLabelCollision = function (_a) {
        var labelSelection = _a.labelSelection, // this is a set of selections determined by component
        avoidMarks = _a.avoidMarks, // marks to draw to bitmap and then avoid when placing a label
        validPositions = _a.validPositions, // this the list of anchor positions to allow (e.g., series label should be middle, top, bottom, right/left?)
        offsets = _a.offsets, // these offsets should be predetermined, but allowing components to specify could be helpful at some point
        accessors = _a.accessors, // these are the accessors to check when building the key:value hash for mark boundaries
        size = _a.size, // an array with chart [ width, height ]
        boundsScope = _a.boundsScope, // used in getting mark bounds, can help more specifically define placment of labels
        bitmaps = _a.bitmaps, // outputted/inputted bitmap created, used to speed up subsequent calls to this function
        hideOnly = _a.hideOnly, // a boolean that will be off by default, but when true is passed it will not place, only hide overlapping
        removeOnly = _a.removeOnly, // a boolean that will be off by default, but when true is passed it will only remove labels passed from bitmap
        suppressMarkDraw = _a.suppressMarkDraw // a boolean that will be off by default, but when true is passed it will skip drawing chart marks to canvas/bitmap
        ;
        var anchors = validPositions; // this should be the allowed placements
        // const padding = 100; // The padding in pixels (default 0) by which a label may extend past the chart bounding box.
        var labelsArray = []; // we will populate this with labels to add to bitmap
        var marksArray = []; // we will populate this with marks to add to bitmap
        var boundsHash = {}; // hash lookup used to match bounds to labels
        // check size is there
        if (!size || size.length !== 2) {
            throw Error('Size of chart should be specified as an array of width and height');
        }
        // step 1a: map d3 mark selections in preperation for vega-label, an array of multiple selections
        if (avoidMarks && avoidMarks.length) {
            avoidMarks.forEach(function (marks) {
                var innerMarkArray = [];
                marks.each(function (d, i, n) {
                    var item = {};
                    item['node'] = n[i];
                    item['nodeName'] = n[i].nodeName;
                    item['datum'] = d && d.data && d.data.data ? d.data.data : d && d.data ? d.data : d ? d : {};
                    n[i].getAttributeNames().forEach(function (attrName) {
                        item[attrName] = select(n[i]).attr(attrName);
                    });
                    item['boundsScope'] = boundsScope;
                    item['bounds'] = getMarkItemBounds(item);
                    var accessorValues = accessors.map(function (key) { return item['datum'][key] || 'Not Found'; });
                    boundsHash[accessorValues.join('-')] = item['bounds'];
                    item['key'] = accessorValues.join('-');
                    innerMarkArray.push(item);
                });
                marksArray.push(innerMarkArray);
            });
        }
        // step 1b: map d3 label selections in preperation for vega-label, a single label selection
        if (labelSelection) {
            labelSelection.each(function (d, i, n) {
                var item = {};
                var textElement = n[i];
                var style = getComputedStyle(textElement);
                var fontSize = parseFloat(style.fontSize);
                var fontFamily = style.fontFamily;
                item['node'] = n[i];
                item['i'] = i;
                item['nodeName'] = textElement.nodeName;
                item['fontSize'] = fontSize; // d.fontSize in Vega
                item['font'] = style.fontFamily;
                item['text'] = textElement.textContent;
                item['sort'] = false;
                item['originalOpacity'] = 1; // should be opacity of the element ultimately
                item['datum'] = d && d.data && d.data.data ? d.data.data : d && d.data ? d.data : d ? d : {};
                textElement.getAttributeNames().forEach(function (attrName) {
                    item[attrName] = select(textElement).attr(attrName);
                });
                item['textWidth'] =
                    textElement.nodeName === 'rect'
                        ? +item['width']
                        : getTextWidth(textElement.textContent, fontSize, true, fontFamily);
                item['textHeight'] = textElement.nodeName === 'rect' ? +item['height'] : Math.max(fontSize - 1, 1); // clone.getBBox().height;
                var accessorValues = accessors.map(function (key) { return item['datum'][key] || 'Not Found'; });
                // we check our has to try and find the corresponding mark boundaries
                // if we do not find them we fall back to our label boundaries
                // but the success of this algorithm seems very reliant on mark boundaries
                item['key'] = accessorValues.join('-');
                item['boundsScope'] = boundsScope;
                var oldDataX = item['data-x'];
                var oldDataY = item['data-y'];
                if (removeOnly && item['x'] && item['y'] && !(item['keep-data-y'] === 'true')) {
                    item['data-x'] = item['x'];
                    item['data-y'] = item['y'];
                }
                item['markBound'] =
                    boundsHash[accessorValues.join('-')] && !hideOnly // if hide only, we need to use text as is
                        ? boundsHash[accessorValues.join('-')]
                        : getMarkItemBounds(item);
                if (removeOnly) {
                    item['data-x'] = oldDataX;
                    item['data-y'] = oldDataY;
                }
                labelsArray.push(item);
            });
        }
        // step 2: create bitmaps via vega-label
        // VCC does not use avoidBaseMark or markType and leverage marksArray directly instead
        // VCC does not leverage padding yet either, defaulted to 1 for the time being
        var avoidBaseMark = false; // marksArray && marksArray.length > 0; // we only use basemark if matching markers are passed
        // console.log('calling bitmap', bitmaps, labelsArray, size, 'markType_unused', avoidBaseMark, marksArray, false, 1);
        // if we received an inputted bitmap, add to it, otherwise, create a new one from scratch
        if (bitmaps && bitmaps.length === 2 && !removeOnly && !suppressMarkDraw) {
            addToBitmap(bitmaps, labelsArray, size, 'markType_unused', avoidBaseMark, marksArray, false);
        }
        else if (!removeOnly && !suppressMarkDraw) {
            bitmaps = prepareBitmap(labelsArray, size, 'markType_unused', avoidBaseMark, marksArray, false, 1);
        }
        // useful examples and debugging info from vega-label
        // this call is an example that will only draw marks into the bitmap and not place any labels
        // const bitmaps =  prepareBitmap([], size, 'markType_unused', true, marksArray, false, 1);
        // this call is an example that will ignore any base marks passed to the util
        // const bitmaps = prepareBitmap(labelsArray, size, 'circle', false, [], false, 1);
        // debugging code
        // printBitMap(bitmaps[0], 'bitmap-render'); // debug the bitmap being created
        // console.log('getting bitmap', bitmaps, labelsArray, marksArray);
        // step 3: place or hide labels...
        // alignMap is used to reset the text anchor based on the position result from the
        // occupancy bitmap check
        var alignMap = {
            right: 'end',
            center: 'middle',
            left: 'start'
        };
        var anchorPositions = anchors.map(function (anchor) { return anchorTextToNumber[anchor]; });
        var labelPlacer = new LabelPlacer(bitmaps, size, anchorPositions, offsets);
        var attributeHash = {};
        if (removeOnly) {
            // removeOnly will circumvent anything done below as it relates to stuff outside
            // of this utility
            labelsArray.forEach(function (item, i) {
                var itemKey = item.key === 'Not Found' ? i : item.i + "-" + item.key;
                // console.log('remove-item-from-bitmap', item.i, item.key, item);
                // call the bitmap remover function we added (tweaked copy of .place())
                // we only do this if the label was not already hidden
                if (item['data-label-hidden'] !== 'true')
                    labelPlacer.unplace(item);
                // we don't do anything when we remove from bitmap only
                attributeHash[itemKey] = {
                    'do-nothing': true
                };
            });
        }
        else {
            labelsArray.forEach(function (item, i) {
                // this handles when we don't have a data match
                // requires the lowest level selection in d3
                var itemKey = item.key === 'Not Found' ? i : item.i + "-" + item.key;
                if (item['data-hidden'] === 'true') {
                    // console.log('data-hidden', item.i, item.key, item);
                    attributeHash[itemKey] = {
                        'do-nothing': true
                    };
                }
                else if (+item['opacity'] === 0) {
                    // console.log('opacity-0', item);
                    attributeHash[itemKey] = {
                        'do-nothing': true
                    };
                }
                else if (!item['data-hidden'] && labelPlacer.place(item)) {
                    // console.log(
                    //   'placing node',
                    //   i,
                    //   item.key,
                    //   item.key === 'Not Found' ? i : item.key,
                    //   item,
                    //   item.baseline === 'top'
                    //     ? item['textHeight']
                    //     : item.baseline === 'bottom'
                    //     ? -item['textHeight'] / 5
                    //     : item['textHeight'] / 3,
                    //   select(item.node).attr('x'),
                    //   item.x,
                    //   select(item.node).attr('y'),
                    //   item.y
                    // );
                    attributeHash[itemKey] = {
                        visibility: null,
                        x: item.x,
                        y: item.y,
                        translateX: !+item['data-translate-x'] ? 0 : +item['data-translate-x'],
                        translateY: !+item['data-translate-y'] ? 0 : +item['data-translate-y'],
                        // this adjusts the placement of text based on LabelPlacer logic from vega-label
                        translateHeight: !item['data-no-text-anchor']
                            ? item.baseline === 'top'
                                ? +item['textHeight'] //  / 3
                                : item.baseline === 'middle'
                                    ? +item['textHeight'] / 3
                                    : 0
                            : 0,
                        'text-anchor': !item['data-no-text-anchor'] ? alignMap[item.align] : null,
                        'data-align': item.align,
                        'data-baseline': item.baseline,
                        'data-label-moved': true,
                        'data-label-hidden': false,
                        textHeight: item.textHeight
                    };
                    // we will have to place item here based on whats comes back
                }
                else {
                    // console.log('hiding node', i, item.key, item.key === 'Not Found' ? i : item.key, item);
                    attributeHash[itemKey] = {
                        visibility: 'hidden',
                        x: item.x,
                        y: item.y,
                        translateX: !+item['data-translate-x'] ? 0 : +item['data-translate-x'],
                        translateY: !+item['data-translate-y'] ? 0 : +item['data-translate-y'],
                        // this adjusts the placement of text based on LabelPlacer logic from vega-label
                        translateHeight: !item['data-no-text-anchor']
                            ? item.baseline === 'top'
                                ? +item['textHeight'] //  / 3
                                : item.baseline === 'middle'
                                    ? +item['textHeight'] / 3
                                    : 0
                            : 0,
                        'text-anchor': !item['data-no-text-anchor'] ? alignMap[item.align] : null,
                        'data-align': item.align,
                        'data-baseline': item.baseline,
                        textHeight: item.textHeight,
                        'data-label-moved': true,
                        'data-label-hidden': true
                    };
                }
            });
            // now that we are done we set the selection values onto the transition
            labelSelection.style('visibility', function (d, i, n) {
                var innerD = d && d.data && d.data.data ? d.data.data : d && d.data ? d.data : d ? d : {};
                var accessorValues = accessors.map(function (key) { return innerD[key] || 'Not Found'; });
                var attributes = accessorValues.join('-') === 'Not Found' ? attributeHash[i] : attributeHash[i + "-" + accessorValues.join('-')];
                // first we check if we are not supposed to do anything
                if (accessors && accessors.length && attributes && attributes['do-nothing']) {
                    // console.log('we are in do nothing', i, d, n[i], attributes);
                    return select(n[i]).style('visibility');
                }
                else {
                    // console.log('we are in do something', i, d, n[i], attributes);
                    // if we get past that, then we can apply visibility update
                    select(n[i])
                        .attr('data-label-hidden', accessors && accessors.length && attributes && attributes['data-label-hidden'])
                        .attr('data-label-moved', accessors && accessors.length && attributes && attributes['data-label-moved'])
                        .attr('data-align', attributes['data-align'])
                        .attr('data-baseline', attributes['data-baseline'])
                        .attr('dx', !(select(n[i]).attr('data-use-dx') === 'true') ? null : select(n[i]).attr('dx'))
                        .attr('dy', !(select(n[i]).attr('data-use-dy') === 'true') ? null : select(n[i]).attr('dy'))
                        .attr('data-use-dx', null)
                        .attr('data-use-dy', null); // we may still need these, but it was causing a blip of placement on world-map during hideOnly mode
                    return accessors && accessors.length && attributes && (attributes.visibility === null || !attributes.visibility)
                        ? null
                        : 'hidden';
                }
            });
            // we only update placement if hideOnly is not passed/truthy, which should be default
            // matching the selection to the array above has lead to a lot of repeated code
            // we can likely improve the performance, conciseness and readibility of this code
            // in future revisions
            if (!hideOnly) {
                labelSelection
                    // .each((d, i, n) => {
                    //   const innerD = d && d.data && d.data.data ? d.data.data : d && d.data ? d.data : d ? d : {};
                    //   const accessorValues = accessors.map(key => innerD[key] || 'Not Found');
                    //   const attributes =
                    //     accessorValues.join('-') === 'Not Found'
                    //       ? attributeHash[i]
                    //       : attributeHash[`${i}-${accessorValues.join('-')}`];
                    // this is more concise, but since it is a different selection it doesn't transition
                    // we would have to get transition info from the passed selection somehow to do it this way
                    // select(n[i])
                    // .transition('collision-update') // this does not work
                    // .ease(labelSelection.ease())
                    // .duration(labelSelection.duration())
                    // .style('visibility', attributes && attributes.visibility === null ? null : 'hidden')
                    // .attr('x', attributes && attributes.x ? attributes.x : select(n[i]).attr('x'))
                    // .attr('y', attributes && attributes.y ? attributes.y : select(n[i]).attr('y'))
                    // .attr('dx', (_, i, n) => (!select(n[i]).attr('data-use-dx') ? null : select(n[i]).attr('dx')))
                    // .attr('dy', (_, i, n) => (!select(n[i]).attr('data-use-dy') ? null : select(n[i]).attr('dy')));
                    // })
                    .attr('x', function (d, i, n) {
                    var innerD = d && d.data && d.data.data ? d.data.data : d && d.data ? d.data : d ? d : {};
                    var accessorValues = accessors.map(function (key) { return innerD[key] || 'Not Found'; });
                    var attributes = accessorValues.join('-') === 'Not Found'
                        ? attributeHash[i]
                        : attributeHash[i + "-" + accessorValues.join('-')];
                    // console.log('checking stuff', n[i], accessorValues, attributeHash, attributes, accessors && accessors.length && attributes && attributes.x);
                    return accessors && accessors.length && attributes && attributes.x
                        ? attributes.x - attributes.translateX
                        : select(n[i]).attr('data-x');
                })
                    .attr('y', function (d, i, n) {
                    var innerD = d && d.data && d.data.data ? d.data.data : d && d.data ? d.data : d ? d : {};
                    var accessorValues = accessors.map(function (key) { return innerD[key] || 'Not Found'; });
                    var attributes = accessorValues.join('-') === 'Not Found'
                        ? attributeHash[i]
                        : attributeHash[i + "-" + accessorValues.join('-')];
                    var translateTextHeight = accessors && accessors.length && attributes && attributes['translateHeight'];
                    return accessors && accessors.length && attributes && attributes.y
                        ? attributes.y - attributes.translateY + translateTextHeight
                        : select(n[i]).attr('data-y');
                })
                    .attr('text-anchor', function (d, i, n) {
                    var innerD = d && d.data && d.data.data ? d.data.data : d && d.data ? d.data : d ? d : {};
                    var accessorValues = accessors.map(function (key) { return innerD[key] || 'Not Found'; });
                    var attributes = accessorValues.join('-') === 'Not Found'
                        ? attributeHash[i]
                        : attributeHash[i + "-" + accessorValues.join('-')];
                    return accessors && accessors.length && attributes && attributes['text-anchor']
                        ? attributes['text-anchor']
                        : select(n[i]).attr('text-anchor');
                });
            }
        }
        // this print is super userful for debugging, it is coupled with the commented out
        // canvas element on each VCC component
        // printBitMap(bitmaps[0], 'bitmap-render');
        return bitmaps;
    };
    // function created for VCC to get the 6 point bounds for vega-label algorithm
    var getMarkItemBounds = function (markItem) {
        var translateX = !+markItem['data-translate-x'] ? 0 : +markItem['data-translate-x'];
        var translateY = !+markItem['data-translate-y'] ? 0 : +markItem['data-translate-y'];
        switch (markItem['nodeName']) {
            case 'text':
                // this could come through as textWidth or data-width depending on the component
                var textWidth = (!markItem['textWidth'] ? +markItem['data-width'] : +markItem['textWidth']) || 0;
                var textHeight = (!markItem['textHeight'] ? +markItem['data-height'] : +markItem['textHeight']) || 0;
                var fontSize = +markItem['fontSize'] || textHeight; // if we have textHeight, we should always have fontSize
                var translateTextAnchor = markItem['data-text-anchor'] // if data-text-anchor is passed, we need to use it first
                    ? !markItem['data-text-anchor'] || markItem['data-text-anchor'] === 'start'
                        ? 0
                        : markItem['data-text-anchor'] === 'middle'
                            ? textWidth / 2
                            : textWidth
                    : markItem['text-anchor']
                        ? !markItem['text-anchor'] || markItem['text-anchor'] === 'start'
                            ? 0
                            : markItem['text-anchor'] === 'middle'
                                ? textWidth / 2
                                : textWidth
                        : 0;
                var dx = markItem['data-use-dx'] !== 'true'
                    ? 0
                    : +markItem['dx']
                        ? +markItem['dx']
                        : markItem['dx'] && markItem['dx'].indexOf('em') >= 0
                            ? +markItem['dx'].replace('em', '') * fontSize
                            : 0;
                var dy = markItem['data-use-dy'] !== 'true'
                    ? 0
                    : +markItem['dy']
                        ? +markItem['dy']
                        : markItem['dy'] && markItem['dy'].indexOf('em') >= 0
                            ? +markItem['dy'].replace('em', '') * fontSize
                            : 0;
                // console.log('creating text bounds for', markItem, textHeight, textWidth, translateTextAnchor);
                switch (markItem['boundsScope']) {
                    case 'centroid':
                        return [
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-y'] + dy + translateY + textHeight / 2,
                            +markItem['data-y'] + dy + translateY + textHeight / 2,
                            +markItem['data-y'] + dy + translateY + textHeight / 2
                        ];
                    case 'top':
                        return [
                            +markItem['data-x'] + dx + translateX - translateTextAnchor,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth,
                            +markItem['data-y'] + dy + translateY,
                            +markItem['data-y'] + dy + translateY,
                            +markItem['data-y'] + dy + translateY
                        ];
                    case 'middle':
                        return [
                            +markItem['data-x'] + dx + translateX - translateTextAnchor,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth,
                            +markItem['data-y'] + dy + translateY + textHeight / 2,
                            +markItem['data-y'] + dy + translateY + textHeight / 2,
                            +markItem['data-y'] + dy + translateY + textHeight / 2
                        ];
                    case 'bottom':
                        return [
                            +markItem['data-x'] + dx + translateX - translateTextAnchor,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth,
                            +markItem['data-y'] + dy + translateY + textHeight,
                            +markItem['data-y'] + dy + translateY + textHeight,
                            +markItem['data-y'] + dy + translateY + textHeight
                        ];
                    case 'center':
                        return [
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-y'] + dy + translateY,
                            +markItem['data-y'] + dy + translateY + textHeight / 2,
                            +markItem['data-y'] + dy + translateY + textHeight
                        ];
                    case 'right':
                        return [
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth,
                            +markItem['data-y'] + dy + translateY,
                            +markItem['data-y'] + dy + translateY + textHeight / 2,
                            +markItem['data-y'] + dy + translateY + textHeight
                        ];
                    case 'left':
                        return [
                            +markItem['data-x'] + dx + translateX - translateTextAnchor,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor,
                            +markItem['data-y'] + dy + translateY,
                            +markItem['data-y'] + dy + translateY + textHeight / 2,
                            +markItem['data-y'] + dy + translateY + textHeight
                        ];
                    default:
                        // for default bounds we push text up as this matches how text is rendered on DOM based on bottom left corner
                        return [
                            +markItem['data-x'] + dx + translateX - translateTextAnchor,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                            +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth,
                            +markItem['data-y'] + dy + translateY - textHeight,
                            +markItem['data-y'] + dy + translateY - textHeight / 2,
                            +markItem['data-y'] + dy + translateY
                        ];
                    // return [ // this will render text with the location centered on the Y axis
                    //   +markItem['data-x'] + dx + translateX - translateTextAnchor,
                    //   +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth / 2,
                    //   +markItem['data-x'] + dx + translateX - translateTextAnchor + textWidth,
                    //   +markItem['data-y'] + dy + translateY - textHeight / 2,
                    //   +markItem['data-y'] + dy + translateY,
                    //   +markItem['data-y'] + dy + translateY + textHeight / 2
                    // ];
                }
            case 'circle': // cx/cy is center point
                return [
                    +markItem['data-cx'] + translateX - +markItem['data-r'],
                    +markItem['data-cx'] + translateX,
                    +markItem['data-cx'] + translateX + +markItem['data-r'],
                    +markItem['data-cy'] + translateY - +markItem['data-r'],
                    +markItem['data-cy'] + translateY,
                    +markItem['data-cy'] + translateY + +markItem['data-r']
                ];
            case 'rect': // x/y is top left corner
                switch (markItem['boundsScope']) {
                    case 'annotation':
                        return [
                            +markItem['data-x'] + translateX - +markItem['data-width'] / 2,
                            +markItem['data-x'] + translateX,
                            +markItem['data-x'] + translateX + +markItem['data-width'] / 2,
                            +markItem['data-y'] + translateY - +markItem['data-height'] / 2,
                            +markItem['data-y'] + translateY,
                            +markItem['data-y'] + translateY + +markItem['data-height'] / 2
                        ];
                    case 'top':
                        return [
                            +markItem['data-x'] + translateX,
                            +markItem['data-x'] + translateX + +markItem['data-width'] / 2,
                            +markItem['data-x'] + translateX + +markItem['data-width'],
                            +markItem['data-y'] + translateY,
                            +markItem['data-y'] + translateY,
                            +markItem['data-y'] + translateY
                        ];
                    case 'middle':
                        return [
                            +markItem['data-x'] + translateX + +markItem['data-width'] / 2,
                            +markItem['data-x'] + translateX + +markItem['data-width'] / 2,
                            +markItem['data-x'] + translateX + +markItem['data-width'] / 2,
                            +markItem['data-y'] + translateY + +markItem['data-height'] / 2,
                            +markItem['data-y'] + translateY + +markItem['data-height'] / 2,
                            +markItem['data-y'] + translateY + +markItem['data-height'] / 2
                        ];
                    case 'bottom':
                        return [
                            +markItem['data-x'] + translateX,
                            +markItem['data-x'] + translateX + +markItem['data-width'] / 2,
                            +markItem['data-x'] + translateX + +markItem['data-width'],
                            +markItem['data-y'] + translateY + +markItem['data-height'] - 6,
                            +markItem['data-y'] + translateY + +markItem['data-height'] - 6,
                            +markItem['data-y'] + translateY + +markItem['data-height'] - 6
                        ];
                    case 'right':
                        return [
                            +markItem['data-x'] + translateX + +markItem['data-width'],
                            +markItem['data-x'] + translateX + +markItem['data-width'],
                            +markItem['data-x'] + translateX + +markItem['data-width'],
                            +markItem['data-y'] + translateY,
                            +markItem['data-y'] + translateY + +markItem['data-height'] / 2,
                            +markItem['data-y'] + translateY + +markItem['data-height']
                        ];
                    case 'left':
                        return [
                            +markItem['data-x'] + translateX,
                            +markItem['data-x'] + translateX,
                            +markItem['data-x'] + translateX,
                            +markItem['data-y'] + translateY,
                            +markItem['data-y'] + translateY + +markItem['data-height'] / 2,
                            +markItem['data-y'] + translateY + +markItem['data-height']
                        ];
                    default:
                        return [
                            +markItem['data-x'] + translateX,
                            +markItem['data-x'] + translateX + +markItem['data-width'] / 2,
                            +markItem['data-x'] + translateX + +markItem['data-width'],
                            +markItem['data-y'] + translateY,
                            +markItem['data-y'] + translateY + +markItem['data-height'] / 2,
                            +markItem['data-y'] + translateY + +markItem['data-height']
                        ];
                }
            case 'path':
                // console.log('we are getting path bounds', markItem);
                return +markItem['data-fake-x']
                    ? [
                        +markItem['data-fake-x'] + translateX - (+markItem['data-r'] || 0),
                        +markItem['data-fake-x'] + translateX,
                        +markItem['data-fake-x'] + translateX + (+markItem['data-r'] || 0),
                        +markItem['data-fake-y'] + translateY - (+markItem['data-r'] || 0),
                        +markItem['data-fake-y'] + translateY,
                        +markItem['data-fake-y'] + translateY + (+markItem['data-r'] || 0)
                    ]
                    : +markItem['data-centerX1']
                        ? [
                            +markItem['data-centerX1'] + translateX,
                            +markItem['data-centerX1'] + (+markItem['data-centerX2'] - +markItem['data-centerX1']) / 2 + translateX,
                            +markItem['data-centerX2'] + translateX,
                            +markItem['data-centerY1'] + translateY,
                            +markItem['data-centerY1'] + (+markItem['data-centerY2'] - +markItem['data-centerY1']) / 2 + translateY,
                            +markItem['data-centerY2'] + translateY
                        ]
                        : [
                            +markItem['data-x'] + translateX - (+markItem['data-r'] || 0),
                            +markItem['data-x'] + translateX,
                            +markItem['data-x'] + translateX + (+markItem['data-r'] || 0),
                            +markItem['data-y'] + translateY - (+markItem['data-r'] || 0),
                            +markItem['data-y'] + translateY,
                            +markItem['data-y'] + translateY + (+markItem['data-r'] || 0)
                        ];
            default:
                // we should not really be hitting default with anything at this point
                return [
                    +markItem['data-x'] + translateX,
                    +markItem['data-x'] + translateX + +markItem['data-width'] / 2,
                    +markItem['data-x'] + translateX + +markItem['data-width'],
                    +markItem['data-y'] + translateY,
                    +markItem['data-y'] + translateY + +markItem['data-height'] / 2,
                    +markItem['data-y'] + translateY + +markItem['data-height']
                ];
            // remove bbox from algorithm because it is slow and we don't need it
            // return [
            //   bbox.x,
            //   bbox.x + bbox.width / 2.0,
            //   bbox.x + bbox.width,
            //   bbox.y,
            //   bbox.y + bbox.height / 2.0,
            //   bbox.y + bbox.height
            // ];
        }
    };

    /**
     * Copyright (c) 2020, 2021, 2022 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    function formatDataLabel(d, labelAccessor, format, normalized) {
        var modifier = normalized ? d.getSum() : 1;
        return format
            ? formatStats(d[labelAccessor] / modifier, format === 'normalized' ? '0[.][0]%' : format)
            : d[labelAccessor] / modifier;
    }
    var placeDataLabels = function (_a) {
        var root = _a.root, xScale = _a.xScale, yScale = _a.yScale, sizeScale = _a.sizeScale, ordinalAccessor = _a.ordinalAccessor, valueAccessor = _a.valueAccessor, groupAccessor = _a.groupAccessor, sizeAccessor = _a.sizeAccessor, shapeArea = _a.shapeArea, placement = _a.placement, layout = _a.layout, labelOffset = _a.labelOffset, radius = _a.radius, chartType = _a.chartType, normalized = _a.normalized, avoidCollision = _a.avoidCollision;
        var xPlacement;
        var yPlacement;
        var offset;
        var offset2;
        var textAnchor;
        // console.log('placing data labels', root.size(), avoidCollision, placement);
        if (chartType === 'bar') {
            switch (placement) {
                case 'auto':
                    if (layout === 'vertical') {
                        xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                        yPlacement = function (d) { return yScale(Math.max(0, d[valueAccessor])); };
                        offset2 = '0.25em';
                        textAnchor = 'middle';
                    }
                    else if (layout === 'horizontal') {
                        yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2; };
                        xPlacement = function (d) { return xScale(Math.max(0, d[valueAccessor])); };
                        offset2 = '0.25em';
                        textAnchor = 'middle';
                    }
                    break;
                case 'top':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                    yPlacement = function (d) { return yScale(Math.max(0, d[valueAccessor])); };
                    offset = '-.3em';
                    textAnchor = 'middle';
                    break;
                case 'bottom':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                    yPlacement = function (d) { return yScale(Math.min(0, d[valueAccessor])); };
                    offset = '-.3em';
                    textAnchor = 'middle';
                    break;
                case 'left':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2; };
                    xPlacement = function (d) { return xScale(Math.min(0, d[valueAccessor])); };
                    offset = '.2em';
                    offset2 = '.3em';
                    textAnchor = 'start';
                    break;
                case 'right':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2; };
                    xPlacement = function (d) { return xScale(Math.max(0, d[valueAccessor])); };
                    offset = '.3em';
                    offset2 = '.3em';
                    textAnchor = 'start';
                    break;
                case 'top-left':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]); };
                    xPlacement = function (d) { return xScale(Math.min(0, d[valueAccessor])); };
                    offset = '.2em';
                    offset2 = '-.2em';
                    textAnchor = 'start';
                    break;
                case 'top-right':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]); };
                    xPlacement = function (d) { return xScale(Math.max(0, d[valueAccessor])); };
                    offset = '-3em';
                    offset2 = '-.2em';
                    textAnchor = 'start';
                    break;
                case 'bottom-left':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth(); };
                    xPlacement = function (d) { return xScale(Math.min(0, d[valueAccessor])); };
                    offset = '.2em';
                    offset2 = '1em';
                    textAnchor = 'start';
                    break;
                case 'bottom-right':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth(); };
                    xPlacement = function (d) { return xScale(Math.max(0, d[valueAccessor])); };
                    offset = '-3em';
                    offset2 = '1em';
                    textAnchor = 'start';
                    break;
            }
        }
        else if (chartType === 'stacked') {
            var getMod_1 = function (d) { return (normalized ? d.getSum() : 1); };
            if (layout === 'vertical') {
                switch (placement) {
                    case 'auto':
                        xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                        yPlacement = function (d) { return (yScale(d.stackStart / getMod_1(d)) + yScale(d.stackEnd / getMod_1(d))) / 2; };
                        offset2 = '0.25em';
                        textAnchor = 'middle';
                        break;
                    case 'bottom':
                        xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                        yPlacement = function (d) { return yScale(d.stackEnd / getMod_1(d)); };
                        offset = '-.3em';
                        textAnchor = 'middle';
                        break;
                    case 'top':
                        xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                        yPlacement = function (d) { return yScale(d.stackStart / getMod_1(d)); };
                        offset = '1em';
                        textAnchor = 'middle';
                        break;
                    case 'middle':
                        xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
                        yPlacement = function (d) { return (yScale(d.stackStart / getMod_1(d)) + yScale(d.stackEnd / getMod_1(d))) / 2; };
                        offset = '.3em';
                        textAnchor = 'middle';
                        break;
                }
            }
            else {
                switch (placement) {
                    case 'auto':
                        yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2 + 4; };
                        xPlacement = function (d) { return (xScale(d.stackStart) + xScale(d.stackEnd)) / 2; };
                        offset = '0em';
                        textAnchor = 'middle';
                        break;
                    case 'base':
                        yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2 + 4; };
                        xPlacement = function (d) { return (d.stackEnd < 0 ? xScale(d.stackStart / getMod_1(d)) : xScale(d.stackEnd / getMod_1(d))); };
                        offset = function (d) { return (d.stackEnd < 0 ? '-.3em' : '.3em'); };
                        textAnchor = function (d) { return (d.stackEnd < 0 ? 'end' : 'start'); };
                        break;
                    case 'end':
                        yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2 + 4; };
                        xPlacement = function (d) { return (d.stackEnd < 0 ? xScale(d.stackEnd / getMod_1(d)) : xScale(d.stackStart / getMod_1(d))); };
                        offset = function (d) { return (d.stackEnd < 0 ? '.3em' : '-.3em'); };
                        textAnchor = function (d) { return (d.stackEnd < 0 ? 'start' : 'end'); };
                        break;
                    case 'middle':
                        yPlacement = function (d) { return yScale(d[ordinalAccessor]) + yScale.bandwidth() / 2 + 4; };
                        xPlacement = function (d) { return (xScale(d.stackStart) + xScale(d.stackEnd)) / 2; };
                        offset = '0em';
                        textAnchor = 'middle';
                        break;
                }
            }
        }
        else if (chartType === 'line') {
            switch (placement) {
                case 'auto':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d[valueAccessor]); };
                    offset2 = '-0.6em';
                    textAnchor = 'middle';
                    break;
                case 'top':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d[valueAccessor]); };
                    offset2 = '-0.6em';
                    textAnchor = 'middle';
                    break;
                case 'bottom':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d[valueAccessor]) + 20; };
                    textAnchor = 'middle';
                    break;
                case 'left':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]); };
                    xPlacement = function (d) { return xScale(d[valueAccessor]); };
                    offset = '.2em';
                    textAnchor = 'start';
                    break;
                case 'right':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]); };
                    xPlacement = function (d) { return xScale(d[valueAccessor]) + 4; };
                    offset = '.2em';
                    textAnchor = 'start';
                    break;
            }
        }
        else if (chartType === 'parallel') {
            switch (placement) {
                case 'auto':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d); };
                    offset = '0em';
                    offset2 = '0em';
                    textAnchor = 'middle';
                    break;
                case 'bottom-right':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d); };
                    offset = '0.45em';
                    offset2 = '1.1em';
                    textAnchor = 'start';
                    break;
                case 'top-right':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d); };
                    offset = '0.45em';
                    offset2 = '-0.3em';
                    textAnchor = 'start';
                    break;
                case 'bottom-left':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d); };
                    offset = '-0.45em';
                    offset2 = '1.1em';
                    textAnchor = 'end';
                    break;
                case 'top-left':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d); };
                    offset = '-0.45em';
                    offset2 = '-0.3em';
                    textAnchor = 'end';
                    break;
            }
        }
        else if (chartType === 'dumbbell') {
            switch (placement) {
                case 'ends':
                    xPlacement = function (d) { return (layout === 'vertical' ? xScale(d[ordinalAccessor]) : xScale(d[valueAccessor]) - d.offset); };
                    yPlacement = function (d) { return (layout === 'vertical' ? yScale(d[valueAccessor]) + d.offset : yScale(d[ordinalAccessor])); };
                    offset = function (d) {
                        return layout === 'vertical' && d.offset >= 0
                            ? '0.9em'
                            : layout === 'vertical'
                                ? '-0.3em'
                                : d.offset >= 0
                                    ? '-0.3em'
                                    : '0.3em';
                    };
                    offset2 = layout === 'vertical' ? '0.0em' : '0.3em';
                    textAnchor = function (d) {
                        return layout === 'vertical' ? 'middle' : d.offset >= 0 ? 'end' : 'start';
                    };
                    break;
                case 'auto': // copy of ends for auto collision
                    xPlacement = function (d) { return (layout === 'vertical' ? xScale(d[ordinalAccessor]) : xScale(d[valueAccessor]) - d.offset); };
                    yPlacement = function (d) { return (layout === 'vertical' ? yScale(d[valueAccessor]) + d.offset : yScale(d[ordinalAccessor])); };
                    offset = function (d) {
                        return layout === 'vertical' && d.offset >= 0
                            ? '0.9em'
                            : layout === 'vertical'
                                ? '-0.3em'
                                : d.offset >= 0
                                    ? '-0.3em'
                                    : '0.3em';
                    };
                    offset2 = layout === 'vertical' ? '0.0em' : '0.3em';
                    textAnchor = function (d) {
                        return layout === 'vertical' ? 'middle' : d.offset >= 0 ? 'end' : 'start';
                    };
                    break;
                case 'top':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]) - Math.abs(d.offset); };
                    xPlacement = function (d) { return xScale(d[valueAccessor]); };
                    offset2 = '-0.3em'; // d => -Math.abs(d.offset);
                    offset = '0.0em';
                    textAnchor = 'middle';
                    break;
                case 'bottom':
                    yPlacement = function (d) { return yScale(d[ordinalAccessor]) + Math.abs(d.offset); };
                    xPlacement = function (d) { return xScale(d[valueAccessor]) + 4; };
                    offset2 = '0.9em'; // d => Math.abs(d.offset);
                    offset = '0.0em';
                    textAnchor = 'middle';
                    break;
                case 'left':
                    yPlacement = function (d) { return yScale(d[valueAccessor]); };
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]) - 4 - Math.abs(d.offset); };
                    offset2 = '0.0em'; // d => -Math.abs(d.offset);
                    offset = '0.3em';
                    textAnchor = 'end';
                    break;
                case 'right':
                    yPlacement = function (d) { return yScale(d[valueAccessor]); };
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]) + 4 + Math.abs(d.offset); };
                    offset2 = '0.0em'; // d => Math.abs(d.offset);
                    offset = '0.3em';
                    textAnchor = 'start';
                    break;
            }
        }
        else if (chartType === 'pie') {
            switch (placement) {
                case 'inside':
                    offset2 = '0.1em';
                    textAnchor = 'middle';
                    break;
                case 'outside':
                    textAnchor = function (d, i) { return (d.endAngle < Math.PI || i === 0 ? 'start' : 'end'); };
                    xPlacement = function (d) { return (radius + 5) * Math.sin((d.startAngle + d.endAngle) / 2); };
                    yPlacement = function (d) { return -(radius + 5) * Math.cos((d.startAngle + d.endAngle) / 2); };
                    offset = function (d) { return (d.endAngle < Math.PI ? -labelOffset : labelOffset); };
                    offset2 = function (d) { return (d.endAngle < Math.PI ? labelOffset : -labelOffset); };
                    break;
                case 'edge':
                    xPlacement = function (d) { return (radius + 10) * Math.sin(d.endAngle); };
                    yPlacement = function (d) { return -(radius + 10) * Math.cos(d.endAngle); };
                    offset = function (d) { return (d.endAngle < Math.PI ? -labelOffset : labelOffset); };
                    offset2 = function (d) { return (d.endAngle < Math.PI ? labelOffset : -labelOffset); };
                    textAnchor = function (d, i) { return (d.endAngle < Math.PI || i === 0 ? 'start' : 'end'); };
                    break;
                case 'note':
                    textAnchor = function (d, i) { return (d.endAngle < Math.PI || i === 0 ? 'start' : 'end'); };
                    xPlacement = function (d) { return (radius + 5) * Math.sin((d.startAngle + d.endAngle) / 2); };
                    yPlacement = function (d) { return -(radius + 5) * Math.cos((d.startAngle + d.endAngle) / 2); };
                    offset = function (d) { return (d.endAngle < Math.PI ? -labelOffset : labelOffset); };
                    offset2 = function (d) { return (d.endAngle < Math.PI ? labelOffset + 15 : -labelOffset + 15); };
                    break;
                case 'note_edge':
                    xPlacement = function (d) { return (radius + 10) * Math.sin(d.endAngle); };
                    yPlacement = function (d) { return -(radius + 10) * Math.cos(d.endAngle); };
                    offset = function (d) { return (d.endAngle < Math.PI ? -labelOffset : labelOffset); };
                    offset2 = function (d) { return (d.endAngle < Math.PI ? labelOffset + 15 : -labelOffset + 15); };
                    textAnchor = function (d, i) { return (d.endAngle < Math.PI || i === 0 ? 'start' : 'end'); };
                    break;
            }
        }
        else if (chartType === 'scatter') {
            var offsetScale_1 = sqrt()
                .domain([sizeScale.domain()[0], sizeScale.domain()[1]])
                .range([1, 4]);
            var shape_1 = function (d) { return shapeArea[groupAccessor ? d[groupAccessor] : '']['shape']; };
            var shapeOffset_1 = function (d) {
                return sizeScale(d[sizeAccessor] * shapeArea[groupAccessor ? d[groupAccessor] : '']['toCircle']) || labelOffset;
            };
            switch (placement) {
                case 'auto':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d[valueAccessor]); };
                    offset2 = '0.25em';
                    textAnchor = 'middle';
                    break;
                case 'middle':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d[valueAccessor]); };
                    offset2 = '0.25em';
                    textAnchor = 'middle';
                    break;
                case 'top':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d[valueAccessor]) - shapeOffset_1(d); };
                    offset2 = function (d) {
                        return ['diamond', 'triangle', 'star'].includes(shape_1(d)) && sizeAccessor
                            ? -1 * (0.35 + 0.35 * offsetScale_1(d[sizeAccessor])) + "em"
                            : '-0.35em';
                    };
                    textAnchor = 'middle';
                    break;
                case 'bottom':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]); };
                    yPlacement = function (d) { return yScale(d[valueAccessor]) + shapeOffset_1(d); };
                    offset2 = function (d) {
                        return shape_1(d) === 'diamond' && sizeAccessor
                            ? 0.75 + 0.5 * offsetScale_1(d[sizeAccessor]) + "em"
                            : shape_1(d) === 'triangle' && sizeAccessor
                                ? 1.1 - 0.2 * offsetScale_1(d[sizeAccessor]) + "em"
                                : '1.1em';
                    };
                    textAnchor = 'middle';
                    break;
                case 'left':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]) - shapeOffset_1(d); };
                    yPlacement = function (d) { return yScale(d[valueAccessor]); };
                    offset = function (d) { return (shape_1(d) === 'diamond' && sizeAccessor ? '-.2em' : '-.4em'); };
                    offset2 = '0.3em';
                    textAnchor = 'end';
                    break;
                case 'right':
                    xPlacement = function (d) { return xScale(d[ordinalAccessor]) + shapeOffset_1(d); };
                    yPlacement = function (d) { return yScale(d[valueAccessor]); };
                    offset = function (d) { return (shape_1(d) === 'diamond' && sizeAccessor ? '.125em' : '.35em'); };
                    offset2 = '0.3em';
                    textAnchor = 'start';
                    break;
            }
        }
        else if (chartType === 'heat-map') {
            xPlacement = function (d) { return xScale(d[ordinalAccessor]) + xScale.bandwidth() / 2; };
            yPlacement = function (d) { return yScale(d[valueAccessor]) + yScale.bandwidth() / 2; };
            offset2 = '.5em';
            textAnchor = 'middle';
        }
        else if (chartType === 'world-map') {
            xPlacement = function (d) { return xScale([+d[ordinalAccessor], +d[valueAccessor]])[0]; };
            yPlacement = function (d) { return xScale([+d[ordinalAccessor], +d[valueAccessor]])[1]; };
        }
        // we run bitmap if passed, not heat-map and whether we pass "auto" OR hideOnly with reg placement
        var autoPlacementIndicator = avoidCollision && avoidCollision.runOccupancyBitmap && placement === 'auto';
        var hideNoPlaceIndicator = avoidCollision && avoidCollision.hideOnly && !autoPlacementIndicator;
        if (chartType !== 'heat-map' && autoPlacementIndicator && !hideNoPlaceIndicator) {
            var bitmaps = resolveLabelCollision({
                bitmaps: avoidCollision.bitmaps,
                labelSelection: avoidCollision.labelSelection,
                avoidMarks: avoidCollision.avoidMarks,
                validPositions: avoidCollision.validPositions,
                offsets: avoidCollision.offsets,
                accessors: avoidCollision.accessors,
                size: avoidCollision.size,
                boundsScope: avoidCollision.boundsScope,
                hideOnly: hideNoPlaceIndicator,
                removeOnly: avoidCollision.removeOnly,
                suppressMarkDraw: avoidCollision.suppressMarkDraw
            });
            // now that the collision check is done we apply original placement to anything hidden (not placed) by it
            // this is needed because the marks will otherwise be placed at [0, 0], this util is expected to place them
            // checking for data-label-hidden !== false will capture anything that didn't go through collision and/or
            // was hidden by it, though we need to ignore this if we are in the setLabelOpacity interaction updates
            // thus we use the class temporarily added to each label to handle that
            // update during label interaction updates, we are excluding hidden labels that we moved from this now as well
            root
                .filter(function (_, i, n) { return select(n[i]).attr('data-label-moved') !== 'true' && !select(n[i]).classed('collision-added'); })
                .attr('x', xPlacement)
                .attr('y', yPlacement)
                .attr(layout === 'vertical' ? 'dy' : 'dx', offset)
                .attr(layout === 'vertical' ? 'dx' : 'dy', offset2)
                .attr('text-anchor', textAnchor);
            return bitmaps;
        }
        else if (chartType !== 'heat-map' && hideNoPlaceIndicator) {
            root.each(function (_, i, n) {
                // doing an each.select will make sure we jump the transition passed in
                // in our mark item bounds we need to pass the result of original dataLabel util
                select(n[i])
                    .attr('data-x', xPlacement)
                    .attr('data-use-dx', true)
                    .attr('dx', layout === 'vertical' ? offset2 : offset)
                    .attr('data-y', yPlacement)
                    .attr('data-use-dy', true)
                    .attr('dy', layout === 'vertical' ? offset : offset2)
                    .attr('text-anchor', textAnchor);
            });
            // next we draw the bitmap with only the marks
            var bitmaps = void 0;
            if (!avoidCollision.suppressMarkDraw) {
                bitmaps = resolveLabelCollision({
                    bitmaps: avoidCollision.bitmaps,
                    labelSelection: select('.empty-stuff-vcc-do-not-use'),
                    avoidMarks: avoidCollision.avoidMarks,
                    validPositions: ['middle'],
                    offsets: [1],
                    accessors: avoidCollision.accessors,
                    size: avoidCollision.size
                });
            }
            // next we try to place labels based on the util placed positions
            bitmaps = resolveLabelCollision({
                bitmaps: bitmaps || avoidCollision.bitmaps,
                labelSelection: root,
                avoidMarks: [],
                validPositions: ['middle'],
                offsets: [1],
                accessors: avoidCollision.accessors,
                size: avoidCollision.size,
                hideOnly: hideNoPlaceIndicator,
                removeOnly: avoidCollision.removeOnly,
                suppressMarkDraw: avoidCollision.suppressMarkDraw
            });
            // hideOnly is passed, we need to place everything as we usually would
            root
                .attr('x', xPlacement)
                .attr('y', yPlacement)
                .attr(layout === 'vertical' ? 'dy' : 'dx', offset)
                .attr(layout === 'vertical' ? 'dx' : 'dy', offset2)
                .attr('text-anchor', textAnchor);
            return bitmaps;
        }
        else {
            // NOTE: heatmap has shortcut collision detection already for labels
            // (the accessibility.showSmallLabels prop handles this automatically and more efficiently due to the algorithmic concerns)
            root
                .attr('x', xPlacement)
                .attr('y', yPlacement)
                .attr(layout === 'vertical' ? 'dy' : 'dx', offset)
                .attr(layout === 'vertical' ? 'dx' : 'dy', offset2)
                .attr('text-anchor', textAnchor);
            return null;
        }
    };
    function getDataSymbol(symbolFunc, symbolType) {
        var symbolMap = {
            cross: symbolCross,
            circle: symbolCircle,
            square: symbolSquare,
            star: symbolStar,
            triangle: symbolTriangle,
            diamond: symbolDiamond
        };
        return symbolMap[symbolType] ? symbolFunc.type(symbolMap[symbolType])() : symbolFunc.type(symbolCircle)();
    }

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var formatDate = function (_a) {
        var date = _a.date, format = _a.format, offsetTimezone = _a.offsetTimezone;
        var userTimezoneOffset = offsetTimezone ? date.getTimezoneOffset() * 60000 : 0;
        var offsetDate = new Date(date.getTime() + userTimezoneOffset);
        format = format.includes('%') ? format : '%Y %b';
        var formatedDate = timeFormat(format)(offsetDate);
        return formatedDate;
    };

    var noop = { value: function () { } };
    function dispatch() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
            if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t))
                throw new Error("illegal type: " + t);
            _[t] = [];
        }
        return new Dispatch(_);
    }
    function Dispatch(_) {
        this._ = _;
    }
    function parseTypenames$1(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            if (t && !types.hasOwnProperty(t))
                throw new Error("unknown type: " + t);
            return { type: t, name: name };
        });
    }
    Dispatch.prototype = dispatch.prototype = {
        constructor: Dispatch,
        on: function (typename, callback) {
            var _ = this._, T = parseTypenames$1(typename + "", _), t, i = -1, n = T.length;
            // If no callback was specified, return the callback of the given type and name.
            if (arguments.length < 2) {
                while (++i < n)
                    if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name)))
                        return t;
                return;
            }
            // If a type was specified, set the callback for the given type and name.
            // Otherwise, if a null callback was specified, remove callbacks of the given name.
            if (callback != null && typeof callback !== "function")
                throw new Error("invalid callback: " + callback);
            while (++i < n) {
                if (t = (typename = T[i]).type)
                    _[t] = set$1(_[t], typename.name, callback);
                else if (callback == null)
                    for (t in _)
                        _[t] = set$1(_[t], typename.name, null);
            }
            return this;
        },
        copy: function () {
            var copy = {}, _ = this._;
            for (var t in _)
                copy[t] = _[t].slice();
            return new Dispatch(copy);
        },
        call: function (type, that) {
            if ((n = arguments.length - 2) > 0)
                for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                    args[i] = arguments[i + 2];
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        },
        apply: function (type, that, args) {
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        }
    };
    function get(type, name) {
        for (var i = 0, n = type.length, c; i < n; ++i) {
            if ((c = type[i]).name === name) {
                return c.value;
            }
        }
    }
    function set$1(type, name, callback) {
        for (var i = 0, n = type.length; i < n; ++i) {
            if (type[i].name === name) {
                type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
                break;
            }
        }
        if (callback != null)
            type.push({ name: name, value: callback });
        return type;
    }

    var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) { setTimeout(f, 17); };
    function now() {
        return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }
    function clearNow() {
        clockNow = 0;
    }
    function Timer() {
        this._call =
            this._time =
                this._next = null;
    }
    Timer.prototype = timer.prototype = {
        constructor: Timer,
        restart: function (callback, delay, time) {
            if (typeof callback !== "function")
                throw new TypeError("callback is not a function");
            time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
            if (!this._next && taskTail !== this) {
                if (taskTail)
                    taskTail._next = this;
                else
                    taskHead = this;
                taskTail = this;
            }
            this._call = callback;
            this._time = time;
            sleep();
        },
        stop: function () {
            if (this._call) {
                this._call = null;
                this._time = Infinity;
                sleep();
            }
        }
    };
    function timer(callback, delay, time) {
        var t = new Timer;
        t.restart(callback, delay, time);
        return t;
    }
    function timerFlush() {
        now(); // Get the current time, if not already set.
        ++frame; // Pretend we’ve set an alarm, if we haven’t already.
        var t = taskHead, e;
        while (t) {
            if ((e = clockNow - t._time) >= 0)
                t._call.call(null, e);
            t = t._next;
        }
        --frame;
    }
    function wake() {
        clockNow = (clockLast = clock.now()) + clockSkew;
        frame = timeout = 0;
        try {
            timerFlush();
        }
        finally {
            frame = 0;
            nap();
            clockNow = 0;
        }
    }
    function poke() {
        var now = clock.now(), delay = now - clockLast;
        if (delay > pokeDelay)
            clockSkew -= delay, clockLast = now;
    }
    function nap() {
        var t0, t1 = taskHead, t2, time = Infinity;
        while (t1) {
            if (t1._call) {
                if (time > t1._time)
                    time = t1._time;
                t0 = t1, t1 = t1._next;
            }
            else {
                t2 = t1._next, t1._next = null;
                t1 = t0 ? t0._next = t2 : taskHead = t2;
            }
        }
        taskTail = t0;
        sleep(time);
    }
    function sleep(time) {
        if (frame)
            return; // Soonest alarm already set, or will be.
        if (timeout)
            timeout = clearTimeout(timeout);
        var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
        if (delay > 24) {
            if (time < Infinity)
                timeout = setTimeout(wake, time - clock.now() - clockSkew);
            if (interval)
                interval = clearInterval(interval);
        }
        else {
            if (!interval)
                clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
            frame = 1, setFrame(wake);
        }
    }

    function timeout$1 (callback, delay, time) {
        var t = new Timer;
        delay = delay == null ? 0 : +delay;
        t.restart(function (elapsed) {
            t.stop();
            callback(elapsed + delay);
        }, delay, time);
        return t;
    }

    var emptyOn = dispatch("start", "end", "interrupt");
    var emptyTween = [];
    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;
    function schedule (node, name, id, index, group, timing) {
        var schedules = node.__transition;
        if (!schedules)
            node.__transition = {};
        else if (id in schedules)
            return;
        create(node, id, {
            name: name,
            index: index,
            group: group,
            on: emptyOn,
            tween: emptyTween,
            time: timing.time,
            delay: timing.delay,
            duration: timing.duration,
            ease: timing.ease,
            timer: null,
            state: CREATED
        });
    }
    function init(node, id) {
        var schedule = get$1(node, id);
        if (schedule.state > CREATED)
            throw new Error("too late; already scheduled");
        return schedule;
    }
    function set$2(node, id) {
        var schedule = get$1(node, id);
        if (schedule.state > STARTING)
            throw new Error("too late; already started");
        return schedule;
    }
    function get$1(node, id) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id]))
            throw new Error("transition not found");
        return schedule;
    }
    function create(node, id, self) {
        var schedules = node.__transition, tween;
        // Initialize the self timer when the transition is created.
        // Note the actual delay is not known until the first callback!
        schedules[id] = self;
        self.timer = timer(schedule, 0, self.time);
        function schedule(elapsed) {
            self.state = SCHEDULED;
            self.timer.restart(start, self.delay, self.time);
            // If the elapsed delay is less than our first sleep, start immediately.
            if (self.delay <= elapsed)
                start(elapsed - self.delay);
        }
        function start(elapsed) {
            var i, j, n, o;
            // If the state is not SCHEDULED, then we previously errored on start.
            if (self.state !== SCHEDULED)
                return stop();
            for (i in schedules) {
                o = schedules[i];
                if (o.name !== self.name)
                    continue;
                // While this element already has a starting transition during this frame,
                // defer starting an interrupting transition until that transition has a
                // chance to tick (and possibly end); see d3/d3-transition#54!
                if (o.state === STARTED)
                    return timeout$1(start);
                // Interrupt the active transition, if any.
                // Dispatch the interrupt event.
                if (o.state === RUNNING) {
                    o.state = ENDED;
                    o.timer.stop();
                    o.on.call("interrupt", node, node.__data__, o.index, o.group);
                    delete schedules[i];
                }
                // Cancel any pre-empted transitions. No interrupt event is dispatched
                // because the cancelled transitions never started. Note that this also
                // removes this transition from the pending list!
                else if (+i < id) {
                    o.state = ENDED;
                    o.timer.stop();
                    delete schedules[i];
                }
            }
            // Defer the first tick to end of the current frame; see d3/d3#1576.
            // Note the transition may be canceled after start and before the first tick!
            // Note this must be scheduled before the start event; see d3/d3-transition#16!
            // Assuming this is successful, subsequent callbacks go straight to tick.
            timeout$1(function () {
                if (self.state === STARTED) {
                    self.state = RUNNING;
                    self.timer.restart(tick, self.delay, self.time);
                    tick(elapsed);
                }
            });
            // Dispatch the start event.
            // Note this must be done before the tween are initialized.
            self.state = STARTING;
            self.on.call("start", node, node.__data__, self.index, self.group);
            if (self.state !== STARTING)
                return; // interrupted
            self.state = STARTED;
            // Initialize the tween, deleting null tween.
            tween = new Array(n = self.tween.length);
            for (i = 0, j = -1; i < n; ++i) {
                if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
                    tween[++j] = o;
                }
            }
            tween.length = j + 1;
        }
        function tick(elapsed) {
            var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n = tween.length;
            while (++i < n) {
                tween[i].call(null, t);
            }
            // Dispatch the end event.
            if (self.state === ENDING) {
                self.on.call("end", node, node.__data__, self.index, self.group);
                stop();
            }
        }
        function stop() {
            self.state = ENDED;
            self.timer.stop();
            delete schedules[id];
            for (var i in schedules)
                return; // eslint-disable-line no-unused-vars
            delete node.__transition;
        }
    }

    function interrupt (node, name) {
        var schedules = node.__transition, schedule, active, empty = true, i;
        if (!schedules)
            return;
        name = name == null ? null : name + "";
        for (i in schedules) {
            if ((schedule = schedules[i]).name !== name) {
                empty = false;
                continue;
            }
            active = schedule.state > STARTING && schedule.state < ENDING;
            schedule.state = ENDED;
            schedule.timer.stop();
            if (active)
                schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
            delete schedules[i];
        }
        if (empty)
            delete node.__transition;
    }

    function selection_interrupt (name) {
        return this.each(function () {
            interrupt(this, name);
        });
    }

    function tweenRemove(id, name) {
        var tween0, tween1;
        return function () {
            var schedule = set$2(this, id), tween = schedule.tween;
            // If this node shared tween with the previous node,
            // just assign the updated shared tween and we’re done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = tween0 = tween;
                for (var i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1 = tween1.slice();
                        tween1.splice(i, 1);
                        break;
                    }
                }
            }
            schedule.tween = tween1;
        };
    }
    function tweenFunction(id, name, value) {
        var tween0, tween1;
        if (typeof value !== "function")
            throw new Error;
        return function () {
            var schedule = set$2(this, id), tween = schedule.tween;
            // If this node shared tween with the previous node,
            // just assign the updated shared tween and we’re done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = (tween0 = tween).slice();
                for (var t = { name: name, value: value }, i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1[i] = t;
                        break;
                    }
                }
                if (i === n)
                    tween1.push(t);
            }
            schedule.tween = tween1;
        };
    }
    function transition_tween (name, value) {
        var id = this._id;
        name += "";
        if (arguments.length < 2) {
            var tween = get$1(this.node(), id).tween;
            for (var i = 0, n = tween.length, t; i < n; ++i) {
                if ((t = tween[i]).name === name) {
                    return t.value;
                }
            }
            return null;
        }
        return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }
    function tweenValue(transition, name, value) {
        var id = transition._id;
        transition.each(function () {
            var schedule = set$2(this, id);
            (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
        });
        return function (node) {
            return get$1(node, id).value[name];
        };
    }

    function interpolate$1 (a, b) {
        var c;
        return (typeof b === "number" ? interpolateNumber
            : b instanceof color ? interpolateRgb
                : (c = color(b)) ? (b = c, interpolateRgb)
                    : interpolateString)(a, b);
    }

    function attrRemove$1(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS$1(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant$1(name, interpolate, value1) {
        var value00, interpolate0;
        return function () {
            var value0 = this.getAttribute(name);
            return value0 === value1 ? null
                : value0 === value00 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value1);
        };
    }
    function attrConstantNS$1(fullname, interpolate, value1) {
        var value00, interpolate0;
        return function () {
            var value0 = this.getAttributeNS(fullname.space, fullname.local);
            return value0 === value1 ? null
                : value0 === value00 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value1);
        };
    }
    function attrFunction$1(name, interpolate, value) {
        var value00, value10, interpolate0;
        return function () {
            var value0, value1 = value(this);
            if (value1 == null)
                return void this.removeAttribute(name);
            value0 = this.getAttribute(name);
            return value0 === value1 ? null
                : value0 === value00 && value1 === value10 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value10 = value1);
        };
    }
    function attrFunctionNS$1(fullname, interpolate, value) {
        var value00, value10, interpolate0;
        return function () {
            var value0, value1 = value(this);
            if (value1 == null)
                return void this.removeAttributeNS(fullname.space, fullname.local);
            value0 = this.getAttributeNS(fullname.space, fullname.local);
            return value0 === value1 ? null
                : value0 === value00 && value1 === value10 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value10 = value1);
        };
    }
    function transition_attr (name, value) {
        var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
        return this.attrTween(name, typeof value === "function"
            ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)(fullname, i, tweenValue(this, "attr." + name, value))
            : value == null ? (fullname.local ? attrRemoveNS$1 : attrRemove$1)(fullname)
                : (fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, i, value + ""));
    }

    function attrTweenNS(fullname, value) {
        function tween() {
            var node = this, i = value.apply(node, arguments);
            return i && function (t) {
                node.setAttributeNS(fullname.space, fullname.local, i(t));
            };
        }
        tween._value = value;
        return tween;
    }
    function attrTween(name, value) {
        function tween() {
            var node = this, i = value.apply(node, arguments);
            return i && function (t) {
                node.setAttribute(name, i(t));
            };
        }
        tween._value = value;
        return tween;
    }
    function transition_attrTween (name, value) {
        var key = "attr." + name;
        if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        var fullname = namespace(name);
        return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
        return function () {
            init(this, id).delay = +value.apply(this, arguments);
        };
    }
    function delayConstant(id, value) {
        return value = +value, function () {
            init(this, id).delay = value;
        };
    }
    function transition_delay (value) {
        var id = this._id;
        return arguments.length
            ? this.each((typeof value === "function"
                ? delayFunction
                : delayConstant)(id, value))
            : get$1(this.node(), id).delay;
    }

    function durationFunction(id, value) {
        return function () {
            set$2(this, id).duration = +value.apply(this, arguments);
        };
    }
    function durationConstant(id, value) {
        return value = +value, function () {
            set$2(this, id).duration = value;
        };
    }
    function transition_duration (value) {
        var id = this._id;
        return arguments.length
            ? this.each((typeof value === "function"
                ? durationFunction
                : durationConstant)(id, value))
            : get$1(this.node(), id).duration;
    }

    function easeConstant(id, value) {
        if (typeof value !== "function")
            throw new Error;
        return function () {
            set$2(this, id).ease = value;
        };
    }
    function transition_ease (value) {
        var id = this._id;
        return arguments.length
            ? this.each(easeConstant(id, value))
            : get$1(this.node(), id).ease;
    }

    function transition_filter (match) {
        if (typeof match !== "function")
            match = matcher(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge (transition) {
        if (transition._id !== this._id)
            throw new Error;
        for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
        return (name + "").trim().split(/^|\s+/).every(function (t) {
            var i = t.indexOf(".");
            if (i >= 0)
                t = t.slice(0, i);
            return !t || t === "start";
        });
    }
    function onFunction(id, name, listener) {
        var on0, on1, sit = start(name) ? init : set$2;
        return function () {
            var schedule = sit(this, id), on = schedule.on;
            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and we’re done!
            // Otherwise, copy-on-write.
            if (on !== on0)
                (on1 = (on0 = on).copy()).on(name, listener);
            schedule.on = on1;
        };
    }
    function transition_on (name, listener) {
        var id = this._id;
        return arguments.length < 2
            ? get$1(this.node(), id).on.on(name)
            : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
        return function () {
            var parent = this.parentNode;
            for (var i in this.__transition)
                if (+i !== id)
                    return;
            if (parent)
                parent.removeChild(this);
        };
    }
    function transition_remove () {
        return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select (select) {
        var name = this._name, id = this._id;
        if (typeof select !== "function")
            select = selector(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                    schedule(subgroup[i], name, id, i, subgroup, get$1(node, id));
                }
            }
        }
        return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll (select) {
        var name = this._name, id = this._id;
        if (typeof select !== "function")
            select = selectorAll(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    for (var children = select.call(node, node.__data__, i, group), child, inherit = get$1(node, id), k = 0, l = children.length; k < l; ++k) {
                        if (child = children[k]) {
                            schedule(child, name, id, k, children, inherit);
                        }
                    }
                    subgroups.push(children);
                    parents.push(node);
                }
            }
        }
        return new Transition(subgroups, parents, name, id);
    }

    var Selection$1 = selection.prototype.constructor;
    function transition_selection () {
        return new Selection$1(this._groups, this._parents);
    }

    function styleRemove$1(name, interpolate) {
        var value00, value10, interpolate0;
        return function () {
            var value0 = styleValue(this, name), value1 = (this.style.removeProperty(name), styleValue(this, name));
            return value0 === value1 ? null
                : value0 === value00 && value1 === value10 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value10 = value1);
        };
    }
    function styleRemoveEnd(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant$1(name, interpolate, value1) {
        var value00, interpolate0;
        return function () {
            var value0 = styleValue(this, name);
            return value0 === value1 ? null
                : value0 === value00 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value1);
        };
    }
    function styleFunction$1(name, interpolate, value) {
        var value00, value10, interpolate0;
        return function () {
            var value0 = styleValue(this, name), value1 = value(this);
            if (value1 == null)
                value1 = (this.style.removeProperty(name), styleValue(this, name));
            return value0 === value1 ? null
                : value0 === value00 && value1 === value10 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value10 = value1);
        };
    }
    function transition_style (name, value, priority) {
        var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
        return value == null ? this
            .styleTween(name, styleRemove$1(name, i))
            .on("end.style." + name, styleRemoveEnd(name))
            : this.styleTween(name, typeof value === "function"
                ? styleFunction$1(name, i, tweenValue(this, "style." + name, value))
                : styleConstant$1(name, i, value + ""), priority);
    }

    function styleTween(name, value, priority) {
        function tween() {
            var node = this, i = value.apply(node, arguments);
            return i && function (t) {
                node.style.setProperty(name, i(t), priority);
            };
        }
        tween._value = value;
        return tween;
    }
    function transition_styleTween (name, value, priority) {
        var key = "style." + (name += "");
        if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant$1(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction$1(value) {
        return function () {
            var value1 = value(this);
            this.textContent = value1 == null ? "" : value1;
        };
    }
    function transition_text (value) {
        return this.tween("text", typeof value === "function"
            ? textFunction$1(tweenValue(this, "text", value))
            : textConstant$1(value == null ? "" : value + ""));
    }

    function transition_transition () {
        var name = this._name, id0 = this._id, id1 = newId();
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    var inherit = get$1(node, id0);
                    schedule(node, name, id1, i, group, {
                        time: inherit.time + inherit.delay + inherit.duration,
                        delay: 0,
                        duration: inherit.duration,
                        ease: inherit.ease
                    });
                }
            }
        }
        return new Transition(groups, this._parents, name, id1);
    }

    var id = 0;
    function Transition(groups, parents, name, id) {
        this._groups = groups;
        this._parents = parents;
        this._name = name;
        this._id = id;
    }
    function transition(name) {
        return selection().transition(name);
    }
    function newId() {
        return ++id;
    }
    var selection_prototype = selection.prototype;
    Transition.prototype = transition.prototype = {
        constructor: Transition,
        select: transition_select,
        selectAll: transition_selectAll,
        filter: transition_filter,
        merge: transition_merge,
        selection: transition_selection,
        transition: transition_transition,
        call: selection_prototype.call,
        nodes: selection_prototype.nodes,
        node: selection_prototype.node,
        size: selection_prototype.size,
        empty: selection_prototype.empty,
        each: selection_prototype.each,
        on: transition_on,
        attr: transition_attr,
        attrTween: transition_attrTween,
        style: transition_style,
        styleTween: transition_styleTween,
        text: transition_text,
        remove: transition_remove,
        tween: transition_tween,
        delay: transition_delay,
        duration: transition_duration,
        ease: transition_ease
    };

    function cubicInOut(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    function circleIn(t) {
        return 1 - Math.sqrt(1 - t * t);
    }

    var defaultTiming = {
        time: null,
        delay: 0,
        duration: 250,
        ease: cubicInOut
    };
    function inherit(node, id) {
        var timing;
        while (!(timing = node.__transition) || !(timing = timing[id])) {
            if (!(node = node.parentNode)) {
                return defaultTiming.time = now(), defaultTiming;
            }
        }
        return timing;
    }
    function selection_transition (name) {
        var id, timing;
        if (name instanceof Transition) {
            id = name._id, name = name._name;
        }
        else {
            id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
        }
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    schedule(node, name, id, i, group, timing || inherit(node, id));
                }
            }
        }
        return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    /**
     * Copyright (c) 2020, 2021, 2022 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var buildTooltipContent = function (_a) {
        var data = _a.data, tooltipLabel = _a.tooltipLabel, xAxis = _a.xAxis, yAxis = _a.yAxis, dataLabel = _a.dataLabel, layout = _a.layout, ordinalAccessor = _a.ordinalAccessor, valueAccessor = _a.valueAccessor, xAccessor = _a.xAccessor, // equivalent to joinNameAccessor / markerNameAccessor in map and sourceAccessor in alluvial
        yAccessor = _a.yAccessor, // equivalent to joinAccessor / markerAccessor in map and targetAccessor in alluvial
        groupAccessor = _a.groupAccessor, // equivalent to seriesAccessor in line, dumbbell, parallel
        diffLabelDetails = _a.diffLabelDetails, normalized = _a.normalized, chartType = _a.chartType;
        // user assigned tooltipLabel
        if (tooltipLabel && tooltipLabel.labelAccessor.length > 0) {
            var labelStr_1 = '';
            tooltipLabel.labelAccessor.map(function (k, i) {
                var title = tooltipLabel.labelTitle && tooltipLabel.labelTitle[i] !== '' ? tooltipLabel.labelTitle[i] + ': ' : '';
                labelStr_1 += title + "<b>" + (tooltipLabel.format && tooltipLabel.format[i]
                    ? data[k] instanceof Date
                        ? formatDate({
                            date: data[k],
                            format: tooltipLabel.format[i],
                            offsetTimezone: true
                        })
                        : normalized && tooltipLabel.format[i] === 'normalized' // only for stacked-bar value
                            ? formatDataLabel(data, k, dataLabel.format, k === valueAccessor)
                            : !isNaN(parseFloat(data[k]))
                                ? formatStats(data[k], tooltipLabel.format[i])
                                : data[k]
                    : data[k]) + " </b><br/>";
            });
            labelStr_1.replace(',', '');
            return labelStr_1;
        }
        else {
            //default tooltip
            var defaultLabel = '';
            var firstTitle = xAxis && yAxis
                ? (layout === 'horizontal' ? yAxis.label : xAxis.label) || xAccessor || ordinalAccessor
                : ordinalAccessor;
            var secondTitle = xAxis && yAxis
                ? (layout === 'horizontal' ? xAxis.label : yAxis.label) || yAccessor || valueAccessor
                : valueAccessor;
            // bar, pie
            if (chartType === 'bar') {
                defaultLabel = "\n      <b>" + (groupAccessor ? data[groupAccessor] + '<br/>' : '') + " </b>\n      " + (capitalized(firstTitle) + ': <b>' + data[ordinalAccessor]) + " </b><br/> \n        " + (capitalized(secondTitle) + ':') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format) + "</b>";
            }
            // if we have normalized then we output percent and value
            else if (chartType === 'pie') {
                defaultLabel = "\n        " + (capitalized(firstTitle) + ': <b>' + data[ordinalAccessor]) + " </b><br/> \n        " + (normalized
                    ? capitalized(secondTitle) +
                        ' (%): <b>' +
                        formatDataLabel(data, valueAccessor, '0[.][0]%', normalized) +
                        '</b><br/>'
                    : '') + "\n        " + (capitalized(secondTitle) + ': ') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format === 'normalized' ? '0[.][0]a' : dataLabel.format) + "</b>\n      ";
            }
            // scatter-plot
            else if (chartType === 'scatter') {
                defaultLabel = "\n        <b>" + (groupAccessor ? data[groupAccessor] + '<br/>' : '') + " </b>\n        " + (capitalized(firstTitle) + ':') + " \n        <b>" + formatStats(data[xAccessor], xAxis.format || '') + " </b><br/>\n        " + (capitalized(secondTitle) + ':') + " \n        <b>" + formatStats(data[yAccessor], yAxis.format || '') + "</b>";
            }
            // line, parallel
            else if (chartType === 'line' || chartType === 'parallel') {
                defaultLabel = "\n        <b>" + (groupAccessor ? data[groupAccessor] + '<br/>' : '') + "</b>\n        " + (capitalized(firstTitle) + ':') + " \n        <b>" + (data[ordinalAccessor] instanceof Date
                    ? formatDate({
                        date: data[ordinalAccessor],
                        format: xAxis.format,
                        offsetTimezone: true
                    })
                    : data[ordinalAccessor]) + " </b><br/>\n        " + (capitalized(secondTitle) + ':') + " \n        <b>" + formatStats(data[valueAccessor], dataLabel.format || '') + "</b>";
            }
            // stacked-bar, clustered-bar
            else if (chartType === 'stacked' || chartType === 'clustered') {
                defaultLabel = "\n        <b>" + (data[groupAccessor] + '<br/>') + "</b>\n        " + (capitalized(firstTitle) + ':') + " \n        <b>" + data[ordinalAccessor] + " </b><br/> \n        " + (normalized
                    ? capitalized(secondTitle) +
                        ' (%): <b>' +
                        formatDataLabel(data, valueAccessor, '0[.][0]%', normalized) +
                        '</b><br/>'
                    : '') + "\n        " + (capitalized(secondTitle) + ': ') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format === 'normalized' ? '0[.][0]a' : dataLabel.format) + "</b>\n      ";
            }
            // heat-map
            else if (chartType === 'heat-map') {
                defaultLabel = "\n        " + (capitalized(firstTitle) + ':') + " \n        <b>" + (data[xAccessor] instanceof Date
                    ? formatDate({
                        date: data[xAccessor],
                        format: xAxis.format,
                        offsetTimezone: true
                    })
                    : data[xAccessor]) + " </b><br/>\n        " + (capitalized(secondTitle) + ':') + " \n        <b>" + (data[yAccessor] instanceof Date
                    ? formatDate({
                        date: data[yAccessor],
                        format: yAxis.format,
                        offsetTimezone: true
                    })
                    : data[yAccessor]) + " </b><br/>\n        " + (capitalized(valueAccessor) + ':') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format || '') + "</b>";
            }
            // circle-packing
            else if (chartType === 'circle-packing') {
                defaultLabel = "\n        <b>" + capitalized(data[ordinalAccessor]) + " </b><br/>\n        " + (capitalized(groupAccessor) + ': <b>' + data[groupAccessor]) + " </b><br/>\n        " + (capitalized(valueAccessor) + ':') + "\n        <b>" + formatStats(data[valueAccessor], dataLabel.format || '') + "</b>";
            }
            // world-map
            else if (chartType === 'world-map') {
                defaultLabel = "\n        <b>" + data[xAccessor] + " (" + data[yAccessor] + ") </b><br/>\n          " + valueAccessor + ": \n          <b>" + formatStats(data[valueAccessor], dataLabel.format || '') + "</b>";
            }
            // dumbbell
            else if (chartType === 'dumbbell') {
                if (data && data.key && data.values) {
                    defaultLabel =
                        "<b>\n          " + (data.values[0][ordinalAccessor] instanceof Date
                            ? formatDate({
                                date: data.values[0][ordinalAccessor],
                                format: xAxis.format,
                                offsetTimezone: true
                            })
                            : data.values[0][ordinalAccessor]) + " </b><br/>" +
                            'Difference: ' +
                            ("<b>" + (dataLabel.format
                                ? formatStats(data[diffLabelDetails.calculation], dataLabel.format)
                                : data[diffLabelDetails.calculation]) + " <br/></b>") +
                            data.values[0][groupAccessor] +
                            ': ' +
                            ("<b>" + (dataLabel.format
                                ? formatStats(data.values[0][valueAccessor], dataLabel.format)
                                : data.values[0][valueAccessor]) + " </b><br/>") +
                            data.values[1][groupAccessor] +
                            ': ' +
                            ("<b>" + (dataLabel.format
                                ? formatStats(data.values[1][valueAccessor], dataLabel.format)
                                : data.values[1][valueAccessor]) + "</b>\n        ");
                }
                else {
                    defaultLabel =
                        "<b>\n        " + (data[ordinalAccessor] instanceof Date
                            ? formatDate({
                                date: data[ordinalAccessor],
                                format: xAxis.format,
                                offsetTimezone: true
                            })
                            : data[ordinalAccessor]) + " </b><br/>" +
                            data[groupAccessor] +
                            ': ' +
                            ("<b>" + (dataLabel.format ? formatStats(data[valueAccessor], dataLabel.format) : data[valueAccessor]) + "</b>\n        ");
                }
            }
            // alluvial-diagram
            else if (chartType === 'alluvial-diagram') {
                defaultLabel = "\n      <b>" + capitalized(data[xAccessor]) + "</b> to <b>" + capitalized(data[yAccessor]) + " </b><br/>\n      " + (capitalized(valueAccessor) + ':') + "\n      <b>" + (dataLabel && dataLabel.format ? formatStats(data[valueAccessor], dataLabel.format) : data[valueAccessor]) + "</b>";
            }
            return defaultLabel;
        }
    };
    var overrideTitleTooltip = function (uniqueID, toRemove) {
        var paddingIdBegin = 'visa-viz-padding-container-g-';
        var paddingG = select("#" + paddingIdBegin + uniqueID);
        if (toRemove) {
            if (paddingG.select('title').size() === 0) {
                paddingG.append('title').text('');
            }
        }
        else {
            paddingG.select('title').remove();
        }
    };
    var initTooltipStyle = function (root) {
        root
            .style('position', 'absolute')
            .style('padding', '0.5rem')
            .style('opacity', 0)
            .style('background-color', '#ffffff')
            .style('font-size', '14px')
            .style('font-weight', '400')
            .style('color', '#222222')
            .style('border', '1px solid #565656')
            .style('border-radius', '3px')
            .style('pointer-events', 'none')
            .style('min-width', '80px')
            .style('max-width', '300px')
            .style('z-index', 10);
        root.append('p').style('margin', 0);
    };
    var drawTooltip = function (_a) {
        var root = _a.root, data = _a.data, event = _a.event, isToShow = _a.isToShow, tooltipLabel = _a.tooltipLabel, xAxis = _a.xAxis, yAxis = _a.yAxis, dataLabel = _a.dataLabel, layout = _a.layout, ordinalAccessor = _a.ordinalAccessor, valueAccessor = _a.valueAccessor, xAccessor = _a.xAccessor, // equivalent to joinNameAccessor / markerNameAccessor in map and sourceAccessor in alluvial
        yAccessor = _a.yAccessor, // equivalent to joinAccessor / markerAccessor in map and targetAccessor in alluvial
        groupAccessor = _a.groupAccessor, // equivalent to seriesAccessor in line, dumbbell, parallel,
        diffLabelDetails = _a.diffLabelDetails, normalized = _a.normalized, chartType = _a.chartType;
        var toShow = function () {
            var positions = [event.pageX, event.pageY];
            var tooltipContent = buildTooltipContent({
                data: data,
                tooltipLabel: tooltipLabel,
                xAxis: xAxis,
                yAxis: yAxis,
                dataLabel: dataLabel,
                layout: layout,
                ordinalAccessor: ordinalAccessor,
                valueAccessor: valueAccessor,
                xAccessor: xAccessor,
                yAccessor: yAccessor,
                groupAccessor: groupAccessor,
                diffLabelDetails: diffLabelDetails,
                normalized: normalized,
                chartType: chartType
            });
            // get bounds of parent (e.g., placement of chart container)
            var parentBounds = root.node().parentElement.getBoundingClientRect();
            // place tooltip on top left temporary to populate and not have wrap
            root.style('left', '0px').style('top', '0px');
            // populate tooltip so we can get its bounds as well
            root.select('p').html(tooltipContent);
            // now we get bounds for height/width/top/left after populating content
            var bounds = root.node().getBoundingClientRect();
            // if the page has been scrolled we need to account for that
            var adjLeft = (document.body.scrollLeft || 0) + (document.documentElement.scrollLeft || 0);
            var adjLeftFlip = parentBounds.width / 2 - (positions[0] - bounds.left - adjLeft) < 0 ? bounds.width : 0;
            var adjTop = (document.body.scrollTop || 0) + (document.documentElement.scrollTop || 0);
            // place tooltip and then fade in
            // left = mouse position - adjust left for parent container location (bounds.left) - adjust for scroll - adjust to left if on right half of graph
            // right = mouse position - adjust up for parent container location (bounds.right) - adjust for height of tooltip - adjust for scroll
            root
                .style('left', positions[0] - bounds.left - adjLeft - adjLeftFlip + "px")
                .style('top', positions[1] - bounds.top - bounds.height - adjTop + "px")
                .transition(transition().duration(200))
                .style('opacity', 1);
        };
        var toHide = function () {
            root.transition(transition().duration(500)).style('opacity', 0);
        };
        if (root) {
            isToShow ? toShow() : toHide();
            setTooltipAccess(root.node());
        }
    };

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var circularFind = function (array, index) {
        var remainder = index % array.length;
        return array[remainder === 0 ? 0 : remainder];
    };

    /**
     * Copyright (c) 2020, 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var visaColors = {
        pri_grey: '#5C5C5C',
        sec_blue: '#003ea9',
        sec_orange: '#ef8400',
        sec_yellow: '#ffd700',
        comp_blue: '#2bb4da',
        comp_green: '#00a25e',
        supp_pink: '#ae48b4',
        supp_purple: '#7f48b4',
        supp_green: '#649f4a',
        supp_red: '#a50026',
        // for data viz component
        base_grey: '#D7D7DE',
        light_text: '#ffffff',
        grey_text: '#565656',
        dark_text: '#222222',
        // blue to black theme
        oss_blue: '#0051dc',
        oss_light_blue: '#7FA8ED',
        oss_dark_grey: '#363636',
        oss_light_grey: '#D7D7D7',
        // for categorical palettes
        categorical_blue: '#226092',
        categorical_light_blue: '#7c99b1',
        categorical_blue_text: '#164d79',
        categorical_purple: '#796aaf',
        categorical_light_purple: '#cacae7',
        categorical_purple_text: '#66589b',
        categorical_olive: '#829e46',
        categorical_light_olive: '#abb798',
        categorical_olive_text: '#498329',
        categorical_grey: '#7a6763',
        categorical_light_grey: '#a19491',
        categorical_grey_text: '#6e5a55',
        categorical_rose: '#c18174',
        categorical_light_rose: '#e7c0b8',
        categorical_rose_text: '#954737',
        categorical_brown: '#43312d',
        categorical_light_brown: '#624c48',
        categorical_brown_text: '#43312d'
    };
    function darkerColor(color) {
        var hexColor = visaColors[color] || color;
        return hsl(hexColor)
            .darker(1.5)
            .hex();
    }
    function brighterColor(color) {
        var hexColor = visaColors[color] || color;
        var brighterScale = linear$1()
            .domain([0, 0.45])
            .range([4, 2]);
        return hsl(hexColor)
            .brighter(brighterScale(hsl(hexColor).l))
            .hex();
        // return "white"
    }
    function outlineColor(color) {
        var hexColor = visaColors[color] || color;
        return hsl(hexColor).l > 0.4 ? darkerColor(hexColor) : brighterColor(hexColor);
    }
    var sequentialColorIndex = [
        [7],
        [7],
        [2, 6],
        [0, 3, 6],
        [0, 2, 4, 6],
        [0, 1, 3, 5, 7],
        [1, 2, 3, 4, 5, 6],
        [0, 1, 2, 3, 4, 5, 6],
        [0, 1, 2, 3, 4, 5, 6, 7]
    ];
    var divergingColorIndex = [
        [0],
        [0],
        [0, 9],
        [0, 4, 9],
        [0, 3, 6, 9],
        [0, 2, 4, 6, 9],
        [0, 2, 4, 5, 7, 9],
        [0, 1, 2, 4, 7, 8, 9],
        [0, 1, 2, 3, 6, 7, 8, 9],
        [0, 1, 2, 3, 4, 6, 7, 8, 9],
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    ];
    var categoricalColorIndex = [
        [0],
        [0],
        [0, 1],
        [0, 1, 2],
        [0, 1, 2, 3],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4, 5],
        [0, 1, 2, 3, 4, 5, 6],
        [0, 1, 2, 3, 4, 5, 6, 7],
        [0, 1, 2, 3, 4, 5, 6, 7, 8],
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] //8-11
    ];
    function getColors(colorPalette, dataRange) {
        var colorArr = [];
        colorArr['single_blue'] = [visaColors.categorical_blue];
        colorArr['single_brown'] = [visaColors.categorical_brown];
        colorArr['single_grey'] = [visaColors.pri_grey];
        colorArr['single_secBlue'] = [visaColors.sec_blue];
        colorArr['single_secOrange'] = [visaColors.sec_orange];
        colorArr['single_compBlue'] = [visaColors.comp_blue];
        colorArr['single_compGreen'] = [visaColors.comp_green];
        colorArr['single_suppPink'] = [visaColors.supp_pink];
        colorArr['single_suppPurple'] = [visaColors.supp_purple];
        colorArr['single_suppGreen'] = [visaColors.supp_green];
        colorArr['single_ossBlue'] = [visaColors.oss_blue];
        colorArr['single_ossLightBlue'] = [visaColors.oss_light_blue];
        colorArr['single_ossGrey'] = [visaColors.oss_dark_grey];
        colorArr['single_ossLightGrey'] = [visaColors.oss_light_grey];
        colorArr['single_categorical_blue'] = [visaColors.categorical_blue];
        colorArr['single_categorical_light_blue'] = [visaColors.categorical_light_blue];
        colorArr['single_categorical_blue_text'] = [visaColors.categorical_blue_text];
        colorArr['single_categorical_purple'] = [visaColors.categorical_purple];
        colorArr['single_categorical_light_purple'] = [visaColors.categorical_light_purple];
        colorArr['single_categorical_purple_text'] = [visaColors.categorical_purple_text];
        colorArr['single_categorical_olive'] = [visaColors.categorical_olive];
        colorArr['single_categorical_light_olive'] = [visaColors.categorical_light_olive];
        colorArr['single_categorical_olive_text'] = [visaColors.categorical_olive_text];
        colorArr['single_categorical_grey'] = [visaColors.categorical_grey];
        colorArr['single_categorical_light_grey'] = [visaColors.categorical_light_grey];
        colorArr['single_categorical_grey_text'] = [visaColors.categorical_grey_text];
        colorArr['single_categorical_rose'] = [visaColors.categorical_rose];
        colorArr['single_categorical_light_rose'] = [visaColors.categorical_light_rose];
        colorArr['single_categorical_rose_text'] = [visaColors.categorical_rose_text];
        colorArr['single_categorical_brown'] = [visaColors.categorical_brown];
        colorArr['single_categorical_light_brown'] = [visaColors.categorical_light_brown];
        colorArr['single_categorical_brown_text'] = [visaColors.categorical_brown_text];
        colorArr['sequential_grey'] = [
            '#f2f2f2',
            '#d7d7d7',
            '#bdbdbd',
            '#a3a3a3',
            '#898989',
            '#717171',
            '#595959',
            '#434343',
            '#2e2e2e'
        ];
        colorArr['sequential_secBlue'] = [
            '#ecf9f9',
            '#c0e0f1',
            '#91c8ea',
            '#57b0e2',
            '#0c96d7',
            '#1778c7',
            '#145bb8',
            '#003da8',
            '#002c76'
        ];
        colorArr['sequential_secOrange'] = [
            '#fee9c7',
            '#ffc78d',
            '#faa654',
            '#ef8506',
            '#e36001',
            '#c04e04',
            '#9c3d05',
            '#7b2c05',
            '#5c1c00'
        ];
        colorArr['sequential_compBlue'] = [
            '#f3fbfe',
            '#bde3f2',
            '#81cae6',
            '#2ab1d7',
            '#2294b5',
            '#1b7994',
            '#135d74',
            '#0c4557',
            '#062c3a'
        ];
        colorArr['sequential_compGreen'] = [
            '#eafed4',
            '#bae7b4',
            '#89cf95',
            '#53b677',
            '#009e5c',
            '#00814b',
            '#00663b',
            '#004b2b',
            '#00321d'
        ];
        colorArr['sequential_suppPink'] = [
            '#f8f4f9',
            '#f3cef3',
            '#eca6ed',
            '#e37ce6',
            '#d74adf',
            '#aa45af',
            '#86378a',
            '#632a66',
            '#421b44'
        ];
        colorArr['sequential_suppPurple'] = [
            '#f7fcfd',
            '#e3daec',
            '#cebadd',
            '#b59acc',
            '#977ebb',
            '#7367a5',
            '#554f87',
            '#423667',
            '#331d48'
        ];
        colorArr['sequential_suppGreen'] = [
            '#ffffe5',
            '#deebc3',
            '#bed6a2',
            '#9ec283',
            '#7fae61',
            '#5e9a48',
            '#448340',
            '#286e3a',
            '#005a32'
        ];
        colorArr['diverging_RtoB'] = [
            '#a50026',
            '#c7422a',
            '#df7232',
            '#f3a14b',
            '#ffcf7b',
            '#afdbf1',
            '#7ab7e5',
            '#5390d1',
            '#386bb6',
            '#2d4697'
        ];
        colorArr['diverging_RtoG'] = [
            '#972800',
            '#ba4d18',
            '#df7131',
            '#f0a04e',
            '#fecd6e',
            '#bcdeba',
            '#72c1a7',
            '#529f8e',
            '#307e75',
            '#015e5d'
        ];
        colorArr['diverging_GtoP'] = [
            '#194f46',
            '#377258',
            '#57976f',
            '#7abb8c',
            '#a6e0b5',
            '#bbd4f9',
            '#aba6ea',
            '#9879d2',
            '#7655b2',
            '#3c3f85'
        ];
        colorArr['categorical'] = ['#7c99b1', '#cacae7', '#abb798', '#a19491', '#e7c0b8', '#624c48'];
        colorArr['categorical_light'] = ['#7c99b1', '#cacae7', '#abb798', '#a19491', '#e7c0b8', '#624c48'];
        colorArr['categorical_dark'] = ['#226092', '#796aaf', '#829e46', '#7a6763', '#c18174', '#43312d'];
        colorArr['categorical_text'] = ['#164d79', '#66589b', '#498329', '#6e5a55', '#954737', '#43312d'];
        var selectedColor = typeof colorPalette === 'string' ? colorArr[colorPalette] : colorPalette;
        if (Array.isArray(dataRange)) {
            // range of data keys is passed
            var colorScale = void 0;
            if (typeof dataRange[0] === 'string') {
                var newColorArr_1 = [];
                var colorIndex = colorPalette.includes('diverging')
                    ? divergingColorIndex
                    : colorPalette.includes('categorical')
                        ? categoricalColorIndex
                        : sequentialColorIndex;
                typeof colorPalette === 'string' && colorIndex[dataRange.length]
                    ? colorIndex[dataRange.length].map(function (key) {
                        selectedColor[key] ? newColorArr_1.push(selectedColor[key]) : newColorArr_1.push(selectedColor[0]);
                    })
                    : (newColorArr_1 = selectedColor);
                colorScale = ordinal()
                    .domain(dataRange)
                    .range(newColorArr_1);
            }
            else {
                colorScale = quantize()
                    .domain(dataRange)
                    .range(selectedColor);
            }
            return colorScale;
        }
        else if (Number.isInteger(dataRange)) {
            // number of colors is passed
            var newColorArr_2 = [];
            var colorIndex = colorPalette.includes('diverging')
                ? divergingColorIndex
                : colorPalette.includes('categorical')
                    ? categoricalColorIndex
                    : sequentialColorIndex;
            colorIndex[dataRange]
                ? colorIndex[dataRange].map(function (key) {
                    selectedColor[key] ? newColorArr_2.push(selectedColor[key]) : newColorArr_2.push(selectedColor[0]);
                })
                : (newColorArr_2 = selectedColor);
            return newColorArr_2;
        }
        else
            return selectedColor;
    }
    /**
     * This function will find up to two strokes for a given input color. This is only designed for accessible graphics.
     *
     * This function is designed with VGAR compliance in mind, using the WCAG 2.1 contrast ratio formula to find the highest contrast stroke colors possible for a graphical element. Formula: https://www.w3.org/TR/WCAG20-TECHS/G18.html#G18-tests
     *
     * @see  uses two visa/visa-charts-utils functions: calculateLuminance()  and calculateRelativeLuminance().
     *
     * @param {string}   fillColor           Any valid HTML string may be passed for color: 'red', '#ffffff', 'rgb(12,200,15)', even 'hsl(0,60%,50%)'. Alpha values will be ignored (for accessibility purposes, web authors are strongly encouraged to avoid using opacity or alpha channels in styling).
     *
     * @return {string[]} Returns an array containing color hex values as strings. The first array position is always contrasted against the fill color. The second array position is sometimes empty but if it has a value it will always be the original color. The second value only populates if the original color has more than 3:1 contrast against white.
     */
    function getAccessibleStrokes(fillColor) {
        var strokes = [];
        strokes.push(getContrastingStroke(fillColor));
        var luminanceToWhite = calculateRelativeLuminance(calculateLuminance(fillColor), 1);
        if (luminanceToWhite >= 3) {
            strokes.push(fillColor);
        }
        return strokes;
    }
    // experimental function
    // early tests show that this method can still fail to produce a valid stroke
    // this is abandoned until further need
    function getRecursiveStroke(foreground, background) {
        var extents = {};
        var foregroundLuminance = calculateLuminance(foreground);
        var backgroundLuminance = calculateLuminance(background);
        var foregroundToWhite = calculateRelativeLuminance(foregroundLuminance, 1);
        var backgroundToWhite = calculateRelativeLuminance(backgroundLuminance, 1);
        extents[foreground] = {};
        extents[background] = {};
        extents[foreground].min = foregroundToWhite - 3 > 1 ? foregroundToWhite - 3 : 1;
        extents[foreground].max = foregroundToWhite + 3 < 21 ? foregroundToWhite + 3 : 21;
        extents[background].min = backgroundToWhite - 3 > 1 ? backgroundToWhite - 3 : 1;
        extents[background].max = backgroundToWhite + 3 < 21 ? backgroundToWhite + 3 : 21;
        var darkerColor = extents[foreground].max >= extents[background].max ? foreground : background;
        var lighterColor = extents[foreground].min <= extents[background].min ? foreground : background;
        var lightestValue = extents[lighterColor].min;
        var darkestValue = extents[darkerColor].max;
        var gaps = {
            dark: 21 - darkestValue > 0 ? 21 - darkestValue : 0,
            light: lightestValue - 1 > 0 ? lightestValue - 1 : 0
        };
        var foundStroke = '';
        var operation = '';
        var target = '';
        if (lighterColor === foreground && extents[foreground].max < extents[background].min) {
            // try darkening foreground into the inner gap space
            operation = 'darken';
            target = foreground;
        }
        else if (darkerColor === foreground && extents[foreground].min > extents[background].max) {
            // try lightening foreground into the inner gap space
            operation = 'lighten';
            target = foreground;
        }
        if (operation) {
            var colorAttempt = processColor(target, operation, 3);
            var attemptLuminance = calculateLuminance(colorAttempt);
            foundStroke = calculateRelativeLuminance(backgroundLuminance, attemptLuminance) >= 3 ? colorAttempt : 0;
        }
        if (!foundStroke) {
            // the inner gap didn't work, must try exterior gaps
            if (darkerColor === foreground && gaps.dark) {
                // try darkening foreground into the outer gap space
                operation = 'darken';
                target = foreground;
            }
            else if (lighterColor === foreground && gaps.light) {
                // try lightening foreground into the outer gap space
                operation = 'lighten';
                target = foreground;
            }
            foundStroke = operation ? processColor(target, operation, 3) : '';
        }
        if (!foundStroke) {
            // must try exterior gaps using the background color
            if (gaps.dark > gaps.light) {
                // try darkening foreground into the gap space
                operation = 'darken';
                target = background;
            }
            else {
                // try lighting foreground into the gap space
                operation = 'lighten';
                target = background;
            }
            foundStroke = operation ? processColor(target, operation, 3) : '';
        }
        if (!foundStroke) {
            foundStroke = foreground;
        }
        return foundStroke;
    }
    function processColor(color, operation, contrast) {
        var originalLuminance = calculateLuminance(color);
        var hslObject = hsl(color);
        var limitReached = false;
        var impossible = false;
        if (operation === 'darken') {
            hslObject.l -= 0.01;
            while (calculateRelativeLuminance(calculateLuminance(hslObject.hex()), originalLuminance) < contrast &&
                !impossible) {
                hslObject.l -= 0.01;
                if (limitReached) {
                    impossible = true;
                }
                if (hslObject.l < 0) {
                    hslObject.l = 0;
                    limitReached = true;
                }
            }
        }
        else {
            hslObject.l += 0.01;
            while (calculateRelativeLuminance(calculateLuminance(hslObject.hex()), originalLuminance) < contrast &&
                !impossible) {
                hslObject.l += 0.01;
                if (limitReached) {
                    impossible = true;
                }
                if (hslObject.l > 1) {
                    hslObject.l = 1;
                    limitReached = true;
                }
            }
        }
        return !impossible ? hslObject.hex() : '';
    }
    function getContrastingStroke(fillColor) {
        var originalLuminance = calculateLuminance(fillColor);
        var luminanceToWhite = calculateRelativeLuminance(originalLuminance, 1);
        var hslObject = hsl(fillColor);
        if (luminanceToWhite < 3) {
            hslObject.l -= 0.01;
            while (hslObject.l > 0 &&
                calculateRelativeLuminance(calculateLuminance(hslObject.hex()), originalLuminance) < 3 &&
                hslObject.l) {
                hslObject.l -= 0.01;
                if (hslObject.l < 0) {
                    hslObject.l = 0;
                }
            }
        }
        else {
            hslObject.l += 0.01;
            while (calculateRelativeLuminance(calculateLuminance(hslObject.hex()), originalLuminance) < 3 &&
                hslObject.l !== 1) {
                hslObject.l += 0.01;
                if (hslObject.l > 1) {
                    hslObject.l = 1;
                }
            }
        }
        return hslObject.hex();
    }
    function ensureTextContrast(textColor) {
        var originalLuminance = calculateLuminance(textColor);
        var luminanceToWhite = calculateRelativeLuminance(originalLuminance, 1);
        var hslObject = hsl(textColor);
        if (luminanceToWhite < 4.5) {
            hslObject.l -= 0.01;
            while (hslObject.l > 0 && calculateRelativeLuminance(calculateLuminance(hslObject.hex()), 1) < 4.5 && hslObject.l) {
                hslObject.l -= 0.01;
                if (hslObject.l < 0) {
                    hslObject.l = 0;
                }
            }
        }
        return hslObject.hex();
    }
    /**
     * This function will calculate the perceived luminance of a valid HTML color.
     *
     * Formula and specification from WCAG 2.0: https://www.w3.org/TR/WCAG20-TECHS/G18.html#G18-tests.
     *
     * @param {string}   color           Any valid HTML string may be passed for color: 'red', '#ffffff', 'rgb(12,200,15)', even 'hsl(0,60%,50%)'. Alpha values will be ignored (for accessibility purposes, web authors are strongly encouraged to avoid using opacity or alpha channels in styling).
     *
     * @return {number} Returns a luminance value between 0 (black, no luminance) and 1 (white, full luminance).
     */
    function calculateLuminance(color) {
        function calcColorScore(normalizedColor) {
            return normalizedColor <= 0.03928 ? normalizedColor / 12.92 : Math.pow((normalizedColor + 0.055) / 1.055, 2.4);
        }
        var rgbObject = rgb(color);
        var rLuminance = 0.2126 * calcColorScore(rgbObject.r / 255);
        var gLuminance = 0.7152 * calcColorScore(rgbObject.g / 255);
        var bLuminance = 0.0722 * calcColorScore(rgbObject.b / 255);
        return rLuminance + gLuminance + bLuminance;
    }
    /**
     * This function will calculate the contrast ratio between two luminance values.
     *
     * Input luminance values may be supplied in any order. The output will always place the highest value as the numerator. Formula and specification from WCAG 2.0: https://www.w3.org/TR/WCAG20-TECHS/G18.html#G18-tests.
     *
     * @see  visa/visa-charts-utils: calculateLuminance() to convert an HTML color into a luminance value (which is the expected input of this function).
     *
     * @param {number}   luminance1           This value must be the calculated luminance of a color.
     * @param {number}   luminance2           This value must be the calculated luminance of another color.
     *
     * @return {number} Returns a contrast ratio between luminance values ranging from 1 (identical luminance) to 21 (complete opposites - black against white).
     */
    function calculateRelativeLuminance(luminance1, luminance2) {
        return luminance1 >= luminance2
            ? (luminance1 + 0.05) / (luminance2 + 0.05)
            : (luminance2 + 0.05) / (luminance1 + 0.05);
    }
    /**
     * This function will find the most appropriate text color (foreground) given a background color.
     *
     * This function is designed with VGAR compliance in mind, using the WCAG 2 contrast ratio formula to find the highest contrast text possible. Formula: https://www.w3.org/TR/WCAG20-TECHS/G18.html#G18-tests
     *
     * @see  uses two visa/visa-charts-utils functions: calculateLuminance()  and calculateRelativeLuminance().
     *
     * @param {string}   backgroundColor           Any valid HTML string may be passed for color: 'red', '#ffffff', 'rgb(12,200,15)', even 'hsl(0,60%,50%)'. Alpha values will be ignored (for accessibility purposes, web authors are strongly encouraged to avoid using opacity or alpha channels in styling).
     *
     * @return {string} Returns a color hex value, either '#ffffff' (white) or '#222222' (lead).
     */
    function autoTextColor(backgroundColor) {
        var lightLuminance = calculateLuminance(visaColors['light_text']);
        var greyLuminance = calculateLuminance(visaColors['dark_text']);
        var backgroundLuminance = calculateLuminance(backgroundColor);
        var relativeToLight = calculateRelativeLuminance(lightLuminance, backgroundLuminance);
        var relativeToGrey = calculateRelativeLuminance(greyLuminance, backgroundLuminance);
        return relativeToGrey < 4.5 && relativeToLight < 4.5
            ? visaColors['dark_text']
            : relativeToGrey > relativeToLight
                ? visaColors['dark_text']
                : visaColors['light_text'];
    }
    function convertVisaColor(colorArr) {
        if (colorArr[0].includes('_')) {
            colorArr.map(function (c, i) { return (colorArr[i] = visaColors[c]); });
        }
        return colorArr;
    }
    function visaColorToHex(color) {
        var hexColor = visaColors[color] || color;
        return hexColor;
    }

    /**
     * Copyright (c) 2020, 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    function transitionEndAll(transition, callback, noTransition) {
        if (noTransition) {
            callback.apply(this, arguments);
        }
        else {
            var n = 0;
            transition
                .each(function () {
                ++n;
            })
                .on('end', function () {
                if (!--n)
                    callback.apply(this, arguments);
            });
        }
    }
    var indices = {
        categorical: [[0], [0], [0, 1], [0, 1, 2], [0, 1, 2, 3], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4, 5]],
        sequential: [
            [0],
            [0],
            [0, 8],
            [0, 4, 8],
            [1, 3, 5, 7],
            [0, 2, 4, 6, 8],
            [1, 2, 3, 4, 5, 6],
            [1, 2, 3, 4, 5, 6, 7],
            [0, 1, 2, 3, 4, 5, 6, 7],
            [0, 1, 2, 3, 4, 5, 6, 7, 8]
        ],
        diverging_center: [
            ,
            // this scheme is odd-length only
            [5],
            ,
            [0, 5, 10],
            ,
            [1, 3, 5, 7, 9],
            ,
            [2, 3, 4, 5, 6, 7, 8],
            ,
            [1, 2, 3, 4, 5, 6, 7, 8, 9],
            ,
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        ],
        diverging_split: [
            ,
            ,
            // this scheme is even-length only
            // this index does not appear on this scheme
            [1, 8],
            ,
            [0, 3, 6, 9],
            ,
            [0, 2, 4, 5, 7, 9],
            ,
            [0, 1, 2, 3, 6, 7, 8, 9],
            ,
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        ]
    };
    function getTexture(_a) {
        var scheme = _a.scheme, id = _a.id, index = _a.index, fillColor = _a.fillColor, textureColor = _a.textureColor;
        var textureData = {
            categorical: [
                {
                    attributes: {
                        width: 12,
                        height: 12,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '12',
                                height: '12',
                                fill: "" + fillColor
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0,0 l 12,12 M -3,9 l 6,6 M 9,-3 l 6,6',
                                'stroke-width': '1',
                                'shape-rendering': 'auto',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 12,
                        height: 12,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '12',
                                height: '12',
                                fill: "" + fillColor
                            }
                        },
                        {
                            name: 'circle',
                            attributes: {
                                cx: '6',
                                cy: '6',
                                r: '1',
                                fill: "" + textureColor,
                                stroke: '#343434',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'circle',
                            attributes: {
                                cx: '0',
                                cy: '0',
                                r: '1',
                                fill: "" + textureColor,
                                stroke: '#343434',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'circle',
                            attributes: {
                                cx: '0',
                                cy: '12',
                                r: '1',
                                fill: "" + textureColor,
                                stroke: '#343434',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'circle',
                            attributes: {
                                cx: '12',
                                cy: '0',
                                r: '1',
                                fill: "" + textureColor,
                                stroke: '#343434',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'circle',
                            attributes: {
                                cx: '12',
                                cy: '12',
                                r: '1',
                                fill: "" + textureColor,
                                stroke: '#343434',
                                'stroke-width': '0'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 24,
                        height: 24,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '24',
                                height: '24',
                                fill: "" + fillColor
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0,0 l 24,24 M -6,18 l 12,12 M 18,-6 l 12,12',
                                'stroke-width': '1',
                                'shape-rendering': 'auto',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0,24 l 24,-24 M -6,6 l 12,-12 M 18,30 l 12,-12',
                                'stroke-width': '1',
                                'shape-rendering': 'auto',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 12,
                        height: 12,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '12',
                                height: '12',
                                fill: "" + fillColor
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 4.5,4.5l3,3M4.5,7.5l3,-3',
                                fill: 'transparent',
                                stroke: "" + textureColor,
                                'stroke-width': '1',
                                'stroke-linecap': 'square',
                                'shape-rendering': 'auto'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 10,
                        height: 10,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '10',
                                height: '10',
                                fill: "" + fillColor
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 5, 0 l 0, 10',
                                'stroke-width': '1',
                                'shape-rendering': 'auto',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 12,
                        height: 12,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '12',
                                height: '12',
                                fill: "" + fillColor
                            }
                        },
                        {
                            name: 'circle',
                            attributes: {
                                cx: '6',
                                cy: '6',
                                r: '1.5',
                                fill: 'none',
                                stroke: "" + textureColor,
                                'stroke-width': '1'
                            }
                        },
                        {
                            name: 'circle',
                            attributes: {
                                cx: '2',
                                cy: '10',
                                r: '1.5',
                                fill: 'none',
                                stroke: "" + textureColor,
                                'stroke-width': '1'
                            }
                        },
                        {
                            name: 'circle',
                            attributes: {
                                cx: '10',
                                cy: '2',
                                r: '1.5',
                                fill: 'none',
                                stroke: "" + textureColor,
                                'stroke-width': '1'
                            }
                        }
                    ]
                }
            ],
            sequential: [
                {
                    attributes: {
                        width: 10,
                        height: 10,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '10',
                                height: '10',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 0 L 10 0M 0 10 L 10 10',
                                'stroke-width': '1',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 52.40843064167849,
                        height: 10.187166949552141,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '52.40843064167849',
                                height: '10.187166949552141',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -52.40843064167849 10.187166949552141 L 52.40843064167849 -10.187166949552141M -52.40843064167849 20.374333899104283 L 104.81686128335699 -10.187166949552141M 0 20.374333899104283 L 104.81686128335699 0',
                                'stroke-width': '2',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 26.694671625540145,
                        height: 10.785347426775834,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '26.694671625540145',
                                height: '10.785347426775834',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -26.694671625540145 10.785347426775834 L 26.694671625540145 -10.785347426775834M -26.694671625540145 21.570694853551668 L 53.38934325108029 -10.785347426775834M 0 21.570694853551668 L 53.38934325108029 0',
                                'stroke-width': '3',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 17.882916499714003,
                        height: 12.062179485039053,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '17.882916499714003',
                                height: '12.062179485039053',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -17.882916499714003 12.062179485039053 L 17.882916499714003 -12.062179485039053M -17.882916499714003 24.124358970078106 L 35.76583299942801 -12.062179485039053M 0 24.124358970078106 L 35.76583299942801 0',
                                'stroke-width': '4',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 14.142135623730951,
                        height: 14.14213562373095,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '14.142135623730951',
                                height: '14.14213562373095',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -14.142135623730951 14.14213562373095 L 14.142135623730951 -14.14213562373095M -14.142135623730951 28.2842712474619 L 28.284271247461902 -14.14213562373095M 0 28.2842712474619 L 28.284271247461902 0',
                                'stroke-width': '5',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 12.062179485039053,
                        height: 17.882916499714003,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '12.062179485039053',
                                height: '17.882916499714003',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -12.062179485039053 17.882916499714003 L 12.062179485039053 -17.882916499714003M -12.062179485039053 35.76583299942801 L 24.124358970078106 -17.882916499714003M 0 35.76583299942801 L 24.124358970078106 0',
                                'stroke-width': '6',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 10.863603774052963,
                        height: 25.593046652474495,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '10.863603774052963',
                                height: '25.593046652474495',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -10.863603774052963 25.593046652474495 L 10.863603774052963 -25.593046652474495M -10.863603774052963 51.18609330494899 L 21.727207548105927 -25.593046652474495M 0 51.18609330494899 L 21.727207548105927 0',
                                'stroke-width': '7',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 10.187166949552141,
                        height: 52.40843064167844,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '10.187166949552141',
                                height: '52.40843064167844',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -10.187166949552141 52.40843064167844 L 10.187166949552141 -52.40843064167844M -10.187166949552141 104.81686128335689 L 20.374333899104283 -52.40843064167844M 0 104.81686128335689 L 20.374333899104283 0',
                                'stroke-width': '8',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 10,
                        height: 10,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '10',
                                height: '10',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 0 L 0 10M 10 0 L 10 10',
                                'stroke-width': '9',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                }
            ],
            diverging_split: [
                {
                    attributes: {
                        width: 10.35276180410083,
                        height: 38.63703305156273,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '10.35276180410083',
                                height: '38.63703305156273',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -38.63703305156273 L 20.70552360820166 38.63703305156273M -10.35276180410083 -38.63703305156273 L 10.35276180410083 38.63703305156273M -10.35276180410083 0 L 10.35276180410083 77.27406610312546',
                                'stroke-width': '9',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 11.547005383792516,
                        height: 20.000000000000004,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '11.547005383792516',
                                height: '20.000000000000004',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -20.000000000000004 L 23.094010767585033 20.000000000000004M -11.547005383792516 -20.000000000000004 L 11.547005383792516 20.000000000000004M -11.547005383792516 0 L 11.547005383792516 40.00000000000001',
                                'stroke-width': '7',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 14.142135623730951,
                        height: 14.142135623730951,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '14.142135623730951',
                                height: '14.142135623730951',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -14.142135623730951 L 28.284271247461902 14.142135623730951M -14.142135623730951 -14.142135623730951 L 14.142135623730951 14.142135623730951M -14.142135623730951 0 L 14.142135623730951 28.284271247461902',
                                'stroke-width': '5',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 20.000000000000004,
                        height: 11.547005383792516,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '20.000000000000004',
                                height: '11.547005383792516',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -11.547005383792516 L 40.00000000000001 11.547005383792516M -20.000000000000004 -11.547005383792516 L 20.000000000000004 11.547005383792516M -20.000000000000004 0 L 20.000000000000004 23.094010767585033',
                                'stroke-width': '3',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 38.63703305156273,
                        height: 10.35276180410083,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '38.63703305156273',
                                height: '10.35276180410083',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -10.35276180410083 L 77.27406610312546 10.35276180410083M -38.63703305156273 -10.35276180410083 L 38.63703305156273 10.35276180410083M -38.63703305156273 0 L 38.63703305156273 20.70552360820166',
                                'stroke-width': '1',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 38.63703305156273,
                        height: 10.35276180410083,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '38.63703305156273',
                                height: '10.35276180410083',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -38.63703305156273 10.35276180410083 L 38.63703305156273 -10.35276180410083M -38.63703305156273 20.70552360820166 L 77.27406610312546 -10.35276180410083M 0 20.70552360820166 L 77.27406610312546 0',
                                'stroke-width': '1',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 20.000000000000004,
                        height: 11.547005383792515,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '20.000000000000004',
                                height: '11.547005383792515',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -20.000000000000004 11.547005383792515 L 20.000000000000004 -11.547005383792515M -20.000000000000004 23.09401076758503 L 40.00000000000001 -11.547005383792515M 0 23.09401076758503 L 40.00000000000001 0',
                                'stroke-width': '3',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 14.142135623730951,
                        height: 14.14213562373095,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '14.142135623730951',
                                height: '14.14213562373095',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -14.142135623730951 14.14213562373095 L 14.142135623730951 -14.14213562373095M -14.142135623730951 28.2842712474619 L 28.284271247461902 -14.14213562373095M 0 28.2842712474619 L 28.284271247461902 0',
                                'stroke-width': '5',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 11.547005383792516,
                        height: 20.000000000000004,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '11.547005383792516',
                                height: '20.000000000000004',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -11.547005383792516 20.000000000000004 L 11.547005383792516 -20.000000000000004M -11.547005383792516 40.00000000000001 L 23.094010767585033 -20.000000000000004M 0 40.00000000000001 L 23.094010767585033 0',
                                'stroke-width': '7',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 10.35276180410083,
                        height: 38.637033051562696,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '10.35276180410083',
                                height: '38.637033051562696',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -10.35276180410083 38.637033051562696 L 10.35276180410083 -38.637033051562696M -10.35276180410083 77.27406610312539 L 20.70552360820166 -38.637033051562696M 0 77.27406610312539 L 20.70552360820166 0',
                                'stroke-width': '9',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                }
            ],
            diverging_center: [
                {
                    attributes: {
                        width: 12.423314164920995,
                        height: 46.36443966187528,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '12.423314164920995',
                                height: '46.36443966187528',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -46.36443966187528 L 24.84662832984199 46.36443966187528M -12.423314164920995 -46.36443966187528 L 12.423314164920995 46.36443966187528M -12.423314164920995 0 L 12.423314164920995 92.72887932375056',
                                'stroke-width': '11',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 13.85640646055102,
                        height: 24.000000000000004,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '13.85640646055102',
                                height: '24.000000000000004',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -24.000000000000004 L 27.71281292110204 24.000000000000004M -13.85640646055102 -24.000000000000004 L 13.85640646055102 24.000000000000004M -13.85640646055102 0 L 13.85640646055102 48.00000000000001',
                                'stroke-width': '9',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 16.970562748477143,
                        height: 16.970562748477143,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '16.970562748477143',
                                height: '16.970562748477143',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -16.970562748477143 L 33.941125496954285 16.970562748477143M -16.970562748477143 -16.970562748477143 L 16.970562748477143 16.970562748477143M -16.970562748477143 0 L 16.970562748477143 33.941125496954285',
                                'stroke-width': '7',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 24.000000000000004,
                        height: 13.85640646055102,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '24.000000000000004',
                                height: '13.85640646055102',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -13.85640646055102 L 48.00000000000001 13.85640646055102M -24.000000000000004 -13.85640646055102 L 24.000000000000004 13.85640646055102M -24.000000000000004 0 L 24.000000000000004 27.71281292110204',
                                'stroke-width': '5',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 46.36443966187528,
                        height: 12.423314164920995,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '46.36443966187528',
                                height: '12.423314164920995',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 -12.423314164920995 L 92.72887932375056 12.423314164920995M -46.36443966187528 -12.423314164920995 L 46.36443966187528 12.423314164920995M -46.36443966187528 0 L 46.36443966187528 24.84662832984199',
                                'stroke-width': '3',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 12,
                        height: 12,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '12',
                                height: '12',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M 0 0 L 12 0M 0 12 L 12 12',
                                'stroke-width': '1',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 46.36443966187528,
                        height: 12.423314164920995,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '46.36443966187528',
                                height: '12.423314164920995',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -46.36443966187528 12.423314164920995 L 46.36443966187528 -12.423314164920995M -46.36443966187528 24.84662832984199 L 92.72887932375056 -12.423314164920995M 0 24.84662832984199 L 92.72887932375056 0',
                                'stroke-width': '3',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 24.000000000000004,
                        height: 13.856406460551018,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '24.000000000000004',
                                height: '13.856406460551018',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -24.000000000000004 13.856406460551018 L 24.000000000000004 -13.856406460551018M -24.000000000000004 27.712812921102035 L 48.00000000000001 -13.856406460551018M 0 27.712812921102035 L 48.00000000000001 0',
                                'stroke-width': '5',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 16.970562748477143,
                        height: 16.97056274847714,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '16.970562748477143',
                                height: '16.97056274847714',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -16.970562748477143 16.97056274847714 L 16.970562748477143 -16.97056274847714M -16.970562748477143 33.94112549695428 L 33.941125496954285 -16.97056274847714M 0 33.94112549695428 L 33.941125496954285 0',
                                'stroke-width': '7',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 13.85640646055102,
                        height: 24.000000000000004,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '13.85640646055102',
                                height: '24.000000000000004',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -13.85640646055102 24.000000000000004 L 13.85640646055102 -24.000000000000004M -13.85640646055102 48.00000000000001 L 27.71281292110204 -24.000000000000004M 0 48.00000000000001 L 27.71281292110204 0',
                                'stroke-width': '9',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                },
                {
                    attributes: {
                        width: 12.423314164920995,
                        height: 46.36443966187523,
                        patternUnits: 'userSpaceOnUse',
                        id: "" + id,
                        class: 'VCL-texture-pattern'
                    },
                    children: [
                        {
                            name: 'rect',
                            attributes: {
                                width: '12.423314164920995',
                                height: '46.36443966187523',
                                fill: "" + fillColor,
                                stroke: 'rgba(255, 0, 0, 0.1)',
                                'stroke-width': '0'
                            }
                        },
                        {
                            name: 'path',
                            attributes: {
                                d: 'M -12.423314164920995 46.36443966187523 L 12.423314164920995 -46.36443966187523M -12.423314164920995 92.72887932375046 L 24.84662832984199 -46.36443966187523M 0 92.72887932375046 L 24.84662832984199 0',
                                'stroke-width': '11',
                                stroke: "" + textureColor,
                                'stroke-linecap': 'square'
                            }
                        }
                    ]
                }
            ]
        };
        // need to check categorical index to fill constancy!! Should import the scheme here
        return textureData[scheme][index];
    }
    var checkAttributeTransitions = function (source, attributeArray) {
        var change = false;
        var i = 0;
        while (!change && i < attributeArray.length) {
            var d = attributeArray[i];
            var currentAttributeValue = d.numeric ? parseFloat(source.attr(d.attr)) : source.attr(d.attr);
            change = !(currentAttributeValue === d.newValue);
            i++;
        }
        return change;
    };
    function runTextureLifecycle(source, data, transitionDisabled) {
        var parent = select(source);
        var defs = parent.select('defs');
        if (!defs.size()) {
            defs = parent.append('defs');
        }
        var patterns = defs.selectAll('.VCL-texture-pattern').data(data, function (d) { return d.scheme + d.index; });
        // append new patterns
        var enter = patterns.enter().append('pattern');
        // update all existing patterns
        var update = patterns.merge(enter);
        update
            .transition('exit')
            .duration(!transitionDisabled ? 750 : 0)
            .call(transitionEndAll, function () {
            // removing here instead of earlier compensates for failing a race condition
            // caused by Stencil where multiple lifecycles are trying to exit
            patterns.exit().remove();
        });
        update
            .each(function (d, i, n) {
            var patternAttributes = Object.keys(d.attributes);
            var me = select(n[i]);
            patternAttributes.forEach(function (attr) {
                me.attr(attr, d.attributes[attr]);
            });
        })
            .attr('patternContentUnits', 'userSpaceOnUse')
            .attr('x', 0)
            .attr('y', 0);
        var children = update.selectAll('.VCL-t-p-e').data(function (d) { return d.children; }, function (d, i) { return d.name + i; });
        // remove children that are a different type, by slot order
        children.exit().remove();
        // append new children, also according to slot order and type
        var enterChildren = children
            .enter()
            .append(function (d) {
            return document.createElementNS('http://www.w3.org/2000/svg', d.name);
        })
            .attr('class', 'VCL-t-p-e');
        // update all existing children
        var updateChildren = children.merge(enterChildren);
        updateChildren.each(function (d, i, n) {
            var me = select(n[i]);
            var childAttributes = Object.keys(d.attributes);
            childAttributes.forEach(function (attr) {
                me.attr(attr, d.attributes[attr]);
            });
        });
    }
    function convertColorsToTextures(_a) {
        var colors = _a.colors, rootSVG = _a.rootSVG, id = _a.id, scheme = _a.scheme, disableTransitions = _a.disableTransitions;
        var output = [];
        var textures = [];
        var i = 0;
        var colorArray = colors.range ? colors.range() : colors;
        // if (colorArray.length === 1) {
        //   output.push;
        // }
        // removePatterns(rootSVG);
        colorArray.forEach(function (color) {
            // we create a unique ID for each texture
            var textureId = id + '_texture_' + i;
            // get one color for the texture/stroke and one for the fill, depending on the scheme
            var contrastedColors = prepareStrokeColorsFromScheme(color, i, colorArray, scheme);
            // we retrieve the appropriate pattern data for the texture
            var texture = getTexture({
                scheme: contrastedColors.textureScheme,
                id: textureId,
                index: indices[contrastedColors.textureScheme][colors.length][i],
                fillColor: contrastedColors.fillColor,
                textureColor: contrastedColors.textureColor
            });
            // we append the pattern to the dom
            // appendPattern(rootSVG, texture);
            texture.scheme = contrastedColors.textureScheme;
            texture.index = indices[contrastedColors.textureScheme][colors.length][i];
            textures.push(texture);
            // we add the url to this pattern to our output array
            output.push(createUrl(textureId));
            i++;
        });
        runTextureLifecycle(rootSVG, textures, disableTransitions);
        // return array of "url(#[id])" strings for use in place of hex codes for element fills
        return output;
    }
    var prepareStrokeColorsFromScheme = function (color, i, colorArray, scheme) {
        // the sequential scheme colors are easiest, so they are default
        var fillColor = colorArray[0];
        var textureColor = colorArray[colorArray.length - 1];
        var textureScheme = scheme === 'categorical' || !scheme
            ? 'categorical'
            : scheme === 'sequential'
                ? 'sequential'
                : colorArray.length % 2
                    ? 'diverging_center' // odd numbered scheme
                    : 'diverging_split'; // even numbered scheme
        if (textureScheme === 'categorical') {
            // we calculate the appropriate stroke color for the texture
            textureColor = getContrastingStroke(color);
            fillColor = color;
        }
        else if (textureScheme !== 'sequential') {
            if (textureScheme.includes('center')) {
                // center diverging scheme
                var firstHalfIndex = (colorArray.length - 1) / 2 - 1;
                var middleIndex = firstHalfIndex + 1;
                var secondHalfIndex = middleIndex + 1;
                if (i <= firstHalfIndex) {
                    textureColor = colorArray[0];
                    fillColor = colorArray[firstHalfIndex];
                }
                else if (i >= secondHalfIndex) {
                    textureColor = colorArray[colorArray.length - 1];
                    fillColor = colorArray[secondHalfIndex];
                }
                else {
                    // we calculate the appropriate stroke color for the texture
                    textureColor = getContrastingStroke(color);
                    fillColor = color;
                }
            }
            else {
                // split diverging scheme
                var topHalfIndex = colorArray.length / 2;
                if (i < topHalfIndex) {
                    textureColor = colorArray[0];
                    fillColor = colorArray[topHalfIndex - 1];
                }
                else {
                    textureColor = colorArray[colorArray.length - 1];
                    fillColor = colorArray[topHalfIndex];
                }
            }
        }
        return {
            fillColor: fillColor,
            textureColor: textureColor,
            textureScheme: textureScheme
        };
    };
    var removeFilters = function (root) {
        select(root)
            .selectAll('.VCL-accessibility-stroke-filter')
            .remove();
    };
    var createTextStrokeFilter = function (_a) {
        var root = _a.root, id = _a.id, color = _a.color, strokeSizeOverride = _a.strokeSizeOverride;
        var sanitizedColor = color[0] === '#' ? color.substr(1) : color;
        var s = ((strokeSizeOverride || '') + '').replace('.', 'p');
        var strokeClass = 'VCL-t-s-f-' + sanitizedColor + s;
        var strokeId = strokeClass + id + s;
        var filter = select(root).select('.' + strokeClass);
        if (!filter.size()) {
            // select(root).selectAll('VCL-text-stroke-filter').remove()
            var defs = select(root).select('defs');
            if (!defs.size()) {
                defs = select(root).append('defs');
            }
            filter = defs
                .append('filter')
                .attr('id', strokeId)
                .attr('class', strokeClass);
            filter
                .append('feMorphology')
                .attr('in', 'SourceAlpha')
                .attr('result', 'dilatedText')
                .attr('operator', 'dilate')
                .attr('radius', strokeSizeOverride || 1.5);
            filter
                .append('feFlood')
                .attr('flood-color', color || '#ffffff')
                .attr('flood-opacity', 1)
                .attr('result', 'whiteTextFlood');
            filter
                .append('feComposite')
                .attr('in', 'whiteTextFlood')
                .attr('in2', 'dilatedText')
                .attr('operator', 'in')
                .attr('result', 'textOutline');
            var merge = filter.append('feMerge');
            merge.append('feMergeNode').attr('in', 'textOutline');
            if (!strokeSizeOverride) {
                // this ensures that text (which use the default) will always have effective outlines
                merge.append('feMergeNode').attr('in', 'textOutline');
                merge.append('feMergeNode').attr('in', 'textOutline');
            }
            merge.append('feMergeNode').attr('in', 'SourceGraphic');
        }
        else {
            filter.attr('id', strokeId);
        }
        return createUrl(strokeId);
    };
    var createMultiStrokeFilter = function (_a) {
        var root = _a.root, id = _a.id, state = _a.state, fillColor = _a.fillColor, strokeWidth = _a.strokeWidth, forceStrokeColor = _a.forceStrokeColor, includeOuterStroke = _a.includeOuterStroke, strokeOnHover = _a.strokeOnHover, alwaysShowStroke = _a.alwaysShowStroke, stacked = _a.stacked;
        var rootDefs = select(root).select('defs');
        var strokes = getAccessibleStrokes(fillColor);
        // dark fills that are at rest don't need a stroke
        var primaryStroke = (state !== 'hover' || strokeOnHover) && (strokes.length === 1 || state === 'click') ? strokes[0] : fillColor;
        // cleanup is always the same as base fill
        var cleanupStroke = fillColor;
        // if there is an edge, use it - this is only for dark fills
        var edgeStroke = strokes[1] || '';
        // if we include outer stroke, it is always white
        var outerStroke = includeOuterStroke ? '#ffffff' : '';
        var filterId = 'VCL-filter-' + (primaryStroke[0] === '#' ? primaryStroke.substring(1) : primaryStroke) + '-' + state + '-' + id;
        if (rootDefs.select('#' + filterId).size()) {
            rootDefs.select('#' + filterId).remove();
        }
        var filter = rootDefs
            .append('filter')
            .attr('id', filterId)
            .attr('class', 'VCL-accessibility-stroke-filter');
        var data = createFilterData(state !== 'hover' && forceStrokeColor ? forceStrokeColor : primaryStroke, cleanupStroke, primaryStroke !== fillColor || state === 'hover' || alwaysShowStroke ? strokeWidth : 0, outerStroke, edgeStroke, !stacked ? 0 : 0.5);
        data.forEach(function (filterComposite) {
            filter
                .append('feMorphology')
                .attr('in', 'SourceAlpha')
                .attr('operator', filterComposite.operator)
                .attr('radius', filterComposite.radius)
                .attr('result', filterComposite.result
                ? filterComposite.result + '-morph'
                : 'morph-' + filterComposite.operator + '-' + filterComposite.radius);
            if (filterComposite.color) {
                filter
                    .append('feFlood')
                    .attr('flood-color', filterComposite.color)
                    .attr('result', filterComposite.result + '-color');
            }
            filter
                .append('feComposite')
                .attr('in', filterComposite.result ? filterComposite.result + '-color' : 'SourceGraphic')
                .attr('in2', filterComposite.result
                ? filterComposite.result + '-morph'
                : 'morph-' + filterComposite.operator + '-' + filterComposite.radius)
                .attr('operator', 'in')
                .attr('result', filterComposite.result ? filterComposite.result + '-stroke' : 'fill');
        });
        var feMerge = filter.append('feMerge');
        data.forEach(function (filterComposite) {
            feMerge.append('feMergeNode').attr('in', filterComposite.result ? filterComposite.result + '-stroke' : 'fill');
        });
        return createUrl(filterId);
    };
    var createFilterData = function (primary, clean, strokeWidth, outside, edge, adjustForStack) {
        var output = [];
        var browser = getBrowser();
        var mod = browser !== 'IE' && browser !== 'Edge' ? 0 : 1;
        var strokeStart = browser !== 'Safari' ? mod : 0.1;
        if (outside) {
            output.push({
                color: outside,
                result: 'outside',
                operator: !adjustForStack ? 'dilate' : 'erode',
                radius: !adjustForStack ? 1 : 0
            });
        }
        if (edge) {
            strokeStart++;
            output.push({
                color: edge,
                result: 'edge',
                operator: 'erode',
                radius: mod + adjustForStack
            });
        }
        output.push({
            color: primary,
            result: 'primary',
            operator: 'erode',
            radius: strokeStart + adjustForStack
        });
        output.push({
            color: clean,
            result: 'clean',
            operator: 'erode',
            radius: strokeStart + strokeWidth + adjustForStack
        });
        output.push({
            operator: 'erode',
            radius: strokeStart + strokeWidth + 1 + adjustForStack
        });
        return output;
    };
    var removeHoverStrokes = function (root) {
        var className = 'vcl-accessibility-focus';
        select(root)
            .selectAll('.' + className + '-hoverSource')
            .classed(className + '-hoverSource', false);
        select(root)
            .selectAll('.' + className + '-hover')
            .remove();
    };
    var removeDuplicateStrokes = function (parent, id) {
        var root = select(parent.ownerSVGElement);
        root.selectAll('.vcl-accessibility-focus-hoverSource').classed('vcl-accessibility-focus-hoverSource', false);
        root.select('#VCL-clip-' + id).remove();
        root.select('#VCL-hover-stroke-' + id).remove();
        root.select('#VCL-buffer-stroke' + id).remove();
        root.select('#VCL-parent-' + id).remove();
    };
    var drawHoverStrokes = function (_a) {
        var inputElement = _a.inputElement, id = _a.id, key = _a.key, strokeWidth = _a.strokeWidth, fill = _a.fill, recursive = _a.recursive, strokeOverride = _a.strokeOverride;
        var strokes = getAccessibleStrokes(fill);
        var stroke = strokeOverride || strokes[0];
        var shouldBuffer = !!strokes[1];
        var uniqueElementId = createId(id, key);
        var source = inputElement.tagName !== 'DIV'
            ? inputElement
            : select(inputElement.parentNode)
                .select('svg')
                .node();
        var className = 'vcl-accessibility-focus';
        var shouldHideOutline = select(source)
            .style('outline')
            .includes('auto');
        if (shouldHideOutline) {
            select(source)
                .style('outline-width', '0px')
                .style('outline-offset', '0px')
                .style('outline-color', 'none');
        }
        var parent = source.parentNode;
        removeDuplicateStrokes(parent, uniqueElementId);
        select(source).classed(className + '-hoverSource', true);
        var dashedStrokeLayer = source.cloneNode(false);
        var darkElementBuffer = shouldBuffer ? source.cloneNode(false) : null;
        var clipPathElement = source.cloneNode(false);
        var clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
        clipPath.appendChild(clipPathElement);
        if (!recursive) {
            var parentOfParent = parent.parentNode;
            var parentCopy = parent.cloneNode(false);
            var newParent = select(parentCopy).attr('id', 'VCL-parent-' + uniqueElementId);
            parentCopy.appendChild(clipPath);
            parentCopy.appendChild(dashedStrokeLayer);
            if (shouldBuffer) {
                parentCopy.appendChild(darkElementBuffer);
            }
            if (parent.nextSibling) {
                parentOfParent.insertBefore(parentCopy, parent.nextSibling);
            }
            else {
                parentOfParent.appendChild(parentCopy);
            }
            applyDefaults(newParent, className);
        }
        else {
            if (source.nextSibling) {
                if (shouldBuffer) {
                    parent.insertBefore(darkElementBuffer, source.nextSibling);
                }
                parent.insertBefore(dashedStrokeLayer, source.nextSibling);
                parent.insertBefore(clipPath, source.nextSibling);
            }
            else {
                parent.appendChild(clipPath);
                parent.appendChild(dashedStrokeLayer);
                if (shouldBuffer) {
                    parent.appendChild(darkElementBuffer);
                }
            }
        }
        var clipId = 'VCL-clip-' + uniqueElementId;
        var url = createUrl(clipId);
        select(clipPath)
            .attr('id', clipId)
            .attr('clipPathUnits', 'userSpaceOnUse')
            .attr('class', className + '-highlight ' + className + '-hover');
        var clip = select(clipPathElement)
            .attr('id', 'VCL-clip-element-' + uniqueElementId)
            .style('opacity', 1)
            .attr('opacity', 1);
        applyDefaults(clip, className);
        var strokeElement = select(dashedStrokeLayer)
            .attr('id', 'VCL-buffer-stroke-' + uniqueElementId)
            .style('opacity', 1)
            .attr('opacity', 1)
            .style('stroke', stroke);
        applyDefaults(strokeElement, className);
        applyOutlineOverride(strokeElement, strokeWidth, url, shouldBuffer, true);
        if (shouldBuffer) {
            var buffer = select(darkElementBuffer)
                .attr('id', 'VCL-buffer-stroke-' + uniqueElementId)
                .style('opacity', 1)
                .attr('opacity', 1)
                .style('stroke', fill);
            applyDefaults(buffer, className);
            applyOutlineOverride(buffer, 1, url, false, false);
        }
    };
    // this is currently unused, but will allow for future strokes to transition with a chart
    // (rather than hiding during transition). See commented section in bar chart for use.
    var mirrorStrokeTransition = function (_a) {
        var id = _a.id, key = _a.key, attribute = _a.attribute, newValue = _a.newValue, easing = _a.easing, duration = _a.duration;
        var baseId = createId(id, key);
        var layers = ['VCL-clip-element-', 'VCL-buffer-stroke-', 'VCL-buffer-stroke-'];
        layers.forEach(function (layer) {
            var targetId = '#' + layer + baseId;
            var target = select(targetId);
            if (target.size()) {
                if (duration) {
                    target = target.transition(attribute).duration(duration);
                    if (easing) {
                        target = target.ease(easing);
                    }
                }
                target.attr(attribute, newValue);
            }
        });
    };
    var applyDefaults = function (selection, className) {
        selection
            .attr('class', className + '-highlight ' + className + '-hover')
            .attr('focusable', false)
            .attr('aria-label', null)
            .attr('aria-hidden', true)
            .attr('role', null)
            .style('pointer-events', 'none')
            .attr('tabindex', null)
            .attr('mix-blend-mode', null)
            .style('mix-blend-mode', null);
    };
    var applyOutlineOverride = function (selection, extraStrokeWidth, url, buffer, dash) {
        selection
            .style('stroke-linecap', 'butt')
            .style('outline-offset', '0px')
            .style('outline-color', 'none')
            .style('outline-width', '0px')
            .attr('fill', 'none')
            .style('fill', 'none')
            .style('stroke-opacity', 1)
            .attr('marker-start', null)
            .attr('marker-end', null)
            .attr('filter', null)
            .attr('stroke-dasharray', dash ? '8 6' : null)
            .attr('clip-path', url)
            .style('stroke-width', function (_, i, n) {
            var scaleIndex = select(n[i]).attr('transform')
                ? select(n[i])
                    .attr('transform')
                    .indexOf('scale')
                : -1;
            var scale = 1;
            if (scaleIndex > -1) {
                var scaleSubstring = select(n[i])
                    .attr('transform')
                    .substring(scaleIndex + 6);
                var endSubstring = scaleSubstring.indexOf(',') < scaleSubstring.indexOf(')') && scaleSubstring.indexOf(',') !== -1
                    ? scaleSubstring.indexOf(',')
                    : scaleSubstring.indexOf(')');
                scale = +scaleSubstring.substring(0, endSubstring);
            }
            return ((buffer ? 2 : 0) + extraStrokeWidth * 2) / scale + 'px';
        });
    };
    var createId = function (id, key) {
        var parsedKey = key instanceof Date ? key.getTime() : key;
        return id + '-' + (parsedKey + '').replace(/\W/g, '-');
    };

    /**
     * Copyright (c) 2020, 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var defaultHoverStrokeWidth = 2;
    var defaultClickStrokeWidth = 2;
    function checkInteraction(d, default_op, hover_op, hoverHighlight, clickHighlight, interactionKeys) {
        // data: d, default opacity: default_op, hover opacity: hover_op, hoverHighlight, clickHighlight, interactionKeys
        var elementOpacity = default_op === 0 ? 0 : hover_op;
        var matchClick = checkClicked(d, clickHighlight, interactionKeys);
        var matchHover = checkHovered(d, hoverHighlight, interactionKeys);
        if (matchHover || matchClick) {
            elementOpacity = default_op;
        }
        else if ((!hoverHighlight || matchHover) && (clickHighlight.length === 0 || matchClick)) {
            elementOpacity = default_op;
        }
        return elementOpacity;
    }
    function checkHovered(d, hoverHighlight, interactionKeys) {
        // here we check for sub data objects, this will help catch time when data might be nested
        // in d for charts like pie chart and circle packing
        var datum = d && d.data && d.data.data ? d.data.data : d && d.data ? d.data : d ? d : {};
        var matchHover = 0;
        if (hoverHighlight) {
            interactionKeys.map(function (key) {
                if (hoverHighlight[key] instanceof Date && datum[key] instanceof Date) {
                    if (hoverHighlight[key].getTime() === datum[key].getTime()) {
                        matchHover++;
                    }
                }
                else if (hoverHighlight[key] === datum[key]) {
                    matchHover++;
                }
            });
        }
        return interactionKeys && interactionKeys.length && matchHover === interactionKeys.length;
    }
    function checkClicked(d, clickHighlight, interactionKeys) {
        // first set flag to false by default
        var clickedCheck = false;
        // here we check for sub data objects, this will help catch time when data might be nested
        // in d for charts like pie chart and circle packing
        var datum = d && d.data && d.data.data ? d.data.data : d && d.data ? d.data : d ? d : {};
        // if we have clickHighlight and it has length then we need to check it
        if (clickHighlight && clickHighlight.length) {
            var _loop_1 = function (i) {
                // we are checking all keys fresh for each object in click highlight
                var matchedClick = 0;
                // now we need to check each key in interactionKeys, if we have a match with data increment matchedClick
                interactionKeys.map(function (key) {
                    if (clickHighlight[i][key] instanceof Date && datum[key] instanceof Date) {
                        if (clickHighlight[i][key].getTime() === datum[key].getTime()) {
                            matchedClick++;
                        }
                    }
                    else if (clickHighlight[i][key] === datum[key]) {
                        matchedClick++;
                    }
                });
                // check whether all interactions keys matched, if so return true and immediately stop looping
                if (matchedClick === interactionKeys.length) {
                    clickedCheck = true;
                    return "break";
                }
            };
            // loop through each element in clickHighlight
            for (var i = 0; i < clickHighlight.length; i++) {
                var state_1 = _loop_1(i);
                if (state_1 === "break")
                    break;
            }
        }
        // return results back to component if we have interaction keys and interaction keys length
        return interactionKeys && interactionKeys.length && clickedCheck;
    }
    var buildStrokes = function (_a) {
        var root = _a.root, id = _a.id, colors = _a.colors, clickStyle = _a.clickStyle, hoverStyle = _a.hoverStyle, additionalStrokeSize = _a.additionalStrokeSize, strokeOnHover = _a.strokeOnHover, stacked = _a.stacked, strokeOverride = _a.strokeOverride;
        var strokes = {};
        var additionalStrokeExists = additionalStrokeSize || additionalStrokeSize === 0;
        var i = 0;
        colors.forEach(function (color) {
            var restSize = additionalStrokeExists ? additionalStrokeSize : 1;
            if (!strokes['rest' + color]) {
                strokes['rest' + color] = createMultiStrokeFilter({
                    root: root,
                    id: id,
                    state: 'rest',
                    fillColor: color,
                    forceStrokeColor: strokeOverride && strokeOverride.length ? strokeOverride[i] : undefined,
                    strokeWidth: restSize,
                    includeOuterStroke: true,
                    alwaysShowStroke: !!additionalStrokeExists,
                    stacked: stacked
                });
            }
            if (additionalStrokeExists && !strokes['default' + color]) {
                strokes['default' + color] = createMultiStrokeFilter({
                    root: root,
                    id: id,
                    state: 'default',
                    fillColor: color,
                    forceStrokeColor: strokeOverride && strokeOverride.length ? strokeOverride[i] : undefined,
                    strokeWidth: 1,
                    includeOuterStroke: true,
                    alwaysShowStroke: !!additionalStrokeExists,
                    stacked: stacked
                });
            }
            if (hoverStyle && hoverStyle.color && !strokes['hover' + hoverStyle.color]) {
                strokes['hover' + hoverStyle.color] = createMultiStrokeFilter({
                    root: root,
                    id: id,
                    state: 'hover',
                    fillColor: hoverStyle.color,
                    strokeWidth: hoverStyle && hoverStyle.strokeWidth ? parseFloat(hoverStyle.strokeWidth) : defaultHoverStrokeWidth,
                    includeOuterStroke: true,
                    strokeOnHover: strokeOnHover,
                    alwaysShowStroke: !!additionalStrokeExists,
                    stacked: stacked
                });
            }
            else {
                strokes['hover' + color] = createMultiStrokeFilter({
                    root: root,
                    id: id,
                    state: 'hover',
                    fillColor: color,
                    forceStrokeColor: strokeOverride && strokeOverride.length ? strokeOverride[i] : undefined,
                    strokeWidth: hoverStyle && hoverStyle.strokeWidth ? parseFloat(hoverStyle.strokeWidth) : defaultHoverStrokeWidth,
                    includeOuterStroke: true,
                    strokeOnHover: strokeOnHover,
                    alwaysShowStroke: !!additionalStrokeExists,
                    stacked: stacked
                });
            }
            if (clickStyle && clickStyle.color && !strokes['click' + clickStyle.color]) {
                strokes['click' + clickStyle.color] = createMultiStrokeFilter({
                    root: root,
                    id: id,
                    state: 'click',
                    fillColor: clickStyle.color,
                    strokeWidth: clickStyle && clickStyle.strokeWidth ? parseFloat(clickStyle.strokeWidth) : defaultClickStrokeWidth,
                    includeOuterStroke: true,
                    alwaysShowStroke: !!additionalStrokeExists,
                    stacked: stacked
                });
            }
            else {
                strokes['click' + color] = createMultiStrokeFilter({
                    root: root,
                    id: id,
                    state: 'click',
                    fillColor: color,
                    forceStrokeColor: strokeOverride && strokeOverride.length ? strokeOverride[i] : undefined,
                    strokeWidth: clickStyle && clickStyle.strokeWidth ? parseFloat(clickStyle.strokeWidth) : defaultClickStrokeWidth,
                    includeOuterStroke: true,
                    alwaysShowStroke: !!additionalStrokeExists,
                    stacked: stacked
                });
            }
            i++;
        });
        return strokes;
    };
    var interactionStyle = function (_a) {
        var data = _a.data, clickHighlight = _a.clickHighlight, hoverHighlight = _a.hoverHighlight, clickStyle = _a.clickStyle, hoverStyle = _a.hoverStyle, interactionKeys = _a.interactionKeys, defaultStroke = _a.defaultStroke, defaultStrokeWidth = _a.defaultStrokeWidth, offset = _a.offset;
        var strokeColor = clickHighlight.length > 0 && checkClicked(data, clickHighlight, interactionKeys)
            ? defaultStroke
            : hoverHighlight && checkHovered(data, hoverHighlight, interactionKeys)
                ? defaultStroke
                : 'none';
        var strokeStyle = checkClicked(data, clickHighlight, interactionKeys) ? 'solid' : 'dashed';
        var strokeWidth = checkClicked(data, clickHighlight, interactionKeys)
            ? clickStyle.strokeWidth || defaultStrokeWidth
            : hoverHighlight && checkHovered(data, hoverHighlight, interactionKeys) && hoverStyle.strokeWidth
                ? hoverStyle.strokeWidth || defaultStrokeWidth
                : 0;
        if (typeof strokeWidth === 'string' && strokeWidth.includes('px')) {
            strokeWidth = parseInt(strokeWidth.substr(0, strokeWidth.indexOf('p')));
        }
        var strokeOffset = offset ? strokeWidth + offset : strokeWidth;
        // const strokeOffset = checkClicked(data, clickHighlight, interactionKeys) ? strokeWidth : strokeWidth + 2;
        return ("outline-color:" +
            strokeColor +
            ";\n        outline-style:" +
            strokeStyle +
            ";\n        outline-width:" +
            strokeWidth +
            "px;\n        outline-offset:-" +
            strokeOffset +
            "px;");
    };

    /**
     * Copyright (c) 2020, 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var tickArguments = [];
    var tickValues = null;
    var transitionDuration = 750;
    var orient = 1;
    var tickFormat$1 = null;
    var tickSizeInner = 6;
    var tickSizeOuter = 6;
    var tickPadding = 3;
    var xOffset = 0;
    var yOffset = 0;
    var tickWidth = 0;
    var scale$1;
    var hideAxisPath;
    var k = 1;
    var x$1 = 'x';
    var transform = translateX;
    var orientTop = 1;
    var orientRight = 2;
    var orientBottom = 3;
    var orientLeft = 4;
    var epsilon$1 = 1e-6;
    var drawAxis = function (_a) {
        var root = _a.root, height = _a.height, width = _a.width, axisScale = _a.axisScale, left = _a.left, right = _a.right, top = _a.top, wrapLabel = _a.wrapLabel, format = _a.format, dateFormat = _a.dateFormat, tickInterval = _a.tickInterval, label = _a.label, padding = _a.padding, hide = _a.hide, markOffset = _a.markOffset, hidePath = _a.hidePath, ticks = _a.ticks, duration = _a.duration;
        transitionDuration = duration || duration === 0 ? duration : transitionDuration;
        scale$1 = axisScale;
        hideAxisPath = hidePath;
        tickValues = ticks ? ticks : null;
        var opacity = 1;
        if (hide) {
            opacity = 0;
        }
        tickWidth = wrapLabel ? wrapLabel : 0;
        if (markOffset) {
            // mark line at x=0
            if (left) {
                var axisBase = root.selectAll('.axis-mark-y');
                if (axisBase.empty()) {
                    transitionDuration = 0;
                    axisBase = root.append('g').attr('class', 'axis-mark-y axis-mark');
                }
                tickFormat$1 = function () { return null; };
                orient = orientLeft;
                setOrientation();
                var context = axisBase.attr('data-testid', 'y-axis-mark');
                // .attr('transform', markOffset > 0 ? `translate(${markOffset}, 0)` : '')
                if (transitionDuration) {
                    context = context
                        .transition('axis_base')
                        .ease(circleIn)
                        .duration(transitionDuration);
                }
                context
                    .attr('transform', markOffset > 0 ? "translate(" + markOffset + ", 0)" : '')
                    .attr('opacity', opacity)
                    .call(axis);
            }
            else {
                // mark line at y=0
                var axisBase = root.selectAll('.axis-mark-x');
                if (axisBase.empty()) {
                    transitionDuration = 0;
                    axisBase = root.append('g');
                }
                tickFormat$1 = function () { return null; };
                orient = orientBottom;
                setOrientation();
                var context = axisBase.attr('class', 'axis-mark-x axis-mark').attr('data-testid', 'x-axis-mark');
                if (transitionDuration) {
                    context = context
                        .transition('axis_base')
                        .ease(circleIn)
                        .duration(transitionDuration);
                }
                context
                    .attr('transform', markOffset > 0 ? "translate(0, " + markOffset + ")" : '')
                    .attr('opacity', opacity)
                    .call(axis);
            }
        }
        else if (left) {
            // left y axis
            var axisNode = root
                .selectAll('.axis')
                .filter('.y')
                .filter('.left');
            var axisLabel = root
                .selectAll('.axis-label')
                .filter('.y')
                .filter('.left');
            if (axisNode.empty()) {
                transitionDuration = 0;
                axisNode = root.append('g');
                axisLabel = root.append('text');
            }
            tickFormat$1 = function (data, i) {
                if (tickInterval && i % tickInterval !== 0) {
                    return null;
                }
                else if (format && typeof data === 'number') {
                    return formatStats(data, format);
                }
                else if (data instanceof Date) {
                    var formatTime = timeFormat(dateFormat);
                    return formatTime(data);
                }
                else {
                    return data;
                }
            };
            tickSizeInner = 0;
            tickSizeOuter = 0;
            tickPadding = 10;
            if (tickWidth) {
                xOffset = -8;
                yOffset = 0.6;
            }
            orient = orientLeft;
            setOrientation();
            var context = axisNode.attr('class', 'y axis left').attr('data-testid', 'y-axis');
            if (transitionDuration) {
                context = context
                    .transition('axis_node')
                    .ease(circleIn)
                    .duration(transitionDuration);
            }
            context.attr('opacity', opacity).call(axis);
            var labelContext = axisLabel
                .attr('class', 'y axis-label left')
                .attr('data-testid', 'y-axis-label')
                .attr('transform', "rotate(-90)")
                .text(label);
            if (transitionDuration) {
                labelContext = labelContext
                    .transition('axis_label')
                    .ease(circleIn)
                    .duration(transitionDuration);
            }
            labelContext
                .attr('y', padding ? 0 - padding.left : -50)
                .attr('x', 0 - height / 2)
                .attr('dy', '1em');
            // .attr("opacity",opacity);
        }
        else if (right) {
            // right y axis
            var axisNode = root
                .selectAll('.axis')
                .filter('.y')
                .filter('.right');
            var axisLabel = root
                .selectAll('.axis-label')
                .filter('.y')
                .filter('.right');
            if (axisNode.empty()) {
                transitionDuration = 0;
                axisNode = root.append('g');
                axisLabel = root.append('text');
            }
            tickFormat$1 = function (data, i) {
                if (tickInterval && i % tickInterval !== 0) {
                    return null;
                }
                else if (format && typeof data === 'number') {
                    return formatStats(data, format);
                }
                else if (data instanceof Date) {
                    var formatTime = timeFormat(dateFormat);
                    return formatTime(data);
                }
                else {
                    return data;
                }
            };
            tickSizeInner = 0;
            tickSizeOuter = 0;
            tickPadding = 10;
            if (tickWidth) {
                xOffset = 8;
                yOffset = 0.6;
            }
            orient = orientRight;
            setOrientation();
            var context = axisNode.attr('class', 'y axis right').attr('data-testid', 'sec-y-axis');
            if (transitionDuration) {
                context = context
                    .transition('axis_node')
                    .ease(circleIn)
                    .duration(transitionDuration);
            }
            context
                .attr('transform', "translate(" + width + ",0)")
                .attr('opacity', opacity)
                .call(axis);
            var labelContext = axisLabel
                .attr('class', 'y axis-label right')
                .attr('data-testid', 'sec-y-axis-label')
                .attr('transform', "rotate(-90)")
                .text(label || 'Cumulative Percentage');
            if (transitionDuration) {
                labelContext = labelContext
                    .transition('axis_label')
                    .ease(circleIn)
                    .duration(transitionDuration);
            }
            labelContext
                .attr('y', padding ? width + padding.left + padding.right - 50 : width - 50)
                .attr('x', 0 - height / 2)
                .attr('dy', '1em');
            // .attr("opacity",opacity);
        }
        else if (top) {
            // x axis on top
            var axisNode = root
                .selectAll('.axis')
                .filter('.x')
                .filter('.top');
            var axisLabel = root
                .selectAll('.axis-label')
                .filter('.x')
                .filter('.top');
            if (axisNode.empty()) {
                transitionDuration = 0;
                axisNode = root.append('g');
                axisLabel = root.append('text');
            }
            tickFormat$1 = function (data, i) {
                if (tickInterval && i % tickInterval !== 0) {
                    return null;
                }
                else if (format && typeof data === 'number') {
                    return formatStats(data, format);
                }
                else if (data instanceof Date) {
                    var formatTime = timeFormat(dateFormat);
                    return formatTime(data);
                }
                else {
                    return data;
                }
            };
            tickSizeInner = 0;
            tickSizeOuter = 0;
            tickPadding = 10;
            if (tickWidth) {
                xOffset = 0;
                yOffset = 1;
            }
            orient = orientTop;
            setOrientation();
            var context = axisNode.attr('class', 'x axis top').attr('data-testid', 'sec-x-axis');
            if (transitionDuration) {
                context = context
                    .transition('axis_node')
                    .ease(circleIn)
                    .duration(transitionDuration);
            }
            context
                .attr('transform', "translate(0, 0)")
                .attr('opacity', opacity)
                .call(axis);
            var labelContext = axisLabel
                .attr('class', 'x axis-label top')
                .attr('data-testid', 'sec-x-axis-label')
                .attr('transform', "translate(0, 0)")
                .text(format && typeof label === 'number' ? formatStats(label, format) : label);
            if (transitionDuration) {
                labelContext = labelContext
                    .transition('axis_label')
                    .ease(circleIn)
                    .duration(transitionDuration);
            }
            labelContext
                .attr('x', width / 2)
                .attr('y', padding ? -padding.top : -50)
                .attr('dy', '1em');
            // .attr("opacity",opacity);
        }
        else {
            // x axis at bottom
            var axisNode = root
                .selectAll('.axis')
                .filter('.x')
                .filter('.bottom');
            var axisLabel = root
                .selectAll('.axis-label')
                .filter('.x')
                .filter('.bottom');
            if (axisNode.empty()) {
                transitionDuration = 0;
                axisNode = root.append('g');
                axisLabel = root.append('text');
            }
            tickFormat$1 = function (data, i) {
                if (tickInterval && i % tickInterval !== 0) {
                    return null;
                }
                else if (format && typeof data === 'number') {
                    return formatStats(data, format);
                }
                else if (data instanceof Date) {
                    var formatTime = timeFormat(dateFormat);
                    return formatTime(data);
                }
                else {
                    return data;
                }
            };
            tickSizeInner = 0;
            tickSizeOuter = 0;
            tickPadding = 10;
            if (tickWidth) {
                xOffset = 0;
                yOffset = 1;
            }
            orient = orientBottom;
            setOrientation();
            var context = axisNode.attr('class', 'x axis bottom').attr('data-testid', 'x-axis');
            if (transitionDuration) {
                context = context
                    .transition('axis_node')
                    .ease(circleIn)
                    .duration(transitionDuration);
            }
            context
                .attr('transform', "translate(0, " + height + ")")
                .attr('opacity', opacity)
                .call(axis);
            var labelContext = axisLabel
                .attr('class', 'x axis-label bottom')
                .attr('data-testid', 'x-axis-label')
                .attr('transform', "translate(0, 0)")
                .text(format && typeof label === 'number' ? formatStats(label, format) : label);
            if (transitionDuration) {
                labelContext = labelContext
                    .transition('axis_node')
                    .ease(circleIn)
                    .duration(transitionDuration);
            }
            labelContext.attr('x', width / 2).attr('y', padding ? height + padding.bottom : height);
            // .attr("opacity",opacity);
        }
        // transitionDuration = 750;
    };
    function axis(context) {
        var values = tickValues == null ? (scale$1.ticks ? scale$1.ticks.apply(scale$1, tickArguments) : scale$1.domain()) : tickValues;
        var format = tickFormat$1 == null ? (scale$1.tickFormat ? scale$1.tickFormat.apply(scale$1, tickArguments) : identity$3) : tickFormat$1;
        var spacing = Math.max(tickSizeInner, 0) + tickPadding;
        var range = scale$1.range();
        var range0 = +range[0] + 0.5;
        var range1 = +range[range.length - 1] + 0.5;
        var position = (scale$1.bandwidth ? center : number$1)(scale$1.copy());
        var selection = context.selection ? context.selection() : context;
        var path = selection.selectAll('.domain').data([null]);
        var tick = selection
            .selectAll('.tick')
            .data(values, scale$1)
            .order();
        var tickExit = tick.exit();
        var tickEnter = tick
            .enter()
            .append('g')
            .attr('class', 'tick')
            .attr('data-testid', 'axis-tick');
        var line = tick.select('line');
        var text = tick.select('text');
        path = path.merge(path
            .enter()
            .insert('path', '.tick')
            .attr('class', 'domain')
            .attr('stroke', 'currentColor'));
        selection.selectAll('.domain').attr('class', hideAxisPath ? 'domain hidden' : 'domain');
        tick = tick.merge(tickEnter);
        line = line.merge(tickEnter
            .append('line')
            .attr('data-testid', 'axis-tick-line')
            .attr('stroke', 'currentColor')
            .attr(x$1 + '2', k * tickSizeInner));
        if (!scale$1.formattedTicks) {
            scale$1.formattedTicks = [];
        }
        text = text
            .merge(tickEnter
            .append('text')
            .attr('data-testid', 'axis-tick-text')
            .attr('fill', 'currentColor')
            .attr(x$1, k * spacing)
            .attr('dy', orient === orientTop ? '0em' : orient === orientBottom ? '0.71em' : '0.32em'))
            .text(function (d, i) {
            if (format(d, i)) {
                scale$1.formattedTicks.push(format(d, i));
            }
            return format(d, i);
        });
        if (tickWidth > 0) {
            text.call(wrap);
        }
        if (context !== selection && transitionDuration) {
            path = path
                .transition(context)
                .duration(transitionDuration)
                .ease(circleIn);
            tick = tick
                .transition(context)
                .duration(transitionDuration)
                .ease(circleIn);
            line = line
                .transition(context)
                .duration(transitionDuration)
                .ease(circleIn);
            text = text
                .transition(context)
                .duration(transitionDuration)
                .ease(circleIn);
            tickExit = tickExit
                .transition(context)
                .attr('opacity', epsilon$1)
                .attr('transform', function (d) {
                return isFinite((d = position(d))) ? transform(d) : this.getAttribute('transform');
            });
            tickEnter.attr('opacity', epsilon$1).attr('transform', function (d) {
                var p = this.parentNode.__axis;
                return transform(p && isFinite((p = p(d))) ? p : position(d));
            });
        }
        tickExit.remove();
        path.attr('d', orient === orientLeft || orient === orientRight
            ? tickSizeOuter
                ? 'M' + k * tickSizeOuter + ',' + range0 + 'H0.5V' + range1 + 'H' + k * tickSizeOuter
                : 'M0.5,' + range0 + 'V' + range1
            : tickSizeOuter
                ? 'M' + range0 + ',' + k * tickSizeOuter + 'V0.5H' + range1 + 'V' + k * tickSizeOuter
                : 'M' + range0 + ',0.5H' + range1);
        tick.attr('opacity', 1).attr('transform', function (d) { return transform(position(d)); });
        line.attr(x$1 + '2', k * tickSizeInner);
        text.attr(x$1, k * spacing);
        selection
            .filter(entering)
            .attr('fill', 'none')
            .attr('font-size', 10)
            .attr('font-family', 'sans-serif')
            .attr('text-anchor', orient === orientRight ? 'start' : orient === orientLeft ? 'end' : 'middle');
        selection.each(function () {
            this.__axis = position;
        });
    }
    function wrap(selection) {
        selection.each(function () {
            var text = select(this);
            var words = manuallyWrapText({
                text: text.text(),
                width: tickWidth,
                fontSize: 12,
                noPadding: false,
                wholeWords: false
            });
            var lineHeight = yOffset; // ems
            var lineNumber = 0;
            var y = text.attr('y');
            var dy = parseFloat(text.attr('dy'));
            text.text(null);
            words.forEach(function (word) {
                text
                    .append('tspan')
                    .attr('data-testid', 'axis-tick-text-tspan')
                    .attr('x', xOffset)
                    .attr('y', y)
                    .attr('dy', lineNumber * lineHeight + dy + 'em')
                    .text(word);
                lineNumber++;
            });
        });
    }
    function setOrientation() {
        k = orient === orientTop || orient === orientLeft ? -1 : 1;
        x$1 = orient === orientLeft || orient === orientRight ? 'x' : 'y';
        transform = orient === orientTop || orient === orientBottom ? translateX : translateY;
    }
    function identity$3(id) {
        return id;
    }
    function translateX(xPos) {
        return 'translate(' + (xPos + 0.5) + ',0)';
    }
    function translateY(yPos) {
        return 'translate(0,' + (yPos + 0.5) + ')';
    }
    function number$1(scaleFunction) {
        return function (d) {
            return +scaleFunction(d);
        };
    }
    function center(scaleFunction) {
        var offset = Math.max(0, scaleFunction.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
        if (scaleFunction.round()) {
            offset = Math.round(offset);
        }
        return function (d) {
            return +scaleFunction(d) + offset;
        };
    }
    function entering() {
        return !this.__axis;
    }

    var slice$2 = Array.prototype.slice;

    function identity$4 (x) {
        return x;
    }

    var top = 1, right = 2, bottom = 3, left = 4, epsilon$2 = 1e-6;
    function translateX$1(x) {
        return "translate(" + (x + 0.5) + ",0)";
    }
    function translateY$1(y) {
        return "translate(0," + (y + 0.5) + ")";
    }
    function number$2(scale) {
        return function (d) {
            return +scale(d);
        };
    }
    function center$1(scale) {
        var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
        if (scale.round())
            offset = Math.round(offset);
        return function (d) {
            return +scale(d) + offset;
        };
    }
    function entering$1() {
        return !this.__axis;
    }
    function axis$1(orient, scale) {
        var tickArguments = [], tickValues = null, tickFormat = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, k = orient === top || orient === left ? -1 : 1, x = orient === left || orient === right ? "x" : "y", transform = orient === top || orient === bottom ? translateX$1 : translateY$1;
        function axis(context) {
            var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues, format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$4) : tickFormat, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + 0.5, range1 = +range[range.length - 1] + 0.5, position = (scale.bandwidth ? center$1 : number$2)(scale.copy()), selection = context.selection ? context.selection() : context, path = selection.selectAll(".domain").data([null]), tick = selection.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
            path = path.merge(path.enter().insert("path", ".tick")
                .attr("class", "domain")
                .attr("stroke", "currentColor"));
            tick = tick.merge(tickEnter);
            line = line.merge(tickEnter.append("line")
                .attr("stroke", "currentColor")
                .attr(x + "2", k * tickSizeInner));
            text = text.merge(tickEnter.append("text")
                .attr("fill", "currentColor")
                .attr(x, k * spacing)
                .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
            if (context !== selection) {
                path = path.transition(context);
                tick = tick.transition(context);
                line = line.transition(context);
                text = text.transition(context);
                tickExit = tickExit.transition(context)
                    .attr("opacity", epsilon$2)
                    .attr("transform", function (d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });
                tickEnter
                    .attr("opacity", epsilon$2)
                    .attr("transform", function (d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
            }
            tickExit.remove();
            path
                .attr("d", orient === left || orient == right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M0.5," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + ",0.5H" + range1));
            tick
                .attr("opacity", 1)
                .attr("transform", function (d) { return transform(position(d)); });
            line
                .attr(x + "2", k * tickSizeInner);
            text
                .attr(x, k * spacing)
                .text(format);
            selection.filter(entering$1)
                .attr("fill", "none")
                .attr("font-size", 10)
                .attr("font-family", "sans-serif")
                .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
            selection
                .each(function () { this.__axis = position; });
        }
        axis.scale = function (_) {
            return arguments.length ? (scale = _, axis) : scale;
        };
        axis.ticks = function () {
            return tickArguments = slice$2.call(arguments), axis;
        };
        axis.tickArguments = function (_) {
            return arguments.length ? (tickArguments = _ == null ? [] : slice$2.call(_), axis) : tickArguments.slice();
        };
        axis.tickValues = function (_) {
            return arguments.length ? (tickValues = _ == null ? null : slice$2.call(_), axis) : tickValues && tickValues.slice();
        };
        axis.tickFormat = function (_) {
            return arguments.length ? (tickFormat = _, axis) : tickFormat;
        };
        axis.tickSize = function (_) {
            return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
        };
        axis.tickSizeInner = function (_) {
            return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
        };
        axis.tickSizeOuter = function (_) {
            return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
        };
        axis.tickPadding = function (_) {
            return arguments.length ? (tickPadding = +_, axis) : tickPadding;
        };
        return axis;
    }
    function axisBottom(scale) {
        return axis$1(bottom, scale);
    }
    function axisLeft(scale) {
        return axis$1(left, scale);
    }

    /**
     * Copyright (c) 2020, 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var drawGrid = function (root, height, width, axis, left, hide, tickInterval, duration) {
        var transitionDuration = duration || duration === 0 ? duration : 750;
        var opacity = 1;
        if (hide) {
            opacity = 0;
        }
        if (left) {
            var grid = root.selectAll('.grid').filter('.left');
            if (!grid.node()) {
                transitionDuration = 0;
                grid = root
                    .append('g')
                    .attr('class', 'grid left')
                    .attr('data-testid', 'grid-left');
            }
            var context = grid;
            if (transitionDuration) {
                context = grid
                    .transition('grid-left-update')
                    .duration(transitionDuration)
                    .ease(circleIn);
            }
            context.attr('opacity', opacity).call(axisLeft(axis)
                .tickSize(-width)
                .tickFormat('')
                .tickValues((axis.ticks ? axis.ticks() : axis.domain()).filter(function (_, i) { return !(tickInterval && i % tickInterval !== 0); })));
        }
        else {
            var grid = root.selectAll('.grid').filter('.bottom');
            if (!grid.node()) {
                transitionDuration = 0;
                grid = root
                    .append('g')
                    .attr('class', 'grid bottom')
                    .attr('data-testid', 'grid-bottom');
            }
            var context = grid;
            if (transitionDuration) {
                context = grid
                    .transition('grid-bottom-update')
                    .duration(transitionDuration)
                    .ease(circleIn);
            }
            context.attr('opacity', opacity).call(axisBottom(axis)
                .tickSize(height)
                .tickFormat('')
                .tickValues((axis.ticks ? axis.ticks() : axis.domain()).filter(function (_, i) { return !(tickInterval && i % tickInterval !== 0); })));
        }
    };

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var baseSymbols = {
        /*13*/ cross: 'M-1.0606601717798214,-0.3535533905932738L-0.3535533905932738,-0.3535533905932738L-0.3535533905932738,-1.0606601717798214L0.3535533905932738,-1.0606601717798214L0.3535533905932738,-0.3535533905932738L1.0606601717798214,-0.3535533905932738L1.0606601717798214,0.3535533905932738L0.3535533905932738,0.3535533905932738L0.3535533905932738,1.0606601717798214L-0.3535533905932738,1.0606601717798214L-0.3535533905932738,0.3535533905932738L-1.0606601717798214,0.3535533905932738Z',
        /*14*/ circle: 'M1,0A1,1,0,1,1,-1,0A1,1,0,1,1,1,0',
        /*2*/ square: 'M-0.9219544457292888,-0.9219544457292888h1.8439088914585775v1.8439088914585775h-1.8439088914585775Z',
        /*11*/ star: 'M0,-1.4621735258409942L0.3282784098583098,-0.4518364682100035L1.3906096597053377,-0.4518364682100036L0.5311656249235138,0.17258617349950994L0.859444034781824,1.1829232311305005L1.1102230246251565e-16,0.5585005894209871L-0.8594440347818236,1.1829232311305007L-0.5311656249235137,0.17258617349951003L-1.390609659705338,-0.4518364682100033L-0.3282784098583099,-0.4518364682100034Z',
        /*4*/ triangle: 'M0,-1.330616708716245L1.1523478724483067,0.6653083543581225L-1.1523478724483067,0.6653083543581225Z',
        /*5*/ diamond: 'M0,-1.4416868484808527L0.8323582900575635,0L0,1.4416868484808527L-0.8323582900575635,0Z'
    };
    var generalizedSymbols = {
        cross: 'M-1.0606601238250732,-0.3535534143447876L-0.919238805770874,-0.3535534143447876L-0.7778174877166748,-0.3535534143447876L-0.6363961100578308,-0.3535534143447876L-0.4949747920036316,-0.3535534143447876L-0.3535534739494324,-0.3535534143447876L-0.3535533845424652,-0.4949747323989868L-0.3535533845424652,-0.636396050453186L-0.3535534143447876,-0.7778173685073853L-0.3535534143447876,-0.9192386865615845L-0.3535534143447876,-1.0606600046157837L-0.21213221549987793,-1.0606601238250732L-0.07071077823638916,-1.0606601238250732L0.07071053981781006,-1.0606601238250732L0.21213185787200928,-1.0606601238250732L0.3535531759262085,-1.0606601238250732L0.35355344414711,-0.9192389249801636L0.35355344414711,-0.7778176069259644L0.3535534143447876,-0.6363962888717651L0.3535534143447876,-0.4949749708175659L0.3535534143447876,-0.3535536527633667L0.49497461318969727,-0.3535534143447876L0.6363959312438965,-0.3535534143447876L0.7778174877166748,-0.3535534143447876L0.919238805770874,-0.3535534143447876L1.0606601238250732,-0.3535534143447876L1.0606601238250732,-0.21213233470916748L1.0606601238250732,-0.07071101665496826L1.0606601238250732,0.07071030139923096L1.0606601238250732,0.21213161945343018L1.0606601238250732,0.3535529375076294L0.9192391633987427,0.35355332493782043L0.7778178453445435,0.3535533547401428L0.6363965272903442,0.3535533845424652L0.494975209236145,0.3535533845424652L0.3535538911819458,0.3535534143447876L0.35355344414711,0.49497437477111816L0.35355344414711,0.6363956928253174L0.3535534143447876,0.7778170108795166L0.3535534143447876,0.9192383289337158L0.3535534143447876,1.060659646987915L0.21213233470916748,1.0606600046157837L0.07071101665496826,1.0606600046157837L-0.07071030139923096,1.0606601238250732L-0.21213161945343018,1.0606601238250732L-0.3535529375076294,1.0606601238250732L-0.3535533845424652,0.9192386865615845L-0.3535533845424652,0.7778173685073853L-0.3535534143447876,0.636396050453186L-0.3535534143447876,0.4949747323989868L-0.3535534143447876,0.3535534143447876L-0.49497485160827637,0.35355332493782043L-0.6363961696624756,0.3535533547401428L-0.7778174877166748,0.3535533845424652L-0.919238805770874,0.3535533845424652L-1.0606601238250732,0.3535534143447876L-1.0606601238250732,0.21213185787200928L-1.0606601238250732,0.07071053981781006L-1.0606601238250732,-0.07071077823638916L-1.0606601238250732,-0.21213209629058838Z',
        circle: 'M1,0L0.9952487945556641,0.10496900230646133L0.9802308678627014,0.20940586924552917L0.9531400799751282,0.31073155999183655L0.9148818850517273,0.4079720079898834L0.8663365244865417,0.5002545714378357L0.8094649910926819,0.5883480906486511L0.743568480014801,0.6698152422904968L0.6695123314857483,0.7439088225364685L0.5881620049476624,0.8099220395088196L0.5004010796546936,0.867180347442627L0.4069012701511383,0.9140697717666626L0.30910128355026245,0.9513185620307922L0.2079721838235855,0.9784069061279297L0.10456041246652603,0.9948219656944275L9.057112038135529e-8,1L-0.10454819351434708,0.994599461555481L-0.20796485245227814,0.9783451557159424L-0.30910056829452515,0.9513131976127625L-0.40682557225227356,0.9137774109840393L-0.5000651478767395,0.8661796450614929L-0.5878113508224487,0.8090839982032776L-0.6691301465034485,0.7431550621986389L-0.7431550025939941,0.6691302061080933L-0.8090841770172119,0.5878111720085144L-0.8661795258522034,0.5000653266906738L-0.9137775301933289,0.4068255126476288L-0.9513131976127625,0.30910077691078186L-0.9783450961112976,0.20796531438827515L-0.994599461555481,0.10454835742712021L-1,1.5099580252808664e-7L-0.9952487945556641,-0.1049688383936882L-0.9802308082580566,-0.2094057947397232L-0.953140139579773,-0.3107314109802246L-0.9148820638656616,-0.4079718291759491L-0.8663367629051208,-0.5002543926239014L-0.8094651103019714,-0.5883479714393616L-0.7435685396194458,-0.6698151230812073L-0.6695123314857483,-0.7439088225364685L-0.5881620645523071,-0.8099220395088196L-0.5004012584686279,-0.867180347442627L-0.4069012701511383,-0.9140697717666626L-0.30910128355026245,-0.9513185620307922L-0.20797239243984222,-0.9784069061279297L-0.10456059128046036,-0.9948219656944275L-3.026798367500305e-9,-1L0.10454817116260529,-0.994599461555481L0.2079651653766632,-0.9783450961112976L0.30910080671310425,-0.9513131380081177L0.4068260192871094,-0.913777232170105L0.5000655055046082,-0.8661794066429138L0.587811291217804,-0.8090839982032776L0.6691306233406067,-0.7431545853614807L0.7431554198265076,-0.6691297292709351L0.8090841770172119,-0.5878111124038696L0.866179883480072,-0.5000647306442261L0.9137775301933289,-0.4068252444267273L0.9513131976127625,-0.309100478887558L0.9783451557159424,-0.20796477794647217L0.9945995211601257,-0.10454780608415604Z',
        square: 'M-0.9219544529914856,-0.9219544529914856L-0.799027144908905,-0.9219544529914856L-0.676099956035614,-0.9219544529914856L-0.5531726479530334,-0.9219544529914856L-0.4302453398704529,-0.9219544529914856L-0.30731815099716187,-0.9219544529914856L-0.18439096212387085,-0.9219544529914856L-0.06146365404129028,-0.9219544529914856L0.06146365404129028,-0.9219544529914856L0.1843908429145813,-0.9219544529914856L0.30731815099716187,-0.9219544529914856L0.43024545907974243,-0.9219544529914856L0.5531726479530334,-0.9219544529914856L0.676099956035614,-0.9219544529914856L0.799027144908905,-0.9219544529914856L0.9219544529914856,-0.9219544529914856L0.9219545125961304,-0.799027144908905L0.9219545125961304,-0.676099956035614L0.9219545125961304,-0.553172767162323L0.9219545125961304,-0.4302453398704529L0.9219545125961304,-0.30731815099716187L0.9219545125961304,-0.18439096212387085L0.9219545125961304,-0.06146353483200073L0.9219545125961304,0.06146365404129028L0.9219545125961304,0.1843908429145813L0.9219544529914856,0.3073182702064514L0.9219544529914856,0.43024545907974243L0.9219544529914856,0.5531726479530334L0.9219544529914856,0.6760998368263245L0.9219544529914856,0.7990272641181946L0.9219544529914856,0.9219544529914856L0.7990273833274841,0.9219542145729065L0.676099956035614,0.9219542145729065L0.553172767162323,0.9219542145729065L0.430245578289032,0.9219542741775513L0.30731838941574097,0.9219542741775513L0.18439120054244995,0.9219542741775513L0.06146353483200073,0.921954333782196L-0.06146365404129028,0.921954333782196L-0.1843908429145813,0.921954333782196L-0.3073180317878723,0.921954333782196L-0.43024522066116333,0.9219543933868408L-0.5531724095344543,0.9219543933868408L-0.6760995984077454,0.9219543933868408L-0.7990272641181946,0.9219544529914856L-0.9219544529914856,0.9219544529914856L-0.9219543933868408,0.799027144908905L-0.9219543933868408,0.676099956035614L-0.9219543933868408,0.553172767162323L-0.9219543933868408,0.430245578289032L-0.9219543933868408,0.30731791257858276L-0.9219543933868408,0.18439072370529175L-0.9219543933868408,0.06146353483200073L-0.9219543933868408,-0.06146365404129028L-0.9219543933868408,-0.1843908429145813L-0.9219544529914856,-0.3073180317878723L-0.9219544529914856,-0.43024522066116333L-0.9219544529914856,-0.5531728863716125L-0.9219544529914856,-0.6761000752449036L-0.9219544529914856,-0.7990272641181946Z',
        star: 'M0,-1.462173581123352L0.05471307039260864,-1.2937841415405273L0.1094261109828949,-1.125394582748413L0.16413918137550354,-0.9570050239562988L0.21885225176811218,-0.7886155843734741L0.2735653221607208,-0.6202260255813599L0.32827839255332947,-0.4518364667892456L0.505333662033081,-0.4518364667892456L0.6823887825012207,-0.4518364667892456L0.8594440221786499,-0.4518364667892456L1.036499261856079,-0.4518364667892456L1.2135545015335083,-0.4518364667892456L1.3906097412109375,-0.4518364667892456L1.2473692893981934,-0.34776610136032104L1.104128360748291,-0.24369558691978455L0.9608877897262573,-0.13962522149085999L0.8176472187042236,-0.03555482625961304L0.6744064092636108,0.06851568818092346L0.5311657786369324,0.17258606851100922L0.5858786702156067,0.34097564220428467L0.6405917406082153,0.5093650817871094L0.6953047513961792,0.6777544617652893L0.7500178813934326,0.8461441397666931L0.8047309517860413,1.014533519744873L0.8594440817832947,1.1829231977462769L0.7162032723426819,1.078852653503418L0.5729628205299377,0.9747823476791382L0.42972204089164734,0.8707118630409241L0.28648123145103455,0.76664137840271L0.1432408094406128,0.6625710725784302L1.1102230246251565e-16,0.5585005879402161L-0.1432408094406128,0.6625711917877197L-0.28648126125335693,0.76664137840271L-0.42972204089164734,0.8707119226455688L-0.5729628801345825,0.9747824668884277L-0.7162032723426819,1.078852653503418L-0.8594440817832947,1.1829231977462769L-0.8047309517860413,1.014533519744873L-0.7500178217887878,0.846143901348114L-0.695304811000824,0.6777547001838684L-0.6405916810035706,0.5093650817871094L-0.5858786106109619,0.34097540378570557L-0.531165599822998,0.17258620262145996L-0.674406111240387,0.0685158371925354L-0.8176469206809998,-0.0355546772480011L-0.9608873128890991,-0.1396249234676361L-1.104128122329712,-0.2436954379081726L-1.2473689317703247,-0.3477659523487091L-1.3906097412109375,-0.4518364667892456L-1.2135542631149292,-0.4518364667892456L-1.0364998579025269,-0.4518364667892456L-0.8594444990158081,-0.4518364667892456L-0.6823891401290894,-0.4518364667892456L-0.5053337812423706,-0.4518364667892456L-0.32827839255332947,-0.4518364667892456L-0.27356526255607605,-0.6202262043952942L-0.21885214745998383,-0.788615882396698L-0.16413933038711548,-0.9570046067237854L-0.10942622274160385,-1.1253942251205444L-0.054713111370801926,-1.2937839031219482Z',
        triangle: 'M0,-1.3306167125701904L0.05761754512786865,-1.2308205366134644L0.1152348518371582,-1.1310244798660278L0.17285221815109253,-1.0312281847000122L0.23046964406967163,-0.9314318895339966L0.28808706998825073,-0.8316354751586914L0.34570443630218506,-0.7318392992019653L0.4033218026161194,-0.6320431232452393L0.4609392285346985,-0.5322468280792236L0.5185565948486328,-0.432450532913208L0.5761740207672119,-0.33265429735183716L0.6337913870811462,-0.2328580617904663L0.6914087533950806,-0.13306176662445068L0.7490261793136597,-0.033265531063079834L0.8066436052322388,0.06653076410293579L0.8642609119415283,0.16632699966430664L0.9218782782554626,0.2661232054233551L0.9794957041740417,0.3659195303916931L1.037113070487976,0.4657157063484192L1.0947304964065552,0.5655120611190796L1.1523479223251343,0.6653083562850952L1.0371133089065552,0.6653079986572266L0.921878457069397,0.6653080582618713L0.8066436052322388,0.6653080582618713L0.6914087533950806,0.6653080582618713L0.5761741399765015,0.6653081178665161L0.46093928813934326,0.6653081178665161L0.34570443630218506,0.6653081178665161L0.23046958446502686,0.6653081178665161L0.11523497104644775,0.6653081774711609L1.1920928955078125e-7,0.6653081774711609L-0.11523473262786865,0.6653081774711609L-0.23046934604644775,0.6653082370758057L-0.34570419788360596,0.6653082370758057L-0.46093904972076416,0.6653082370758057L-0.5761736631393433,0.6653082966804504L-0.6914085149765015,0.6653082966804504L-0.8066433668136597,0.6653082966804504L-0.9218782186508179,0.6653082966804504L-1.037113070487976,0.6653083562850952L-1.1523479223251343,0.6653083562850952L-1.094730257987976,0.5655120611190796L-1.037113070487976,0.4657161235809326L-0.9794957041740417,0.365919828414917L-0.9218782782554626,0.26612353324890137L-0.8642608523368835,0.1663271188735962L-0.8066434264183044,0.06653082370758057L-0.7490260004997253,-0.03326547145843506L-0.6914085745811462,-0.13306176662445068L-0.6337913870811462,-0.23285770416259766L-0.5761739611625671,-0.3326539993286133L-0.518556535243988,-0.4324502944946289L-0.4609391391277313,-0.5322465896606445L-0.4033217132091522,-0.6320429444313049L-0.3457042872905731,-0.7318392395973206L-0.288086861371994,-0.831635594367981L-0.2304694503545761,-0.9314318895339966L-0.1728522628545761,-1.0312278270721436L-0.1152348443865776,-1.1310241222381592L-0.0576174221932888,-1.2308204174041748Z',
        diamond: 'M0,-1.4416868686676025L0.05549061298370361,-1.3455744981765747L0.11098116636276245,-1.2494620084762573L0.1664717197418213,-1.15334951877594L0.22196227312088013,-1.057237148284912L0.27745282649993896,-0.96112459897995L0.3329433500766754,-0.8650121688842773L0.38843390345573425,-0.76889967918396L0.4439244568347931,-0.6727872490882874L0.49941501021385193,-0.57667475938797L0.5549055337905884,-0.480562299489975L0.6103960871696472,-0.38444983959198L0.665886640548706,-0.288337379693985L0.7213771939277649,-0.19222491979599L0.7768677473068237,-0.096112459897995L0.8323583006858826,0L0.7768678665161133,0.09611248970031738L0.7213772535324097,0.19222497940063477L0.6658867001533508,0.2883373498916626L0.6103960871696472,0.38444995880126953L0.5549055933952332,0.48056232929229736L0.4994150996208191,0.5766746401786804L0.4439244866371155,0.6727872490882874L0.38843387365341187,0.7688997983932495L0.3329433500766754,0.8650121092796326L0.27745285630226135,0.9611244797706604L0.22196224331855774,1.0572370290756226L0.16647161543369293,1.1533496379852295L0.11098112165927887,1.2494620084762573L0.05549062043428421,1.3455742597579956L0,1.4416868686676025L-0.05549055337905884,1.345574140548706L-0.11098110675811768,1.2494617700576782L-0.16647160053253174,1.15334951877594L-0.22196221351623535,1.057236909866333L-0.27745282649993896,0.9611243605613708L-0.332943320274353,0.865011990070343L-0.3884338140487671,0.7688996195793152L-0.44392454624176025,0.6727868914604187L-0.4994150698184967,0.5766745209693909L-0.5549055337905884,0.4805621802806854L-0.6103960275650024,0.3844498097896576L-0.6658865809440613,0.28833746910095215L-0.7213773131370544,0.19222471117973328L-0.7768678069114685,0.09611235558986664L-0.8323583006858826,0L-0.7768675684928894,-0.09611260890960693L-0.7213770747184753,-0.19222497940063477L-0.6658865809440613,-0.2883373498916626L-0.6103960871696472,-0.38444972038269043L-0.5549055933952332,-0.4805620312690735L-0.4994148910045624,-0.5766748189926147L-0.4439243972301483,-0.6727871894836426L-0.38843390345573425,-0.7688995003700256L-0.3329431712627411,-0.8650122880935669L-0.277452677488327,-0.9611246585845947L-0.22196219861507416,-1.0572370290756226L-0.1664717048406601,-1.1533493995666504L-0.11098121851682663,-1.2494617700576782L-0.055490490049123764,-1.3455744981765747Z'
    };
    var symbols = {
        cross: {
            general: generalizedSymbols.cross,
            base: baseSymbols.cross
        },
        circle: {
            general: generalizedSymbols.circle,
            base: baseSymbols.circle
        },
        square: {
            general: generalizedSymbols.square,
            base: baseSymbols.square
        },
        star: {
            general: generalizedSymbols.star,
            base: baseSymbols.star
        },
        triangle: {
            general: generalizedSymbols.triangle,
            base: baseSymbols.triangle
        },
        diamond: {
            general: generalizedSymbols.diamond,
            base: baseSymbols.diamond
        }
    };

    /**
     * Copyright (c) 2020, 2021, 2022 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var drawLegend = function (_a) {
        var root = _a.root, uniqueID = _a.uniqueID, width = _a.width, height = _a.height, colorArr = _a.colorArr, baseColorArr = _a.baseColorArr, hideStrokes = _a.hideStrokes, dashPatterns = _a.dashPatterns, scale = _a.scale, steps = _a.steps, margin = _a.margin, padding = _a.padding, duration = _a.duration, type = _a.type, secondary = _a.secondary, fontSize = _a.fontSize, data = _a.data, labelKey = _a.labelKey, label = _a.label, symbol = _a.symbol, format = _a.format, hide = _a.hide, hoverHighlight = _a.hoverHighlight, clickHighlight = _a.clickHighlight, groupAccessor = _a.groupAccessor, interactionKeys = _a.interactionKeys, hoverStyle = _a.hoverStyle, clickStyle = _a.clickStyle, hoverOpacity = _a.hoverOpacity;
        var totalWidth = width + padding.left + padding.right + 5;
        var leftOffset = padding.left + margin.left;
        var offsetLegend = type === 'scatter' || type === 'key' || type === 'line' || type === 'bar';
        var legendWidth = steps ? width / steps : 0;
        var legendHeight = 15;
        height = hide ? 0 : height + (offsetLegend ? 25 : 5);
        var opacity = hide ? 0 : 1;
        if (type === 'parallel') {
            type = 'line';
        }
        root.attr('viewBox', '0 0 ' + totalWidth + ' ' + height);
        var paddingWrapper = root.select('.legend-padding-wrapper');
        if (!root.select('.legend-padding-wrapper').size()) {
            paddingWrapper = root.append('g').attr('class', 'legend-padding-wrapper');
        }
        var symbolMod = !symbol ? 4 : 7;
        paddingWrapper.attr('transform', "translate(" + ((offsetLegend ? leftOffset : 0) + symbolMod) + "," + (offsetLegend ? 24 : 4) + ")");
        var filter = createTextStrokeFilter({
            root: root.node(),
            id: uniqueID + "-legend",
            color: '#ffffff'
        });
        switch (type) {
            default:
                root
                    .attr('opacity', opacity)
                    .attr('width', totalWidth)
                    .attr('height', height)
                    .attr('style', hide ? 'display: none;' : null)
                    .attr('transform', "translate(0, 0)");
                var defaultLegend = paddingWrapper.selectAll('.legend.default').data([0].concat(colorArr));
                root.selectAll('.key').remove();
                root.selectAll('.gradient').remove();
                defaultLegend
                    .enter()
                    .append('g')
                    .attr('class', 'legend default')
                    .merge(defaultLegend)
                    .attr('transform', function (_, i) {
                    return i === 0 ? "translate(" + leftOffset + ", 20)" : "translate(" + ((i - 1) * legendWidth + leftOffset) + ", 20)";
                })
                    .each(function (d, i, n) {
                    var gridLabel = i === 0
                        ? formatStats(scale.invertExtent(colorArr[0])[0], format)
                        : formatStats(scale.invertExtent(d)[1], format);
                    var labelPosition = i === 0 ? 0 : legendWidth;
                    var colorGrid = select(n[i])
                        .selectAll('rect')
                        .data([d]);
                    var context = colorGrid
                        .enter()
                        .append('rect')
                        .attr('opacity', 0)
                        .merge(colorGrid)
                        .attr('width', legendWidth)
                        .attr('height', legendHeight)
                        .attr('x', 0)
                        .attr('y', 0)
                        .attr('fill', d);
                    var exitContext = colorGrid.exit();
                    var gridText = select(n[i])
                        .selectAll('text')
                        .data([d]);
                    var textContext = gridText
                        .enter()
                        .append('text')
                        .attr('opacity', 0)
                        .merge(gridText)
                        .attr('dx', labelPosition)
                        .attr('dy', '2.5em')
                        .text(gridLabel);
                    var textExit = gridText.exit();
                    if (duration) {
                        context = context
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        exitContext = exitContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textContext = textContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textExit = textExit
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                    }
                    context.attr('opacity', opacity);
                    exitContext.attr('opacity', 0).remove();
                    textContext.attr('opacity', opacity);
                    textExit.attr('opacity', 0).remove();
                });
                defaultLegend.exit().remove();
                break;
            case 'gradient':
                var gradientId = new Date().getTime();
                // draw legend as a gradient band
                root
                    .attr('width', totalWidth)
                    .attr('height', height)
                    .attr('style', hide ? 'display: none;' : null)
                    .attr('transform', "translate(0, 20)")
                    .attr('opacity', opacity);
                root.selectAll('.key').remove();
                root.selectAll('.default').remove();
                var textDiv = paddingWrapper.selectAll('text.gradient').data([0].concat(colorArr));
                var textContext = textDiv
                    .enter()
                    .append('text')
                    .attr('class', 'legend-text gradient')
                    .merge(textDiv)
                    .attr('transform', function (_, i) {
                    return i === 0 ? "translate(" + leftOffset + ", 0)" : "translate(" + ((i - 1) * legendWidth + leftOffset) + ", 0)";
                })
                    .attr('opacity', 0)
                    .attr('dx', function (_, i) { return (i === 0 ? 0 : legendWidth); })
                    .attr('dy', '2.5em')
                    .text(function (d, i) {
                    return i === 0
                        ? formatStats(scale.invertExtent(colorArr[0])[0], format)
                        : formatStats(scale.invertExtent(d)[1], format);
                });
                var textExit = textDiv.exit();
                if (duration) {
                    textContext = textContext
                        .transition()
                        .duration(duration)
                        .ease(circleIn);
                    textExit = textExit
                        .transition()
                        .duration(duration)
                        .ease(circleIn);
                }
                textContext.attr('opacity', function (_, i) { return (i === 0 || i === colorArr.length ? opacity : 0); });
                textExit.attr('opacity', 0).remove();
                if (!paddingWrapper.selectAll('.legend').empty()) {
                    paddingWrapper.selectAll('.legend').remove();
                }
                var gradientDiv = paddingWrapper.append('g').attr('class', 'legend gradient');
                gradientDiv
                    .append('defs')
                    .append('linearGradient')
                    .attr('id', 'mainGradient-' + gradientId)
                    .selectAll('stop')
                    .data(colorArr)
                    .enter()
                    .append('stop')
                    .attr('offset', function (_, i) { return (100 / colorArr.length) * (i + 1) + '%'; })
                    .attr('stop-color', function (d) { return d; });
                gradientDiv
                    .append('rect')
                    .attr('class', 'legend-gradient')
                    .attr('x', leftOffset)
                    .attr('y', 0)
                    .attr('width', width)
                    .attr('height', legendHeight)
                    .attr('style', 'fill: url(#mainGradient-' + gradientId + ')');
                break;
            case 'key':
                var accumWidth_1 = 0;
                var yPos_1 = 0;
                root
                    .attr('width', totalWidth)
                    .attr('height', height)
                    .attr('opacity', opacity)
                    .attr('style', hide ? 'display: none;' : null);
                var currentKeyLegend = paddingWrapper.selectAll('.legend.key').data(colorArr);
                root.selectAll('.default').remove();
                root.selectAll('.gradient').remove();
                currentKeyLegend
                    .enter()
                    .append('g')
                    .attr('class', 'legend key')
                    .merge(currentKeyLegend)
                    .each(function (d, i, n) {
                    var prevLabel = i === 0
                        ? ''
                        : label
                            ? label[i - 1]
                            : formatStats(scale.invertExtent(colorArr[i - 1])[0], format) +
                                '-' +
                                formatStats(scale.invertExtent(colorArr[i - 1])[1], format);
                    accumWidth_1 = i === 0 ? 0 : accumWidth_1 + getTextWidth(prevLabel, fontSize) + 40;
                    if (accumWidth_1 + getTextWidth(prevLabel, fontSize) > width) {
                        //wrap legends if the length is larger than chart width
                        accumWidth_1 = 0;
                        yPos_1 += fontSize + 10; // line height
                    }
                    var keyLabel = label
                        ? label[i]
                        : formatStats(scale.invertExtent(d)[0], format) + '-' + formatStats(scale.invertExtent(d)[1], format);
                    var keyDot = select(n[i])
                        .selectAll('rect')
                        .data([d]);
                    var context = keyDot
                        .enter()
                        .append('rect')
                        .attr('opacity', 0)
                        .merge(keyDot)
                        .attr('fill', d)
                        .attr('width', 15)
                        .attr('height', 15);
                    var exitContext = keyDot.exit();
                    var keyText = select(n[i])
                        .selectAll('text')
                        .data([keyLabel]);
                    var textContext = keyText
                        .enter()
                        .append('text')
                        .attr('class', 'key-text')
                        .attr('opacity', 0)
                        .merge(keyText)
                        .attr('dx', '.2em')
                        .attr('dy', 13)
                        .text(keyLabel);
                    var textExit = keyText.exit();
                    if (duration) {
                        context = context
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        exitContext = exitContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textContext = textContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textExit = textExit
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                    }
                    context
                        .attr('x', accumWidth_1)
                        .attr('y', yPos_1)
                        .attr('opacity', opacity);
                    exitContext.attr('opacity', 0).remove();
                    textContext
                        .attr('x', accumWidth_1 + 20)
                        .attr('y', yPos_1)
                        .attr('opacity', opacity);
                    textExit.attr('opacity', 0).remove();
                });
                currentKeyLegend.exit().remove();
                break;
            case 'line':
                var accumWidthLine_1 = 0;
                var yPosLine_1 = 0;
                var strokeWidth_1 = 3;
                var dashIdealSize_1 = [28, 28, 26, 28, 26];
                root
                    .attr('width', totalWidth)
                    .attr('height', height)
                    .attr('opacity', 1)
                    .attr('style', hide ? 'display: none;' : null);
                var currentLineLegend = paddingWrapper.selectAll('.legend').data(data);
                currentLineLegend
                    .enter()
                    .append('g')
                    .attr('class', 'legend')
                    .merge(currentLineLegend)
                    .each(function (d, i, n) {
                    var prevLabel = i === 0 ? '' : label ? label[i - 1] : data[i - 1].key;
                    var keyLabel = label ? label[i] : d.key;
                    accumWidthLine_1 = i === 0 ? 0 : accumWidthLine_1 + getTextWidth(prevLabel, fontSize) + 60;
                    if (accumWidthLine_1 + getTextWidth(keyLabel, fontSize) > width) {
                        //wrap legends if the length is larger than chart width
                        accumWidthLine_1 = 0;
                        yPosLine_1 += fontSize + 10; // line height
                    }
                    var keyDot = select(n[i])
                        .selectAll('line')
                        .data([d.key]);
                    var context = keyDot
                        .enter()
                        .append('line')
                        .merge(keyDot)
                        .style('stroke-width', secondary.includes(d.key) ? strokeWidth_1 - 1 : strokeWidth_1)
                        .style('stroke', colorArr[i])
                        .style('stroke-dasharray', secondary.includes(d.key) ? '2,2' : dashPatterns && i < dashPatterns.length ? dashPatterns[i] : '')
                        .attr('stroke-width', secondary.includes(d.key) ? strokeWidth_1 - 1 : strokeWidth_1)
                        .attr('stroke', colorArr[i])
                        .attr('stroke-dasharray', secondary.includes(d.key) ? '2,2' : dashPatterns && i < dashPatterns.length ? dashPatterns[i] : '')
                        .style('opacity', opacity);
                    var exitContext = keyDot.exit();
                    var keyText = select(n[i])
                        .selectAll('text')
                        .data([d.key]);
                    var textContext = keyText
                        .enter()
                        .append('text')
                        .attr('class', 'key-text')
                        .attr('opacity', 0)
                        .merge(keyText)
                        .attr('dx', '.2em')
                        .attr('dy', 13)
                        .text(keyLabel);
                    var textExit = keyText.exit();
                    if (duration) {
                        context = context
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        exitContext = exitContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textContext = textContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textExit = textExit
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                    }
                    context
                        .attr('x1', accumWidthLine_1)
                        .attr('x2', accumWidthLine_1 +
                        (secondary.includes(d.key) ? 30 : dashPatterns && i < dashPatterns.length ? dashIdealSize_1[i] : 30))
                        .attr('y1', yPosLine_1 + 8)
                        .attr('y2', yPosLine_1 + 8);
                    exitContext.attr('opacity', 0).remove();
                    textContext
                        .attr('x', accumWidthLine_1 +
                        5 +
                        (secondary.includes(d.key) ? 30 : dashPatterns && i < dashPatterns.length ? dashIdealSize_1[i] : 30))
                        .attr('y', yPosLine_1)
                        .attr('opacity', opacity);
                    textExit.attr('opacity', 0).remove();
                });
                currentLineLegend.exit().remove();
                break;
            case 'bar':
                var accumWidthBar_1 = 0;
                var yPosBar_1 = 0;
                root
                    .attr('width', totalWidth)
                    .attr('height', height)
                    .attr('opacity', opacity)
                    .attr('style', hide ? 'display: none;' : null);
                var currentBarLegend = paddingWrapper.selectAll('.legend.bar').data(data);
                currentBarLegend
                    .enter()
                    .append('g')
                    .attr('class', 'legend bar')
                    .merge(currentBarLegend)
                    .each(function (d, i, n) {
                    var prevLabel = i === 0
                        ? ''
                        : label && label[i - 1]
                            ? format
                                ? formatStats(label[i - 1], format)
                                : label[i - 1]
                            : format
                                ? formatStats(data[i - 1][labelKey], format)
                                : data[i - 1][labelKey];
                    var keyLabel = label && label[i]
                        ? format
                            ? formatStats(label[i], format)
                            : label[i]
                        : format
                            ? formatStats(d[labelKey], format)
                            : d[labelKey];
                    accumWidthBar_1 = i === 0 ? 0 : accumWidthBar_1 + getTextWidth(prevLabel, fontSize) + 45;
                    if (accumWidthBar_1 + getTextWidth(keyLabel, fontSize) > width) {
                        //wrap legends if the length is larger than chart width
                        accumWidthBar_1 = 0;
                        yPosBar_1 += fontSize + 10; // line height
                    }
                    var keyDot = select(n[i])
                        .selectAll('rect')
                        .data([d[labelKey]]);
                    var context = keyDot
                        .enter()
                        .append('rect')
                        .attr('class', 'bar-rect')
                        .attr('opacity', 0)
                        .merge(keyDot)
                        .attr('fill', scale ? scale(d[labelKey]) : colorArr[i] || colorArr(d[labelKey]))
                        .attr('width', 20)
                        .attr('height', 20);
                    var exitContext = keyDot.exit();
                    var keyText = select(n[i])
                        .selectAll('text')
                        .data([d[labelKey]]);
                    var textContext = keyText
                        .enter()
                        .append('text')
                        .attr('class', 'bar-text')
                        .attr('opacity', 0)
                        .merge(keyText)
                        .attr('dx', '.2em')
                        .attr('dy', 16)
                        .text(keyLabel);
                    var textExit = keyText.exit();
                    if (duration) {
                        context = context
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        exitContext = exitContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textContext = textContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textExit = textExit
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                    }
                    context
                        .attr('x', accumWidthBar_1)
                        .attr('y', yPosBar_1)
                        .attr('opacity', opacity);
                    exitContext.attr('opacity', 0).remove();
                    textContext
                        .attr('x', accumWidthBar_1 + 25)
                        .attr('y', yPosBar_1)
                        .attr('opacity', opacity);
                    textExit.attr('opacity', 0).remove();
                });
                currentBarLegend.exit().remove();
                break;
            case 'scatter':
                var accumWidthScatter_1 = 0;
                var yPosScatter_1 = 0;
                root
                    .attr('width', totalWidth)
                    .attr('height', height)
                    .attr('opacity', opacity)
                    .attr('style', hide ? 'display: none;' : null);
                var currentScatterLegend = paddingWrapper.selectAll('.legend').data(data);
                currentScatterLegend
                    .enter()
                    .append('g')
                    .attr('class', 'legend')
                    .merge(currentScatterLegend)
                    .each(function (d, i, n) {
                    var prevLabel = i === 0 ? '' : label ? label[i - 1] : data[i - 1].key;
                    var keyLabel = label ? label[i] : d.key;
                    accumWidthScatter_1 = i === 0 ? 0 : accumWidthScatter_1 + getTextWidth(prevLabel, fontSize) + 50;
                    if (accumWidthScatter_1 + getTextWidth(keyLabel, fontSize) > width) {
                        //wrap legends if the length is larger than chart width
                        accumWidthScatter_1 = 0;
                        yPosScatter_1 += fontSize + 10; // line height
                    }
                    var keyDot = select(n[i])
                        .selectAll('path')
                        .data([d]);
                    var context = keyDot
                        .enter()
                        .append('path')
                        .attr('opacity', 0)
                        .merge(keyDot)
                        .attr('fill', colorArr[i]);
                    var exitContext = keyDot.exit();
                    var keyText = select(n[i])
                        .selectAll('text')
                        .data([d]);
                    var textContext = keyText
                        .enter()
                        .append('text')
                        .attr('class', 'key-text')
                        .attr('opacity', 0)
                        .merge(keyText)
                        .attr('dx', '.2em')
                        .attr('dy', 13)
                        .text(keyLabel);
                    var textExit = keyText.exit();
                    if (duration) {
                        context = context
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        exitContext = exitContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textContext = textContext
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                        textExit = textExit
                            .transition()
                            .duration(duration)
                            .ease(circleIn);
                    }
                    context
                        .attr('transform', "translate(" + (+accumWidthScatter_1 + 4) + "," + (+yPosScatter_1 + 8) + ")  scale(4)")
                        .attr('d', symbols[symbol[i] || symbol[0]].general)
                        .attr('opacity', opacity);
                    exitContext.attr('opacity', 0).remove();
                    textContext
                        .attr('x', accumWidthScatter_1 + 15)
                        .attr('y', yPosScatter_1)
                        .attr('opacity', opacity);
                    textExit.attr('opacity', 0).remove();
                });
                currentScatterLegend.exit().remove();
                break;
        }
        if (baseColorArr && !hideStrokes) {
            var isArray_1 = Array.isArray(baseColorArr);
            root.selectAll('.legend').each(function (d, i, n) {
                var baseColor = isArray_1 && baseColorArr.length === 1
                    ? baseColorArr[0]
                    : isArray_1
                        ? baseColorArr[i]
                        : baseColorArr[i] || baseColorArr(d[labelKey]);
                if (baseColor) {
                    var contrast = calculateRelativeLuminance(calculateLuminance(baseColor), 1);
                    var contrastFriendlyColor = contrast < 3 ? getContrastingStroke(baseColor) : baseColor;
                    select(n[i].firstElementChild).attr('data-base-color', baseColor);
                    select(n[i].firstElementChild).attr('stroke', contrastFriendlyColor);
                    select(n[i].firstElementChild).attr('stroke-width', 1);
                }
            });
        }
        else if (type !== 'line') {
            root
                .selectAll('.legend')
                .selectAll('*')
                .attr('stroke', 'none')
                .attr('stroke-width', 0);
        }
        root.selectAll('text').attr('filter', filter);
        root.attr('data-type', type || 'default');
        root.selectAll('.legend *:first-child').each(function (_, i, n) {
            var me = select(n[i]);
            if (me.attr('fill')) {
                me.attr('data-fill', me.attr('fill'));
            }
            if (me.attr('stroke')) {
                me.attr('data-stroke', me.attr('stroke'));
            }
            if (me.attr('stroke-width')) {
                me.attr('data-stroke-width', me.attr('stroke-width'));
            }
        });
        setLegendInteractionState({
            root: root,
            uniqueID: uniqueID,
            interactionKeys: interactionKeys,
            groupAccessor: groupAccessor,
            hoverHighlight: hoverHighlight,
            clickHighlight: clickHighlight,
            hoverStyle: hoverStyle,
            clickStyle: clickStyle,
            hoverOpacity: hoverOpacity
        });
        setLegendAccess(root.node(), uniqueID);
    };
    var setLegendInteractionState = function (_a) {
        var root = _a.root, interactionKeys = _a.interactionKeys, groupAccessor = _a.groupAccessor, hoverHighlight = _a.hoverHighlight, clickHighlight = _a.clickHighlight, hoverStyle = _a.hoverStyle, clickStyle = _a.clickStyle, hoverOpacity = _a.hoverOpacity;
        var type = root.attr('data-type');
        if (type !== 'gradient') {
            root.selectAll('.legend').each(function (d, i, n) {
                var child = select(n[i].firstElementChild);
                var text = select(n[i]).select('text');
                var datum = !d.values ? d : d.values[0];
                var validLegendInteraction = groupAccessor && interactionKeys.length === 1 && interactionKeys[0] === groupAccessor;
                var hovered = checkHovered(datum, hoverHighlight, interactionKeys) && validLegendInteraction;
                var clicked = checkClicked(datum, clickHighlight, interactionKeys) && validLegendInteraction;
                var fill = child.attr('data-fill');
                var stroke = child.attr('data-stroke');
                var resultingStroke = '';
                if (fill) {
                    var clickColor = clickStyle ? visaColorToHex(clickStyle.color) : '';
                    var hoverColor = hoverStyle ? visaColorToHex(hoverStyle.color) : '';
                    var resultingFill = clicked ? clickColor || fill : hovered && hoverColor ? hoverColor : fill;
                    child.attr('fill', resultingFill);
                    child.style('fill', resultingFill);
                    var hasStroke = child.attr('stroke');
                    var baseColor = child.attr('data-base-color');
                    var resultingClick = type !== 'scatter'
                        ? [getContrastingStroke(clickColor || baseColor || fill)]
                        : getAccessibleStrokes(clickColor || baseColor || fill);
                    var resultingHover = type !== 'scatter'
                        ? [getContrastingStroke(hoverColor || baseColor || fill)]
                        : getAccessibleStrokes(hoverColor || baseColor || fill);
                    resultingStroke = clicked
                        ? resultingClick[1] || resultingClick[0]
                        : hovered
                            ? resultingHover[1] || resultingHover[0]
                            : hasStroke
                                ? stroke
                                : getContrastingStroke(fill);
                }
                else if (stroke) {
                    var clickColor = clickStyle && clickStyle.color ? getAccessibleStrokes(visaColorToHex(clickStyle.color)) : [stroke];
                    var hoverColor = hoverStyle && hoverStyle.color ? getAccessibleStrokes(visaColorToHex(hoverStyle.color)) : [stroke];
                    resultingStroke = clicked ? clickColor[1] || clickColor[0] : hovered ? hoverColor[1] || hoverColor[0] : stroke;
                }
                child.attr('stroke', resultingStroke);
                child.style('stroke', resultingStroke);
                var baseStrokeWidth = parseFloat(child.attr('data-stroke-width')) || (stroke === 'none' ? 0 : 1);
                var strokeWidthDenominator = baseStrokeWidth < 1 ? baseStrokeWidth : 1;
                var strokeWidthMultiplier = type !== 'line' ? 1 : 2;
                var scale = type !== 'scatter' ? 1 : 4;
                child.attr('stroke-width', (clicked
                    ? clickStyle && clickStyle.strokeWidth && strokeWidthDenominator
                        ? (parseFloat(clickStyle.strokeWidth + '') * strokeWidthMultiplier) / strokeWidthDenominator
                        : baseStrokeWidth
                    : hovered && hoverStyle && hoverStyle.strokeWidth && strokeWidthDenominator
                        ? (parseFloat(hoverStyle.strokeWidth + '') * strokeWidthMultiplier) / strokeWidthDenominator
                        : baseStrokeWidth) / scale);
                child.style('stroke-width', child.attr('stroke-width'));
                var disableDash = type === 'scatter' || type === 'line';
                child.attr('stroke-dasharray', hovered && !clicked && !disableDash ? '8 6' : type !== 'line' ? 'none' : child.attr('stroke-dasharray'));
                child.style('stroke-dasharray', child.attr('stroke-dasharray'));
                var opacity = checkInteraction(d, 1, hoverOpacity, hoverHighlight, clickHighlight || [], interactionKeys);
                child.attr('opacity', opacity);
                text.attr('opacity', !opacity ? 0 : 1);
            });
        }
    };

    /**
     * Copyright (c) 2020, 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    // incorporates all associated OSS License information to bundle with the application build
    // licenses are provided as an array of objects for now
    var licenses = [
        {
            dependency: 'visa-chart-components',
            github_link: 'https://github.com/visa/visa-chart-components',
            license: {
                type: 'MIT',
                update_date: '11/15/2020',
                link: 'https://github.com/visa/visa-chart-components/blob/master/LICENSE.md',
                text: "\n        Copyright (c) Visa, Inc.\n\n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in\n        all copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n        THE SOFTWARE.\n      "
            }
        },
        {
            dependency: 'node-uuid',
            github_link: 'https://github.com/kelektiv/node-uuid',
            license: {
                type: 'MIT',
                update_date: '10/15/2019',
                link: 'https://github.com/kelektiv/node-uuid/blob/master/LICENSE.md',
                text: "\n        The MIT License (MIT)\n \n        Copyright (c) 2010-2016 Robert Kieffer and other contributors\n        \n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in all\n        copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n        SOFTWARE.\n      "
            }
        },
        {
            dependency: 'turf.js',
            github_link: 'https://github.com/Turfjs/turf',
            license: {
                type: 'MIT',
                update_date: '8/8/2019',
                link: 'https://github.com/Turfjs/turf/blob/master/LICENSE',
                text: "\n                The MIT License (MIT)\n\n                Copyright (c) 2019 Morgan Herlocker\n                \n                Permission is hereby granted, free of charge, to any person obtaining a copy of\n                this software and associated documentation files (the \"Software\"), to deal in\n                the Software without restriction, including without limitation the rights to\n                use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n                the Software, and to permit persons to whom the Software is furnished to do so,\n                subject to the following conditions:\n                \n                The above copyright notice and this permission notice shall be included in all\n                copies or substantial portions of the Software.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n                FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n                COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n                IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n                CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n            "
            }
        },
        {
            dependency: 'mapbox-gl-draw',
            github_link: 'https://github.com/mapbox/mapbox-gl-draw',
            license: {
                type: 'ISC',
                update_date: '8/8/2019',
                link: 'https://github.com/mapbox/mapbox-gl-draw/blob/master/LICENSE',
                text: "\n                Copyright (c) Mapbox\n\n                All rights reserved.\n                \n                Permission to use, copy, modify, and/or distribute this software for any\n                purpose with or without fee is hereby granted, provided that the above\n                copyright notice and this permission notice appear in all copies.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n                REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n                AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n                INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n                LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n                OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n                PERFORMANCE OF THIS SOFTWARE.\n            "
            }
        },
        {
            dependency: 'mapbox-gl-js',
            github_link: 'https://github.com/mapbox/mapbox-gl-js',
            license: {
                type: 'BSD',
                update_date: '8/8/2019',
                link: 'https://github.com/mapbox/mapbox-gl-js/blob/master/LICENSE.txt',
                text: "\n                Copyright (c) 2016, Mapbox\n\n                All rights reserved.\n                \n                Redistribution and use in source and binary forms, with or without modification,\n                are permitted provided that the following conditions are met:\n                \n                    * Redistributions of source code must retain the above copyright notice,\n                    this list of conditions and the following disclaimer.\n                    * Redistributions in binary form must reproduce the above copyright notice,\n                    this list of conditions and the following disclaimer in the documentation\n                    and/or other materials provided with the distribution.\n                    * Neither the name of Mapbox GL JS nor the names of its contributors\n                    may be used to endorse or promote products derived from this software\n                    without specific prior written permission.\n                \n                THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n                \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n                LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n                A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n                CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n                EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n                PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n                PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n                LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n                NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n                SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n                \n                -------------------------------------------------------------------------------\n                \n                Contains Hershey Simplex Font: http://paulbourke.net/dataformats/hershey/\n                \n                -------------------------------------------------------------------------------\n                \n                Contains code from glfx.js\n                \n                Copyright (C) 2011 by Evan Wallace\n                \n                Permission is hereby granted, free of charge, to any person obtaining a copy\n                of this software and associated documentation files (the \"Software\"), to deal\n                in the Software without restriction, including without limitation the rights\n                to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n                copies of the Software, and to permit persons to whom the Software is\n                furnished to do so, subject to the following conditions:\n                \n                The above copyright notice and this permission notice shall be included in\n                all copies or substantial portions of the Software.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n                FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n                AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n                LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n                OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n                THE SOFTWARE.\n                \n                --------------------------------------------------------------------------------\n                \n                Contains a portion of d3-color https://github.com/d3/d3-color\n                \n                Copyright 2010-2016 Mike Bostock\n                All rights reserved.\n                \n                Redistribution and use in source and binary forms, with or without modification,\n                are permitted provided that the following conditions are met:\n                \n                * Redistributions of source code must retain the above copyright notice, this\n                list of conditions and the following disclaimer.\n                \n                * Redistributions in binary form must reproduce the above copyright notice,\n                this list of conditions and the following disclaimer in the documentation\n                and/or other materials provided with the distribution.\n                \n                * Neither the name of the author nor the names of contributors may be used to\n                endorse or promote products derived from this software without specific prior\n                written permission.\n                \n                THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n                ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n                WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n                DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n                ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n                (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n                LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n                ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n                (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n                SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n            "
            }
        },
        {
            dependency: 'numeral.js',
            github_link: 'https://github.com/adamwdraper/Numeral-js',
            license: {
                type: 'MIT',
                update_date: '8/8/2019',
                link: 'https://github.com/adamwdraper/Numeral-js/blob/master/LICENSE',
                text: "\n                The MIT License (MIT)\n\n                Copyright (c) 2016 Adam Draper\n\n                Permission is hereby granted, free of charge, to any person\n                obtaining a copy of this software and associated documentation\n                files (the \"Software\"), to deal in the Software without\n                restriction, including without limitation the rights to use,\n                copy, modify, merge, publish, distribute, sublicense, and/or sell\n                copies of the Software, and to permit persons to whom the\n                Software is furnished to do so, subject to the following\n                conditions:\n                \n                The above copyright notice and this permission notice shall be\n                included in all copies or substantial portions of the Software.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n                EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n                OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n                NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n                HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n                WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n                FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n                OTHER DEALINGS IN THE SOFTWARE.\n            "
            }
        },
        {
            dependency: 'stencil.js',
            github_link: 'https://github.com/ionic-team/stencil',
            license: {
                type: 'MIT',
                update_date: '8/8/2019',
                link: 'https://github.com/ionic-team/stencil/blob/master/LICENSE',
                text: "\n                The MIT License (MIT)\n\n                Copyright (c) 2018-present Drifty Co.\n                \n                Permission is hereby granted, free of charge, to any person obtaining a copy\n                of this software and associated documentation files (the \"Software\"), to deal\n                in the Software without restriction, including without limitation the rights\n                to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n                copies of the Software, and to permit persons to whom the Software is\n                furnished to do so, subject to the following conditions:\n                \n                The above copyright notice and this permission notice shall be included in\n                all copies or substantial portions of the Software.\n                \n                THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n                IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n                FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n                AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n                LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n                OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n                THE SOFTWARE.\n            "
            }
        },
        {
            dependency: 'topojson.js',
            github_link: 'https://github.com/topojson/topojson',
            license: {
                type: 'BSD 3-Clause',
                update_date: '8/8/2019',
                link: 'https://github.com/topojson/topojson/blob/master/LICENSE.md',
                text: "\n                Copyright (c) 2012-2016, Michael Bostock All rights reserved.\n\n                Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n                \n                Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n                \n                Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n                \n                The name Michael Bostock may not be used to endorse or promote products derived from this software without specific prior written permission.\n                \n                THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n            "
            }
        },
        {
            dependency: 'd3.js',
            github_link: 'https://github.com/d3/d3',
            license: {
                type: 'BSD 3-Clause',
                update_date: '8/8/2019',
                link: 'https://github.com/d3/d3/blob/master/LICENSE',
                text: "\n                Copyright 2010-2017 Mike Bostock\n                All rights reserved.\n        \n                Redistribution and use in source and binary forms, with or without modification,\n                are permitted provided that the following conditions are met:\n        \n                * Redistributions of source code must retain the above copyright notice, this\n                list of conditions and the following disclaimer.\n        \n                * Redistributions in binary form must reproduce the above copyright notice,\n                this list of conditions and the following disclaimer in the documentation\n                and/or other materials provided with the distribution.\n        \n                * Neither the name of the author nor the names of contributors may be used to\n                endorse or promote products derived from this software without specific prior\n                written permission.\n        \n                THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n                ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n                WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n                DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n                ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n                (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n                LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n                ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n                (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n                SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n            "
            }
        },
        {
            dependency: 'd3-annotation.js',
            github_link: 'https://github.com/susielu/d3-annotation',
            license: {
                type: 'Apache-2.0',
                update_date: '8/8/2019',
                link: 'https://raw.githubusercontent.com/susielu/d3-annotation/master/LICENSE',
                text: "\n                            Apache License\n                            Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n                TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n                1. Definitions.\n\n                \"License\" shall mean the terms and conditions for use, reproduction,\n                and distribution as defined by Sections 1 through 9 of this document.\n\n                \"Licensor\" shall mean the copyright owner or entity authorized by\n                the copyright owner that is granting the License.\n\n                \"Legal Entity\" shall mean the union of the acting entity and all\n                other entities that control, are controlled by, or are under common\n                control with that entity. For the purposes of this definition,\n                \"control\" means (i) the power, direct or indirect, to cause the\n                direction or management of such entity, whether by contract or\n                otherwise, or (ii) ownership of fifty percent (50%) or more of the\n                outstanding shares, or (iii) beneficial ownership of such entity.\n\n                \"You\" (or \"Your\") shall mean an individual or Legal Entity\n                exercising permissions granted by this License.\n\n                \"Source\" form shall mean the preferred form for making modifications,\n                including but not limited to software source code, documentation\n                source, and configuration files.\n\n                \"Object\" form shall mean any form resulting from mechanical\n                transformation or translation of a Source form, including but\n                not limited to compiled object code, generated documentation,\n                and conversions to other media types.\n\n                \"Work\" shall mean the work of authorship, whether in Source or\n                Object form, made available under the License, as indicated by a\n                copyright notice that is included in or attached to the work\n                (an example is provided in the Appendix below).\n\n                \"Derivative Works\" shall mean any work, whether in Source or Object\n                form, that is based on (or derived from) the Work and for which the\n                editorial revisions, annotations, elaborations, or other modifications\n                represent, as a whole, an original work of authorship. For the purposes\n                of this License, Derivative Works shall not include works that remain\n                separable from, or merely link (or bind by name) to the interfaces of,\n                the Work and Derivative Works thereof.\n\n                \"Contribution\" shall mean any work of authorship, including\n                the original version of the Work and any modifications or additions\n                to that Work or Derivative Works thereof, that is intentionally\n                submitted to Licensor for inclusion in the Work by the copyright owner\n                or by an individual or Legal Entity authorized to submit on behalf of\n                the copyright owner. For the purposes of this definition, \"submitted\"\n                means any form of electronic, verbal, or written communication sent\n                to the Licensor or its representatives, including but not limited to\n                communication on electronic mailing lists, source code control systems,\n                and issue tracking systems that are managed by, or on behalf of, the\n                Licensor for the purpose of discussing and improving the Work, but\n                excluding communication that is conspicuously marked or otherwise\n                designated in writing by the copyright owner as \"Not a Contribution.\"\n\n                \"Contributor\" shall mean Licensor and any individual or Legal Entity\n                on behalf of whom a Contribution has been received by Licensor and\n                subsequently incorporated within the Work.\n\n                2. Grant of Copyright License. Subject to the terms and conditions of\n                this License, each Contributor hereby grants to You a perpetual,\n                worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n                copyright license to reproduce, prepare Derivative Works of,\n                publicly display, publicly perform, sublicense, and distribute the\n                Work and such Derivative Works in Source or Object form.\n\n                3. Grant of Patent License. Subject to the terms and conditions of\n                this License, each Contributor hereby grants to You a perpetual,\n                worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n                (except as stated in this section) patent license to make, have made,\n                use, offer to sell, sell, import, and otherwise transfer the Work,\n                where such license applies only to those patent claims licensable\n                by such Contributor that are necessarily infringed by their\n                Contribution(s) alone or by combination of their Contribution(s)\n                with the Work to which such Contribution(s) was submitted. If You\n                institute patent litigation against any entity (including a\n                cross-claim or counterclaim in a lawsuit) alleging that the Work\n                or a Contribution incorporated within the Work constitutes direct\n                or contributory patent infringement, then any patent licenses\n                granted to You under this License for that Work shall terminate\n                as of the date such litigation is filed.\n\n                4. Redistribution. You may reproduce and distribute copies of the\n                Work or Derivative Works thereof in any medium, with or without\n                modifications, and in Source or Object form, provided that You\n                meet the following conditions:\n\n                (a) You must give any other recipients of the Work or\n                Derivative Works a copy of this License; and\n\n                (b) You must cause any modified files to carry prominent notices\n                stating that You changed the files; and\n\n                (c) You must retain, in the Source form of any Derivative Works\n                that You distribute, all copyright, patent, trademark, and\n                attribution notices from the Source form of the Work,\n                excluding those notices that do not pertain to any part of\n                the Derivative Works; and\n\n                (d) If the Work includes a \"NOTICE\" text file as part of its\n                distribution, then any Derivative Works that You distribute must\n                include a readable copy of the attribution notices contained\n                within such NOTICE file, excluding those notices that do not\n                pertain to any part of the Derivative Works, in at least one\n                of the following places: within a NOTICE text file distributed\n                as part of the Derivative Works; within the Source form or\n                documentation, if provided along with the Derivative Works; or,\n                within a display generated by the Derivative Works, if and\n                wherever such third-party notices normally appear. The contents\n                of the NOTICE file are for informational purposes only and\n                do not modify the License. You may add Your own attribution\n                notices within Derivative Works that You distribute, alongside\n                or as an addendum to the NOTICE text from the Work, provided\n                that such additional attribution notices cannot be construed\n                as modifying the License.\n\n                You may add Your own copyright statement to Your modifications and\n                may provide additional or different license terms and conditions\n                for use, reproduction, or distribution of Your modifications, or\n                for any such Derivative Works as a whole, provided Your use,\n                reproduction, and distribution of the Work otherwise complies with\n                the conditions stated in this License.\n\n                5. Submission of Contributions. Unless You explicitly state otherwise,\n                any Contribution intentionally submitted for inclusion in the Work\n                by You to the Licensor shall be under the terms and conditions of\n                this License, without any additional terms or conditions.\n                Notwithstanding the above, nothing herein shall supersede or modify\n                the terms of any separate license agreement you may have executed\n                with Licensor regarding such Contributions.\n\n                6. Trademarks. This License does not grant permission to use the trade\n                names, trademarks, service marks, or product names of the Licensor,\n                except as required for reasonable and customary use in describing the\n                origin of the Work and reproducing the content of the NOTICE file.\n\n                7. Disclaimer of Warranty. Unless required by applicable law or\n                agreed to in writing, Licensor provides the Work (and each\n                Contributor provides its Contributions) on an \"AS IS\" BASIS,\n                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n                implied, including, without limitation, any warranties or conditions\n                of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n                PARTICULAR PURPOSE. You are solely responsible for determining the\n                appropriateness of using or redistributing the Work and assume any\n                risks associated with Your exercise of permissions under this License.\n\n                8. Limitation of Liability. In no event and under no legal theory,\n                whether in tort (including negligence), contract, or otherwise,\n                unless required by applicable law (such as deliberate and grossly\n                negligent acts) or agreed to in writing, shall any Contributor be\n                liable to You for damages, including any direct, indirect, special,\n                incidental, or consequential damages of any character arising as a\n                result of this License or out of the use or inability to use the\n                Work (including but not limited to damages for loss of goodwill,\n                work stoppage, computer failure or malfunction, or any and all\n                other commercial damages or losses), even if such Contributor\n                has been advised of the possibility of such damages.\n\n                9. Accepting Warranty or Additional Liability. While redistributing\n                the Work or Derivative Works thereof, You may choose to offer,\n                and charge a fee for, acceptance of support, warranty, indemnity,\n                or other liability obligations and/or rights consistent with this\n                License. However, in accepting such obligations, You may act only\n                on Your own behalf and on Your sole responsibility, not on behalf\n                of any other Contributor, and only if You agree to indemnify,\n                defend, and hold each Contributor harmless for any liability\n                incurred by, or claims asserted against, such Contributor by reason\n                of your accepting any such warranty or additional liability.\n\n                END OF TERMS AND CONDITIONS\n\n\n                APPENDIX: How to apply the Apache License to your work.\n\n                To apply the Apache License to your work, attach the following\n                boilerplate notice, with the fields enclosed by brackets \"[]\"\n                replaced with your own identifying information. (Don't include\n                the brackets!)  The text should be enclosed in the appropriate\n                comment syntax for the file format. We also recommend that a\n                file or class name and description of purpose be included on the\n                same \"printed page\" as the copyright notice for easier\n                identification within third-party archives.\n\n                Copyright (c) 2017, Susie Lu\n\n                Licensed under the Apache License, Version 2.0 (the \"License\");\n                you may not use this file except in compliance with the License.\n                You may obtain a copy of the License at\n\n                http://www.apache.org/licenses/LICENSE-2.0\n\n                Unless required by applicable law or agreed to in writing, software\n                distributed under the License is distributed on an \"AS IS\" BASIS,\n                WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                See the License for the specific language governing permissions and\n                limitations under the License.\n            "
            }
        },
        {
            dependency: 'ua-parser-js',
            github_link: 'https://github.com/faisalman/ua-parser-js',
            license: {
                type: 'MIT',
                update_date: '12/16/2020',
                link: 'https://github.com/faisalman/ua-parser-js/blob/master/license.md',
                text: "\n        MIT License\n\n        Copyright (c) 2012-2019 Faisal Salman <<f@faisalman.com>>\n        \n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in all\n        copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n        SOFTWARE.\n      "
            }
        },
        {
            dependency: 'yup',
            github_link: 'https://github.com/jquense/yup',
            license: {
                type: 'MIT',
                update_date: '12/16/2020',
                link: 'https://github.com/jquense/yup/blob/master/LICENSE.md',
                text: "\n        The MIT License (MIT)\n\n        Copyright (c) 2014 Jason Quense\n        \n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in all\n        copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n        SOFTWARE.\n      "
            }
        },
        {
            dependency: 'htmlwidgets',
            github_link: 'https://github.com/ramnathv/htmlwidgets',
            license: {
                type: 'MIT',
                update_date: '3/11/2021',
                link: 'https://github.com/ramnathv/htmlwidgets/blob/master/LICENSE',
                text: "\n        MIT License\n\n        Copyright (c) 2016, Ramnath Vaidyanathan, Joe Cheng, JJ Allaire, Yihui Xie, and Kenton Russell\n\n        Permission is hereby granted, free of charge, to any person obtaining a copy\n        of this software and associated documentation files (the \"Software\"), to deal\n        in the Software without restriction, including without limitation the rights\n        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n        copies of the Software, and to permit persons to whom the Software is\n        furnished to do so, subject to the following conditions:\n        \n        The above copyright notice and this permission notice shall be included in all\n        copies or substantial portions of the Software.\n        \n        THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n        SOFTWARE.\n      "
            }
        },
        {
            dependency: 'vega-label and vega-canvas',
            github_link: 'https://github.com/vega/vega-label',
            license: {
                type: 'BSD-3-Clause',
                update_date: '7/8/2021',
                link: 'https://github.com/vega/vega-label/blob/master/LICENSE',
                text: "\n        Copyright (c) 2016, University of Washington Interactive Data Lab\n        All rights reserved.\n        \n        Redistribution and use in source and binary forms, with or without\n        modification, are permitted provided that the following conditions are met:\n        \n        1. Redistributions of source code must retain the above copyright notice, this\n          list of conditions and the following disclaimer.\n        \n        2. Redistributions in binary form must reproduce the above copyright notice,\n          this list of conditions and the following disclaimer in the documentation\n          and/or other materials provided with the distribution.\n        \n        3. Neither the name of the copyright holder nor the names of its contributors\n          may be used to endorse or promote products derived from this software\n          without specific prior written permission.\n        \n        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n        AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n        IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n        DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\n        FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n        DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n        SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n        CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n        OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n        OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n      "
            }
        }
    ];
    function getLicenses() {
        return licenses;
    }

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var prepareRenderChange = function (_a) {
        var selection = _a.selection, duration = _a.duration, namespace = _a.namespace, easing = _a.easing, delay = _a.delay;
        // we do not want to use javascript's animation engine if the change should be immediate
        if (!duration) {
            return selection;
        }
        // every transition must have a namespace
        var transitionNamespace = namespace || 'generic-transition';
        // interrupt any existing transitions of that namespace and stop any queued
        selection.interrupt(transitionNamespace);
        // set up initial transition
        var transitionChain = selection.transition(transitionNamespace).duration(duration);
        // for transitions with an easing, we modify the object chain to include it
        if (easing) {
            transitionChain = transitionChain.ease(easing);
        }
        // for transitions with a delay, we modify the object chain to include it
        if (delay) {
            transitionChain = transitionChain.delay(delay);
        }
        // we return the new selection
        return transitionChain;
    };

    /**
     * Copyright (c) 2020, 2021, 2022 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    function transformData(data, groupAccessor, ordinalAccessor, valueAccessor) {
        // transform data to below format
        // [{label: "2018", "A": 23, "B": 7, "C": 11}, {label: ..}]
        var dataArr = [];
        data.forEach(function (obj) {
            var o = {};
            if (!dataArr.length) {
                o[groupAccessor] = obj[groupAccessor];
                o[obj[ordinalAccessor]] = obj[valueAccessor];
                dataArr.push(o);
            }
            else {
                o = dataArr.filter(function (d) { return d[groupAccessor] === obj[groupAccessor]; }).pop();
                if (!!o) {
                    var idx = dataArr.findIndex(function (d) { return d[groupAccessor] === obj[groupAccessor]; });
                    o[obj[ordinalAccessor]] = obj[valueAccessor];
                    dataArr[idx] = o;
                }
                else {
                    o = {};
                    o[groupAccessor] = obj[groupAccessor];
                    o[obj[ordinalAccessor]] = obj[valueAccessor];
                    dataArr.push(o);
                }
            }
        });
        return dataArr;
    }
    var accessorFormatMap = {
        number: '0[.][0][0]a',
        date: '%B %d %Y',
        percent: '0[.][0][0]%',
        string: ''
    };
    var accessorFormats = {
        valueAccessor: 'number',
        nodeSizeAccessor: 'number',
        latitudeAccessor: 'number',
        longitudeAccessor: 'number',
        xAccessor: [
            {
                charts: ['scatter-plot'],
                type: 'number'
            }
        ],
        yAccessor: [
            {
                charts: ['scatter-plot'],
                type: 'number'
            }
        ],
        sizeAccessor: [
            {
                charts: ['scatter-plot'],
                type: 'number'
            }
        ]
    };
    var orderColumns = {
        'alluvial-diagram': ['nodeIDAccessor', 'labelAccessor', 'valueAccessor'],
        'alluvial-diagram-secondary-table': ['sourceAccessor', 'targetAccessor', 'groupAccessor', 'valueAccessor'],
        'bar-chart': ['ordinalAccessor', 'valueAccessor', 'groupAccessor'],
        'clustered-bar-chart': ['groupAccessor', 'ordinalAccessor', 'valueAccessor'],
        'stacked-bar-chart': ['groupAccessor', 'ordinalAccessor', 'valueAccessor'],
        'line-chart': ['seriesAccessor', 'ordinalAccessor', 'valueAccessor'],
        'pie-chart': ['ordinalAccessor', 'valueAccessor'],
        'scatter-plot': ['groupAccessor', 'xAccessor', 'yAccessor', 'sizeAccessor'],
        'heat-map': ['xAccessor', 'yAccessor', 'valueAccessor'],
        'circle-packing': ['clusterAccessor', 'nodeAccessor', 'nodeSizeAccessor', 'idAccessor'],
        'parallel-plot': ['seriesAccessor', 'ordinalAccessor', 'valueAccessor'],
        'dumbbell-plot': ['seriesAccessor', 'ordinalAccessor', 'valueAccessor'],
        'world-map': ['markerNameAccessor', 'joinNameAccessor', 'valueAccessor']
    };
    var chartAccessors = {
        singleAccessors: [
            'valueAccessor',
            'sizeAccessor',
            'xAccessor',
            'yAccessor',
            'latitudeAccessor',
            'longitudeAccessor',
            'ordinalAccessor',
            'idAccessor',
            'markerAccessor',
            'markerNameAccessor',
            'joinAccessor',
            'joinNameAccessor',
            'nodeAccessor',
            'parentAccessor',
            'groupAccessor',
            'seriesAccessor',
            // 'nodeIDAccessor',
            'sourceAccessor',
            'targetAccessor'
        ],
        arrayAccessors: ['interactionKeys'],
        nestedAccessors: [
            {
                objectName: 'tooltipLabel',
                objectAccessors: ['labelAccessor'],
                formatAccessors: ['format']
            },
            {
                objectName: 'accessibility',
                objectAccessors: ['elementDescriptionAccessor']
            },
            {
                objectName: 'dataLabel',
                objectAccessors: ['labelAccessor'],
                formatAccessors: ['format']
            },
            {
                objectName: 'sizeConfig',
                objectAccessors: ['sizeAccessor']
            }
        ]
    };
    function orderScopedData(_this, dataSample, chartType) {
        var tableColumns = [];
        orderColumns[chartType].forEach(function (col) {
            if (_this[col]) {
                tableColumns.push(_this[col]);
            }
        });
        Object.keys(dataSample).forEach(function (key) {
            if (tableColumns.indexOf(key) < 0) {
                tableColumns.push(key);
            }
        });
        return tableColumns;
    }
    function getScopedData(data, keyMap) {
        var scopedData = [];
        data.forEach(function (dataRecord) {
            var scopedDataRecord = {};
            // loop through target fields instead of all data record fields
            Object.keys(keyMap).forEach(function (field) {
                // check if we have a date object, if we do format with provided or default date format
                if (dataRecord[field] instanceof Date) {
                    scopedDataRecord[field] = formatDate({
                        date: dataRecord[field],
                        format: keyMap[field] ? keyMap[field] : accessorFormatMap['date'],
                        offsetTimezone: true
                    });
                }
                else {
                    if (keyMap[field] === 'normalized') {
                        scopedDataRecord[field] =
                            keyMap[field] && dataRecord[field]
                                ? formatStats(dataRecord[field], accessorFormatMap['number'])
                                : dataRecord[field];
                        scopedDataRecord[field + "%"] =
                            keyMap[field] && dataRecord[field] && dataRecord.getSum
                                ? formatStats(dataRecord[field] / dataRecord.getSum(), accessorFormatMap['percent'])
                                : dataRecord[field];
                    }
                    else {
                        scopedDataRecord[field] =
                            keyMap[field] && dataRecord[field] ? formatStats(dataRecord[field], keyMap[field]) : dataRecord[field];
                    }
                }
            });
            scopedData.push(scopedDataRecord);
        });
        return scopedData;
    }
    function getDefaultFormat(accessor, formats, formatMap, chartType) {
        // we are going to use a map for now instead of finding the type of the data in the data row
        if (formats[accessor]) {
            if (formats[accessor] instanceof Array) {
                // we have chart specific stuff
                var mappedFormat_1 = undefined;
                formats[accessor].forEach(function (formatObj) {
                    if (formatObj.charts.indexOf(chartType) >= 0) {
                        mappedFormat_1 = formatMap[formatObj.type];
                    }
                    else {
                        mappedFormat_1 = mappedFormat_1 ? mappedFormat_1 : (mappedFormat_1 = '');
                    }
                });
                return mappedFormat_1;
            }
            else {
                // we can simple return default type based on value
                if (formatMap[formats[accessor]]) {
                    return formatMap[formats[accessor]];
                }
                else {
                    return '';
                }
            }
        }
        else {
            return '';
        }
    }
    function scopeDataKeys(_this, accessors, chartType, skipSorting) {
        // this doesn't work need to get the list of props on the element.
        var valueKeyMap = {};
        var valueKeyHash = {};
        // first we do nested accessors, starting with tooltip
        if (accessors.nestedAccessors && accessors.nestedAccessors instanceof Array) {
            accessors.nestedAccessors.forEach(function (accessor) {
                if (accessor.objectName && accessor.objectAccessors && accessor.objectAccessors instanceof Array) {
                    if (_this[accessor.objectName]) {
                        accessor.objectAccessors.forEach(function (k, i) {
                            if (_this[accessor.objectName][k] instanceof Array) {
                                _this[accessor.objectName][k].forEach(function (innerK, j) {
                                    // is there an associated format that is an array?
                                    if (!valueKeyHash[innerK]) {
                                        valueKeyMap[innerK] =
                                            accessor.formatAccessors &&
                                                accessor.formatAccessors instanceof Array &&
                                                _this[accessor.objectName][accessor.formatAccessors[i]]
                                                ? _this[accessor.objectName][accessor.formatAccessors[i]][j]
                                                : undefined;
                                        valueKeyHash[innerK] = 1;
                                    }
                                });
                            }
                            else {
                                if (_this[accessor.objectName][k] && !valueKeyHash[_this[accessor.objectName][k]]) {
                                    valueKeyMap[_this[accessor.objectName][k]] = accessor.formatAccessors
                                        ? _this[accessor.objectName][accessor.formatAccessors]
                                        : undefined;
                                    valueKeyHash[_this[accessor.objectName][k]] = 1;
                                }
                            }
                        });
                    }
                }
            });
        }
        // next we do singleAccessors, make sure it exists and is an array
        if (accessors.singleAccessors && accessors.singleAccessors instanceof Array) {
            accessors.singleAccessors.forEach(function (accessor) {
                // now we check whether the chart has the accessor for each
                if (_this[accessor] && !valueKeyHash[_this[accessor]]) {
                    var defFormat = getDefaultFormat(accessor, accessorFormats, accessorFormatMap, chartType);
                    valueKeyMap[_this[accessor]] = defFormat;
                    valueKeyHash[_this[accessor]] = 1;
                }
            });
        }
        // next we do array accessors
        if (accessors.arrayAccessors && accessors.arrayAccessors instanceof Array) {
            accessors.arrayAccessors.forEach(function (accessor) {
                if (_this[accessor]) {
                    _this[accessor].forEach(function (k) {
                        if (!valueKeyHash[k] && k !== 'xAccessor' && k !== 'yAccessor') {
                            // have to account for mutation of heat-map interaction key props
                            valueKeyMap[k] = undefined;
                            valueKeyHash[k] = 1;
                        }
                    });
                }
            });
        }
        if (!skipSorting) {
            var newKeyMap_1 = {};
            var correctKeysInOrder = orderScopedData(_this, valueKeyMap, chartType);
            correctKeysInOrder.forEach(function (key) {
                newKeyMap_1[key] = valueKeyMap[key];
            });
            valueKeyMap = newKeyMap_1;
        }
        return valueKeyMap;
    }
    // this operation happens in-place (it mutates the incoming data, must duplicate before sending when necessary)
    function fixNestedSparseness(data, ordinalAccessor, groupAccessor, valueAccessor, defaultValue) {
        // full group is what an ideal group will look like in the nest
        var fullGroup = {};
        // currentNest is what the current nest looks like, we check its sparseness against fullGroup
        var currentNest = {};
        // we will now populate fullGroup and currentNest
        data.forEach(function (datum) {
            // make sure the ideal group has every ordinal value we encounter
            fullGroup[datum[ordinalAccessor]] = 1;
            // check if we have a group in the nest yet
            if (!currentNest[datum[groupAccessor]]) {
                // initialize the group if we don't
                currentNest[datum[groupAccessor]] = {};
            }
            // add the ordinal value to the current group
            currentNest[datum[groupAccessor]][datum[ordinalAccessor]] = 1;
        });
        // we create this array once, so we don't have to repeat it inside our looping
        var everyOrdinal = Object.keys(fullGroup);
        // now that we know what the nest looks like, we are checking sparseness against fullGroup
        Object.keys(currentNest).forEach(function (groupValue) {
            // everyOrdinal has the "perfect" group (non-sparse), so we use it to compare
            everyOrdinal.forEach(function (ordinalValue) {
                // we check each group's ordinals against everyOrdinal, one at a time
                if (!currentNest[groupValue][ordinalValue]) {
                    // when we encounter a missing item in the current nest, we add to the original array
                    var missingPiece = {};
                    // make sure we always have some kind of numeric value here if one is not sent
                    missingPiece[valueAccessor] = defaultValue || 0;
                    missingPiece[ordinalAccessor] = ordinalValue;
                    missingPiece[groupAccessor] = groupValue;
                    // now our data contains each missing piece it requires
                    data.push(missingPiece);
                }
            });
        });
    }

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var createLabel = function (_a) {
        var d = _a.d, i = _a.i, n = _a.n, capitalizedGeomType = _a.capitalizedGeomType, capitalizedGroupName = _a.capitalizedGroupName, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, recursive = _a.recursive;
        var datum = !recursive ? d : d.data.data;
        var label = '';
        if (nested) {
            if (datum[nested].length) {
                datum[nested].forEach(function (child) {
                    label += iterateKeys(child, dataKeys, includeKeyNames, true);
                });
            }
            if (groupKeys && groupKeys.length) {
                groupKeys.forEach(function (groupKey) {
                    label += !groupKey ? '' : datum[groupKey] + '. ';
                });
            }
        }
        else {
            label += iterateKeys(datum, dataKeys, includeKeyNames);
        }
        label += capitalizedGeomType + ' ' + (i + 1) + ' of ' + n.length + '.';
        if (recursive) {
            var depth_1 = d.depth;
            var size = select(n[i].parentNode)
                .selectAll('g:not(.vcl-accessibility-focus-highlight)')
                .filter(function (data) { return (depth_1 === undefined ? true : data && data.depth === depth_1 + 1); })
                .size();
            label +=
                (' This ' + capitalizedGroupName || capitalizedGeomType + ' group') +
                    ' contains ' +
                    (size || '0') +
                    ' child elements' +
                    (!size && d.children && d.children.length ? ' (but some may be hidden until you interact with this node)' : '');
        }
        return label;
    };
    var createGroupLabel = function (_a) {
        var d = _a.d, targetNode = _a.targetNode, index = _a.index, groupAccessor = _a.groupAccessor, groupKeys = _a.groupKeys, siblings = _a.siblings, isOffsetGroup = _a.isOffsetGroup, includeKeyNames = _a.includeKeyNames, capitalizedGroupName = _a.capitalizedGroupName, capitalizedGeomType = _a.capitalizedGeomType, geomType = _a.geomType;
        var tabbableSiblings = 0;
        Array.prototype.forEach.call(siblings, function (sibling) {
            if (select(sibling).attr('tabindex') !== null) {
                tabbableSiblings++;
            }
        });
        if (tabbableSiblings > 1) {
            var targetRootForChildren = !isOffsetGroup ? targetNode : targetNode.parentNode.nextSibling.childNodes[index];
            var firstChild = targetNode.querySelectorAll('*:not(.vcl-accessibility-focus-highlight)')[0];
            var groupData_1 = firstChild && firstChild['__data__']
                ? includeKeyNames && groupAccessor && firstChild['__data__'][groupAccessor]
                    ? groupAccessor + ' ' + firstChild['__data__'][groupAccessor] + '. '
                    : firstChild['__data__'][groupAccessor] + '. '
                : '';
            if (groupKeys && groupKeys.length) {
                groupKeys.forEach(function (groupKey) {
                    groupData_1 += !groupKey ? '' : d[groupKey] + '. ';
                });
            }
            var childrenCount = targetRootForChildren
                ? targetRootForChildren.querySelectorAll('*:not(.vcl-accessibility-focus-highlight)').length
                : 0;
            return (groupData_1 +
                (capitalizedGroupName || capitalizedGeomType + ' group') +
                ' ' +
                (index + 1) +
                ' of ' +
                targetNode.parentNode.querySelectorAll('g:not(.vcl-accessibility-focus-highlight)').length +
                ' which contains ' +
                childrenCount +
                ' interactive ' +
                geomType +
                (childrenCount !== 1 ? 's.' : '.'));
        }
        else {
            var childrenCount = siblings[index].querySelectorAll('*:not(.vcl-accessibility-focus-highlight)').length;
            return ((capitalizedGroupName || capitalizedGeomType + ' group') +
                ' which contains ' +
                childrenCount +
                ' interactive ' +
                geomType +
                (childrenCount !== 1 ? 's.' : '.'));
        }
    };
    var iterateKeys = function (item, objectOfDataKeys, includeKeyNames, nested) {
        var dataKeys = Object.keys(objectOfDataKeys);
        var label = '';
        var datum = !item.data
            ? getScopedData([item], objectOfDataKeys)[0]
            : getScopedData([item.data], objectOfDataKeys)[0];
        var keyPosition = 1;
        dataKeys.forEach(function (key) {
            if (datum[key] !== undefined) {
                var keyEnding = typeof datum[key] === 'string' && datum[key][datum[key].length - 1] === '.' ? ' ' : '. ';
                if (!(nested && !includeKeyNames)) {
                    label += includeKeyNames ? key + ' ' : '';
                    label += datum[key] + keyEnding;
                }
                else {
                    label += datum[key] + (keyPosition % 2 ? ' ' : keyEnding);
                }
                if (datum[key + '%'] !== undefined) {
                    var percentKeyEnding = datum[key + '%'][datum[key + '%'].length - 1] === '.' ? ' ' : '. ';
                    label += includeKeyNames ? key + ' as a percentage ' : '';
                    label += datum[key + '%'] + percentKeyEnding;
                }
                keyPosition++;
            }
        });
        return label;
    };

    /**
     * Copyright (c) 2020, 2021, 2022 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var keyCodes = {
        parent: 27,
        child: 13,
        select: 32,
        nextSibling: 39,
        previousSibling: 37,
        nextCousin: 40,
        previousCousin: 38,
        nextCousinAlternate: 190,
        previousCousinAlternate: 188,
        shift: 16,
        tab: 9 // TAB
    };
    var browser$2 = getBrowser();
    var isIE11$2 = browser$2 === 'IE'; // ua.includes('rv:11.0');
    var isIEEdge$1 = browser$2 === 'Edge'; // ua.includes('Edge');
    var rootSVGRole = 'application'; // !isIE11 ? 'region' : 'application';
    var staticGeometryRole = 'img'; // 'menuitem'; // !(isIE11 || isIEEdge) ? 'img' : 'treeitem';
    var interactiveGeometryRole = 'button'; // 'menuitem'; // !(isIE11 || isIEEdge) ? 'button' : 'treeitem';
    var controllerPrefix = 'node-';
    var fired = false;
    if (isIE11$2) {
        polyfillMouseEvents(window);
    }
    var setAccessibilityController = function (_a) {
        var node = _a.node, chartTag = _a.chartTag, title = _a.title, description = _a.description, uniqueID = _a.uniqueID, geomType = _a.geomType, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, groupName = _a.groupName, groupAccessor = _a.groupAccessor, recursive = _a.recursive, disableKeyNav = _a.disableKeyNav;
        var svg = select(node);
        var sameGroupCousinKey = groupAccessor && (chartTag === 'bar-chart' || chartTag === 'world-map') ? groupAccessor : '';
        svg
            .attr('role', 'presentation')
            .attr('focusable', false)
            .attr('tabindex', -1)
            .style('overflow', 'hidden')
            .on('focus', !disableKeyNav
            ? function () {
                focusTarget(select(parent)
                    .select('.VCL-controller')
                    .node());
                // removeKeyboardHighlight(n[i].firstElementChild, true)
            }
            : null);
        var parent = node.parentNode;
        var controller = select(parent).select('.VCL-controller');
        var getRootAriaLabel = function () {
            var titleText = title + ". ";
            var subtitle = description ? description + '. ' : '';
            var descText = subtitle + " Navigate into the chart area by pressing ENTER.";
            return titleText + descText;
        };
        if (!controller.size()) {
            select(parent).style('position', 'relative');
            controller = select(parent).insert('div', ':first-child');
            controller
                .attr('class', 'VCL-controller')
                .style('position', 'absolute')
                .style('top', 0)
                .style('left', 0)
                .style('opacity', 0)
                .style('pointer-events', 'none');
        }
        var bounds = node.getBoundingClientRect();
        controller
            .style('width', bounds.width + "px")
            .style('height', bounds.height + "px")
            .attr('id', 'chart-area-' + uniqueID)
            .attr('data-sgck', sameGroupCousinKey || null)
            .attr('data-group', groupAccessor)
            .attr('aria-label', !disableKeyNav ? getRootAriaLabel() : null)
            .text(!disableKeyNav ? "Interactive " + chartTag + "." : '')
            .attr('role', !disableKeyNav ? rootSVGRole : 'presentation')
            .attr('tabindex', !disableKeyNav ? '0' : '-1')
            .on('keyup', !disableKeyNav
            ? function () {
                keyUpHandler();
            }
            : null)
            .on('focus', !disableKeyNav
            ? function (_, i, n) {
                select(n[i])
                    .selectAll('[tabindex]')
                    .attr('tabindex', -1);
                drawKeyboardFocusClone(n[i], recursive);
                var bounds = node.getBoundingClientRect();
                controller
                    .style('width', bounds.width + "px")
                    .style('height', bounds.height + "px")
                    .attr('aria-label', getRootAriaLabel());
            }
            : null)
            .on('blur', !disableKeyNav
            ? function (_, i, n) {
                removeKeyboardHighlight(select(n[i].parentNode)
                    .select('svg :first-child')
                    .node(), true);
                controller.attr('aria-label', "Interactive " + chartTag + ".");
            }
            : null)
            .on('keydown', !disableKeyNav
            ? function () {
                var e = event;
                var keyCode = event.keyCode || event.which;
                var eventType = validKeyCode(keyCode);
                if (eventType && !fired) {
                    fired = true;
                    e.stopPropagation();
                    var targetChild = enterChartArea(e);
                    if (targetChild) {
                        prepareControllerNodes({
                            rootNode: controller.node(),
                            nodeID: targetChild.id,
                            geomType: geomType,
                            includeKeyNames: includeKeyNames,
                            dataKeys: dataKeys,
                            groupKeys: groupKeys,
                            nested: nested,
                            groupName: groupName,
                            groupAccessor: groupAccessor,
                            recursive: recursive,
                            sameGroupCousinKey: sameGroupCousinKey
                        });
                    }
                }
            }
            : null);
        var controllerChildID = controller.attr('aria-activedescendant');
        if (controllerChildID && !disableKeyNav) {
            var child = document.getElementById(controllerChildID.substring(5));
            if (child) {
                setActiveChild(child);
            }
            else {
                controller.attr('aria-activedescendant', null);
            }
        }
        else {
            controller.attr('aria-activedescendant', null);
        }
        var rootNode = controller.node();
        if (disableKeyNav && rootNode.children && rootNode.children.length) {
            var childrenToRemove = rootNode.children.length;
            while (childrenToRemove) {
                rootNode.removeChild(rootNode.children[0]);
                childrenToRemove--;
            }
        }
        setHighContrastListener(node, uniqueID); // 'chart-area-' + chartTag +
    };
    var setElementFocusHandler = function (_a) {
        var node = _a.node, geomType = _a.geomType, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, recursive = _a.recursive, groupName = _a.groupName, uniqueID = _a.uniqueID, disableKeyNav = _a.disableKeyNav;
        select(node).on('focus', !disableKeyNav
            ? function (_, i, n) {
                var idOfTarget = n[i].id;
                if (idOfTarget) {
                    var rootNode = document.getElementById('chart-area-' + uniqueID);
                    var sameGroupCousinKey = select(rootNode).attr('data-sgck');
                    var groupAccessor = select(rootNode).attr('data-group');
                    prepareControllerNodes({
                        rootNode: rootNode,
                        nodeID: idOfTarget,
                        geomType: geomType,
                        includeKeyNames: includeKeyNames,
                        dataKeys: dataKeys,
                        groupKeys: groupKeys,
                        nested: nested,
                        groupName: groupName,
                        groupAccessor: groupAccessor,
                        recursive: recursive,
                        sameGroupCousinKey: sameGroupCousinKey,
                        deleteControllers: false
                    });
                    hideKeyboardHighlight(n[i]);
                }
            }
            : null);
    };
    var setElementInteractionAccessState = function (node, selected, selectable) {
        var targetID = '#' + controllerPrefix + select(node).attr('id');
        select(node)
            .attr('data-aria-pressed', selectable ? selected : null)
            .attr('data-role', selectable ? interactiveGeometryRole : staticGeometryRole);
        select(targetID)
            .attr('aria-pressed', selectable ? selected : null)
            .attr('role', selectable ? interactiveGeometryRole : staticGeometryRole);
    };
    var setElementAccessID = function (_a) {
        var node = _a.node, uniqueID = _a.uniqueID;
        select(node).attr('id', function () {
            if (!node.id) {
                return generateRandomStringID(uniqueID);
            }
            return node.id;
        });
    };
    var checkAccessFocus = function (parentGNode) {
        return !!select(parentGNode)
            .select('.vcl-accessibility-focus-source')
            .size();
    };
    var retainAccessFocus = function (_a) {
        var parentGNode = _a.parentGNode, focusDidExist = _a.focusDidExist, recursive = _a.recursive;
        var primaryG = select(parentGNode);
        if (primaryG.select('.vcl-accessibility-focus-source').size()) {
            var target = primaryG.select('.vcl-accessibility-focus-source').node();
            var previouslyHidden = primaryG.select('.vcl-accessibility-focus-indicator').classed('hidden');
            drawKeyboardFocusClone(target, recursive);
            if (previouslyHidden) {
                hideKeyboardHighlight(target);
            }
        }
        else if (focusDidExist) {
            // if there is no focus source, we will put the user back at the start of the current group they are on
            var target_1;
            primaryG.selectAll('[tabindex]').each(function (_, i, n) {
                if (!target_1 && select(n[i]).attr('tabindex') !== null) {
                    target_1 = n[i];
                }
            });
            if (!target_1) {
                // if there is not a valid target in the group, we must find a valid target
                var root = findSVGRoot(parentGNode);
                // if there are no tabindex children
                target_1 =
                    select(root)
                        .select('[tabindex]')
                        .node() || root;
            }
            focusTarget(target_1);
            drawKeyboardFocusClone(target_1, recursive);
        }
    };
    var validKeyCode = function (keyCode) {
        return (keyCode === keyCodes.select ||
            keyCode === keyCodes.child ||
            keyCode === keyCodes.parent ||
            keyCode === keyCodes.nextSibling ||
            keyCode === keyCodes.previousSibling ||
            keyCode === keyCodes.nextCousin ||
            keyCode === keyCodes.previousCousin ||
            keyCode === keyCodes.nextCousinAlternate ||
            keyCode === keyCodes.previousCousinAlternate);
    };
    var prepareControllerNodes = function (_a) {
        var rootNode = _a.rootNode, nodeID = _a.nodeID, geomType = _a.geomType, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, groupName = _a.groupName, groupAccessor = _a.groupAccessor, recursive = _a.recursive, sameGroupCousinKey = _a.sameGroupCousinKey, deleteControllers = _a.deleteControllers;
        if (isIE11$2 || isIEEdge$1) {
            fired = false;
        }
        var drawCount = 0;
        if (!deleteControllers) {
            // find tab back node, append
            var tabBackNode = findTabBackwardNode(nodeID, recursive);
            if (tabBackNode && tabBackNode.id) {
                drawCount++;
                createControllerNode({
                    rootNode: rootNode,
                    nodeID: tabBackNode.id,
                    isTarget: false,
                    geomType: geomType,
                    includeKeyNames: includeKeyNames,
                    dataKeys: dataKeys,
                    groupKeys: groupKeys,
                    nested: nested,
                    recursive: recursive,
                    groupName: groupName,
                    groupAccessor: groupAccessor,
                    direction: 'backward',
                    sourceID: nodeID,
                    sameGroupCousinKey: sameGroupCousinKey
                });
            }
            var controllerNodeAlreadyExists = document.getElementById(controllerPrefix + nodeID);
            if (!controllerNodeAlreadyExists) {
                drawCount++;
                createControllerNode({
                    rootNode: rootNode,
                    nodeID: nodeID,
                    isTarget: true,
                    geomType: geomType,
                    includeKeyNames: includeKeyNames,
                    dataKeys: dataKeys,
                    groupKeys: groupKeys,
                    nested: nested,
                    recursive: recursive,
                    groupName: groupName,
                    groupAccessor: groupAccessor,
                    sameGroupCousinKey: sameGroupCousinKey
                });
            }
            else {
                drawCount++;
                rootNode.appendChild(controllerNodeAlreadyExists.parentNode);
                var sourceNode = document.getElementById(nodeID);
                // now we get bounds for height/width/top/left after populating content
                var bounds = sourceNode.getBoundingClientRect();
                var parentBounds = rootNode.getBoundingClientRect();
                select(controllerNodeAlreadyExists)
                    .on('focus', function () { })
                    .style('position', 'absolute')
                    .style('padding', 0)
                    .style('margin', 0)
                    .style('overflow', 'visible')
                    .style('left', bounds.left - parentBounds.left + "px")
                    .style('top', bounds.top - parentBounds.top + "px")
                    .style('width', bounds.width + "px")
                    .style('height', bounds.height + "px");
            }
            var tabForwardNode = findTabForwardNode(nodeID, recursive);
            if (tabForwardNode && tabForwardNode.id) {
                drawCount++;
                createControllerNode({
                    rootNode: rootNode,
                    nodeID: tabForwardNode.id,
                    isTarget: false,
                    geomType: geomType,
                    includeKeyNames: includeKeyNames,
                    dataKeys: dataKeys,
                    groupKeys: groupKeys,
                    nested: nested,
                    recursive: recursive,
                    groupName: groupName,
                    groupAccessor: groupAccessor,
                    direction: 'forward',
                    sourceID: nodeID,
                    sameGroupCousinKey: sameGroupCousinKey
                });
            }
        }
        // focus controller node and add keyboard focus indication to chart element
        simulateFocus(nodeID, recursive, deleteControllers);
        // remove old nodes
        var childrenToRemove = rootNode.children.length - drawCount;
        while (childrenToRemove) {
            rootNode.removeChild(rootNode.children[0]);
            childrenToRemove--;
        }
    };
    var simulateFocus = function (nodeID, recursive, directID) {
        var id = !directID ? controllerPrefix + nodeID : nodeID;
        var targetControllerElement = document.getElementById(id);
        var targetChartElement = document.getElementById(nodeID);
        simulateBlur(!directID ? targetControllerElement.parentNode.parentNode : targetControllerElement);
        focusTarget(targetControllerElement);
        if (!directID) {
            select(targetControllerElement).classed('VCL-controller-focused', true);
            focusAsMouseover(targetChartElement, recursive, false);
            setActiveChild(targetChartElement);
        }
        else {
            removeActiveChild(targetChartElement, true);
        }
        drawKeyboardFocusClone(targetChartElement, recursive);
    };
    var simulateBlur = function (controllerRoot) {
        var controllerToBlur = select(controllerRoot).select('.VCL-controller-focused');
        if (controllerToBlur.size()) {
            controllerToBlur.classed('VCL-controller-focused', false);
            var targetNode = document.getElementById(controllerToBlur.node().id.substring(5));
            controllerBlurToMouseout(targetNode);
        }
    };
    var createControllerNode = function (_a) {
        var rootNode = _a.rootNode, nodeID = _a.nodeID, isTarget = _a.isTarget, geomType = _a.geomType, includeKeyNames = _a.includeKeyNames, dataKeys = _a.dataKeys, groupKeys = _a.groupKeys, nested = _a.nested, recursive = _a.recursive, groupName = _a.groupName, groupAccessor = _a.groupAccessor, direction = _a.direction, sourceID = _a.sourceID, sameGroupCousinKey = _a.sameGroupCousinKey;
        var sourceNode = document.getElementById(nodeID);
        var isOffsetGroup = select(sourceNode).attr('data-offset-group');
        var isGroup = sourceNode.nodeName === 'g' || isOffsetGroup;
        var nodeType = 'div';
        var nodeRole = 'img';
        var nodeCanBePressed = null;
        if (!isGroup) {
            nodeRole = select(sourceNode).attr('data-role');
            nodeCanBePressed = select(sourceNode).attr('data-aria-pressed');
            nodeType = nodeCanBePressed ? 'button' : 'div';
        }
        // now we get bounds for height/width/top/left after populating content
        var bounds = sourceNode.getBoundingClientRect();
        var parentBounds = rootNode.getBoundingClientRect();
        select(rootNode)
            .append(!isIEEdge$1 ? 'figure' : 'div')
            .attr('role', 'figure')
            .append(nodeType)
            .style('position', 'absolute')
            .style('padding', 0)
            .style('margin', 0)
            .style('overflow', 'visible')
            .attr('role', nodeRole)
            .attr('id', controllerPrefix + nodeID)
            .attr('tabindex', -1)
            .on('keydown', function () {
            var e = event;
            e.stopPropagation();
            var result = getInteractionResult(nodeID, e, isGroup, recursive, sameGroupCousinKey);
            if (result) {
                if (result.clicked) {
                    // we will "click" the element now
                    var resultTarget = document.getElementById(result.id);
                    hideKeyboardHighlight(resultTarget.parentNode);
                    var evt = new MouseEvent('click', { bubbles: false, cancelable: true });
                    resultTarget.dispatchEvent(evt);
                    // focus controller node and add keyboard focus indication to chart element
                    simulateFocus(nodeID, recursive);
                }
                else if (result.focused) {
                    // this will prepare the controller's nodes and then focus the result.id
                    var idOfTarget = result.id || rootNode.id;
                    prepareControllerNodes({
                        rootNode: rootNode,
                        nodeID: idOfTarget,
                        geomType: geomType,
                        includeKeyNames: includeKeyNames,
                        dataKeys: dataKeys,
                        groupKeys: groupKeys,
                        nested: nested,
                        groupName: groupName,
                        groupAccessor: groupAccessor,
                        recursive: recursive,
                        sameGroupCousinKey: sameGroupCousinKey,
                        deleteControllers: idOfTarget === rootNode.id
                    });
                }
            }
        })
            .on('keyup', function () {
            fired = false;
        })
            .on('focus', !isTarget
            ? function () {
                var id = nodeID;
                if (direction) {
                    var node = direction === 'backward'
                        ? findTabBackwardNode(sourceID, recursive)
                        : findTabForwardNode(sourceID, recursive);
                    id = node ? node.id : '';
                }
                if (id) {
                    prepareControllerNodes({
                        rootNode: rootNode,
                        nodeID: id,
                        geomType: geomType,
                        includeKeyNames: includeKeyNames,
                        dataKeys: dataKeys,
                        groupKeys: groupKeys,
                        nested: nested,
                        groupName: groupName,
                        groupAccessor: groupAccessor,
                        recursive: recursive,
                        sameGroupCousinKey: sameGroupCousinKey
                    });
                }
            }
            : null)
            .on('blur', function () {
            var node = document.getElementById(nodeID);
            controllerBlurToMouseout(node);
        })
            .attr('aria-label', function (_, i, n) {
            var label = '';
            var capitalizedGeomType = geomType[0].toUpperCase() + geomType.substring(1);
            var capitalizedGroupName = groupName ? groupName[0].toUpperCase() + groupName.substring(1) : '';
            var targetNode = !recursive ? sourceNode : sourceNode.parentNode;
            var siblings = !recursive ? targetNode.parentNode.childNodes : findValidRecursiveSiblings(sourceNode);
            var index = Array.prototype.indexOf.call(siblings, sourceNode);
            var element = select(targetNode);
            var d = targetNode['__data__'] || element.data()[0];
            if (isGroup) {
                label = createGroupLabel({
                    d: d,
                    targetNode: targetNode,
                    index: index,
                    groupAccessor: groupAccessor,
                    groupKeys: groupKeys,
                    siblings: siblings,
                    isOffsetGroup: isOffsetGroup,
                    includeKeyNames: includeKeyNames,
                    capitalizedGroupName: capitalizedGroupName,
                    capitalizedGeomType: capitalizedGeomType,
                    geomType: geomType
                });
            }
            else {
                label = createLabel({
                    d: d,
                    i: index,
                    n: siblings,
                    capitalizedGeomType: capitalizedGeomType,
                    capitalizedGroupName: capitalizedGroupName,
                    includeKeyNames: includeKeyNames,
                    dataKeys: dataKeys,
                    groupKeys: groupKeys,
                    nested: nested,
                    recursive: recursive
                });
            }
            select(n[i]).text(label);
            if (nodeCanBePressed) {
                select(n[i]).attr('aria-pressed', nodeCanBePressed);
            }
            return label;
        })
            .style('left', bounds.left - parentBounds.left + "px")
            .style('top', bounds.top - parentBounds.top + "px")
            .style('width', bounds.width + "px")
            .style('height', bounds.height + "px")
            .style('pointer-events', 'none');
    };
    var findFirstOffsetValidChild = function (node) {
        var i = Array.prototype.indexOf.call(node.parentNode.childNodes, node);
        return node.parentNode.nextSibling.childNodes[i]
            ? node.parentNode.nextSibling.childNodes[i].childNodes[0]
            : undefined;
    };
    var findOffsetParent = function (node, direction) {
        var parent = direction === 'next' ? 'target' : 'source';
        var i = direction
            ? node.__data__[parent].index
            : Array.prototype.indexOf.call(node.parentNode.parentNode.childNodes, node.parentNode);
        return node.parentNode.parentNode.previousSibling.childNodes[i];
    };
    var generateRandomStringID = function (lead) {
        return (lead +
            '-' +
            Math.round(Math.random() * 1000000) +
            '-' +
            Math.round(Math.random() * 1000000) +
            '-' +
            Math.round(Math.random() * 1000000));
    };
    var findTabForwardNode = function (elementID, recursive, siblingsOnly) {
        var target = elementID === '' ? null : document.getElementById(elementID);
        if (!target || target.tagName === 'svg') {
            return null;
        }
        else if (!recursive && target.nextElementSibling) {
            if (select(target.nextElementSibling).attr('tabindex') !== null) {
                return target.nextElementSibling;
            }
            else {
                return findTabForwardNode(target.nextElementSibling.id, recursive);
            }
        }
        else if (recursive && findValidCousin(target, 'next', true)) {
            return findValidCousin(target, 'next', true);
        }
        else if (!siblingsOnly) {
            var parent = findValidParent(target, recursive);
            var parentSibling = !recursive
                ? parent.nextElementSibling
                : parent
                    ? findValidCousin(parent, 'next', true)
                    : null;
            if (parentSibling) {
                if (select(parentSibling).attr('tabindex') !== null) {
                    return parentSibling;
                }
                else if (parentSibling.id) {
                    return findTabForwardNode(parentSibling.id, recursive, true);
                }
            }
        }
        return null;
    };
    var findTabBackwardNode = function (elementID, recursive) {
        var target = elementID === '' ? null : document.getElementById(elementID);
        if (!target || target.tagName === 'svg') {
            return null;
        }
        else if (!recursive && target.previousElementSibling) {
            if (select(target.previousElementSibling).attr('tabindex') !== null) {
                return target.previousElementSibling;
            }
            else {
                return findTabBackwardNode(target.previousElementSibling.id, recursive);
            }
        }
        else if (recursive && findValidCousin(target, 'previous', true)) {
            return findValidCousin(target, 'previous', true);
        }
        else if (target.tagName === 'g') {
            return null;
        }
        return findValidParent(target, recursive);
    };
    var setActiveChild = function (node) {
        var rootSVG = findSVGRoot(node);
        if (!(rootSVG === document.body) && rootSVGRole === 'application') {
            var targetRoot = rootSVG.parentNode.firstElementChild;
            targetRoot.setAttribute('aria-activedescendant', controllerPrefix + node.id);
        }
    };
    var removeActiveChild = function (node, isTheRoot) {
        var rootSVG = !isTheRoot ? findSVGRoot(node) : node;
        if (!(rootSVG === document.body) && rootSVGRole === 'application') {
            var targetRoot = !isTheRoot ? rootSVG.parentNode.firstElementChild : node;
            targetRoot.setAttribute('aria-activedescendant', null);
        }
    };
    var focusTarget = function (target) {
        // set the target focus state
        if (isIE11$2) {
            // https://mkyong.com/javascript/focus-is-not-working-in-ie-solution/
            // IE has lazy focusing, so it must be wrapped in a timeout
            setTimeout(function () {
                'focus' in target ? target.focus() : target.dispatchEvent(new Event('focus'));
            }, 10);
            // HTMLElement.prototype.focus.apply(target);
        } /* else if (isIEEdge) {
          FocusableForeignObject(target);
        }*/
        else {
            'focus' in target ? target.focus() : target.dispatchEvent(new Event('focus'));
        }
    };
    var controllerBlurToMouseout = function (target) {
        if (!target) {
            return;
        }
        // remove the target focus state
        removeActiveChild(target);
        blurAsMouseout(target);
        removeKeyboardHighlight(target);
    };
    var findValidSibling = function (currentTarget, direction) {
        var sibling = direction + 'Sibling';
        var loopSibling = (direction === 'next' ? 'first' : 'last') + 'ElementChild';
        var loopSiblingElement = function () {
            return direction === 'next' ? currentTarget.parentNode.firstElementChild : findValidFinalSibling(currentTarget);
        };
        var siblingElement = currentTarget[sibling] && select(currentTarget[sibling]).attr('tabindex') !== null ? currentTarget[sibling] : null;
        var target = !siblingElement ? loopSiblingElement() : currentTarget[sibling];
        return target || target.parentNode[loopSibling];
    };
    var findValidFinalSibling = function (node) {
        if (select(node.parentNode.lastElementChild).attr('tabindex') !== null) {
            return node.parentNode.lastElementChild;
        }
        var target = null;
        var index = node.parentNode.childNodes.length - 2;
        while (!target && index >= 0) {
            var currentChild = node.parentNode.childNodes[index];
            if (select(currentChild).attr('tabindex') !== null) {
                target = currentChild;
            }
            index--;
        }
        return target;
    };
    var findValidParent = function (currentTarget, recursive, requireTabIndex) {
        if (!recursive) {
            if (requireTabIndex && select(currentTarget.parentNode).attr('tabindex') !== null) {
                return currentTarget.parentNode;
            }
            return findSVGRoot(currentTarget);
        }
        if (currentTarget.parentNode &&
            currentTarget.parentNode.parentNode &&
            currentTarget.parentNode.parentNode.firstElementChild) {
            return (findValidChildTarget(currentTarget.parentNode.parentNode.firstElementChild, true) || findSVGRoot(currentTarget));
        }
        return findSVGRoot(currentTarget);
    };
    var findSVGRoot = function (node) {
        if (node.ownerSVGElement) {
            return node.ownerSVGElement;
        }
        if (node.parentNode.nodeName === 'svg' || node.parentNode === document.body) {
            return node.parentNode;
        }
        else {
            return findSVGRoot(node.parentNode);
        }
    };
    var enterChartArea = function (_event) {
        var currentTarget = _event.target;
        var keyCode = _event.keyCode || _event.which;
        if (keyCode === keyCodes.child || keyCode === keyCodes.select) {
            // we will allow ENTER or SPACEBAR to enter the chart area
            _event.preventDefault();
            return select(currentTarget.parentNode)
                .select('svg')
                .select('[tabindex]')
                .node();
        }
    };
    var keyUpHandler = function (code) {
        fired = false;
    };
    var findFirstValidChild = function (currentTarget, recursive) {
        // recursive by default until it finds something with a tab index?
        var target = !recursive ? currentTarget : findValidSiblingTarget(currentTarget);
        return target && target.firstElementChild ? findValidChildTarget(target.firstElementChild, true) : null;
    };
    var findValidRecursiveSiblings = function (node) {
        var parentOfParent = node.parentNode.parentNode;
        var parents = parentOfParent.childNodes;
        var siblings = [];
        Array.prototype.forEach.call(parents, function (parent) {
            if (parent.tagName === 'g' && !parent.classList.contains('.vcl-accessibility-focus-highlight')) {
                siblings.push(parent.firstElementChild);
            }
        });
        return siblings;
    };
    var findValidCousin = function (currentTarget, direction, returnEarly) {
        var parentSiblingChildren;
        var target;
        var currentParentIdx = getElementIndex(currentTarget.parentNode);
        var currentIdx = select(currentTarget).attr('data-index')
            ? +select(currentTarget).attr('data-index')
            : getElementIndex(currentTarget);
        var _parent = currentTarget.parentNode.parentNode;
        var parentsSiblings = [];
        // const parentsSiblings = _parent.querySelectorAll('g:not(.vcl-accessibility-focus-highlight)')
        Array.prototype.forEach.call(_parent.childNodes, function (child) {
            if (child.tagName === 'g' && !child.classList.contains('vcl-accessibility-focus-highlight')) {
                parentsSiblings.push(child);
            }
        });
        var childrenCount = parentsSiblings.length;
        if (!childrenCount) {
            return null;
        }
        if (direction === 'previous') {
            // up
            if (returnEarly && currentParentIdx === 0) {
                return null;
            }
            parentSiblingChildren =
                currentParentIdx !== 0
                    ? parentsSiblings[currentParentIdx - 1].childNodes
                    : parentsSiblings[childrenCount - 1].childNodes;
        }
        else if (direction === 'next') {
            // down
            if (returnEarly && currentParentIdx === childrenCount - 1) {
                return null;
            }
            parentSiblingChildren =
                currentParentIdx !== childrenCount - 1
                    ? parentsSiblings[currentParentIdx + 1].childNodes
                    : parentsSiblings[0].childNodes;
        }
        // set target -- this does assume that currentIdx and data-index are interchangable/reconciled
        target = select(currentTarget).attr('data-index')
            ? Array.prototype.filter.call(parentSiblingChildren, function (el) { return currentIdx === +select(el).attr('data-index'); })[0]
            : parentSiblingChildren[currentIdx];
        // ensure that target is actually something, will check backwards across groups if group sizes don't match
        while (!target && currentIdx > -1) {
            target = select(currentTarget).attr('data-index')
                ? Array.prototype.filter.call(parentSiblingChildren, function (el) { return currentIdx === +select(el).attr('data-index'); })[0]
                : parentSiblingChildren[currentIdx];
            // if we don't find anything going back, then just assign the first cousin of parent's sibling
            if (currentIdx === 0 && !target && select(currentTarget).attr('data-index')) {
                target = parentSiblingChildren[currentIdx];
            }
            currentIdx--;
        }
        return !(currentTarget === target) ? target : null;
    };
    var findValidSameGroupCousin = function (currentTarget, direction, sameGroupCousinKey) {
        var currentData = select(currentTarget).data()[0];
        var targetGroup = currentData[sameGroupCousinKey];
        var target;
        var cousins = [];
        var targetIndex = -1;
        var found = 0;
        select(currentTarget.parentNode)
            .selectAll('*')
            .each(function (d, i, n) {
            if (d && d[sameGroupCousinKey] === targetGroup) {
                cousins.push(n[i]);
                found++;
            }
            if (targetIndex < 0 && currentTarget === n[i]) {
                // same reference means we know our index
                targetIndex = found - 1;
            }
        });
        if (found && targetIndex > -1) {
            // we have results and a starting point
            if (direction === 'previous') {
                // return either the previous or last cousin
                target = cousins[targetIndex - 1] || cousins[cousins.length - 1];
            }
            else if (direction === 'next') {
                // return either the next or first cousin
                target = cousins[targetIndex + 1] || cousins[0];
            }
        }
        return target;
    };
    var getElementIndex = function (el) {
        var i = 0;
        var originalNodeName = el.nodeName;
        while (el.previousSibling) {
            if (originalNodeName === el.previousSibling.nodeName &&
                !select(el.previousSibling).classed('vcl-accessibility-focus-hover')) {
                i++;
            }
            el = el.previousSibling;
        }
        return i;
    };
    var getInteractionResult = function (nodeID, _event, isGroup, recursive, sameGroupCousinKey) {
        var target;
        var result = {
            clicked: false,
            focused: false,
            id: ''
        };
        var currentTarget = document.getElementById(nodeID);
        var keyCode = _event.keyCode || _event.which;
        var direction = keyCode === keyCodes.nextSibling || keyCode === keyCodes.nextCousin || keyCode === keyCodes.nextCousinAlternate
            ? 'next'
            : keyCode === keyCodes.previousSibling ||
                keyCode === keyCodes.previousCousin ||
                keyCode === keyCodes.previousCousinAlternate
                ? 'previous'
                : keyCode === keyCodes.parent
                    ? 'up'
                    : keyCode === keyCodes.child
                        ? 'down'
                        : '';
        if (direction || keyCode === keyCodes.select) {
            _event.preventDefault();
        }
        if (!fired) {
            fired = true;
            if (keyCode === keyCodes.select) {
                // a selection has happened
                result.clicked = true;
                result.id = nodeID;
            }
            else if ((keyCode === keyCodes.nextSibling || keyCode === keyCodes.previousSibling) && !recursive) {
                // we are moving among siblings
                target = findValidSibling(currentTarget, direction);
            }
            else if ((!recursive &&
                (keyCode === keyCodes.nextCousin ||
                    keyCode === keyCodes.nextCousinAlternate ||
                    keyCode === keyCodes.previousCousin ||
                    keyCode === keyCodes.previousCousinAlternate)) ||
                ((keyCode === keyCodes.nextSibling || keyCode === keyCodes.previousSibling) && recursive)) {
                // we are moving among cousins (which are siblings if the chart is recursive)
                if (sameGroupCousinKey && !isGroup) {
                    // the cousin is in the same tree and must be found among siblings
                    target = findValidSameGroupCousin(currentTarget, direction, sameGroupCousinKey);
                }
                else if (!isGroup) {
                    // the dom is structured in a hierarchy, so we navigate accordingly
                    var isOffset = select(currentTarget).attr('data-offset-element');
                    target = !isOffset ? findValidCousin(currentTarget, direction) : findOffsetParent(currentTarget, direction);
                }
            }
            else if (direction === 'down' ||
                (recursive && (keyCode === keyCodes.nextCousin || keyCode === keyCodes.nextCousinAlternate))) {
                // we are moving down
                if (isGroup || recursive) {
                    var isOffset = select(currentTarget).attr('data-offset-group');
                    target = !isOffset ? findFirstValidChild(currentTarget, recursive) : findFirstOffsetValidChild(currentTarget);
                }
            }
            else if (direction === 'up' ||
                (recursive && (keyCode === keyCodes.previousCousin || keyCode === keyCodes.previousCousinAlternate))) {
                // we are moving up
                if (isGroup) {
                    target = findSVGRoot(currentTarget);
                }
                else {
                    var isOffset = select(currentTarget).attr('data-offset-element');
                    target = !isOffset ? findValidParent(currentTarget, recursive, true) : findOffsetParent(currentTarget);
                }
            }
        }
        if (target && select(target).attr('tabindex')) {
            result.focused = true;
            result.id = target.id;
        }
        return result;
    };
    var removeKeyboardHighlight = function (parent, rootOnly) {
        var className = !rootOnly ? 'vcl-accessibility-focus' : 'vcl-accessibility-focus-root';
        select(parent.ownerSVGElement)
            .selectAll('.' + className + '-source')
            .classed(className + '-source', false);
        select(parent.ownerSVGElement)
            .selectAll('.' + className + '-indicator')
            .remove();
    };
    var hideKeyboardHighlight = function (parent) {
        select(parent.ownerSVGElement)
            .selectAll('.vcl-accessibility-focus-indicator')
            .classed('hidden', true)
            .style('opacity', 0)
            .attr('opacity', 0);
    };
    var drawKeyboardFocusClone = function (inputElement, recursive) {
        var source = inputElement.tagName !== 'DIV'
            ? inputElement
            : select(inputElement.parentNode)
                .select('svg')
                .node();
        var shouldDeleteSource = false;
        var className = !(source.tagName === 'svg') ? 'vcl-accessibility-focus' : 'vcl-accessibility-focus-root';
        var isNotAGeometry = source.tagName === 'g' || source.tagName === 'svg';
        if (isNotAGeometry) {
            var bbox = source.getBBox();
            var width = source.tagName === 'svg' ? Math.max(+source.getAttribute('width') - 10, 0) : +bbox.width + 10;
            var height = source.tagName === 'svg' ? Math.max(+source.getAttribute('height') - 10, 0) : +bbox.height + 10;
            var x = source.tagName === 'svg' ? 5 : +bbox.x - 5;
            var y = source.tagName === 'svg' ? 5 : +bbox.y - 5;
            var newSource = select(!(source.tagName === 'svg') ? source.parentNode : source)
                .append('rect')
                .attr('x', x)
                .attr('y', y)
                .attr('width', width)
                .attr('height', height)
                .attr('transform', select(source).attr('transform') || null)
                .attr('fill', 'none')
                .style('fill', 'none');
            source = newSource.node();
            shouldDeleteSource = true;
        }
        else {
            var shouldHideOutline = select(source)
                .style('outline')
                .includes('auto');
            if (shouldHideOutline) {
                select(source)
                    .style('outline-width', '0px')
                    .style('outline-offset', '0px')
                    .style('outline-color', 'none');
            }
        }
        var parent = source.parentNode;
        removeKeyboardHighlight(parent.tagName !== 'svg' ? parent : parent.firstElementChild);
        select(source).classed(className + '-source', true);
        var hasWidth = select(source).attr('width');
        var highlightCopy = source.cloneNode(false);
        var haloCopy = source.cloneNode(false);
        var copy = source.cloneNode(false);
        if ((!recursive && !shouldDeleteSource) || (recursive && isNotAGeometry)) {
            var elevateParentLevel = !isNotAGeometry &&
                (!(select(source.parentNode).attr('tabindex') === null) || select(source.parentNode).classed('offset-target'));
            var targetAppendLocation = !elevateParentLevel ? parent : parent.parentNode;
            var parentCopy = parent.cloneNode(false);
            parentCopy.appendChild(haloCopy);
            parentCopy.appendChild(highlightCopy);
            parentCopy.appendChild(copy);
            targetAppendLocation.appendChild(parentCopy);
            applyDefaults$1(select(parentCopy), className);
            select(parentCopy).attr('filter', null);
        }
        else {
            if (recursive) {
                // NOTE: below chunk assumes recursive === a circle SVG primitive
                // this is true for now, with circle-packing as the only current recursive chart
                // future hierarchical charts will need special treatment
                var baseRadius = +select(copy).attr('r');
                parent.parentNode.appendChild(haloCopy);
                select(haloCopy)
                    .attr('r', baseRadius + 6)
                    .attr('stroke-width', 0);
                parent.parentNode.appendChild(highlightCopy);
                select(highlightCopy)
                    .attr('r', baseRadius + 3)
                    .attr('stroke-width', 0);
                // NOTE ALSO: recursive elements do not need to copy+append themselves,
                // they only need to append their halo + highlight elements
            }
            else {
                var isOffsetGroup = !!select(inputElement).attr('data-offset-group');
                if (!isOffsetGroup) {
                    if (source.nextSibling) {
                        parent.insertBefore(copy, source.nextSibling);
                        parent.insertBefore(highlightCopy, source.nextSibling);
                        parent.insertBefore(haloCopy, source.nextSibling);
                    }
                    else {
                        parent.appendChild(haloCopy);
                        parent.appendChild(highlightCopy);
                        parent.appendChild(copy);
                    }
                }
                else {
                    var offsetTarget = parent.nextSibling.nextSibling;
                    parent.parentNode.insertBefore(haloCopy, offsetTarget);
                    parent.parentNode.insertBefore(highlightCopy, offsetTarget);
                    parent.parentNode.insertBefore(copy, offsetTarget);
                }
            }
        }
        var copyStyle = select(copy)
            .style('opacity', !isNotAGeometry ? 1 : 0)
            .attr('opacity', !isNotAGeometry ? 1 : 0)
            .style('stroke-opacity', !isNotAGeometry ? 1 : 0)
            .attr('stroke-opacity', !isNotAGeometry ? 1 : 0);
        if ((!recursive && !isNotAGeometry && hasWidth) || isNotAGeometry) {
            copyStyle.style('fill-opacity', 0).attr('fill-opacity', 0);
        }
        applyDefaults$1(copyStyle, className);
        var isAlluvial = select(source).data() &&
            select(source).data()[0] &&
            select(source).data()[0].source &&
            select(source).data()[0].target &&
            (select(source).data()[0].y0 || select(source).data()[0].y0 === 0);
        var highlightStyle = select(highlightCopy);
        applyDefaults$1(highlightStyle, className);
        applyOutlineOverride$1(highlightStyle, !isNotAGeometry && !recursive && !hasWidth ? 10 : 6, '#ffffff', isAlluvial ? select(source).data()[0] : undefined);
        if (!recursive && !isNotAGeometry && hasWidth) {
            applySizeOverride(highlightStyle, 3);
        }
        highlightStyle.style('opacity', 1).attr('opacity', 1);
        var haloStyle = select(haloCopy);
        applyDefaults$1(haloStyle, className);
        applyOutlineOverride$1(haloStyle, !isNotAGeometry && !recursive && !hasWidth ? 14 : !isNotAGeometry ? 2 : 10, '#000000', isAlluvial ? select(source).data()[0] : undefined);
        if (!recursive && !isNotAGeometry && hasWidth) {
            applySizeOverride(haloStyle, 7);
        }
        haloStyle.style('opacity', 1).attr('opacity', 1);
        if (shouldDeleteSource) {
            select(source).remove();
        }
    };
    var applyDefaults$1 = function (selection, className) {
        if (selection.attr('d') && selection.attr('filter') && !selection.attr('marker-start')) {
            selection.attr('filter', null);
        }
        selection
            .attr('id', null)
            .attr('class', className + '-highlight ' + className + '-indicator')
            .attr('focusable', false)
            .attr('aria-label', null)
            .attr('aria-hidden', true)
            .attr('role', null)
            .style('pointer-events', 'none')
            .attr('tabindex', null)
            .attr('mix-blend-mode', null)
            .style('mix-blend-mode', null)
            .attr('r', function (_, i, n) {
            var r = parseFloat(select(n[i]).attr('r'));
            return r || 1;
        });
    };
    var applySizeOverride = function (selection, offset) {
        selection
            .attr('width', function (_, i, n) {
            var width = parseFloat(select(n[i]).attr('width'));
            return width + offset * 2;
        })
            .attr('height', function (_, i, n) {
            var height = parseFloat(select(n[i]).attr('height'));
            return height + offset * 2;
        })
            .attr('x', function (_, i, n) {
            var x = parseFloat(select(n[i]).attr('x'));
            return x - offset;
        })
            .attr('y', function (_, i, n) {
            var y = parseFloat(select(n[i]).attr('y'));
            return y - offset;
        });
    };
    var applyOutlineOverride$1 = function (selection, extraStrokeWidth, strokeColor, d) {
        selection
            .style('stroke-dasharray', '')
            .attr('stroke-dasharray', null)
            .style('outline-offset', '0px')
            .style('outline-color', 'none')
            .style('outline-width', '0px')
            .attr('filter', null)
            .style('stroke-linecap', !d ? 'round' : 'butt')
            .style('fill', 'none')
            .style('stroke-opacity', 1)
            .style('stroke', strokeColor)
            .style('stroke-width', function (_, i, n) {
            var width = select(n[i]).style('stroke') !== 'none' ? parseFloat(select(n[i]).style('stroke-width')) || 0 : 0;
            var scaleIndex = select(n[i]).attr('transform')
                ? select(n[i])
                    .attr('transform')
                    .indexOf('scale')
                : -1;
            var scale = 1;
            if (scaleIndex > -1) {
                var scaleSubstring = select(n[i])
                    .attr('transform')
                    .substring(scaleIndex + 6);
                var endSubstring = scaleSubstring.indexOf(',') < scaleSubstring.indexOf(')') && scaleSubstring.indexOf(',') !== -1
                    ? scaleSubstring.indexOf(',')
                    : scaleSubstring.indexOf(')');
                scale = +scaleSubstring.substring(0, endSubstring);
            }
            var bonus = 0;
            var me = select(n[i]);
            if (me.attr('d') && d) {
                var originalPath = me.attr('d').substr(1);
                var offsetStart = "M " + (d.source.x1 - extraStrokeWidth / 2) + " " + d.y0 + " L";
                var offsetEnd = "L " + (d.target.x0 + extraStrokeWidth / 2) + " " + d.y1;
                me.attr('d', offsetStart + originalPath + offsetEnd);
            }
            else if (me.attr('marker-start') && me.attr('data-centerX1') && me.attr('d')) {
                var x1 = me.attr('data-centerX1');
                var y1 = me.attr('data-centerY1');
                var x2 = me.attr('data-centerX2');
                var y2 = me.attr('data-centerY2');
                me.attr('d', "M " + x1 + " " + y1 + " L " + x2 + " " + y2);
                bonus = +me.attr('data-barSize') + 6;
            }
            me.attr('marker-start', null);
            me.attr('marker-end', null);
            return (width + extraStrokeWidth + bonus) / scale + 'px';
        });
    };
    var findValidSiblingTarget = function (element) {
        return !element.nextElementSibling
            ? null
            : element.nextElementSibling.nodeName === 'g'
                ? element.nextElementSibling
                : findValidSiblingTarget(element.nextElementSibling);
    };
    var findValidChildTarget = function (element, requireTabIndex) {
        if ((!requireTabIndex || (requireTabIndex && select(element).attr('tabindex') !== null)) &&
            !select(element).classed('vcl-accessibility-focus-highlight')) {
            return element;
        }
        if (element.nextElementSibling) {
            return findValidChildTarget(element.nextElementSibling, requireTabIndex);
        }
        else {
            return null;
        }
    };
    var getOffset = function (el) {
        var bounds = el.getBoundingClientRect(); // bounds.top
        // ie11 includes scroll already in pageX/Y, other tested browsers do not do this
        var left = bounds.left + (isIE11$2 ? 0 : document.body.scrollLeft + document.documentElement.scrollLeft);
        var top = bounds.top + (isIE11$2 ? 0 : document.body.scrollTop + document.documentElement.scrollTop);
        return {
            top: top,
            left: left
        };
    };
    var blurAsMouseout = function (node) {
        removeKeyboardHighlight(node.parentNode);
        var evt = new MouseEvent('mouseout', { bubbles: false, cancelable: true });
        node.dispatchEvent(evt);
    };
    var focusAsMouseover = function (node, recursive, drawClone) {
        var leftPos = getOffset(node).left;
        var topPos = getOffset(node).top;
        var evt = new MouseEvent('mouseover', { bubbles: false, cancelable: true, clientX: leftPos, clientY: topPos });
        if (drawClone) {
            drawKeyboardFocusClone(node, recursive);
        }
        node.dispatchEvent(evt);
    };

    /**
     * Copyright (c) 2021, 2022 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var emptyDescriptions = {
        'vcl-access-title': '',
        'vcl-access-subtitle': '',
        'vcl-access-long-description': '',
        'vcl-access-context': '',
        'vcl-access-executive-summary': '',
        'vcl-access-purpose': '',
        'vcl-access-statistics': '',
        'vcl-access-layout': '',
        'vcl-access-xAxis': '',
        'vcl-access-yAxis': '',
        'vcl-access-notes': '',
        'vcl-access-annotation': '',
        'vcl-access-annotation-title': '',
        'vcl-access-annotation-description': '',
        headings: ''
    };
    var initializeDescriptionRoot = function (_a) {
        var rootEle = _a.rootEle, title = _a.title, chartTag = _a.chartTag, uniqueID = _a.uniqueID, highestHeadingLevel = _a.highestHeadingLevel, redraw = _a.redraw, disableKeyNav = _a.disableKeyNav;
        var level1 = findTagLevel(highestHeadingLevel, 0);
        level1 = level1 === 'h1' ? 'h2' : level1;
        var level2 = findTagLevel(level1, 1);
        var level3 = findTagLevel(level1, 2);
        var level4 = findTagLevel(level1, 3);
        var instructionsWrapper = select(rootEle).select('.vcl-accessibility-instructions');
        if (!instructionsWrapper.size() || redraw) {
            select(rootEle)
                .select('.vcl-main-title')
                .attr('aria-hidden', 'true');
            select(rootEle)
                .select('.vcl-sub-title')
                .attr('aria-hidden', 'true');
            if (!instructionsWrapper.size()) {
                instructionsWrapper = select(rootEle)
                    .select('.o-layout')
                    .insert('div', ':first-child')
                    .attr('class', 'vcl-accessibility-instructions')
                    .style('position', 'absolute')
                    .style('width', '200px');
            }
            else {
                instructionsWrapper.selectAll('*').remove();
            }
            instructionsWrapper.append(level4).attr('class', 'screen-reader-info vcl-region-label');
            // .on('focus', focusInstructions)
            // .on('blur', blurInstructions)
            // .attr('tabindex', 0);
            instructionsWrapper
                .append(level1)
                .attr('class', 'screen-reader-info vcl-access-title')
                .text(emptyDescriptions['vcl-access-title']);
            instructionsWrapper
                .append(level2)
                .attr('class', 'screen-reader-info vcl-access-subtitle')
                .text(emptyDescriptions['vcl-access-subtitle']);
            instructionsWrapper
                .append(level2)
                .attr('class', 'screen-reader-info vcl-access-executive-summary-heading')
                .text(emptyDescriptions['headings']);
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info vcl-access-executive-summary')
                .attr('data-level', level2)
                .text(emptyDescriptions['vcl-access-executive-summary']);
            instructionsWrapper
                .append(level2)
                .attr('class', 'screen-reader-info vcl-access-purpose-heading')
                .text(emptyDescriptions['headings']);
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info vcl-access-purpose')
                .attr('data-level', level2)
                .text(emptyDescriptions['vcl-access-purpose']);
            instructionsWrapper
                .append(level2)
                .attr('class', 'screen-reader-info vcl-access-long-description-heading')
                .text(emptyDescriptions['headings']);
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info vcl-access-long-description')
                .attr('data-level', level2)
                .text(emptyDescriptions['vcl-access-long-description']);
            instructionsWrapper
                .append(level4)
                .attr('data-level', level2)
                .attr('class', 'screen-reader-info vcl-access-context')
                .text(emptyDescriptions['vcl-access-context']);
            instructionsWrapper
                .append(level2)
                .attr('class', 'screen-reader-info vcl-access-structure-heading')
                .text('Structure');
            instructionsWrapper
                .append(level3)
                .attr('class', 'screen-reader-info vcl-access-statistics-heading')
                .text(emptyDescriptions['headings']);
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info vcl-access-statistics')
                .attr('data-level', level3)
                .text(emptyDescriptions['vcl-access-statistics']);
            instructionsWrapper
                .append(level3)
                .attr('class', 'screen-reader-info vcl-access-chart-layout-heading')
                .text('Chart Layout Description');
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info vcl-access-layout')
                .text(emptyDescriptions['vcl-access-layout']);
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info vcl-access-xAxis')
                .text(emptyDescriptions['vcl-access-xAxis']);
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info vcl-access-yAxis')
                .text(emptyDescriptions['vcl-access-yAxis']);
            instructionsWrapper
                .append(level3)
                .attr('class', 'screen-reader-info vcl-access-notes-heading')
                .text(emptyDescriptions['headings']);
            instructionsWrapper
                .append(level4)
                .attr('class', 'screen-reader-info vcl-access-notes')
                .attr('data-level', level3)
                .attr('data-annotationlevel', level2)
                .text(emptyDescriptions['vcl-access-notes']);
            instructionsWrapper
                .append(level2)
                .attr('class', 'screen-reader-info vcl-access-annotations-heading')
                .text(emptyDescriptions['headings']);
        }
        instructionsWrapper.attr('id', 'chart-instructions-' + uniqueID);
        var chartTitle = title ? ', Titled: ' + title : ', with no title provided.';
        var fullDescription = "Keyboard interactive " + chartTag + chartTitle + ". This section contains additional information about this chart. Pressing TAB will focus the keyboard instructions menu. Tabbing again takes you to the chart area."; //  Chart Unique ID: ${uniqueID}.
        var nonInteractive = "Static " + chartTag + " image" + chartTitle + ". This section contains additional information about this chart. Pressing TAB will focus the data table button.";
        instructionsWrapper.select('.vcl-region-label').text(!disableKeyNav ? fullDescription : nonInteractive);
    };
    var setAccessTitle = function (rootEle, title) {
        select(rootEle)
            .select('.vcl-access-title')
            .text(title ? 'Chart title: ' + title : emptyDescriptions['vcl-access-title']);
    };
    var setAccessSubtitle = function (rootEle, subtitle) {
        select(rootEle)
            .select('.vcl-access-subtitle')
            .text(subtitle ? 'Chart subtitle: ' + subtitle : emptyDescriptions['vcl-access-subtitle']);
    };
    var setAccessLongDescription = function (rootEle, description) {
        setDescriptionNode(select(rootEle).select('.vcl-accessibility-instructions'), description, 'Long Description', 'vcl-access-long-description', description ||
            select(rootEle)
                .select('.vcl-access-context')
                .text());
    };
    var setAccessContext = function (rootEle, context) {
        setDescriptionNode(select(rootEle).select('.vcl-accessibility-instructions'), context, 'Long Description', 'vcl-access-context', context ||
            select(rootEle)
                .select('.vcl-access-long-description')
                .text(), 'vcl-access-long-description');
    };
    var setAccessExecutiveSummary = function (rootEle, summary) {
        setDescriptionNode(select(rootEle).select('.vcl-accessibility-instructions'), summary, 'Executive Summary', 'vcl-access-executive-summary', !!summary);
    };
    var setAccessPurpose = function (rootEle, purpose) {
        setDescriptionNode(select(rootEle).select('.vcl-accessibility-instructions'), purpose, 'Purpose', 'vcl-access-purpose', !!purpose);
    };
    var setAccessStatistics = function (rootEle, statistics) {
        setDescriptionNode(select(rootEle).select('.vcl-accessibility-instructions'), statistics, 'Statistical Information', 'vcl-access-statistics', !!statistics);
    };
    var setAccessChartCounts = function (_a) {
        var rootEle = _a.rootEle, parentGNode = _a.parentGNode, chartTag = _a.chartTag, geomType = _a.geomType, groupName = _a.groupName, recursive = _a.recursive;
        var primaryG = select(parentGNode);
        var plural = primaryG
            .selectAll('g')
            .selectAll('*:not(title)')
            .size() > 1 ||
            (primaryG
                .selectAll('g')
                .selectAll('*:not(title)')
                .size() === 0 && primaryG.selectAll('*:not(title)').size()) > 1
            ? 's'
            : '';
        var groupNameString = groupName || geomType + ' group';
        var groupPlural = primaryG.selectAll('g').size() > 1 ? 's' : '';
        var count = !recursive
            ? primaryG.selectAll('g').size()
                ? primaryG.selectAll('g').size() +
                    ' ' +
                    groupNameString +
                    groupPlural +
                    ' containing a total ' +
                    (primaryG
                        .selectAll('g')
                        .selectAll('*:not(title)')
                        .size() -
                        primaryG
                            .selectAll('g')
                            .selectAll('.vcl-accessibility-focus-highlight')
                            .size()) +
                    ' ' +
                    geomType +
                    plural
                : primaryG.selectAll('*:not(title)').size() -
                    primaryG.selectAll('.vcl-accessibility-focus-highlight').size() +
                    ' ' +
                    geomType +
                    plural
            : primaryG.selectAll('g').size() +
                ' ' +
                geomType +
                plural +
                ' (more ' +
                geomType +
                's may be revealed upon interaction)';
        select(rootEle)
            .select('.vcl-access-layout')
            .text("This is a " + chartTag + " with " + count + ".");
    };
    var setAccessXAxis = function (_a) {
        var rootEle = _a.rootEle, hasXAxis = _a.hasXAxis, xAxis = _a.xAxis, xAxisLabel = _a.xAxisLabel;
        var label = emptyDescriptions['vcl-access-xAxis'];
        if (hasXAxis) {
            var xDomain = xAxis && xAxis.formattedTicks && xAxis.formattedTicks[0] ? xAxis.formattedTicks : [];
            var xAxisTitle = xAxisLabel ? ", titled " + xAxisLabel : '';
            var xAxisRange = xDomain.length
                ? " with a range that starts with " + xDomain[0] + " and ends with " + xDomain[xDomain.length - 1]
                : '';
            label = "The chart has a horizontal X Axis" + xAxisTitle + xAxisRange + ".";
        }
        select(rootEle)
            .select('.vcl-access-xAxis')
            .text(label);
    };
    var setAccessYAxis = function (_a) {
        var rootEle = _a.rootEle, hasYAxis = _a.hasYAxis, yAxis = _a.yAxis, secondaryYAxis = _a.secondaryYAxis, yAxisLabel = _a.yAxisLabel, secondaryYAxisLabel = _a.secondaryYAxisLabel, xAxisLabel = _a.xAxisLabel;
        var label = emptyDescriptions['vcl-access-yAxis'];
        // y axis range from min to max
        // secondary y axis range from min to max e.g for pareto-chart.
        var yAxisTicks;
        if (yAxis && yAxis.formattedTicks) {
            yAxisTicks = yAxis.formattedTicks;
        }
        var secondaryYAxisTicks;
        if (secondaryYAxis && secondaryYAxis.formattedTicks) {
            secondaryYAxisTicks = secondaryYAxis.formattedTicks;
        }
        if (hasYAxis) {
            if (secondaryYAxisTicks) {
                // secondary y axis present
                var yAxis1Title = yAxisLabel ? ", titled " + yAxisLabel : '';
                var yAxis1Ticks = yAxisTicks
                    ? " with a range that starts with " + yAxisTicks[0] + " and ends with " + yAxisTicks[yAxisTicks.length - 1]
                    : '';
                var yAxis2Title = secondaryYAxisLabel ? ", titled " + secondaryYAxisLabel : '';
                var yAxis2Ticks = secondaryYAxisTicks
                    ? " with a range that starts with " + secondaryYAxisTicks[0] + " and ends with " + secondaryYAxisTicks[secondaryYAxisTicks.length - 1]
                    : '';
                label = "The chart has a primary vertical Y Axis" + yAxis1Title + yAxis1Ticks + ". ";
                label += "The chart has a secondary vertical Y Axis" + yAxis2Title + yAxis2Ticks + ".";
            }
            else if (!(typeof yAxis === 'function')) {
                // y axis is an object that may contain multiple axes
                // parallel plot uses this
                var yLabels = Object.keys(yAxis);
                var firstYDomain = yAxis[yLabels[0]].y && yAxis[yLabels[0]].y.formattedTicks && yAxis[yLabels[0]].y.formattedTicks[0]
                    ? yAxis[yLabels[0]].y.formattedTicks
                    : [];
                var y1Range = firstYDomain.length
                    ? ", with a range that starts with " + firstYDomain[0] + " and ends with " + firstYDomain[firstYDomain.length - 1]
                    : '';
                label =
                    yLabels.length > 1
                        ? "The chart has " + yLabels.length + " vertical Y Axis sections, all using different scales" + (xAxisLabel ? '. This series is titled ' + xAxisLabel : '') + "."
                        : "The chart has a vertical Y Axis, titled " + yLabels[0] + y1Range + ".";
                if (yLabels.length > 1) {
                    // the yAxis objected *does* contain multiple objects!
                    var i = 0;
                    for (i = 0; i < yLabels.length; i++) {
                        var labelScale = yAxis[yLabels[i]].y;
                        var iYDomain = labelScale && labelScale.formattedTicks && labelScale.formattedTicks[0] ? labelScale.formattedTicks : [];
                        var iYRange = iYDomain.length
                            ? ", with a range that starts with " + iYDomain[0] + " and ends with " + iYDomain[iYDomain.length - 1]
                            : '';
                        label += " Y Axis " + (i + 1) + " of " + yLabels.length + ", titled " + yLabels[i] + iYRange + ".";
                    }
                }
            }
            else {
                // only one axis present
                var yDomain = yAxis && yAxis.formattedTicks && yAxis.formattedTicks[0] ? yAxis.formattedTicks : [];
                var yAxisTitle = yAxisLabel ? ", titled " + yAxisLabel : '';
                var yAxisRange = yDomain.length
                    ? " with a range that starts with " + yDomain[0] + " and ends with " + yDomain[yDomain.length - 1]
                    : '';
                label = "The chart has a vertical Y axis" + yAxisTitle + yAxisRange + ".";
            }
        }
        select(rootEle)
            .select('.vcl-access-yAxis')
            .text(label);
    };
    var setAccessStructure = function (rootEle, structure) {
        setDescriptionNode(select(rootEle).select('.vcl-accessibility-instructions'), structure, 'Notes about the chart structure', 'vcl-access-notes', !!structure);
    };
    var setAccessAnnotation = function (rootEle, annotations) {
        var parent = select(rootEle).select('.vcl-accessibility-instructions');
        var notesNode = parent.select('.vcl-access-notes').node();
        var header = parent.select('.vcl-access-annotations-heading');
        var instructionsHeading = '.vcl-interaction-instructions';
        var headerLevel = notesNode.dataset.annotationlevel;
        var level1 = findTagLevel(headerLevel, 1);
        var level2 = findTagLevel(headerLevel, 2);
        parent.selectAll('.vcl-access-annotation').remove();
        var i = 1;
        if (annotations && annotations.length) {
            if (!header.size()) {
                header = parent
                    .insert(headerLevel, instructionsHeading)
                    .attr('class', 'screen-reader-info vcl-access-annotations-heading');
            }
            annotations.forEach(function (annotation) {
                var count = false;
                if (annotation.accessibilityDecorationOnly) {
                    count = false;
                }
                else {
                    if (annotation.note) {
                        if (annotation.note.title) {
                            count = true;
                            parent
                                .insert(level1, instructionsHeading)
                                .attr('class', 'screen-reader-info vcl-access-annotation')
                                .text(annotation.note.title || 'Annotation ' + i);
                        }
                        if (annotation.note.label) {
                            count = true;
                            parent
                                .insert(level2, instructionsHeading)
                                .attr('class', 'screen-reader-info vcl-access-annotation')
                                .text(annotation.note.label);
                        }
                    }
                    if (annotation.accessibilityDescription) {
                        count = true;
                        parent
                            .insert(level2, instructionsHeading)
                            .attr('class', 'screen-reader-info vcl-access-annotation')
                            .text(annotation.accessibilityDescription);
                    }
                }
                if (count) {
                    i++;
                }
            });
        }
        if (i - 1) {
            var plural = i - 2 > 0 ? 's' : '';
            var headingText = i - 1 + ' annotation' + plural + ' on the chart';
            header.text(headingText);
        }
        else {
            header.remove();
        }
    };
    var setAccessibilityDescriptionWidth = function (uniqueID, width) {
        select('#chart-instructions-' + uniqueID).style('width', function () {
            return Math.max(width, 200) + 'px';
        });
    };
    var findTagLevel = function (startLevel, depthFromStart) {
        if (startLevel === 'p' || startLevel === 'P' || !startLevel) {
            return 'p';
        }
        else if (startLevel === 'span' || startLevel === 'SPAN') {
            return 'span';
        }
        else if (startLevel === 'div' || startLevel === 'DIV') {
            return 'div';
        }
        var depth = depthFromStart || 0;
        var start = typeof startLevel !== 'string' || startLevel.length <= 1 ? startLevel : startLevel[1];
        if (+start + depth < 7 && depth < 3) {
            return 'h' + (+start + depth);
        }
        return 'p';
    };
    var setDescriptionNode = function (root, description, headingText, tag, contentExists, headingTag) {
        var contentNode = root.select('.' + tag).text(description || emptyDescriptions[tag]);
        var headingNode = root.select('.' + (headingTag || tag) + '-heading');
        if (contentExists) {
            if (!headingNode.size()) {
                headingNode = root
                    .insert(contentNode.node().dataset.level, '.' + (headingTag || tag))
                    .attr('class', 'screen-reader-info ' + (headingTag || tag) + '-heading');
            }
            headingNode.text(headingText);
        }
        else {
            headingNode.remove();
        }
    };

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    function getPadding(padding) {
        var paddingSetting;
        if (padding === 'large') {
            paddingSetting = {
                top: 40,
                bottom: 60,
                right: 100,
                left: 80
            };
        }
        else if (padding === 'small') {
            paddingSetting = {
                top: 10,
                bottom: 20,
                right: 40,
                left: 40
            };
        }
        else if (padding === '') {
            paddingSetting = {
                top: 20,
                bottom: 50,
                right: 70,
                left: 60
            };
        }
        return paddingSetting;
    }

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    // import { selection } from 'd3-selection';
    // in production build t.moveToFront() was erroring as not a function, refactored
    function moveToFront(selection) {
        // selection.prototype.moveToFront = function() {
        return selection.each(function () {
            this.parentNode.appendChild(this);
        });
        // };
        // return node.moveToFront();
    }

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    var mapButtons = {
        alaska: 'M0.2,1ZM0,0ZM0.1,0.3ZM0,0.2L8.1,6.9L3.8,7.5L0,0.2ZM0,0.3ZM0.5,1.2L0.5,1.2ZM1.4,2.5L1.4,2.5ZM5.1,6.6L5.1,6.6ZM1,0.7L4,7.2L1,0.7ZM0,0ZM0.6,0.8L5.5,4.1L0.6,0.8ZM2.1,0ZM0.8,0ZM51.5,5.8L60.5,5.3L66.9,10.4L68.9,20.3L70.9,30.2L72.8,40.1L74.8,50L76.8,60L82.9,61.6L89.5,68.2L94.3,62.3L101.8,67.6L108.9,74.6L116.4,77.9L119.6,85.6L114.5,84.3L110.2,81.3L105.5,75.8L98.9,70.1L97.7,69.7L92.3,68.5L92.3,71.8L83.6,67.7L79.2,66.4L69.8,66.2L62.1,64.5L59.9,61.7L56,64L53.2,68.1L47.1,73.4L45.4,70.6L48.6,62.5L45.6,62.8L41.4,70.4L40.4,75.3L34.9,81.6L29.7,87.2L23.9,90.9L18,93.5L11.9,94.7L7.5,97.8L2.3,99.3L5.3,96.9L12.3,92.3L16.4,91.7L23.2,86.2L27.5,77.7L23.2,76L18.8,74.1L14,72.7L11.2,67.6L5.2,62.2L3.5,56.3L8.3,49.6L15.4,46.7L19.5,41.1L16.1,39.7L8.9,38.9L4.8,32.3L9.5,28.7L14.2,29.8L19.4,28.7L20,27.4L15.2,21.7L10.7,14.4L18.3,10.6L24.8,4.6L32.7,0.2L36.9,1.5L43.1,4.9ZM0.9,2.9L0.9,2.9ZM2.6,2.8L7.4,1.5L3.5,6.8L2.6,2.8ZM0.7,0ZM0.6,0ZM1.4,0ZM1.1,0ZM0.4,0ZM0.5,0ZM0,0ZM0.5,0ZM1.2,0.3ZM3.2,0.1L3.2,0.1ZM5.6,0.1L0.1,3.6L5.6,0.1ZM0,1.8L0,1.8ZM0.9,0ZM0.6,0ZM0.6,0ZM0.7,0L6.6,4.9L0.7,0ZM0.6,0ZM0,0ZM2.6,0.6L2.6,0.6ZM1.7,0.8ZM0.8,0ZM0,0ZM1.6,0.8Z',
        hawaii: 'M67.6,57L65.7,56.3L63.8,55.6L62.9,53.9L63.1,51.9L63.3,49.9L62.5,48.1L61.7,46.2L60.9,44.4L61.2,42.7L62.7,41.3L63.6,39.5L64.1,37.7L63.2,36L63.6,34.2L65.4,35.1L67.2,36.1L69.1,36.9L71,37.5L72.9,38.2L74.5,39.4L76.1,40.7L76.4,42.5L77.5,44.1L79.1,45.3L80.7,46.6L80.2,48L78.8,49.5L77.1,50.4L75.1,50.9L73.2,51.5L71.5,52.6L69.8,53.7L68.6,55.3ZM51.8,20.9L53.1,22.6L54.7,22.8L56.6,22.5L58.5,23.5L60.4,24.5L61.1,25.9L60.1,27.6L58.1,28L56,28.5L54.1,28.2L53.9,26.1L52.7,24.9L50.8,24.2L50.3,22.4L51.8,20.9ZM45.3,17.8L43.9,19.4L41.9,19.6L40,19.4L41.1,17.6L43.2,17.7ZM29.4,9.3L30.3,11.3L31.2,13.2L30.5,15.2L28.8,15.9L26.7,16L25.8,14L24.9,12.1L25.7,11.2L27.7,10.5L29.4,9.3ZM4.7,0L6.7,0.4L7.4,2.4L6.9,4.6L5.2,6L3.2,5.4L1.2,4.6L0,3.3L0.6,1.2L2.6,0.6Z',
        puertoRico: 'M37.3,0L35.4,0.7L34.6,2.3L33.8,4.2L32.5,5.6L30.9,6.7L30.2,8.4L31.3,10.1L32.9,11.3L33.7,13.1L33.9,15L33.6,17L33.2,19L32.5,20.9L32.8,22.9L32.1,24.7L32.6,26.5L34.1,26.2L36,26.9L37.8,26.5L39.8,26.2L41.8,26.5L43.7,27L45.7,27.2L47.7,27L49.6,26.5L51.4,25.6L53.2,25.1L55.2,25.4L57.1,25.9L59.1,25.9L61.2,25.9L63.1,25.5L65,25.3L67,25.8L68.6,26.9L70.5,26.3L72.4,26.4L74.4,26.7L76.4,26.8L78.3,26.8L80,27.3L82,26.7L83.9,26.2L85.9,25.8L87.9,25.7L89.9,25.4L91.8,24.8L93.6,23.9L94.6,22.2L95.8,20.6L96.9,19L97.8,17.2L99.5,16.2L101.1,15L103,14.3L104.7,13.4L105.1,12.1L104,10.5L103.7,8.5L104.2,6.6L102.5,6.2L100.5,6.1L98.6,5.5L96.7,4.7L94.9,3.8L93,3.4L91,2.9L89,2.7L87,2.6L85,2.6L83.1,2.1L81.1,2.3L79.1,2.7L77.3,1.9L75.3,1.7L73.3,1.5L71.3,1.3L69.3,1.1L67.3,1.3L65.3,1.6L63.3,1.5L61.3,1.2L59.3,1.1L57.3,1.2L55.3,1.4L53.3,1.4L51.3,1.2L49.3,1.1L47.2,1.2L45.2,1.1L43.3,0.7L41.3,0.3L39.3,0.1L37.3,0ZM105,5.5ZM20.4,5.8ZM106.8,6.1ZM107.8,6.6ZM115.1,6.6ZM105.7,7ZM116.2,7L116.7,9.1L118.3,10.2L120.1,9.8L120.2,8.5L118.3,7.5L116.2,7ZM114,8ZM105.5,8.7ZM104.2,8.9ZM-1,16.4ZM114,16.5L112,16.7L110.1,17.3L108.2,17.8L106.5,18.7L106.8,20.1L108.7,20.4L110.7,20.1L112.6,19.7L114.6,19.3L116.5,18.8L118.3,18L117.9,17L116,16.7ZM2.8,18.2L0.6,18.5L-0.1,20.4L1.9,21.4L3.8,20.2L2.8,18.2ZM58.2,25.9ZM41.3,26.6ZM37,27.8ZM63.5,28.7Z',
        continentalUS: 'M78.9,25.6L79.9,23.8L81.4,27.2L81.4,23.5L82.8,21.8L84.4,18.8L83.3,18.3L86.8,16.4L87.2,14.9L87.2,11.2L90,8.7L89.5,5.7L87.2,3L85.5,6.1L83.4,9.2L79.6,10.2L77.4,13.3L74.4,15L72.2,18L68.9,20.1L68,17.6L66.1,15.3L65.8,12.1L62.8,13L61.6,16.5L61.5,20.2L59.6,17.9L60,14L60,12.1L63.6,10.7L62.9,9.2L59,9.6L57.1,9L53.6,9.7L54.9,7.7L53.1,6.8L49.3,5.9L45.8,5.1L41.8,5.1L37.8,4.9L33.8,4.6L29.8,4.2L25.8,3.7L21.9,3L18,2.2L14,1.4L10.2,0.4L7.6,1.6L4.5,1.1L4.2,5L2.9,8.8L1.2,12.4L0.4,16.2L0.1,20.1L1.2,24L1.8,27.8L2.8,31.5L6,33.8L8.1,37.1L11.8,38.1L15.2,40.2L18.7,42.1L22.7,42.6L26.5,42.1L29.4,44.8L31.4,48.2L34.5,47.1L37.6,49.3L39.6,52.7L42,55.6L43.6,53.8L45.8,50.7L49.1,48.4L52.9,47.9L56,48.7L59.6,48.4L59.3,45.9L63.2,45.6L67,46.3L70.5,46.3L72.3,49.6L74.2,52.8L77,55.3L78,51.8L76.3,48.1L74.3,44.7L74.5,40.8L76.9,37.7L79.2,34.8L81.2,31.9L81.2,28.5L78.9,25.6ZM75.2,56.8ZM76.5,56.3L76.5,56.3ZM82,32.1L82,32.1ZM88.4,16.4ZM87.5,16.5ZM88.6,9.7ZM89.3,9.2ZM80.4,25.4ZM56.6,7.2ZM65.2,10.4ZM6.8,0.2ZM44.1,55.7L44.6,51.7L44.1,55.7ZM3.3,32.7ZM3.5,32.7ZM5.5,34.7ZM5.4,35.5Z'
    };

    /**
     * Copyright (c) 2020 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    function resolveLines(left, right, key) {
        var output = [[], []];
        if (left.length < 1 || right.length < 1)
            return [];
        var leftKeys = {};
        var rightKeys = {};
        var deltas = [];
        var i = 0;
        for (i = 0; i < left.length; i++) {
            leftKeys[left[i][key]] = 1;
        }
        i = 0;
        for (i = 0; i < right.length; i++) {
            rightKeys[right[i][key]] = 1;
            if (leftKeys[right[i][key]]) {
                deltas.push(0);
            }
            else {
                deltas.push(1);
            }
        }
        i = 0;
        var rightPointer = 0;
        var leftPointer = 0;
        function push(change) {
            var leftElement = __assign({}, left[leftPointer]);
            var rightElement = __assign({}, right[rightPointer]);
            if (change) {
                leftElement[change] = true;
                rightElement[change] = true;
            }
            output[0].push(leftElement);
            output[1].push(rightElement);
        }
        function movePointers(leftChange, rightChange) {
            leftPointer = leftPointer + leftChange;
            rightPointer = rightPointer + rightChange;
        }
        var changeCounter = 0;
        var end = false;
        while (leftPointer < left.length && rightPointer < right.length) {
            var start = rightPointer !== 0 ? false : true;
            var adding = deltas[rightPointer];
            var removing = end && adding ? false : !rightKeys[left[leftPointer][key]];
            var retaining = !end && !removing ? true : false;
            if (removing) {
                var firstMove = !start && !end ? [0, -1] : [0, 0];
                var secondMove = !start && !end ? [1, 1] : [1, 0];
                movePointers(firstMove[0], firstMove[1]);
                push('exit');
                movePointers(secondMove[0], secondMove[1]);
            }
            else if (adding) {
                push('enter');
                movePointers(0, 1);
            }
            else if (retaining) {
                push(false);
                movePointers(1, 1);
            }
            if (!end && leftPointer === left.length && rightPointer < right.length) {
                end = true;
                movePointers(-1, 0);
            }
            else if (!end && leftPointer < left.length && rightPointer === right.length) {
                end = true;
                movePointers(0, -1);
            }
            changeCounter += removing || adding ? 1 : 0;
        }
        if (!changeCounter) {
            return [];
        }
        return output;
    }
    function generalizePath(element, targetLength) {
        var l = element.getTotalLength();
        var i = 0;
        var increment = l / targetLength;
        var path = 'M';
        while (i <= l) {
            if (i) {
                path += 'L';
            }
            var point = element.getPointAtLength(i);
            path += point.x + ',' + point.y;
            i += increment;
        }
        path += 'Z';
        return path;
    }
    function equalizePath(element, limit) {
        var l = element.getTotalLength();
        try {
            if (l > limit)
                throw 'Path length exceeds supplied limit. Raise limit.';
        }
        catch (err) {
            console.log(err);
        }
        var i = 0;
        var increment = 1;
        var path = 'M';
        var point = {};
        while (i <= l) {
            if (i) {
                path += 'L';
            }
            point = element.getPointAtLength(i);
            path += point['x'] + ',' + point['y'];
            i += increment;
        }
        while (i <= limit) {
            path += point['x'] + ',' + point['y'];
            i += increment;
        }
        path += 'Z';
        return path;
    }

    var version = "4.13.0";

    function ascending$2 (a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector$1 (compare) {
        if (compare.length === 1)
            compare = ascendingComparator$1(compare);
        return {
            left: function (a, x, lo, hi) {
                if (lo == null)
                    lo = 0;
                if (hi == null)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                        lo = mid + 1;
                    else
                        hi = mid;
                }
                return lo;
            },
            right: function (a, x, lo, hi) {
                if (lo == null)
                    lo = 0;
                if (hi == null)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                        hi = mid;
                    else
                        lo = mid + 1;
                }
                return lo;
            }
        };
    }
    function ascendingComparator$1(f) {
        return function (d, x) {
            return ascending$2(f(d), x);
        };
    }

    var ascendingBisect$1 = bisector$1(ascending$2);
    var bisectRight$1 = ascendingBisect$1.right;
    var bisectLeft = ascendingBisect$1.left;

    function pairs (array, f) {
        if (f == null)
            f = pair;
        var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
            pairs[i] = f(p, p = array[++i]);
        return pairs;
    }
    function pair(a, b) {
        return [a, b];
    }

    function cross (values0, values1, reduce) {
        var n0 = values0.length, n1 = values1.length, values = new Array(n0 * n1), i0, i1, i, value0;
        if (reduce == null)
            reduce = pair;
        for (i0 = i = 0; i0 < n0; ++i0) {
            for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
                values[i] = reduce(value0, values1[i1]);
            }
        }
        return values;
    }

    function descending (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function number$3 (x) {
        return x === null ? NaN : +x;
    }

    function variance (values, valueof) {
        var n = values.length, m = 0, i = -1, mean = 0, value, delta, sum = 0;
        if (valueof == null) {
            while (++i < n) {
                if (!isNaN(value = number$3(values[i]))) {
                    delta = value - mean;
                    mean += delta / ++m;
                    sum += delta * (value - mean);
                }
            }
        }
        else {
            while (++i < n) {
                if (!isNaN(value = number$3(valueof(values[i], i, values)))) {
                    delta = value - mean;
                    mean += delta / ++m;
                    sum += delta * (value - mean);
                }
            }
        }
        if (m > 1)
            return sum / (m - 1);
    }

    function deviation (array, f) {
        var v = variance(array, f);
        return v ? Math.sqrt(v) : v;
    }

    function extent (values, valueof) {
        var n = values.length, i = -1, value, min, max;
        if (valueof == null) {
            while (++i < n) { // Find the first comparable value.
                if ((value = values[i]) != null && value >= value) {
                    min = max = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = values[i]) != null) {
                            if (min > value)
                                min = value;
                            if (max < value)
                                max = value;
                        }
                    }
                }
            }
        }
        else {
            while (++i < n) { // Find the first comparable value.
                if ((value = valueof(values[i], i, values)) != null && value >= value) {
                    min = max = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = valueof(values[i], i, values)) != null) {
                            if (min > value)
                                min = value;
                            if (max < value)
                                max = value;
                        }
                    }
                }
            }
        }
        return [min, max];
    }

    var array$1 = Array.prototype;
    var slice$3 = array$1.slice;
    var map$3 = array$1.map;

    function constant$4 (x) {
        return function () {
            return x;
        };
    }

    function identity$5 (x) {
        return x;
    }

    function range$1 (start, stop, step) {
        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
        var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
        while (++i < n) {
            range[i] = start + i * step;
        }
        return range;
    }

    var e10$1 = Math.sqrt(50), e5$1 = Math.sqrt(10), e2$1 = Math.sqrt(2);
    function ticks$1 (start, stop, count) {
        var reverse, i = -1, n, ticks, step;
        stop = +stop, start = +start, count = +count;
        if (start === stop && count > 0)
            return [start];
        if (reverse = stop < start)
            n = start, start = stop, stop = n;
        if ((step = tickIncrement$1(start, stop, count)) === 0 || !isFinite(step))
            return [];
        if (step > 0) {
            start = Math.ceil(start / step);
            stop = Math.floor(stop / step);
            ticks = new Array(n = Math.ceil(stop - start + 1));
            while (++i < n)
                ticks[i] = (start + i) * step;
        }
        else {
            start = Math.floor(start * step);
            stop = Math.ceil(stop * step);
            ticks = new Array(n = Math.ceil(start - stop + 1));
            while (++i < n)
                ticks[i] = (start - i) / step;
        }
        if (reverse)
            ticks.reverse();
        return ticks;
    }
    function tickIncrement$1(start, stop, count) {
        var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
        return power >= 0
            ? (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1) * Math.pow(10, power)
            : -Math.pow(10, -power) / (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1);
    }
    function tickStep$1(start, stop, count) {
        var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
        if (error >= e10$1)
            step1 *= 10;
        else if (error >= e5$1)
            step1 *= 5;
        else if (error >= e2$1)
            step1 *= 2;
        return stop < start ? -step1 : step1;
    }

    function sturges (values) {
        return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
    }

    function histogram () {
        var value = identity$5, domain = extent, threshold = sturges;
        function histogram(data) {
            var i, n = data.length, x, values = new Array(n);
            for (i = 0; i < n; ++i) {
                values[i] = value(data[i], i, data);
            }
            var xz = domain(values), x0 = xz[0], x1 = xz[1], tz = threshold(values, x0, x1);
            // Convert number of thresholds into uniform thresholds.
            if (!Array.isArray(tz)) {
                tz = tickStep$1(x0, x1, tz);
                tz = range$1(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
            }
            // Remove any thresholds outside the domain.
            var m = tz.length;
            while (tz[0] <= x0)
                tz.shift(), --m;
            while (tz[m - 1] > x1)
                tz.pop(), --m;
            var bins = new Array(m + 1), bin;
            // Initialize bins.
            for (i = 0; i <= m; ++i) {
                bin = bins[i] = [];
                bin.x0 = i > 0 ? tz[i - 1] : x0;
                bin.x1 = i < m ? tz[i] : x1;
            }
            // Assign data to bins by value, ignoring any outside the domain.
            for (i = 0; i < n; ++i) {
                x = values[i];
                if (x0 <= x && x <= x1) {
                    bins[bisectRight$1(tz, x, 0, m)].push(data[i]);
                }
            }
            return bins;
        }
        histogram.value = function (_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant$4(_), histogram) : value;
        };
        histogram.domain = function (_) {
            return arguments.length ? (domain = typeof _ === "function" ? _ : constant$4([_[0], _[1]]), histogram) : domain;
        };
        histogram.thresholds = function (_) {
            return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$4(slice$3.call(_)) : constant$4(_), histogram) : threshold;
        };
        return histogram;
    }

    function quantile (values, p, valueof) {
        if (valueof == null)
            valueof = number$3;
        if (!(n = values.length))
            return;
        if ((p = +p) <= 0 || n < 2)
            return +valueof(values[0], 0, values);
        if (p >= 1)
            return +valueof(values[n - 1], n - 1, values);
        var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
        return value0 + (value1 - value0) * (i - i0);
    }

    function freedmanDiaconis (values, min, max) {
        values = map$3.call(values, number$3).sort(ascending$2);
        return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
    }

    function scott (values, min, max) {
        return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
    }

    function max$1 (values, valueof) {
        var n = values.length, i = -1, value, max;
        if (valueof == null) {
            while (++i < n) { // Find the first comparable value.
                if ((value = values[i]) != null && value >= value) {
                    max = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = values[i]) != null && value > max) {
                            max = value;
                        }
                    }
                }
            }
        }
        else {
            while (++i < n) { // Find the first comparable value.
                if ((value = valueof(values[i], i, values)) != null && value >= value) {
                    max = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = valueof(values[i], i, values)) != null && value > max) {
                            max = value;
                        }
                    }
                }
            }
        }
        return max;
    }

    function mean (values, valueof) {
        var n = values.length, m = n, i = -1, value, sum = 0;
        if (valueof == null) {
            while (++i < n) {
                if (!isNaN(value = number$3(values[i])))
                    sum += value;
                else
                    --m;
            }
        }
        else {
            while (++i < n) {
                if (!isNaN(value = number$3(valueof(values[i], i, values))))
                    sum += value;
                else
                    --m;
            }
        }
        if (m)
            return sum / m;
    }

    function median (values, valueof) {
        var n = values.length, i = -1, value, numbers = [];
        if (valueof == null) {
            while (++i < n) {
                if (!isNaN(value = number$3(values[i]))) {
                    numbers.push(value);
                }
            }
        }
        else {
            while (++i < n) {
                if (!isNaN(value = number$3(valueof(values[i], i, values)))) {
                    numbers.push(value);
                }
            }
        }
        return quantile(numbers.sort(ascending$2), 0.5);
    }

    function merge$1 (arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n)
            j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    }

    function min$1 (values, valueof) {
        var n = values.length, i = -1, value, min;
        if (valueof == null) {
            while (++i < n) { // Find the first comparable value.
                if ((value = values[i]) != null && value >= value) {
                    min = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = values[i]) != null && min > value) {
                            min = value;
                        }
                    }
                }
            }
        }
        else {
            while (++i < n) { // Find the first comparable value.
                if ((value = valueof(values[i], i, values)) != null && value >= value) {
                    min = value;
                    while (++i < n) { // Compare the remaining values.
                        if ((value = valueof(values[i], i, values)) != null && min > value) {
                            min = value;
                        }
                    }
                }
            }
        }
        return min;
    }

    function permute (array, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while (i--)
            permutes[i] = array[indexes[i]];
        return permutes;
    }

    function scan (values, compare) {
        if (!(n = values.length))
            return;
        var n, i = 0, j = 0, xi, xj = values[j];
        if (compare == null)
            compare = ascending$2;
        while (++i < n) {
            if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
                xj = xi, j = i;
            }
        }
        if (compare(xj, xj) === 0)
            return j;
    }

    function shuffle (array, i0, i1) {
        var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0];
            array[m + i0] = array[i + i0];
            array[i + i0] = t;
        }
        return array;
    }

    function sum$1 (values, valueof) {
        var n = values.length, i = -1, value, sum = 0;
        if (valueof == null) {
            while (++i < n) {
                if (value = +values[i])
                    sum += value; // Note: zero and null are equivalent.
            }
        }
        else {
            while (++i < n) {
                if (value = +valueof(values[i], i, values))
                    sum += value;
            }
        }
        return sum;
    }

    function transpose (matrix) {
        if (!(n = matrix.length))
            return [];
        for (var i = -1, m = min$1(matrix, length), transpose = new Array(m); ++i < m;) {
            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
                row[j] = matrix[j][i];
            }
        }
        return transpose;
    }
    function length(d) {
        return d.length;
    }

    function zip () {
        return transpose(arguments);
    }

    var slice$4 = Array.prototype.slice;

    function identity$6 (x) {
        return x;
    }

    var top$1 = 1, right$1 = 2, bottom$1 = 3, left$1 = 4, epsilon$3 = 1e-6;
    function translateX$2(x) {
        return "translate(" + (x + 0.5) + ",0)";
    }
    function translateY$2(y) {
        return "translate(0," + (y + 0.5) + ")";
    }
    function number$4(scale) {
        return function (d) {
            return +scale(d);
        };
    }
    function center$2(scale) {
        var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.
        if (scale.round())
            offset = Math.round(offset);
        return function (d) {
            return +scale(d) + offset;
        };
    }
    function entering$2() {
        return !this.__axis;
    }
    function axis$2(orient, scale) {
        var tickArguments = [], tickValues = null, tickFormat = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, k = orient === top$1 || orient === left$1 ? -1 : 1, x = orient === left$1 || orient === right$1 ? "x" : "y", transform = orient === top$1 || orient === bottom$1 ? translateX$2 : translateY$2;
        function axis(context) {
            var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues, format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$6) : tickFormat, spacing = Math.max(tickSizeInner, 0) + tickPadding, range = scale.range(), range0 = +range[0] + 0.5, range1 = +range[range.length - 1] + 0.5, position = (scale.bandwidth ? center$2 : number$4)(scale.copy()), selection = context.selection ? context.selection() : context, path = selection.selectAll(".domain").data([null]), tick = selection.selectAll(".tick").data(values, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line = tick.select("line"), text = tick.select("text");
            path = path.merge(path.enter().insert("path", ".tick")
                .attr("class", "domain")
                .attr("stroke", "#000"));
            tick = tick.merge(tickEnter);
            line = line.merge(tickEnter.append("line")
                .attr("stroke", "#000")
                .attr(x + "2", k * tickSizeInner));
            text = text.merge(tickEnter.append("text")
                .attr("fill", "#000")
                .attr(x, k * spacing)
                .attr("dy", orient === top$1 ? "0em" : orient === bottom$1 ? "0.71em" : "0.32em"));
            if (context !== selection) {
                path = path.transition(context);
                tick = tick.transition(context);
                line = line.transition(context);
                text = text.transition(context);
                tickExit = tickExit.transition(context)
                    .attr("opacity", epsilon$3)
                    .attr("transform", function (d) { return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform"); });
                tickEnter
                    .attr("opacity", epsilon$3)
                    .attr("transform", function (d) { var p = this.parentNode.__axis; return transform(p && isFinite(p = p(d)) ? p : position(d)); });
            }
            tickExit.remove();
            path
                .attr("d", orient === left$1 || orient == right$1
                ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter
                : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);
            tick
                .attr("opacity", 1)
                .attr("transform", function (d) { return transform(position(d)); });
            line
                .attr(x + "2", k * tickSizeInner);
            text
                .attr(x, k * spacing)
                .text(format);
            selection.filter(entering$2)
                .attr("fill", "none")
                .attr("font-size", 10)
                .attr("font-family", "sans-serif")
                .attr("text-anchor", orient === right$1 ? "start" : orient === left$1 ? "end" : "middle");
            selection
                .each(function () { this.__axis = position; });
        }
        axis.scale = function (_) {
            return arguments.length ? (scale = _, axis) : scale;
        };
        axis.ticks = function () {
            return tickArguments = slice$4.call(arguments), axis;
        };
        axis.tickArguments = function (_) {
            return arguments.length ? (tickArguments = _ == null ? [] : slice$4.call(_), axis) : tickArguments.slice();
        };
        axis.tickValues = function (_) {
            return arguments.length ? (tickValues = _ == null ? null : slice$4.call(_), axis) : tickValues && tickValues.slice();
        };
        axis.tickFormat = function (_) {
            return arguments.length ? (tickFormat = _, axis) : tickFormat;
        };
        axis.tickSize = function (_) {
            return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
        };
        axis.tickSizeInner = function (_) {
            return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
        };
        axis.tickSizeOuter = function (_) {
            return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
        };
        axis.tickPadding = function (_) {
            return arguments.length ? (tickPadding = +_, axis) : tickPadding;
        };
        return axis;
    }
    function axisTop(scale) {
        return axis$2(top$1, scale);
    }
    function axisRight(scale) {
        return axis$2(right$1, scale);
    }
    function axisBottom$1(scale) {
        return axis$2(bottom$1, scale);
    }
    function axisLeft$1(scale) {
        return axis$2(left$1, scale);
    }

    function noevent () {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    function dragDisable (view) {
        var root = view.document.documentElement, selection = select(view).on("dragstart.drag", noevent, true);
        if ("onselectstart" in root) {
            selection.on("selectstart.drag", noevent, true);
        }
        else {
            root.__noselect = root.style.MozUserSelect;
            root.style.MozUserSelect = "none";
        }
    }
    function yesdrag(view, noclick) {
        var root = view.document.documentElement, selection = select(view).on("dragstart.drag", null);
        if (noclick) {
            selection.on("click.drag", noevent, true);
            setTimeout(function () { selection.on("click.drag", null); }, 0);
        }
        if ("onselectstart" in root) {
            selection.on("selectstart.drag", null);
        }
        else {
            root.style.MozUserSelect = root.__noselect;
            delete root.__noselect;
        }
    }

    var emptyOn$1 = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween$1 = [];
    var CREATED$1 = 0;
    var SCHEDULED$1 = 1;
    var STARTING$1 = 2;
    var STARTED$1 = 3;
    var RUNNING$1 = 4;
    var ENDING$1 = 5;
    var ENDED$1 = 6;
    function schedule$1 (node, name, id, index, group, timing) {
        var schedules = node.__transition;
        if (!schedules)
            node.__transition = {};
        else if (id in schedules)
            return;
        create$1(node, id, {
            name: name,
            index: index,
            group: group,
            on: emptyOn$1,
            tween: emptyTween$1,
            time: timing.time,
            delay: timing.delay,
            duration: timing.duration,
            ease: timing.ease,
            timer: null,
            state: CREATED$1
        });
    }
    function init$1(node, id) {
        var schedule = get$2(node, id);
        if (schedule.state > CREATED$1)
            throw new Error("too late; already scheduled");
        return schedule;
    }
    function set$3(node, id) {
        var schedule = get$2(node, id);
        if (schedule.state > STARTED$1)
            throw new Error("too late; already running");
        return schedule;
    }
    function get$2(node, id) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id]))
            throw new Error("transition not found");
        return schedule;
    }
    function create$1(node, id, self) {
        var schedules = node.__transition, tween;
        // Initialize the self timer when the transition is created.
        // Note the actual delay is not known until the first callback!
        schedules[id] = self;
        self.timer = timer(schedule, 0, self.time);
        function schedule(elapsed) {
            self.state = SCHEDULED$1;
            self.timer.restart(start, self.delay, self.time);
            // If the elapsed delay is less than our first sleep, start immediately.
            if (self.delay <= elapsed)
                start(elapsed - self.delay);
        }
        function start(elapsed) {
            var i, j, n, o;
            // If the state is not SCHEDULED, then we previously errored on start.
            if (self.state !== SCHEDULED$1)
                return stop();
            for (i in schedules) {
                o = schedules[i];
                if (o.name !== self.name)
                    continue;
                // While this element already has a starting transition during this frame,
                // defer starting an interrupting transition until that transition has a
                // chance to tick (and possibly end); see d3/d3-transition#54!
                if (o.state === STARTED$1)
                    return timeout$1(start);
                // Interrupt the active transition, if any.
                if (o.state === RUNNING$1) {
                    o.state = ENDED$1;
                    o.timer.stop();
                    o.on.call("interrupt", node, node.__data__, o.index, o.group);
                    delete schedules[i];
                }
                // Cancel any pre-empted transitions.
                else if (+i < id) {
                    o.state = ENDED$1;
                    o.timer.stop();
                    o.on.call("cancel", node, node.__data__, o.index, o.group);
                    delete schedules[i];
                }
            }
            // Defer the first tick to end of the current frame; see d3/d3#1576.
            // Note the transition may be canceled after start and before the first tick!
            // Note this must be scheduled before the start event; see d3/d3-transition#16!
            // Assuming this is successful, subsequent callbacks go straight to tick.
            timeout$1(function () {
                if (self.state === STARTED$1) {
                    self.state = RUNNING$1;
                    self.timer.restart(tick, self.delay, self.time);
                    tick(elapsed);
                }
            });
            // Dispatch the start event.
            // Note this must be done before the tween are initialized.
            self.state = STARTING$1;
            self.on.call("start", node, node.__data__, self.index, self.group);
            if (self.state !== STARTING$1)
                return; // interrupted
            self.state = STARTED$1;
            // Initialize the tween, deleting null tween.
            tween = new Array(n = self.tween.length);
            for (i = 0, j = -1; i < n; ++i) {
                if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
                    tween[++j] = o;
                }
            }
            tween.length = j + 1;
        }
        function tick(elapsed) {
            var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING$1, 1), i = -1, n = tween.length;
            while (++i < n) {
                tween[i].call(node, t);
            }
            // Dispatch the end event.
            if (self.state === ENDING$1) {
                self.on.call("end", node, node.__data__, self.index, self.group);
                stop();
            }
        }
        function stop() {
            self.state = ENDED$1;
            self.timer.stop();
            delete schedules[id];
            for (var i in schedules)
                return; // eslint-disable-line no-unused-vars
            delete node.__transition;
        }
    }

    function interrupt$1 (node, name) {
        var schedules = node.__transition, schedule, active, empty = true, i;
        if (!schedules)
            return;
        name = name == null ? null : name + "";
        for (i in schedules) {
            if ((schedule = schedules[i]).name !== name) {
                empty = false;
                continue;
            }
            active = schedule.state > STARTING$1 && schedule.state < ENDING$1;
            schedule.state = ENDED$1;
            schedule.timer.stop();
            schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
            delete schedules[i];
        }
        if (empty)
            delete node.__transition;
    }

    function selection_interrupt$1 (name) {
        return this.each(function () {
            interrupt$1(this, name);
        });
    }

    function tweenRemove$1(id, name) {
        var tween0, tween1;
        return function () {
            var schedule = set$3(this, id), tween = schedule.tween;
            // If this node shared tween with the previous node,
            // just assign the updated shared tween and we’re done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = tween0 = tween;
                for (var i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1 = tween1.slice();
                        tween1.splice(i, 1);
                        break;
                    }
                }
            }
            schedule.tween = tween1;
        };
    }
    function tweenFunction$1(id, name, value) {
        var tween0, tween1;
        if (typeof value !== "function")
            throw new Error;
        return function () {
            var schedule = set$3(this, id), tween = schedule.tween;
            // If this node shared tween with the previous node,
            // just assign the updated shared tween and we’re done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = (tween0 = tween).slice();
                for (var t = { name: name, value: value }, i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1[i] = t;
                        break;
                    }
                }
                if (i === n)
                    tween1.push(t);
            }
            schedule.tween = tween1;
        };
    }
    function transition_tween$1 (name, value) {
        var id = this._id;
        name += "";
        if (arguments.length < 2) {
            var tween = get$2(this.node(), id).tween;
            for (var i = 0, n = tween.length, t; i < n; ++i) {
                if ((t = tween[i]).name === name) {
                    return t.value;
                }
            }
            return null;
        }
        return this.each((value == null ? tweenRemove$1 : tweenFunction$1)(id, name, value));
    }
    function tweenValue$1(transition, name, value) {
        var id = transition._id;
        transition.each(function () {
            var schedule = set$3(this, id);
            (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
        });
        return function (node) {
            return get$2(node, id).value[name];
        };
    }

    function interpolate$2 (a, b) {
        var c;
        return (typeof b === "number" ? interpolateNumber
            : b instanceof color ? interpolateRgb
                : (c = color(b)) ? (b = c, interpolateRgb)
                    : interpolateString)(a, b);
    }

    function attrRemove$2(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS$2(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant$2(name, interpolate, value1) {
        var string00, string1 = value1 + "", interpolate0;
        return function () {
            var string0 = this.getAttribute(name);
            return string0 === string1 ? null
                : string0 === string00 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, value1);
        };
    }
    function attrConstantNS$2(fullname, interpolate, value1) {
        var string00, string1 = value1 + "", interpolate0;
        return function () {
            var string0 = this.getAttributeNS(fullname.space, fullname.local);
            return string0 === string1 ? null
                : string0 === string00 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, value1);
        };
    }
    function attrFunction$2(name, interpolate, value) {
        var string00, string10, interpolate0;
        return function () {
            var string0, value1 = value(this), string1;
            if (value1 == null)
                return void this.removeAttribute(name);
            string0 = this.getAttribute(name);
            string1 = value1 + "";
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
    }
    function attrFunctionNS$2(fullname, interpolate, value) {
        var string00, string10, interpolate0;
        return function () {
            var string0, value1 = value(this), string1;
            if (value1 == null)
                return void this.removeAttributeNS(fullname.space, fullname.local);
            string0 = this.getAttributeNS(fullname.space, fullname.local);
            string1 = value1 + "";
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
    }
    function transition_attr$1 (name, value) {
        var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$2;
        return this.attrTween(name, typeof value === "function"
            ? (fullname.local ? attrFunctionNS$2 : attrFunction$2)(fullname, i, tweenValue$1(this, "attr." + name, value))
            : value == null ? (fullname.local ? attrRemoveNS$2 : attrRemove$2)(fullname)
                : (fullname.local ? attrConstantNS$2 : attrConstant$2)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
        return function (t) {
            this.setAttribute(name, i.call(this, t));
        };
    }
    function attrInterpolateNS(fullname, i) {
        return function (t) {
            this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
        };
    }
    function attrTweenNS$1(fullname, value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
                t0 = (i0 = i) && attrInterpolateNS(fullname, i);
            return t0;
        }
        tween._value = value;
        return tween;
    }
    function attrTween$1(name, value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
                t0 = (i0 = i) && attrInterpolate(name, i);
            return t0;
        }
        tween._value = value;
        return tween;
    }
    function transition_attrTween$1 (name, value) {
        var key = "attr." + name;
        if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        var fullname = namespace(name);
        return this.tween(key, (fullname.local ? attrTweenNS$1 : attrTween$1)(fullname, value));
    }

    function delayFunction$1(id, value) {
        return function () {
            init$1(this, id).delay = +value.apply(this, arguments);
        };
    }
    function delayConstant$1(id, value) {
        return value = +value, function () {
            init$1(this, id).delay = value;
        };
    }
    function transition_delay$1 (value) {
        var id = this._id;
        return arguments.length
            ? this.each((typeof value === "function"
                ? delayFunction$1
                : delayConstant$1)(id, value))
            : get$2(this.node(), id).delay;
    }

    function durationFunction$1(id, value) {
        return function () {
            set$3(this, id).duration = +value.apply(this, arguments);
        };
    }
    function durationConstant$1(id, value) {
        return value = +value, function () {
            set$3(this, id).duration = value;
        };
    }
    function transition_duration$1 (value) {
        var id = this._id;
        return arguments.length
            ? this.each((typeof value === "function"
                ? durationFunction$1
                : durationConstant$1)(id, value))
            : get$2(this.node(), id).duration;
    }

    function easeConstant$1(id, value) {
        if (typeof value !== "function")
            throw new Error;
        return function () {
            set$3(this, id).ease = value;
        };
    }
    function transition_ease$1 (value) {
        var id = this._id;
        return arguments.length
            ? this.each(easeConstant$1(id, value))
            : get$2(this.node(), id).ease;
    }

    function transition_filter$1 (match) {
        if (typeof match !== "function")
            match = matcher(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Transition$1(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge$1 (transition) {
        if (transition._id !== this._id)
            throw new Error;
        for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Transition$1(merges, this._parents, this._name, this._id);
    }

    function start$1(name) {
        return (name + "").trim().split(/^|\s+/).every(function (t) {
            var i = t.indexOf(".");
            if (i >= 0)
                t = t.slice(0, i);
            return !t || t === "start";
        });
    }
    function onFunction$1(id, name, listener) {
        var on0, on1, sit = start$1(name) ? init$1 : set$3;
        return function () {
            var schedule = sit(this, id), on = schedule.on;
            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and we’re done!
            // Otherwise, copy-on-write.
            if (on !== on0)
                (on1 = (on0 = on).copy()).on(name, listener);
            schedule.on = on1;
        };
    }
    function transition_on$1 (name, listener) {
        var id = this._id;
        return arguments.length < 2
            ? get$2(this.node(), id).on.on(name)
            : this.each(onFunction$1(id, name, listener));
    }

    function removeFunction$1(id) {
        return function () {
            var parent = this.parentNode;
            for (var i in this.__transition)
                if (+i !== id)
                    return;
            if (parent)
                parent.removeChild(this);
        };
    }
    function transition_remove$1 () {
        return this.on("end.remove", removeFunction$1(this._id));
    }

    function transition_select$1 (select) {
        var name = this._name, id = this._id;
        if (typeof select !== "function")
            select = selector(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                    schedule$1(subgroup[i], name, id, i, subgroup, get$2(node, id));
                }
            }
        }
        return new Transition$1(subgroups, this._parents, name, id);
    }

    function transition_selectAll$1 (select) {
        var name = this._name, id = this._id;
        if (typeof select !== "function")
            select = selectorAll(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    for (var children = select.call(node, node.__data__, i, group), child, inherit = get$2(node, id), k = 0, l = children.length; k < l; ++k) {
                        if (child = children[k]) {
                            schedule$1(child, name, id, k, children, inherit);
                        }
                    }
                    subgroups.push(children);
                    parents.push(node);
                }
            }
        }
        return new Transition$1(subgroups, parents, name, id);
    }

    var Selection$2 = selection.prototype.constructor;
    function transition_selection$1 () {
        return new Selection$2(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
        var string00, string10, interpolate0;
        return function () {
            var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, string10 = string1);
        };
    }
    function styleRemove$2(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant$2(name, interpolate, value1) {
        var string00, string1 = value1 + "", interpolate0;
        return function () {
            var string0 = styleValue(this, name);
            return string0 === string1 ? null
                : string0 === string00 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, value1);
        };
    }
    function styleFunction$2(name, interpolate, value) {
        var string00, string10, interpolate0;
        return function () {
            var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
            if (value1 == null)
                string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
    }
    function styleMaybeRemove(id, name) {
        var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
        return function () {
            var schedule = set$3(this, id), on = schedule.on, listener = schedule.value[key] == null ? remove || (remove = styleRemove$2(name)) : undefined;
            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and we’re done!
            // Otherwise, copy-on-write.
            if (on !== on0 || listener0 !== listener)
                (on1 = (on0 = on).copy()).on(event, listener0 = listener);
            schedule.on = on1;
        };
    }
    function transition_style$1 (name, value, priority) {
        var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$2;
        return value == null ? this
            .styleTween(name, styleNull(name, i))
            .on("end.style." + name, styleRemove$2(name))
            : typeof value === "function" ? this
                .styleTween(name, styleFunction$2(name, i, tweenValue$1(this, "style." + name, value)))
                .each(styleMaybeRemove(this._id, name))
                : this
                    .styleTween(name, styleConstant$2(name, i, value), priority)
                    .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
        return function (t) {
            this.style.setProperty(name, i.call(this, t), priority);
        };
    }
    function styleTween$1(name, value, priority) {
        var t, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
                t = (i0 = i) && styleInterpolate(name, i, priority);
            return t;
        }
        tween._value = value;
        return tween;
    }
    function transition_styleTween$1 (name, value, priority) {
        var key = "style." + (name += "");
        if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        return this.tween(key, styleTween$1(name, value, priority == null ? "" : priority));
    }

    function textConstant$2(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction$2(value) {
        return function () {
            var value1 = value(this);
            this.textContent = value1 == null ? "" : value1;
        };
    }
    function transition_text$1 (value) {
        return this.tween("text", typeof value === "function"
            ? textFunction$2(tweenValue$1(this, "text", value))
            : textConstant$2(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
        return function (t) {
            this.textContent = i.call(this, t);
        };
    }
    function textTween(value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
                t0 = (i0 = i) && textInterpolate(i);
            return t0;
        }
        tween._value = value;
        return tween;
    }
    function transition_textTween (value) {
        var key = "text";
        if (arguments.length < 1)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        return this.tween(key, textTween(value));
    }

    function transition_transition$1 () {
        var name = this._name, id0 = this._id, id1 = newId$1();
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    var inherit = get$2(node, id0);
                    schedule$1(node, name, id1, i, group, {
                        time: inherit.time + inherit.delay + inherit.duration,
                        delay: 0,
                        duration: inherit.duration,
                        ease: inherit.ease
                    });
                }
            }
        }
        return new Transition$1(groups, this._parents, name, id1);
    }

    function transition_end () {
        var on0, on1, that = this, id = that._id, size = that.size();
        return new Promise(function (resolve, reject) {
            var cancel = { value: reject }, end = { value: function () { if (--size === 0)
                    resolve(); } };
            that.each(function () {
                var schedule = set$3(this, id), on = schedule.on;
                // If this node shared a dispatch with the previous node,
                // just assign the updated shared dispatch and we’re done!
                // Otherwise, copy-on-write.
                if (on !== on0) {
                    on1 = (on0 = on).copy();
                    on1._.cancel.push(cancel);
                    on1._.interrupt.push(cancel);
                    on1._.end.push(end);
                }
                schedule.on = on1;
            });
        });
    }

    var id$1 = 0;
    function Transition$1(groups, parents, name, id) {
        this._groups = groups;
        this._parents = parents;
        this._name = name;
        this._id = id;
    }
    function newId$1() {
        return ++id$1;
    }
    var selection_prototype$1 = selection.prototype;
    Transition$1.prototype = {
        constructor: Transition$1,
        select: transition_select$1,
        selectAll: transition_selectAll$1,
        filter: transition_filter$1,
        merge: transition_merge$1,
        selection: transition_selection$1,
        transition: transition_transition$1,
        call: selection_prototype$1.call,
        nodes: selection_prototype$1.nodes,
        node: selection_prototype$1.node,
        size: selection_prototype$1.size,
        empty: selection_prototype$1.empty,
        each: selection_prototype$1.each,
        on: transition_on$1,
        attr: transition_attr$1,
        attrTween: transition_attrTween$1,
        style: transition_style$1,
        styleTween: transition_styleTween$1,
        text: transition_text$1,
        textTween: transition_textTween,
        remove: transition_remove$1,
        tween: transition_tween$1,
        delay: transition_delay$1,
        duration: transition_duration$1,
        ease: transition_ease$1,
        end: transition_end
    };

    var defaultTiming$1 = {
        time: null,
        delay: 0,
        duration: 250,
        ease: cubicInOut
    };
    function inherit$1(node, id) {
        var timing;
        while (!(timing = node.__transition) || !(timing = timing[id])) {
            if (!(node = node.parentNode)) {
                return defaultTiming$1.time = now(), defaultTiming$1;
            }
        }
        return timing;
    }
    function selection_transition$1 (name) {
        var id, timing;
        if (name instanceof Transition$1) {
            id = name._id, name = name._name;
        }
        else {
            id = newId$1(), (timing = defaultTiming$1).time = now(), name = name == null ? null : name + "";
        }
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    schedule$1(node, name, id, i, group, timing || inherit$1(node, id));
                }
            }
        }
        return new Transition$1(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt$1;
    selection.prototype.transition = selection_transition$1;

    function constant$5 (x) {
        return function () {
            return x;
        };
    }

    function BrushEvent (target, type, selection) {
        this.target = target;
        this.type = type;
        this.selection = selection;
    }

    function nopropagation() {
        event.stopImmediatePropagation();
    }
    function noevent$1 () {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    var MODE_DRAG = { name: "drag" }, MODE_SPACE = { name: "space" }, MODE_HANDLE = { name: "handle" }, MODE_CENTER = { name: "center" };
    var X = {
        name: "x",
        handles: ["e", "w"].map(type),
        input: function (x, e) { return x && [[x[0], e[0][1]], [x[1], e[1][1]]]; },
        output: function (xy) { return xy && [xy[0][0], xy[1][0]]; }
    };
    var Y = {
        name: "y",
        handles: ["n", "s"].map(type),
        input: function (y, e) { return y && [[e[0][0], y[0]], [e[1][0], y[1]]]; },
        output: function (xy) { return xy && [xy[0][1], xy[1][1]]; }
    };
    var XY = {
        name: "xy",
        handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
        input: function (xy) { return xy; },
        output: function (xy) { return xy; }
    };
    var cursors = {
        overlay: "crosshair",
        selection: "move",
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
    };
    var flipX = {
        e: "w",
        w: "e",
        nw: "ne",
        ne: "nw",
        se: "sw",
        sw: "se"
    };
    var flipY = {
        n: "s",
        s: "n",
        nw: "sw",
        ne: "se",
        se: "ne",
        sw: "nw"
    };
    var signsX = {
        overlay: +1,
        selection: +1,
        n: null,
        e: +1,
        s: null,
        w: -1,
        nw: -1,
        ne: +1,
        se: +1,
        sw: -1
    };
    var signsY = {
        overlay: +1,
        selection: +1,
        n: -1,
        e: null,
        s: +1,
        w: null,
        nw: -1,
        ne: -1,
        se: +1,
        sw: +1
    };
    function type(t) {
        return { type: t };
    }
    // Ignore right-click, since that should open the context menu.
    function defaultFilter() {
        return !event.button;
    }
    function defaultExtent() {
        var svg = this.ownerSVGElement || this;
        return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }
    // Like d3.local, but with the name “__brush” rather than auto-generated.
    function local(node) {
        while (!node.__brush)
            if (!(node = node.parentNode))
                return;
        return node.__brush;
    }
    function empty$1(extent) {
        return extent[0][0] === extent[1][0]
            || extent[0][1] === extent[1][1];
    }
    function brushSelection(node) {
        var state = node.__brush;
        return state ? state.dim.output(state.selection) : null;
    }
    function brushX() {
        return brush$1(X);
    }
    function brushY() {
        return brush$1(Y);
    }
    function brush () {
        return brush$1(XY);
    }
    function brush$1(dim) {
        var extent = defaultExtent, filter = defaultFilter, listeners = dispatch(brush, "start", "brush", "end"), handleSize = 6, touchending;
        function brush(group) {
            var overlay = group
                .property("__brush", initialize)
                .selectAll(".overlay")
                .data([type("overlay")]);
            overlay.enter().append("rect")
                .attr("class", "overlay")
                .attr("pointer-events", "all")
                .attr("cursor", cursors.overlay)
                .merge(overlay)
                .each(function () {
                var extent = local(this).extent;
                select(this)
                    .attr("x", extent[0][0])
                    .attr("y", extent[0][1])
                    .attr("width", extent[1][0] - extent[0][0])
                    .attr("height", extent[1][1] - extent[0][1]);
            });
            group.selectAll(".selection")
                .data([type("selection")])
                .enter().append("rect")
                .attr("class", "selection")
                .attr("cursor", cursors.selection)
                .attr("fill", "#777")
                .attr("fill-opacity", 0.3)
                .attr("stroke", "#fff")
                .attr("shape-rendering", "crispEdges");
            var handle = group.selectAll(".handle")
                .data(dim.handles, function (d) { return d.type; });
            handle.exit().remove();
            handle.enter().append("rect")
                .attr("class", function (d) { return "handle handle--" + d.type; })
                .attr("cursor", function (d) { return cursors[d.type]; });
            group
                .each(redraw)
                .attr("fill", "none")
                .attr("pointer-events", "all")
                .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)")
                .on("mousedown.brush touchstart.brush", started);
        }
        brush.move = function (group, selection) {
            if (group.selection) {
                group
                    .on("start.brush", function () { emitter(this, arguments).beforestart().start(); })
                    .on("interrupt.brush end.brush", function () { emitter(this, arguments).end(); })
                    .tween("brush", function () {
                    var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent), i = interpolate(selection0, selection1);
                    function tween(t) {
                        state.selection = t === 1 && empty$1(selection1) ? null : i(t);
                        redraw.call(that);
                        emit.brush();
                    }
                    return selection0 && selection1 ? tween : tween(1);
                });
            }
            else {
                group
                    .each(function () {
                    var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent), emit = emitter(that, args).beforestart();
                    interrupt$1(that);
                    state.selection = selection1 == null || empty$1(selection1) ? null : selection1;
                    redraw.call(that);
                    emit.start().brush().end();
                });
            }
        };
        function redraw() {
            var group = select(this), selection = local(this).selection;
            if (selection) {
                group.selectAll(".selection")
                    .style("display", null)
                    .attr("x", selection[0][0])
                    .attr("y", selection[0][1])
                    .attr("width", selection[1][0] - selection[0][0])
                    .attr("height", selection[1][1] - selection[0][1]);
                group.selectAll(".handle")
                    .style("display", null)
                    .attr("x", function (d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
                    .attr("y", function (d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
                    .attr("width", function (d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
                    .attr("height", function (d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
            }
            else {
                group.selectAll(".selection,.handle")
                    .style("display", "none")
                    .attr("x", null)
                    .attr("y", null)
                    .attr("width", null)
                    .attr("height", null);
            }
        }
        function emitter(that, args) {
            return that.__brush.emitter || new Emitter(that, args);
        }
        function Emitter(that, args) {
            this.that = that;
            this.args = args;
            this.state = that.__brush;
            this.active = 0;
        }
        Emitter.prototype = {
            beforestart: function () {
                if (++this.active === 1)
                    this.state.emitter = this, this.starting = true;
                return this;
            },
            start: function () {
                if (this.starting)
                    this.starting = false, this.emit("start");
                return this;
            },
            brush: function () {
                this.emit("brush");
                return this;
            },
            end: function () {
                if (--this.active === 0)
                    delete this.state.emitter, this.emit("end");
                return this;
            },
            emit: function (type) {
                customEvent(new BrushEvent(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
            }
        };
        function started() {
            if (event.touches) {
                if (event.changedTouches.length < event.touches.length)
                    return noevent$1();
            }
            else if (touchending)
                return;
            if (!filter.apply(this, arguments))
                return;
            var that = this, type = event.target.__data__.type, mode = (event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (event.altKey ? MODE_CENTER : MODE_HANDLE), signX = dim === Y ? null : signsX[type], signY = dim === X ? null : signsY[type], state = local(that), extent = state.extent, selection = state.selection, W = extent[0][0], w0, w1, N = extent[0][1], n0, n1, E = extent[1][0], e0, e1, S = extent[1][1], s0, s1, dx, dy, moving, shifting = signX && signY && event.shiftKey, lockX, lockY, point0 = mouse(that), point = point0, emit = emitter(that, arguments).beforestart();
            if (type === "overlay") {
                state.selection = selection = [
                    [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
                    [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]
                ];
            }
            else {
                w0 = selection[0][0];
                n0 = selection[0][1];
                e0 = selection[1][0];
                s0 = selection[1][1];
            }
            w1 = w0;
            n1 = n0;
            e1 = e0;
            s1 = s0;
            var group = select(that)
                .attr("pointer-events", "none");
            var overlay = group.selectAll(".overlay")
                .attr("cursor", cursors[type]);
            if (event.touches) {
                group
                    .on("touchmove.brush", moved, true)
                    .on("touchend.brush touchcancel.brush", ended, true);
            }
            else {
                var view = select(event.view)
                    .on("keydown.brush", keydowned, true)
                    .on("keyup.brush", keyupped, true)
                    .on("mousemove.brush", moved, true)
                    .on("mouseup.brush", ended, true);
                dragDisable(event.view);
            }
            nopropagation();
            interrupt$1(that);
            redraw.call(that);
            emit.start();
            function moved() {
                var point1 = mouse(that);
                if (shifting && !lockX && !lockY) {
                    if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1]))
                        lockY = true;
                    else
                        lockX = true;
                }
                point = point1;
                moving = true;
                noevent$1();
                move();
            }
            function move() {
                var t;
                dx = point[0] - point0[0];
                dy = point[1] - point0[1];
                switch (mode) {
                    case MODE_SPACE:
                    case MODE_DRAG: {
                        if (signX)
                            dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
                        if (signY)
                            dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
                        break;
                    }
                    case MODE_HANDLE: {
                        if (signX < 0)
                            dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                        else if (signX > 0)
                            dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                        if (signY < 0)
                            dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                        else if (signY > 0)
                            dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
                        break;
                    }
                    case MODE_CENTER: {
                        if (signX)
                            w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
                        if (signY)
                            n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
                        break;
                    }
                }
                if (e1 < w1) {
                    signX *= -1;
                    t = w0, w0 = e0, e0 = t;
                    t = w1, w1 = e1, e1 = t;
                    if (type in flipX)
                        overlay.attr("cursor", cursors[type = flipX[type]]);
                }
                if (s1 < n1) {
                    signY *= -1;
                    t = n0, n0 = s0, s0 = t;
                    t = n1, n1 = s1, s1 = t;
                    if (type in flipY)
                        overlay.attr("cursor", cursors[type = flipY[type]]);
                }
                if (state.selection)
                    selection = state.selection; // May be set by brush.move!
                if (lockX)
                    w1 = selection[0][0], e1 = selection[1][0];
                if (lockY)
                    n1 = selection[0][1], s1 = selection[1][1];
                if (selection[0][0] !== w1
                    || selection[0][1] !== n1
                    || selection[1][0] !== e1
                    || selection[1][1] !== s1) {
                    state.selection = [[w1, n1], [e1, s1]];
                    redraw.call(that);
                    emit.brush();
                }
            }
            function ended() {
                nopropagation();
                if (event.touches) {
                    if (event.touches.length)
                        return;
                    if (touchending)
                        clearTimeout(touchending);
                    touchending = setTimeout(function () { touchending = null; }, 500); // Ghost clicks are delayed!
                    group.on("touchmove.brush touchend.brush touchcancel.brush", null);
                }
                else {
                    yesdrag(event.view, moving);
                    view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
                }
                group.attr("pointer-events", "all");
                overlay.attr("cursor", cursors.overlay);
                if (state.selection)
                    selection = state.selection; // May be set by brush.move (on start)!
                if (empty$1(selection))
                    state.selection = null, redraw.call(that);
                emit.end();
            }
            function keydowned() {
                switch (event.keyCode) {
                    case 16: { // SHIFT
                        shifting = signX && signY;
                        break;
                    }
                    case 18: { // ALT
                        if (mode === MODE_HANDLE) {
                            if (signX)
                                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                            if (signY)
                                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                            mode = MODE_CENTER;
                            move();
                        }
                        break;
                    }
                    case 32: { // SPACE; takes priority over ALT
                        if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                            if (signX < 0)
                                e0 = e1 - dx;
                            else if (signX > 0)
                                w0 = w1 - dx;
                            if (signY < 0)
                                s0 = s1 - dy;
                            else if (signY > 0)
                                n0 = n1 - dy;
                            mode = MODE_SPACE;
                            overlay.attr("cursor", cursors.selection);
                            move();
                        }
                        break;
                    }
                    default: return;
                }
                noevent$1();
            }
            function keyupped() {
                switch (event.keyCode) {
                    case 16: { // SHIFT
                        if (shifting) {
                            lockX = lockY = shifting = false;
                            move();
                        }
                        break;
                    }
                    case 18: { // ALT
                        if (mode === MODE_CENTER) {
                            if (signX < 0)
                                e0 = e1;
                            else if (signX > 0)
                                w0 = w1;
                            if (signY < 0)
                                s0 = s1;
                            else if (signY > 0)
                                n0 = n1;
                            mode = MODE_HANDLE;
                            move();
                        }
                        break;
                    }
                    case 32: { // SPACE
                        if (mode === MODE_SPACE) {
                            if (event.altKey) {
                                if (signX)
                                    e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                                if (signY)
                                    s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                                mode = MODE_CENTER;
                            }
                            else {
                                if (signX < 0)
                                    e0 = e1;
                                else if (signX > 0)
                                    w0 = w1;
                                if (signY < 0)
                                    s0 = s1;
                                else if (signY > 0)
                                    n0 = n1;
                                mode = MODE_HANDLE;
                            }
                            overlay.attr("cursor", cursors[type]);
                            move();
                        }
                        break;
                    }
                    default: return;
                }
                noevent$1();
            }
        }
        function initialize() {
            var state = this.__brush || { selection: null };
            state.extent = extent.apply(this, arguments);
            state.dim = dim;
            return state;
        }
        brush.extent = function (_) {
            return arguments.length ? (extent = typeof _ === "function" ? _ : constant$5([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
        };
        brush.filter = function (_) {
            return arguments.length ? (filter = typeof _ === "function" ? _ : constant$5(!!_), brush) : filter;
        };
        brush.handleSize = function (_) {
            return arguments.length ? (handleSize = +_, brush) : handleSize;
        };
        brush.on = function () {
            var value = listeners.on.apply(listeners, arguments);
            return value === listeners ? brush : value;
        };
        return brush;
    }

    var cos = Math.cos;
    var sin = Math.sin;
    var pi$2 = Math.PI;
    var halfPi = pi$2 / 2;
    var tau$2 = pi$2 * 2;
    var max$2 = Math.max;

    function compareValue(compare) {
        return function (a, b) {
            return compare(a.source.value + a.target.value, b.source.value + b.target.value);
        };
    }
    function chord () {
        var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;
        function chord(matrix) {
            var n = matrix.length, groupSums = [], groupIndex = range(n), subgroupIndex = [], chords = [], groups = chords.groups = new Array(n), subgroups = new Array(n * n), k, x, x0, dx, i, j;
            // Compute the sum.
            k = 0, i = -1;
            while (++i < n) {
                x = 0, j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(range(n));
                k += x;
            }
            // Sort groups…
            if (sortGroups)
                groupIndex.sort(function (a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            // Sort subgroups…
            if (sortSubgroups)
                subgroupIndex.forEach(function (d, i) {
                    d.sort(function (a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            // Convert the sum to scaling factor for [0, 2pi].
            // TODO Allow start and end angle to be specified?
            // TODO Allow padding to be specified as percentage?
            k = max$2(0, tau$2 - padAngle * n) / k;
            dx = k ? padAngle : tau$2 / n;
            // Compute the start and end angle for each group and subgroup.
            // Note: Opera has a bug reordering object literal properties!
            x = 0, i = -1;
            while (++i < n) {
                x0 = x, j = -1;
                while (++j < n) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[dj * n + di] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: groupSums[di]
                };
                x += dx;
            }
            // Generate chords for each (non-empty) subgroup-subgroup link.
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[j * n + i], target = subgroups[i * n + j];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value
                            ? { source: target, target: source }
                            : { source: source, target: target });
                    }
                }
            }
            return sortChords ? chords.sort(sortChords) : chords;
        }
        chord.padAngle = function (_) {
            return arguments.length ? (padAngle = max$2(0, _), chord) : padAngle;
        };
        chord.sortGroups = function (_) {
            return arguments.length ? (sortGroups = _, chord) : sortGroups;
        };
        chord.sortSubgroups = function (_) {
            return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
        };
        chord.sortChords = function (_) {
            return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
        };
        return chord;
    }

    var slice$5 = Array.prototype.slice;

    function constant$6 (x) {
        return function () {
            return x;
        };
    }

    function defaultSource(d) {
        return d.source;
    }
    function defaultTarget(d) {
        return d.target;
    }
    function defaultRadius(d) {
        return d.radius;
    }
    function defaultStartAngle(d) {
        return d.startAngle;
    }
    function defaultEndAngle(d) {
        return d.endAngle;
    }
    function ribbon () {
        var source = defaultSource, target = defaultTarget, radius = defaultRadius, startAngle = defaultStartAngle, endAngle = defaultEndAngle, context = null;
        function ribbon() {
            var buffer, argv = slice$5.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv), sr = +radius.apply(this, (argv[0] = s, argv)), sa0 = startAngle.apply(this, argv) - halfPi, sa1 = endAngle.apply(this, argv) - halfPi, sx0 = sr * cos(sa0), sy0 = sr * sin(sa0), tr = +radius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi, ta1 = endAngle.apply(this, argv) - halfPi;
            if (!context)
                context = buffer = path();
            context.moveTo(sx0, sy0);
            context.arc(0, 0, sr, sa0, sa1);
            if (sa0 !== ta0 || sa1 !== ta1) { // TODO sr !== tr?
                context.quadraticCurveTo(0, 0, tr * cos(ta0), tr * sin(ta0));
                context.arc(0, 0, tr, ta0, ta1);
            }
            context.quadraticCurveTo(0, 0, sx0, sy0);
            context.closePath();
            if (buffer)
                return context = null, buffer + "" || null;
        }
        ribbon.radius = function (_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : radius;
        };
        ribbon.startAngle = function (_) {
            return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : startAngle;
        };
        ribbon.endAngle = function (_) {
            return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : endAngle;
        };
        ribbon.source = function (_) {
            return arguments.length ? (source = _, ribbon) : source;
        };
        ribbon.target = function (_) {
            return arguments.length ? (target = _, ribbon) : target;
        };
        ribbon.context = function (_) {
            return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
        };
        return ribbon;
    }

    var prefix$1 = "$";
    function Map$2() { }
    Map$2.prototype = map$4.prototype = {
        constructor: Map$2,
        has: function (key) {
            return (prefix$1 + key) in this;
        },
        get: function (key) {
            return this[prefix$1 + key];
        },
        set: function (key, value) {
            this[prefix$1 + key] = value;
            return this;
        },
        remove: function (key) {
            var property = prefix$1 + key;
            return property in this && delete this[property];
        },
        clear: function () {
            for (var property in this)
                if (property[0] === prefix$1)
                    delete this[property];
        },
        keys: function () {
            var keys = [];
            for (var property in this)
                if (property[0] === prefix$1)
                    keys.push(property.slice(1));
            return keys;
        },
        values: function () {
            var values = [];
            for (var property in this)
                if (property[0] === prefix$1)
                    values.push(this[property]);
            return values;
        },
        entries: function () {
            var entries = [];
            for (var property in this)
                if (property[0] === prefix$1)
                    entries.push({ key: property.slice(1), value: this[property] });
            return entries;
        },
        size: function () {
            var size = 0;
            for (var property in this)
                if (property[0] === prefix$1)
                    ++size;
            return size;
        },
        empty: function () {
            for (var property in this)
                if (property[0] === prefix$1)
                    return false;
            return true;
        },
        each: function (f) {
            for (var property in this)
                if (property[0] === prefix$1)
                    f(this[property], property.slice(1), this);
        }
    };
    function map$4(object, f) {
        var map = new Map$2;
        // Copy constructor.
        if (object instanceof Map$2)
            object.each(function (value, key) { map.set(key, value); });
        // Index array by numeric index or specified key function.
        else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (f == null)
                while (++i < n)
                    map.set(i, object[i]);
            else
                while (++i < n)
                    map.set(f(o = object[i], i, object), o);
        }
        // Convert object to map.
        else if (object)
            for (var key in object)
                map.set(key, object[key]);
        return map;
    }

    function nest () {
        var keys = [], sortKeys = [], sortValues, rollup, nest;
        function apply(array, depth, createResult, setResult) {
            if (depth >= keys.length) {
                if (sortValues != null)
                    array.sort(sortValues);
                return rollup != null ? rollup(array) : array;
            }
            var i = -1, n = array.length, key = keys[depth++], keyValue, value, valuesByKey = map$4(), values, result = createResult();
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
                    values.push(value);
                }
                else {
                    valuesByKey.set(keyValue, [value]);
                }
            }
            valuesByKey.each(function (values, key) {
                setResult(result, key, apply(values, depth, createResult, setResult));
            });
            return result;
        }
        function entries(map, depth) {
            if (++depth > keys.length)
                return map;
            var array, sortKey = sortKeys[depth - 1];
            if (rollup != null && depth >= keys.length)
                array = map.entries();
            else
                array = [], map.each(function (v, k) { array.push({ key: k, values: entries(v, depth) }); });
            return sortKey != null ? array.sort(function (a, b) { return sortKey(a.key, b.key); }) : array;
        }
        return nest = {
            object: function (array) { return apply(array, 0, createObject, setObject); },
            map: function (array) { return apply(array, 0, createMap, setMap); },
            entries: function (array) { return entries(apply(array, 0, createMap, setMap), 0); },
            key: function (d) { keys.push(d); return nest; },
            sortKeys: function (order) { sortKeys[keys.length - 1] = order; return nest; },
            sortValues: function (order) { sortValues = order; return nest; },
            rollup: function (f) { rollup = f; return nest; }
        };
    }
    function createObject() {
        return {};
    }
    function setObject(object, key, value) {
        object[key] = value;
    }
    function createMap() {
        return map$4();
    }
    function setMap(map, key, value) {
        map.set(key, value);
    }

    function Set$2() { }
    var proto$1 = map$4.prototype;
    Set$2.prototype = set$4.prototype = {
        constructor: Set$2,
        has: proto$1.has,
        add: function (value) {
            value += "";
            this[prefix$1 + value] = value;
            return this;
        },
        remove: proto$1.remove,
        clear: proto$1.clear,
        values: proto$1.keys,
        size: proto$1.size,
        empty: proto$1.empty,
        each: proto$1.each
    };
    function set$4(object, f) {
        var set = new Set$2;
        // Copy constructor.
        if (object instanceof Set$2)
            object.each(function (value) { set.add(value); });
        // Otherwise, assume it’s an array.
        else if (object) {
            var i = -1, n = object.length;
            if (f == null)
                while (++i < n)
                    set.add(object[i]);
            else
                while (++i < n)
                    set.add(f(object[i], i, object));
        }
        return set;
    }

    function keys (map) {
        var keys = [];
        for (var key in map)
            keys.push(key);
        return keys;
    }

    function values (map) {
        var values = [];
        for (var key in map)
            values.push(map[key]);
        return values;
    }

    function entries (map) {
        var entries = [];
        for (var key in map)
            entries.push({ key: key, value: map[key] });
        return entries;
    }

    function define$1 (constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
    }
    function extend$1(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition)
            prototype[key] = definition[key];
        return prototype;
    }

    function Color$1() { }
    var darker$1 = 0.7;
    var brighter$1 = 1 / darker$1;
    var reI$1 = "\\s*([+-]?\\d+)\\s*", reN$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$1 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex3 = /^#([0-9a-f]{3})$/, reHex6 = /^#([0-9a-f]{6})$/, reRgbInteger$1 = new RegExp("^rgb\\(" + [reI$1, reI$1, reI$1] + "\\)$"), reRgbPercent$1 = new RegExp("^rgb\\(" + [reP$1, reP$1, reP$1] + "\\)$"), reRgbaInteger$1 = new RegExp("^rgba\\(" + [reI$1, reI$1, reI$1, reN$1] + "\\)$"), reRgbaPercent$1 = new RegExp("^rgba\\(" + [reP$1, reP$1, reP$1, reN$1] + "\\)$"), reHslPercent$1 = new RegExp("^hsl\\(" + [reN$1, reP$1, reP$1] + "\\)$"), reHslaPercent$1 = new RegExp("^hsla\\(" + [reN$1, reP$1, reP$1, reN$1] + "\\)$");
    var named$1 = {
        aliceblue: 0xf0f8ff,
        antiquewhite: 0xfaebd7,
        aqua: 0x00ffff,
        aquamarine: 0x7fffd4,
        azure: 0xf0ffff,
        beige: 0xf5f5dc,
        bisque: 0xffe4c4,
        black: 0x000000,
        blanchedalmond: 0xffebcd,
        blue: 0x0000ff,
        blueviolet: 0x8a2be2,
        brown: 0xa52a2a,
        burlywood: 0xdeb887,
        cadetblue: 0x5f9ea0,
        chartreuse: 0x7fff00,
        chocolate: 0xd2691e,
        coral: 0xff7f50,
        cornflowerblue: 0x6495ed,
        cornsilk: 0xfff8dc,
        crimson: 0xdc143c,
        cyan: 0x00ffff,
        darkblue: 0x00008b,
        darkcyan: 0x008b8b,
        darkgoldenrod: 0xb8860b,
        darkgray: 0xa9a9a9,
        darkgreen: 0x006400,
        darkgrey: 0xa9a9a9,
        darkkhaki: 0xbdb76b,
        darkmagenta: 0x8b008b,
        darkolivegreen: 0x556b2f,
        darkorange: 0xff8c00,
        darkorchid: 0x9932cc,
        darkred: 0x8b0000,
        darksalmon: 0xe9967a,
        darkseagreen: 0x8fbc8f,
        darkslateblue: 0x483d8b,
        darkslategray: 0x2f4f4f,
        darkslategrey: 0x2f4f4f,
        darkturquoise: 0x00ced1,
        darkviolet: 0x9400d3,
        deeppink: 0xff1493,
        deepskyblue: 0x00bfff,
        dimgray: 0x696969,
        dimgrey: 0x696969,
        dodgerblue: 0x1e90ff,
        firebrick: 0xb22222,
        floralwhite: 0xfffaf0,
        forestgreen: 0x228b22,
        fuchsia: 0xff00ff,
        gainsboro: 0xdcdcdc,
        ghostwhite: 0xf8f8ff,
        gold: 0xffd700,
        goldenrod: 0xdaa520,
        gray: 0x808080,
        green: 0x008000,
        greenyellow: 0xadff2f,
        grey: 0x808080,
        honeydew: 0xf0fff0,
        hotpink: 0xff69b4,
        indianred: 0xcd5c5c,
        indigo: 0x4b0082,
        ivory: 0xfffff0,
        khaki: 0xf0e68c,
        lavender: 0xe6e6fa,
        lavenderblush: 0xfff0f5,
        lawngreen: 0x7cfc00,
        lemonchiffon: 0xfffacd,
        lightblue: 0xadd8e6,
        lightcoral: 0xf08080,
        lightcyan: 0xe0ffff,
        lightgoldenrodyellow: 0xfafad2,
        lightgray: 0xd3d3d3,
        lightgreen: 0x90ee90,
        lightgrey: 0xd3d3d3,
        lightpink: 0xffb6c1,
        lightsalmon: 0xffa07a,
        lightseagreen: 0x20b2aa,
        lightskyblue: 0x87cefa,
        lightslategray: 0x778899,
        lightslategrey: 0x778899,
        lightsteelblue: 0xb0c4de,
        lightyellow: 0xffffe0,
        lime: 0x00ff00,
        limegreen: 0x32cd32,
        linen: 0xfaf0e6,
        magenta: 0xff00ff,
        maroon: 0x800000,
        mediumaquamarine: 0x66cdaa,
        mediumblue: 0x0000cd,
        mediumorchid: 0xba55d3,
        mediumpurple: 0x9370db,
        mediumseagreen: 0x3cb371,
        mediumslateblue: 0x7b68ee,
        mediumspringgreen: 0x00fa9a,
        mediumturquoise: 0x48d1cc,
        mediumvioletred: 0xc71585,
        midnightblue: 0x191970,
        mintcream: 0xf5fffa,
        mistyrose: 0xffe4e1,
        moccasin: 0xffe4b5,
        navajowhite: 0xffdead,
        navy: 0x000080,
        oldlace: 0xfdf5e6,
        olive: 0x808000,
        olivedrab: 0x6b8e23,
        orange: 0xffa500,
        orangered: 0xff4500,
        orchid: 0xda70d6,
        palegoldenrod: 0xeee8aa,
        palegreen: 0x98fb98,
        paleturquoise: 0xafeeee,
        palevioletred: 0xdb7093,
        papayawhip: 0xffefd5,
        peachpuff: 0xffdab9,
        peru: 0xcd853f,
        pink: 0xffc0cb,
        plum: 0xdda0dd,
        powderblue: 0xb0e0e6,
        purple: 0x800080,
        rebeccapurple: 0x663399,
        red: 0xff0000,
        rosybrown: 0xbc8f8f,
        royalblue: 0x4169e1,
        saddlebrown: 0x8b4513,
        salmon: 0xfa8072,
        sandybrown: 0xf4a460,
        seagreen: 0x2e8b57,
        seashell: 0xfff5ee,
        sienna: 0xa0522d,
        silver: 0xc0c0c0,
        skyblue: 0x87ceeb,
        slateblue: 0x6a5acd,
        slategray: 0x708090,
        slategrey: 0x708090,
        snow: 0xfffafa,
        springgreen: 0x00ff7f,
        steelblue: 0x4682b4,
        tan: 0xd2b48c,
        teal: 0x008080,
        thistle: 0xd8bfd8,
        tomato: 0xff6347,
        turquoise: 0x40e0d0,
        violet: 0xee82ee,
        wheat: 0xf5deb3,
        white: 0xffffff,
        whitesmoke: 0xf5f5f5,
        yellow: 0xffff00,
        yellowgreen: 0x9acd32
    };
    define$1(Color$1, color$1, {
        displayable: function () {
            return this.rgb().displayable();
        },
        toString: function () {
            return this.rgb() + "";
        }
    });
    function color$1(format) {
        var m;
        format = (format + "").trim().toLowerCase();
        return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb$1((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
            : (m = reHex6.exec(format)) ? rgbn$1(parseInt(m[1], 16)) // #ff0000
                : (m = reRgbInteger$1.exec(format)) ? new Rgb$1(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
                    : (m = reRgbPercent$1.exec(format)) ? new Rgb$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
                        : (m = reRgbaInteger$1.exec(format)) ? rgba$1(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
                            : (m = reRgbaPercent$1.exec(format)) ? rgba$1(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
                                : (m = reHslPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
                                    : (m = reHslaPercent$1.exec(format)) ? hsla$1(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
                                        : named$1.hasOwnProperty(format) ? rgbn$1(named$1[format])
                                            : format === "transparent" ? new Rgb$1(NaN, NaN, NaN, 0)
                                                : null;
    }
    function rgbn$1(n) {
        return new Rgb$1(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }
    function rgba$1(r, g, b, a) {
        if (a <= 0)
            r = g = b = NaN;
        return new Rgb$1(r, g, b, a);
    }
    function rgbConvert$1(o) {
        if (!(o instanceof Color$1))
            o = color$1(o);
        if (!o)
            return new Rgb$1;
        o = o.rgb();
        return new Rgb$1(o.r, o.g, o.b, o.opacity);
    }
    function rgb$1(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert$1(r) : new Rgb$1(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb$1(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
    }
    define$1(Rgb$1, rgb$1, extend$1(Color$1, {
        brighter: function (k) {
            k = k == null ? brighter$1 : Math.pow(brighter$1, k);
            return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$1 : Math.pow(darker$1, k);
            return new Rgb$1(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function () {
            return this;
        },
        displayable: function () {
            return (0 <= this.r && this.r <= 255)
                && (0 <= this.g && this.g <= 255)
                && (0 <= this.b && this.b <= 255)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        toString: function () {
            var a = this.opacity;
            a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
            return (a === 1 ? "rgb(" : "rgba(")
                + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
                + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
                + Math.max(0, Math.min(255, Math.round(this.b) || 0))
                + (a === 1 ? ")" : ", " + a + ")");
        }
    }));
    function hsla$1(h, s, l, a) {
        if (a <= 0)
            h = s = l = NaN;
        else if (l <= 0 || l >= 1)
            h = s = NaN;
        else if (s <= 0)
            h = NaN;
        return new Hsl$1(h, s, l, a);
    }
    function hslConvert$1(o) {
        if (o instanceof Hsl$1)
            return new Hsl$1(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color$1))
            o = color$1(o);
        if (!o)
            return new Hsl$1;
        if (o instanceof Hsl$1)
            return o;
        o = o.rgb();
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
        if (s) {
            if (r === max)
                h = (g - b) / s + (g < b) * 6;
            else if (g === max)
                h = (b - r) / s + 2;
            else
                h = (r - g) / s + 4;
            s /= l < 0.5 ? max + min : 2 - max - min;
            h *= 60;
        }
        else {
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl$1(h, s, l, o.opacity);
    }
    function hsl$1(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert$1(h) : new Hsl$1(h, s, l, opacity == null ? 1 : opacity);
    }
    function Hsl$1(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define$1(Hsl$1, hsl$1, extend$1(Color$1, {
        brighter: function (k) {
            k = k == null ? brighter$1 : Math.pow(brighter$1, k);
            return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$1 : Math.pow(darker$1, k);
            return new Hsl$1(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
            return new Rgb$1(hsl2rgb$1(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb$1(h, m1, m2), hsl2rgb$1(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
        },
        displayable: function () {
            return (0 <= this.s && this.s <= 1 || isNaN(this.s))
                && (0 <= this.l && this.l <= 1)
                && (0 <= this.opacity && this.opacity <= 1);
        }
    }));
    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb$1(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60
            : h < 180 ? m2
                : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
                    : m1) * 255;
    }

    var deg2rad$1 = Math.PI / 180;
    var rad2deg$1 = 180 / Math.PI;

    var Kn = 18, Xn$1 = 0.950470, // D65 standard referent
    Yn$1 = 1, Zn$1 = 1.088830, t0$2 = 4 / 29, t1$2 = 6 / 29, t2$1 = 3 * t1$2 * t1$2, t3$1 = t1$2 * t1$2 * t1$2;
    function labConvert$1(o) {
        if (o instanceof Lab$1)
            return new Lab$1(o.l, o.a, o.b, o.opacity);
        if (o instanceof Hcl$1) {
            var h = o.h * deg2rad$1;
            return new Lab$1(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
        }
        if (!(o instanceof Rgb$1))
            o = rgbConvert$1(o);
        var b = rgb2xyz(o.r), a = rgb2xyz(o.g), l = rgb2xyz(o.b), x = xyz2lab$1((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn$1), y = xyz2lab$1((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn$1), z = xyz2lab$1((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn$1);
        return new Lab$1(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }
    function lab$1(l, a, b, opacity) {
        return arguments.length === 1 ? labConvert$1(l) : new Lab$1(l, a, b, opacity == null ? 1 : opacity);
    }
    function Lab$1(l, a, b, opacity) {
        this.l = +l;
        this.a = +a;
        this.b = +b;
        this.opacity = +opacity;
    }
    define$1(Lab$1, lab$1, extend$1(Color$1, {
        brighter: function (k) {
            return new Lab$1(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        darker: function (k) {
            return new Lab$1(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        rgb: function () {
            var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
            y = Yn$1 * lab2xyz$1(y);
            x = Xn$1 * lab2xyz$1(x);
            z = Zn$1 * lab2xyz$1(z);
            return new Rgb$1(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
            xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), this.opacity);
        }
    }));
    function xyz2lab$1(t) {
        return t > t3$1 ? Math.pow(t, 1 / 3) : t / t2$1 + t0$2;
    }
    function lab2xyz$1(t) {
        return t > t1$2 ? t * t * t : t2$1 * (t - t0$2);
    }
    function xyz2rgb(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }
    function rgb2xyz(x) {
        return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }
    function hclConvert$1(o) {
        if (o instanceof Hcl$1)
            return new Hcl$1(o.h, o.c, o.l, o.opacity);
        if (!(o instanceof Lab$1))
            o = labConvert$1(o);
        var h = Math.atan2(o.b, o.a) * rad2deg$1;
        return new Hcl$1(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }
    function hcl$1(h, c, l, opacity) {
        return arguments.length === 1 ? hclConvert$1(h) : new Hcl$1(h, c, l, opacity == null ? 1 : opacity);
    }
    function Hcl$1(h, c, l, opacity) {
        this.h = +h;
        this.c = +c;
        this.l = +l;
        this.opacity = +opacity;
    }
    define$1(Hcl$1, hcl$1, extend$1(Color$1, {
        brighter: function (k) {
            return new Hcl$1(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
        },
        darker: function (k) {
            return new Hcl$1(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
        },
        rgb: function () {
            return labConvert$1(this).rgb();
        }
    }));

    var A$1 = -0.14861, B$1 = +1.78277, C$1 = -0.29227, D$1 = -0.90649, E$1 = +1.97294, ED$1 = E$1 * D$1, EB$1 = E$1 * B$1, BC_DA$1 = B$1 * C$1 - D$1 * A$1;
    function cubehelixConvert$1(o) {
        if (o instanceof Cubehelix$1)
            return new Cubehelix$1(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Rgb$1))
            o = rgbConvert$1(o);
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA$1 * b + ED$1 * r - EB$1 * g) / (BC_DA$1 + ED$1 - EB$1), bl = b - l, k = (E$1 * (g - l) - C$1 * bl) / D$1, s = Math.sqrt(k * k + bl * bl) / (E$1 * l * (1 - l)), // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * rad2deg$1 - 120 : NaN;
        return new Cubehelix$1(h < 0 ? h + 360 : h, s, l, o.opacity);
    }
    function cubehelix$1(h, s, l, opacity) {
        return arguments.length === 1 ? cubehelixConvert$1(h) : new Cubehelix$1(h, s, l, opacity == null ? 1 : opacity);
    }
    function Cubehelix$1(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define$1(Cubehelix$1, cubehelix$1, extend$1(Color$1, {
        brighter: function (k) {
            k = k == null ? brighter$1 : Math.pow(brighter$1, k);
            return new Cubehelix$1(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$1 : Math.pow(darker$1, k);
            return new Cubehelix$1(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad$1, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
            return new Rgb$1(255 * (l + a * (A$1 * cosh + B$1 * sinh)), 255 * (l + a * (C$1 * cosh + D$1 * sinh)), 255 * (l + a * (E$1 * cosh)), this.opacity);
        }
    }));

    var noop$1 = { value: function () { } };
    function dispatch$1() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
            if (!(t = arguments[i] + "") || (t in _))
                throw new Error("illegal type: " + t);
            _[t] = [];
        }
        return new Dispatch$1(_);
    }
    function Dispatch$1(_) {
        this._ = _;
    }
    function parseTypenames$2(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            if (t && !types.hasOwnProperty(t))
                throw new Error("unknown type: " + t);
            return { type: t, name: name };
        });
    }
    Dispatch$1.prototype = dispatch$1.prototype = {
        constructor: Dispatch$1,
        on: function (typename, callback) {
            var _ = this._, T = parseTypenames$2(typename + "", _), t, i = -1, n = T.length;
            // If no callback was specified, return the callback of the given type and name.
            if (arguments.length < 2) {
                while (++i < n)
                    if ((t = (typename = T[i]).type) && (t = get$3(_[t], typename.name)))
                        return t;
                return;
            }
            // If a type was specified, set the callback for the given type and name.
            // Otherwise, if a null callback was specified, remove callbacks of the given name.
            if (callback != null && typeof callback !== "function")
                throw new Error("invalid callback: " + callback);
            while (++i < n) {
                if (t = (typename = T[i]).type)
                    _[t] = set$5(_[t], typename.name, callback);
                else if (callback == null)
                    for (t in _)
                        _[t] = set$5(_[t], typename.name, null);
            }
            return this;
        },
        copy: function () {
            var copy = {}, _ = this._;
            for (var t in _)
                copy[t] = _[t].slice();
            return new Dispatch$1(copy);
        },
        call: function (type, that) {
            if ((n = arguments.length - 2) > 0)
                for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                    args[i] = arguments[i + 2];
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        },
        apply: function (type, that, args) {
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        }
    };
    function get$3(type, name) {
        for (var i = 0, n = type.length, c; i < n; ++i) {
            if ((c = type[i]).name === name) {
                return c.value;
            }
        }
    }
    function set$5(type, name, callback) {
        for (var i = 0, n = type.length; i < n; ++i) {
            if (type[i].name === name) {
                type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
                break;
            }
        }
        if (callback != null)
            type.push({ name: name, value: callback });
        return type;
    }

    var noop$2 = { value: function () { } };
    function dispatch$2() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
            if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t))
                throw new Error("illegal type: " + t);
            _[t] = [];
        }
        return new Dispatch$2(_);
    }
    function Dispatch$2(_) {
        this._ = _;
    }
    function parseTypenames$3(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            if (t && !types.hasOwnProperty(t))
                throw new Error("unknown type: " + t);
            return { type: t, name: name };
        });
    }
    Dispatch$2.prototype = dispatch$2.prototype = {
        constructor: Dispatch$2,
        on: function (typename, callback) {
            var _ = this._, T = parseTypenames$3(typename + "", _), t, i = -1, n = T.length;
            // If no callback was specified, return the callback of the given type and name.
            if (arguments.length < 2) {
                while (++i < n)
                    if ((t = (typename = T[i]).type) && (t = get$4(_[t], typename.name)))
                        return t;
                return;
            }
            // If a type was specified, set the callback for the given type and name.
            // Otherwise, if a null callback was specified, remove callbacks of the given name.
            if (callback != null && typeof callback !== "function")
                throw new Error("invalid callback: " + callback);
            while (++i < n) {
                if (t = (typename = T[i]).type)
                    _[t] = set$6(_[t], typename.name, callback);
                else if (callback == null)
                    for (t in _)
                        _[t] = set$6(_[t], typename.name, null);
            }
            return this;
        },
        copy: function () {
            var copy = {}, _ = this._;
            for (var t in _)
                copy[t] = _[t].slice();
            return new Dispatch$2(copy);
        },
        call: function (type, that) {
            if ((n = arguments.length - 2) > 0)
                for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                    args[i] = arguments[i + 2];
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        },
        apply: function (type, that, args) {
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        }
    };
    function get$4(type, name) {
        for (var i = 0, n = type.length, c; i < n; ++i) {
            if ((c = type[i]).name === name) {
                return c.value;
            }
        }
    }
    function set$6(type, name, callback) {
        for (var i = 0, n = type.length; i < n; ++i) {
            if (type[i].name === name) {
                type[i] = noop$2, type = type.slice(0, i).concat(type.slice(i + 1));
                break;
            }
        }
        if (callback != null)
            type.push({ name: name, value: callback });
        return type;
    }

    var xhtml$1 = "http://www.w3.org/1999/xhtml";
    var namespaces$1 = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml$1,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace$1 (name) {
        var prefix = name += "", i = prefix.indexOf(":");
        if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
            name = name.slice(i + 1);
        return namespaces$1.hasOwnProperty(prefix) ? { space: namespaces$1[prefix], local: name } : name;
    }

    function creatorInherit$1(name) {
        return function () {
            var document = this.ownerDocument, uri = this.namespaceURI;
            return uri === xhtml$1 && document.documentElement.namespaceURI === xhtml$1
                ? document.createElement(name)
                : document.createElementNS(uri, name);
        };
    }
    function creatorFixed$1(fullname) {
        return function () {
            return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
    }
    function creator$1 (name) {
        var fullname = namespace$1(name);
        return (fullname.local
            ? creatorFixed$1
            : creatorInherit$1)(fullname);
    }

    function none$1() { }
    function selector$1 (selector) {
        return selector == null ? none$1 : function () {
            return this.querySelector(selector);
        };
    }

    function selection_select$1 (select) {
        if (typeof select !== "function")
            select = selector$1(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                }
            }
        }
        return new Selection$3(subgroups, this._parents);
    }

    function empty$2() {
        return [];
    }
    function selectorAll$1 (selector) {
        return selector == null ? empty$2 : function () {
            return this.querySelectorAll(selector);
        };
    }

    function selection_selectAll$1 (select) {
        if (typeof select !== "function")
            select = selectorAll$1(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    subgroups.push(select.call(node, node.__data__, i, group));
                    parents.push(node);
                }
            }
        }
        return new Selection$3(subgroups, parents);
    }

    function matcher$1 (selector) {
        return function () {
            return this.matches(selector);
        };
    }

    function selection_filter$1 (match) {
        if (typeof match !== "function")
            match = matcher$1(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Selection$3(subgroups, this._parents);
    }

    function sparse$1 (update) {
        return new Array(update.length);
    }

    function selection_enter$1 () {
        return new Selection$3(this._enter || this._groups.map(sparse$1), this._parents);
    }
    function EnterNode$1(parent, datum) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum;
    }
    EnterNode$1.prototype = {
        constructor: EnterNode$1,
        appendChild: function (child) { return this._parent.insertBefore(child, this._next); },
        insertBefore: function (child, next) { return this._parent.insertBefore(child, next); },
        querySelector: function (selector) { return this._parent.querySelector(selector); },
        querySelectorAll: function (selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$7 (x) {
        return function () {
            return x;
        };
    }

    var keyPrefix$1 = "$"; // Protect against keys like “__proto__”.
    function bindIndex$1(parent, group, enter, update, exit, data) {
        var i = 0, node, groupLength = group.length, dataLength = data.length;
        // Put any non-null nodes that fit into update.
        // Put any null nodes into enter.
        // Put any remaining data into enter.
        for (; i < dataLength; ++i) {
            if (node = group[i]) {
                node.__data__ = data[i];
                update[i] = node;
            }
            else {
                enter[i] = new EnterNode$1(parent, data[i]);
            }
        }
        // Put any non-null nodes that don’t fit into exit.
        for (; i < groupLength; ++i) {
            if (node = group[i]) {
                exit[i] = node;
            }
        }
    }
    function bindKey$1(parent, group, enter, update, exit, data, key) {
        var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
        // Compute the key for each node.
        // If multiple nodes have the same key, the duplicates are added to exit.
        for (i = 0; i < groupLength; ++i) {
            if (node = group[i]) {
                keyValues[i] = keyValue = keyPrefix$1 + key.call(node, node.__data__, i, group);
                if (keyValue in nodeByKeyValue) {
                    exit[i] = node;
                }
                else {
                    nodeByKeyValue[keyValue] = node;
                }
            }
        }
        // Compute the key for each datum.
        // If there a node associated with this key, join and add it to update.
        // If there is not (or the key is a duplicate), add it to enter.
        for (i = 0; i < dataLength; ++i) {
            keyValue = keyPrefix$1 + key.call(parent, data[i], i, data);
            if (node = nodeByKeyValue[keyValue]) {
                update[i] = node;
                node.__data__ = data[i];
                nodeByKeyValue[keyValue] = null;
            }
            else {
                enter[i] = new EnterNode$1(parent, data[i]);
            }
        }
        // Add any remaining nodes that were not bound to data to exit.
        for (i = 0; i < groupLength; ++i) {
            if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
                exit[i] = node;
            }
        }
    }
    function selection_data$1 (value, key) {
        if (!value) {
            data = new Array(this.size()), j = -1;
            this.each(function (d) { data[++j] = d; });
            return data;
        }
        var bind = key ? bindKey$1 : bindIndex$1, parents = this._parents, groups = this._groups;
        if (typeof value !== "function")
            value = constant$7(value);
        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
            var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
            bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
            // Now connect the enter nodes to their following update node, such that
            // appendChild can insert the materialized enter node before this node,
            // rather than at the end of the parent node.
            for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
                if (previous = enterGroup[i0]) {
                    if (i0 >= i1)
                        i1 = i0 + 1;
                    while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                        ;
                    previous._next = next || null;
                }
            }
        }
        update = new Selection$3(update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
    }

    function selection_exit$1 () {
        return new Selection$3(this._exit || this._groups.map(sparse$1), this._parents);
    }

    function selection_join$1 (onenter, onupdate, onexit) {
        var enter = this.enter(), update = this, exit = this.exit();
        enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
        if (onupdate != null)
            update = onupdate(update);
        if (onexit == null)
            exit.remove();
        else
            onexit(exit);
        return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge$1 (selection) {
        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Selection$3(merges, this._parents);
    }

    function selection_order$1 () {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
            for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && node.compareDocumentPosition(next) ^ 4)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    }

    function selection_sort$1 (compare) {
        if (!compare)
            compare = ascending$3;
        function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    sortgroup[i] = node;
                }
            }
            sortgroup.sort(compareNode);
        }
        return new Selection$3(sortgroups, this._parents).order();
    }
    function ascending$3(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call$1 () {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
    }

    function selection_nodes$1 () {
        var nodes = new Array(this.size()), i = -1;
        this.each(function () { nodes[++i] = this; });
        return nodes;
    }

    function selection_node$1 () {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    }

    function selection_size$1 () {
        var size = 0;
        this.each(function () { ++size; });
        return size;
    }

    function selection_empty$1 () {
        return !this.node();
    }

    function selection_each$1 (callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
                if (node = group[i])
                    callback.call(node, node.__data__, i, group);
            }
        }
        return this;
    }

    function attrRemove$3(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS$3(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant$3(name, value) {
        return function () {
            this.setAttribute(name, value);
        };
    }
    function attrConstantNS$3(fullname, value) {
        return function () {
            this.setAttributeNS(fullname.space, fullname.local, value);
        };
    }
    function attrFunction$3(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, v);
        };
    }
    function attrFunctionNS$3(fullname, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttributeNS(fullname.space, fullname.local);
            else
                this.setAttributeNS(fullname.space, fullname.local, v);
        };
    }
    function selection_attr$1 (name, value) {
        var fullname = namespace$1(name);
        if (arguments.length < 2) {
            var node = this.node();
            return fullname.local
                ? node.getAttributeNS(fullname.space, fullname.local)
                : node.getAttribute(fullname);
        }
        return this.each((value == null
            ? (fullname.local ? attrRemoveNS$3 : attrRemove$3) : (typeof value === "function"
            ? (fullname.local ? attrFunctionNS$3 : attrFunction$3)
            : (fullname.local ? attrConstantNS$3 : attrConstant$3)))(fullname, value));
    }

    function defaultView$1 (node) {
        return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
            || (node.document && node) // node is a Window
            || node.defaultView; // node is a Document
    }

    function styleRemove$3(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant$3(name, value, priority) {
        return function () {
            this.style.setProperty(name, value, priority);
        };
    }
    function styleFunction$3(name, value, priority) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, v, priority);
        };
    }
    function selection_style$1 (name, value, priority) {
        return arguments.length > 1
            ? this.each((value == null
                ? styleRemove$3 : typeof value === "function"
                ? styleFunction$3
                : styleConstant$3)(name, value, priority == null ? "" : priority))
            : styleValue$1(this.node(), name);
    }
    function styleValue$1(node, name) {
        return node.style.getPropertyValue(name)
            || defaultView$1(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove$1(name) {
        return function () {
            delete this[name];
        };
    }
    function propertyConstant$1(name, value) {
        return function () {
            this[name] = value;
        };
    }
    function propertyFunction$1(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                delete this[name];
            else
                this[name] = v;
        };
    }
    function selection_property$1 (name, value) {
        return arguments.length > 1
            ? this.each((value == null
                ? propertyRemove$1 : typeof value === "function"
                ? propertyFunction$1
                : propertyConstant$1)(name, value))
            : this.node()[name];
    }

    function classArray$1(string) {
        return string.trim().split(/^|\s+/);
    }
    function classList$1(node) {
        return node.classList || new ClassList$1(node);
    }
    function ClassList$1(node) {
        this._node = node;
        this._names = classArray$1(node.getAttribute("class") || "");
    }
    ClassList$1.prototype = {
        add: function (name) {
            var i = this._names.indexOf(name);
            if (i < 0) {
                this._names.push(name);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        remove: function (name) {
            var i = this._names.indexOf(name);
            if (i >= 0) {
                this._names.splice(i, 1);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        contains: function (name) {
            return this._names.indexOf(name) >= 0;
        }
    };
    function classedAdd$1(node, names) {
        var list = classList$1(node), i = -1, n = names.length;
        while (++i < n)
            list.add(names[i]);
    }
    function classedRemove$1(node, names) {
        var list = classList$1(node), i = -1, n = names.length;
        while (++i < n)
            list.remove(names[i]);
    }
    function classedTrue$1(names) {
        return function () {
            classedAdd$1(this, names);
        };
    }
    function classedFalse$1(names) {
        return function () {
            classedRemove$1(this, names);
        };
    }
    function classedFunction$1(names, value) {
        return function () {
            (value.apply(this, arguments) ? classedAdd$1 : classedRemove$1)(this, names);
        };
    }
    function selection_classed$1 (name, value) {
        var names = classArray$1(name + "");
        if (arguments.length < 2) {
            var list = classList$1(this.node()), i = -1, n = names.length;
            while (++i < n)
                if (!list.contains(names[i]))
                    return false;
            return true;
        }
        return this.each((typeof value === "function"
            ? classedFunction$1 : value
            ? classedTrue$1
            : classedFalse$1)(names, value));
    }

    function textRemove$1() {
        this.textContent = "";
    }
    function textConstant$3(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction$3(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        };
    }
    function selection_text$1 (value) {
        return arguments.length
            ? this.each(value == null
                ? textRemove$1 : (typeof value === "function"
                ? textFunction$3
                : textConstant$3)(value))
            : this.node().textContent;
    }

    function htmlRemove$1() {
        this.innerHTML = "";
    }
    function htmlConstant$1(value) {
        return function () {
            this.innerHTML = value;
        };
    }
    function htmlFunction$1(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        };
    }
    function selection_html$1 (value) {
        return arguments.length
            ? this.each(value == null
                ? htmlRemove$1 : (typeof value === "function"
                ? htmlFunction$1
                : htmlConstant$1)(value))
            : this.node().innerHTML;
    }

    function raise$1() {
        if (this.nextSibling)
            this.parentNode.appendChild(this);
    }
    function selection_raise$1 () {
        return this.each(raise$1);
    }

    function lower$1() {
        if (this.previousSibling)
            this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower$1 () {
        return this.each(lower$1);
    }

    function selection_append$1 (name) {
        var create = typeof name === "function" ? name : creator$1(name);
        return this.select(function () {
            return this.appendChild(create.apply(this, arguments));
        });
    }

    function constantNull$1() {
        return null;
    }
    function selection_insert$1 (name, before) {
        var create = typeof name === "function" ? name : creator$1(name), select = before == null ? constantNull$1 : typeof before === "function" ? before : selector$1(before);
        return this.select(function () {
            return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        });
    }

    function remove$1() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    function selection_remove$1 () {
        return this.each(remove$1);
    }

    function selection_cloneShallow$1() {
        var clone = this.cloneNode(false), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep$1() {
        var clone = this.cloneNode(true), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone$1 (deep) {
        return this.select(deep ? selection_cloneDeep$1 : selection_cloneShallow$1);
    }

    function selection_datum$1 (value) {
        return arguments.length
            ? this.property("__data__", value)
            : this.node().__data__;
    }

    var filterEvents$1 = {};
    var event$1 = null;
    if (typeof document !== "undefined") {
        var element$1 = document.documentElement;
        if (!("onmouseenter" in element$1)) {
            filterEvents$1 = { mouseenter: "mouseover", mouseleave: "mouseout" };
        }
    }
    function filterContextListener$1(listener, index, group) {
        listener = contextListener$1(listener, index, group);
        return function (event) {
            var related = event.relatedTarget;
            if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
                listener.call(this, event);
            }
        };
    }
    function contextListener$1(listener, index, group) {
        return function (event1) {
            var event0 = event$1; // Events can be reentrant (e.g., focus).
            event$1 = event1;
            try {
                listener.call(this, this.__data__, index, group);
            }
            finally {
                event$1 = event0;
            }
        };
    }
    function parseTypenames$4(typenames) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            return { type: t, name: name };
        });
    }
    function onRemove$1(typename) {
        return function () {
            var on = this.__on;
            if (!on)
                return;
            for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
                if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                    this.removeEventListener(o.type, o.listener, o.capture);
                }
                else {
                    on[++i] = o;
                }
            }
            if (++i)
                on.length = i;
            else
                delete this.__on;
        };
    }
    function onAdd$1(typename, value, capture) {
        var wrap = filterEvents$1.hasOwnProperty(typename.type) ? filterContextListener$1 : contextListener$1;
        return function (d, i, group) {
            var on = this.__on, o, listener = wrap(value, i, group);
            if (on)
                for (var j = 0, m = on.length; j < m; ++j) {
                    if ((o = on[j]).type === typename.type && o.name === typename.name) {
                        this.removeEventListener(o.type, o.listener, o.capture);
                        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                        o.value = value;
                        return;
                    }
                }
            this.addEventListener(typename.type, listener, capture);
            o = { type: typename.type, name: typename.name, value: value, listener: listener, capture: capture };
            if (!on)
                this.__on = [o];
            else
                on.push(o);
        };
    }
    function selection_on$1 (typename, value, capture) {
        var typenames = parseTypenames$4(typename + ""), i, n = typenames.length, t;
        if (arguments.length < 2) {
            var on = this.node().__on;
            if (on)
                for (var j = 0, m = on.length, o; j < m; ++j) {
                    for (i = 0, o = on[j]; i < n; ++i) {
                        if ((t = typenames[i]).type === o.type && t.name === o.name) {
                            return o.value;
                        }
                    }
                }
            return;
        }
        on = value ? onAdd$1 : onRemove$1;
        if (capture == null)
            capture = false;
        for (i = 0; i < n; ++i)
            this.each(on(typenames[i], value, capture));
        return this;
    }
    function customEvent$1(event1, listener, that, args) {
        var event0 = event$1;
        event1.sourceEvent = event$1;
        event$1 = event1;
        try {
            return listener.apply(that, args);
        }
        finally {
            event$1 = event0;
        }
    }

    function dispatchEvent$1(node, type, params) {
        var window = defaultView$1(node), event = window.CustomEvent;
        if (typeof event === "function") {
            event = new event(type, params);
        }
        else {
            event = window.document.createEvent("Event");
            if (params)
                event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
            else
                event.initEvent(type, false, false);
        }
        node.dispatchEvent(event);
    }
    function dispatchConstant$1(type, params) {
        return function () {
            return dispatchEvent$1(this, type, params);
        };
    }
    function dispatchFunction$1(type, params) {
        return function () {
            return dispatchEvent$1(this, type, params.apply(this, arguments));
        };
    }
    function selection_dispatch$1 (type, params) {
        return this.each((typeof params === "function"
            ? dispatchFunction$1
            : dispatchConstant$1)(type, params));
    }

    var root$1 = [null];
    function Selection$3(groups, parents) {
        this._groups = groups;
        this._parents = parents;
    }
    Selection$3.prototype = {
        constructor: Selection$3,
        select: selection_select$1,
        selectAll: selection_selectAll$1,
        filter: selection_filter$1,
        data: selection_data$1,
        enter: selection_enter$1,
        exit: selection_exit$1,
        join: selection_join$1,
        merge: selection_merge$1,
        order: selection_order$1,
        sort: selection_sort$1,
        call: selection_call$1,
        nodes: selection_nodes$1,
        node: selection_node$1,
        size: selection_size$1,
        empty: selection_empty$1,
        each: selection_each$1,
        attr: selection_attr$1,
        style: selection_style$1,
        property: selection_property$1,
        classed: selection_classed$1,
        text: selection_text$1,
        html: selection_html$1,
        raise: selection_raise$1,
        lower: selection_lower$1,
        append: selection_append$1,
        insert: selection_insert$1,
        remove: selection_remove$1,
        clone: selection_clone$1,
        datum: selection_datum$1,
        on: selection_on$1,
        dispatch: selection_dispatch$1
    };

    function select$1 (selector) {
        return typeof selector === "string"
            ? new Selection$3([[document.querySelector(selector)]], [document.documentElement])
            : new Selection$3([[selector]], root$1);
    }

    function sourceEvent$1 () {
        var current = event$1, source;
        while (source = current.sourceEvent)
            current = source;
        return current;
    }

    function point$2 (node, event) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            point.x = event.clientX, point.y = event.clientY;
            point = point.matrixTransform(node.getScreenCTM().inverse());
            return [point.x, point.y];
        }
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }

    function mouse$1 (node) {
        var event = sourceEvent$1();
        if (event.changedTouches)
            event = event.changedTouches[0];
        return point$2(node, event);
    }

    function touch$1 (node, touches, identifier) {
        if (arguments.length < 3)
            identifier = touches, touches = sourceEvent$1().changedTouches;
        for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
                return point$2(node, touch);
            }
        }
        return null;
    }

    function nopropagation$1() {
        event$1.stopImmediatePropagation();
    }
    function noevent$2 () {
        event$1.preventDefault();
        event$1.stopImmediatePropagation();
    }

    function nodrag (view) {
        var root = view.document.documentElement, selection = select$1(view).on("dragstart.drag", noevent$2, true);
        if ("onselectstart" in root) {
            selection.on("selectstart.drag", noevent$2, true);
        }
        else {
            root.__noselect = root.style.MozUserSelect;
            root.style.MozUserSelect = "none";
        }
    }
    function yesdrag$1(view, noclick) {
        var root = view.document.documentElement, selection = select$1(view).on("dragstart.drag", null);
        if (noclick) {
            selection.on("click.drag", noevent$2, true);
            setTimeout(function () { selection.on("click.drag", null); }, 0);
        }
        if ("onselectstart" in root) {
            selection.on("selectstart.drag", null);
        }
        else {
            root.style.MozUserSelect = root.__noselect;
            delete root.__noselect;
        }
    }

    function constant$8 (x) {
        return function () {
            return x;
        };
    }

    function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
        this.target = target;
        this.type = type;
        this.subject = subject;
        this.identifier = id;
        this.active = active;
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;
        this._ = dispatch;
    }
    DragEvent.prototype.on = function () {
        var value = this._.on.apply(this._, arguments);
        return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1() {
        return !event$1.button;
    }
    function defaultContainer() {
        return this.parentNode;
    }
    function defaultSubject(d) {
        return d == null ? { x: event$1.x, y: event$1.y } : d;
    }
    function defaultTouchable() {
        return "ontouchstart" in this;
    }
    function drag () {
        var filter = defaultFilter$1, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable, gestures = {}, listeners = dispatch$2("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
        function drag(selection) {
            selection
                .on("mousedown.drag", mousedowned)
                .filter(touchable)
                .on("touchstart.drag", touchstarted)
                .on("touchmove.drag", touchmoved)
                .on("touchend.drag touchcancel.drag", touchended)
                .style("touch-action", "none")
                .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
        }
        function mousedowned() {
            if (touchending || !filter.apply(this, arguments))
                return;
            var gesture = beforestart("mouse", container.apply(this, arguments), mouse$1, this, arguments);
            if (!gesture)
                return;
            select$1(event$1.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
            nodrag(event$1.view);
            nopropagation$1();
            mousemoving = false;
            mousedownx = event$1.clientX;
            mousedowny = event$1.clientY;
            gesture("start");
        }
        function mousemoved() {
            noevent$2();
            if (!mousemoving) {
                var dx = event$1.clientX - mousedownx, dy = event$1.clientY - mousedowny;
                mousemoving = dx * dx + dy * dy > clickDistance2;
            }
            gestures.mouse("drag");
        }
        function mouseupped() {
            select$1(event$1.view).on("mousemove.drag mouseup.drag", null);
            yesdrag$1(event$1.view, mousemoving);
            noevent$2();
            gestures.mouse("end");
        }
        function touchstarted() {
            if (!filter.apply(this, arguments))
                return;
            var touches = event$1.changedTouches, c = container.apply(this, arguments), n = touches.length, i, gesture;
            for (i = 0; i < n; ++i) {
                if (gesture = beforestart(touches[i].identifier, c, touch$1, this, arguments)) {
                    nopropagation$1();
                    gesture("start");
                }
            }
        }
        function touchmoved() {
            var touches = event$1.changedTouches, n = touches.length, i, gesture;
            for (i = 0; i < n; ++i) {
                if (gesture = gestures[touches[i].identifier]) {
                    noevent$2();
                    gesture("drag");
                }
            }
        }
        function touchended() {
            var touches = event$1.changedTouches, n = touches.length, i, gesture;
            if (touchending)
                clearTimeout(touchending);
            touchending = setTimeout(function () { touchending = null; }, 500); // Ghost clicks are delayed!
            for (i = 0; i < n; ++i) {
                if (gesture = gestures[touches[i].identifier]) {
                    nopropagation$1();
                    gesture("end");
                }
            }
        }
        function beforestart(id, container, point, that, args) {
            var p = point(container, id), s, dx, dy, sublisteners = listeners.copy();
            if (!customEvent$1(new DragEvent(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
                if ((event$1.subject = s = subject.apply(that, args)) == null)
                    return false;
                dx = s.x - p[0] || 0;
                dy = s.y - p[1] || 0;
                return true;
            }))
                return;
            return function gesture(type) {
                var p0 = p, n;
                switch (type) {
                    case "start":
                        gestures[id] = gesture, n = active++;
                        break;
                    case "end": delete gestures[id], --active; // nobreak
                    case "drag":
                        p = point(container, id), n = active;
                        break;
                }
                customEvent$1(new DragEvent(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
            };
        }
        drag.filter = function (_) {
            return arguments.length ? (filter = typeof _ === "function" ? _ : constant$8(!!_), drag) : filter;
        };
        drag.container = function (_) {
            return arguments.length ? (container = typeof _ === "function" ? _ : constant$8(_), drag) : container;
        };
        drag.subject = function (_) {
            return arguments.length ? (subject = typeof _ === "function" ? _ : constant$8(_), drag) : subject;
        };
        drag.touchable = function (_) {
            return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$8(!!_), drag) : touchable;
        };
        drag.on = function () {
            var value = listeners.on.apply(listeners, arguments);
            return value === listeners ? drag : value;
        };
        drag.clickDistance = function (_) {
            return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
        };
        return drag;
    }

    var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
    function objectConverter(columns) {
        return new Function("d", "return {" + columns.map(function (name, i) {
            return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
    }
    function customConverter(columns, f) {
        var object = objectConverter(columns);
        return function (row, i) {
            return f(object(row), i, columns);
        };
    }
    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
        var columnSet = Object.create(null), columns = [];
        rows.forEach(function (row) {
            for (var column in row) {
                if (!(column in columnSet)) {
                    columns.push(columnSet[column] = column);
                }
            }
        });
        return columns;
    }
    function dsv (delimiter) {
        var reFormat = new RegExp("[\"" + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
        function parse(text, f) {
            var convert, columns, rows = parseRows(text, function (row, i) {
                if (convert)
                    return convert(row, i - 1);
                columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
            });
            rows.columns = columns || [];
            return rows;
        }
        function parseRows(text, f) {
            var rows = [], // output rows
            N = text.length, I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?
            // Strip the trailing newline.
            if (text.charCodeAt(N - 1) === NEWLINE)
                --N;
            if (text.charCodeAt(N - 1) === RETURN)
                --N;
            function token() {
                if (eof)
                    return EOF;
                if (eol)
                    return eol = false, EOL;
                // Unescape quotes.
                var i, j = I, c;
                if (text.charCodeAt(j) === QUOTE) {
                    while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE)
                        ;
                    if ((i = I) >= N)
                        eof = true;
                    else if ((c = text.charCodeAt(I++)) === NEWLINE)
                        eol = true;
                    else if (c === RETURN) {
                        eol = true;
                        if (text.charCodeAt(I) === NEWLINE)
                            ++I;
                    }
                    return text.slice(j + 1, i - 1).replace(/""/g, "\"");
                }
                // Find next delimiter or newline.
                while (I < N) {
                    if ((c = text.charCodeAt(i = I++)) === NEWLINE)
                        eol = true;
                    else if (c === RETURN) {
                        eol = true;
                        if (text.charCodeAt(I) === NEWLINE)
                            ++I;
                    }
                    else if (c !== DELIMITER)
                        continue;
                    return text.slice(j, i);
                }
                // Return last token before EOF.
                return eof = true, text.slice(j, N);
            }
            while ((t = token()) !== EOF) {
                var row = [];
                while (t !== EOL && t !== EOF)
                    row.push(t), t = token();
                if (f && (row = f(row, n++)) == null)
                    continue;
                rows.push(row);
            }
            return rows;
        }
        function format(rows, columns) {
            if (columns == null)
                columns = inferColumns(rows);
            return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
                return columns.map(function (column) {
                    return formatValue(row[column]);
                }).join(delimiter);
            })).join("\n");
        }
        function formatRows(rows) {
            return rows.map(formatRow).join("\n");
        }
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return text == null ? ""
                : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\""
                    : text;
        }
        return {
            parse: parse,
            parseRows: parseRows,
            format: format,
            formatRows: formatRows
        };
    }

    var csv = dsv(",");
    var csvParse = csv.parse;
    var csvParseRows = csv.parseRows;
    var csvFormat = csv.format;
    var csvFormatRows = csv.formatRows;

    var tsv = dsv("\t");
    var tsvParse = tsv.parse;
    var tsvParseRows = tsv.parseRows;
    var tsvFormat = tsv.format;
    var tsvFormatRows = tsv.formatRows;

    function linear$2(t) {
        return +t;
    }

    function quadIn(t) {
        return t * t;
    }
    function quadOut(t) {
        return t * (2 - t);
    }
    function quadInOut(t) {
        return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
        return t * t * t;
    }
    function cubicOut(t) {
        return --t * t * t + 1;
    }
    function cubicInOut$1(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;
    var polyIn = (function custom(e) {
        e = +e;
        function polyIn(t) {
            return Math.pow(t, e);
        }
        polyIn.exponent = custom;
        return polyIn;
    })(exponent$1);
    var polyOut = (function custom(e) {
        e = +e;
        function polyOut(t) {
            return 1 - Math.pow(1 - t, e);
        }
        polyOut.exponent = custom;
        return polyOut;
    })(exponent$1);
    var polyInOut = (function custom(e) {
        e = +e;
        function polyInOut(t) {
            return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
        }
        polyInOut.exponent = custom;
        return polyInOut;
    })(exponent$1);

    var pi$3 = Math.PI, halfPi$1 = pi$3 / 2;
    function sinIn(t) {
        return 1 - Math.cos(t * halfPi$1);
    }
    function sinOut(t) {
        return Math.sin(t * halfPi$1);
    }
    function sinInOut(t) {
        return (1 - Math.cos(pi$3 * t)) / 2;
    }

    function expIn(t) {
        return Math.pow(2, 10 * t - 10);
    }
    function expOut(t) {
        return 1 - Math.pow(2, -10 * t);
    }
    function expInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
    }

    function circleIn$1(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function circleOut(t) {
        return Math.sqrt(1 - --t * t);
    }
    function circleInOut(t) {
        return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
    function bounceIn(t) {
        return 1 - bounceOut(1 - t);
    }
    function bounceOut(t) {
        return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }
    function bounceInOut(t) {
        return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;
    var backIn = (function custom(s) {
        s = +s;
        function backIn(t) {
            return t * t * ((s + 1) * t - s);
        }
        backIn.overshoot = custom;
        return backIn;
    })(overshoot);
    var backOut = (function custom(s) {
        s = +s;
        function backOut(t) {
            return --t * t * ((s + 1) * t + s) + 1;
        }
        backOut.overshoot = custom;
        return backOut;
    })(overshoot);
    var backInOut = (function custom(s) {
        s = +s;
        function backInOut(t) {
            return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
        }
        backInOut.overshoot = custom;
        return backInOut;
    })(overshoot);

    var tau$3 = 2 * Math.PI, amplitude = 1, period = 0.3;
    var elasticIn = (function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$3);
        function elasticIn(t) {
            return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
        }
        elasticIn.amplitude = function (a) { return custom(a, p * tau$3); };
        elasticIn.period = function (p) { return custom(a, p); };
        return elasticIn;
    })(amplitude, period);
    var elasticOut = (function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$3);
        function elasticOut(t) {
            return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
        }
        elasticOut.amplitude = function (a) { return custom(a, p * tau$3); };
        elasticOut.period = function (p) { return custom(a, p); };
        return elasticOut;
    })(amplitude, period);
    var elasticInOut = (function custom(a, p) {
        var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$3);
        function elasticInOut(t) {
            return ((t = t * 2 - 1) < 0
                ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p)
                : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
        }
        elasticInOut.amplitude = function (a) { return custom(a, p * tau$3); };
        elasticInOut.period = function (p) { return custom(a, p); };
        return elasticInOut;
    })(amplitude, period);

    function center$3 (x, y) {
        var nodes;
        if (x == null)
            x = 0;
        if (y == null)
            y = 0;
        function force() {
            var i, n = nodes.length, node, sx = 0, sy = 0;
            for (i = 0; i < n; ++i) {
                node = nodes[i], sx += node.x, sy += node.y;
            }
            for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
                node = nodes[i], node.x -= sx, node.y -= sy;
            }
        }
        force.initialize = function (_) {
            nodes = _;
        };
        force.x = function (_) {
            return arguments.length ? (x = +_, force) : x;
        };
        force.y = function (_) {
            return arguments.length ? (y = +_, force) : y;
        };
        return force;
    }

    function constant$9 (x) {
        return function () {
            return x;
        };
    }

    function jiggle () {
        return (Math.random() - 0.5) * 1e-6;
    }

    function tree_add (d) {
        var x = +this._x.call(null, d), y = +this._y.call(null, d);
        return add(this.cover(x, y), x, y, d);
    }
    function add(tree, x, y, d) {
        if (isNaN(x) || isNaN(y))
            return tree; // ignore invalid points
        var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
        // If the tree is empty, initialize the root as a leaf.
        if (!node)
            return tree._root = leaf, tree;
        // Find the existing leaf for the new point, or add it.
        while (node.length) {
            if (right = x >= (xm = (x0 + x1) / 2))
                x0 = xm;
            else
                x1 = xm;
            if (bottom = y >= (ym = (y0 + y1) / 2))
                y0 = ym;
            else
                y1 = ym;
            if (parent = node, !(node = node[i = bottom << 1 | right]))
                return parent[i] = leaf, tree;
        }
        // Is the new point is exactly coincident with the existing point?
        xp = +tree._x.call(null, node.data);
        yp = +tree._y.call(null, node.data);
        if (x === xp && y === yp)
            return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
        // Otherwise, split the leaf node until the old and new point are separated.
        do {
            parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
            if (right = x >= (xm = (x0 + x1) / 2))
                x0 = xm;
            else
                x1 = xm;
            if (bottom = y >= (ym = (y0 + y1) / 2))
                y0 = ym;
            else
                y1 = ym;
        } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
        return parent[j] = node, parent[i] = leaf, tree;
    }
    function addAll(data) {
        var d, i, n = data.length, x, y, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
        // Compute the points and their extent.
        for (i = 0; i < n; ++i) {
            if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d)))
                continue;
            xz[i] = x;
            yz[i] = y;
            if (x < x0)
                x0 = x;
            if (x > x1)
                x1 = x;
            if (y < y0)
                y0 = y;
            if (y > y1)
                y1 = y;
        }
        // If there were no (valid) points, abort.
        if (x0 > x1 || y0 > y1)
            return this;
        // Expand the tree to cover the new points.
        this.cover(x0, y0).cover(x1, y1);
        // Add the new points.
        for (i = 0; i < n; ++i) {
            add(this, xz[i], yz[i], data[i]);
        }
        return this;
    }

    function tree_cover (x, y) {
        if (isNaN(x = +x) || isNaN(y = +y))
            return this; // ignore invalid points
        var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
        // If the quadtree has no extent, initialize them.
        // Integer extent are necessary so that if we later double the extent,
        // the existing quadrant boundaries don’t change due to floating point error!
        if (isNaN(x0)) {
            x1 = (x0 = Math.floor(x)) + 1;
            y1 = (y0 = Math.floor(y)) + 1;
        }
        // Otherwise, double repeatedly to cover.
        else {
            var z = x1 - x0, node = this._root, parent, i;
            while (x0 > x || x >= x1 || y0 > y || y >= y1) {
                i = (y < y0) << 1 | (x < x0);
                parent = new Array(4), parent[i] = node, node = parent, z *= 2;
                switch (i) {
                    case 0:
                        x1 = x0 + z, y1 = y0 + z;
                        break;
                    case 1:
                        x0 = x1 - z, y1 = y0 + z;
                        break;
                    case 2:
                        x1 = x0 + z, y0 = y1 - z;
                        break;
                    case 3:
                        x0 = x1 - z, y0 = y1 - z;
                        break;
                }
            }
            if (this._root && this._root.length)
                this._root = node;
        }
        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        return this;
    }

    function tree_data () {
        var data = [];
        this.visit(function (node) {
            if (!node.length)
                do
                    data.push(node.data);
                while (node = node.next);
        });
        return data;
    }

    function tree_extent (_) {
        return arguments.length
            ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
            : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad (node, x0, y0, x1, y1) {
        this.node = node;
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
    }

    function tree_find (x, y, radius) {
        var data, x0 = this._x0, y0 = this._y0, x1, y1, x2, y2, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i;
        if (node)
            quads.push(new Quad(node, x0, y0, x3, y3));
        if (radius == null)
            radius = Infinity;
        else {
            x0 = x - radius, y0 = y - radius;
            x3 = x + radius, y3 = y + radius;
            radius *= radius;
        }
        while (q = quads.pop()) {
            // Stop searching if this quadrant can’t contain a closer node.
            if (!(node = q.node)
                || (x1 = q.x0) > x3
                || (y1 = q.y0) > y3
                || (x2 = q.x1) < x0
                || (y2 = q.y1) < y0)
                continue;
            // Bisect the current quadrant.
            if (node.length) {
                var xm = (x1 + x2) / 2, ym = (y1 + y2) / 2;
                quads.push(new Quad(node[3], xm, ym, x2, y2), new Quad(node[2], x1, ym, xm, y2), new Quad(node[1], xm, y1, x2, ym), new Quad(node[0], x1, y1, xm, ym));
                // Visit the closest quadrant first.
                if (i = (y >= ym) << 1 | (x >= xm)) {
                    q = quads[quads.length - 1];
                    quads[quads.length - 1] = quads[quads.length - 1 - i];
                    quads[quads.length - 1 - i] = q;
                }
            }
            // Visit this point. (Visiting coincident points isn’t necessary!)
            else {
                var dx = x - +this._x.call(null, node.data), dy = y - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
                if (d2 < radius) {
                    var d = Math.sqrt(radius = d2);
                    x0 = x - d, y0 = y - d;
                    x3 = x + d, y3 = y + d;
                    data = node.data;
                }
            }
        }
        return data;
    }

    function tree_remove (d) {
        if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d)))
            return this; // ignore invalid points
        var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x, y, xm, ym, right, bottom, i, j;
        // If the tree is empty, initialize the root as a leaf.
        if (!node)
            return this;
        // Find the leaf node for the point.
        // While descending, also retain the deepest parent with a non-removed sibling.
        if (node.length)
            while (true) {
                if (right = x >= (xm = (x0 + x1) / 2))
                    x0 = xm;
                else
                    x1 = xm;
                if (bottom = y >= (ym = (y0 + y1) / 2))
                    y0 = ym;
                else
                    y1 = ym;
                if (!(parent = node, node = node[i = bottom << 1 | right]))
                    return this;
                if (!node.length)
                    break;
                if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3])
                    retainer = parent, j = i;
            }
        // Find the point to remove.
        while (node.data !== d)
            if (!(previous = node, node = node.next))
                return this;
        if (next = node.next)
            delete node.next;
        // If there are multiple coincident points, remove just the point.
        if (previous)
            return (next ? previous.next = next : delete previous.next), this;
        // If this is the root point, remove it.
        if (!parent)
            return this._root = next, this;
        // Remove this leaf.
        next ? parent[i] = next : delete parent[i];
        // If the parent now contains exactly one leaf, collapse superfluous parents.
        if ((node = parent[0] || parent[1] || parent[2] || parent[3])
            && node === (parent[3] || parent[2] || parent[1] || parent[0])
            && !node.length) {
            if (retainer)
                retainer[j] = node;
            else
                this._root = node;
        }
        return this;
    }
    function removeAll(data) {
        for (var i = 0, n = data.length; i < n; ++i)
            this.remove(data[i]);
        return this;
    }

    function tree_root () {
        return this._root;
    }

    function tree_size () {
        var size = 0;
        this.visit(function (node) {
            if (!node.length)
                do
                    ++size;
                while (node = node.next);
        });
        return size;
    }

    function tree_visit (callback) {
        var quads = [], q, node = this._root, child, x0, y0, x1, y1;
        if (node)
            quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
        while (q = quads.pop()) {
            if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
                var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
                if (child = node[3])
                    quads.push(new Quad(child, xm, ym, x1, y1));
                if (child = node[2])
                    quads.push(new Quad(child, x0, ym, xm, y1));
                if (child = node[1])
                    quads.push(new Quad(child, xm, y0, x1, ym));
                if (child = node[0])
                    quads.push(new Quad(child, x0, y0, xm, ym));
            }
        }
        return this;
    }

    function tree_visitAfter (callback) {
        var quads = [], next = [], q;
        if (this._root)
            quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
        while (q = quads.pop()) {
            var node = q.node;
            if (node.length) {
                var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
                if (child = node[0])
                    quads.push(new Quad(child, x0, y0, xm, ym));
                if (child = node[1])
                    quads.push(new Quad(child, xm, y0, x1, ym));
                if (child = node[2])
                    quads.push(new Quad(child, x0, ym, xm, y1));
                if (child = node[3])
                    quads.push(new Quad(child, xm, ym, x1, y1));
            }
            next.push(q);
        }
        while (q = next.pop()) {
            callback(q.node, q.x0, q.y0, q.x1, q.y1);
        }
        return this;
    }

    function defaultX(d) {
        return d[0];
    }
    function tree_x (_) {
        return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
        return d[1];
    }
    function tree_y (_) {
        return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
        var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
        return nodes == null ? tree : tree.addAll(nodes);
    }
    function Quadtree(x, y, x0, y0, x1, y1) {
        this._x = x;
        this._y = y;
        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        this._root = undefined;
    }
    function leaf_copy(leaf) {
        var copy = { data: leaf.data }, next = copy;
        while (leaf = leaf.next)
            next = next.next = { data: leaf.data };
        return copy;
    }
    var treeProto = quadtree.prototype = Quadtree.prototype;
    treeProto.copy = function () {
        var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
        if (!node)
            return copy;
        if (!node.length)
            return copy._root = leaf_copy(node), copy;
        nodes = [{ source: node, target: copy._root = new Array(4) }];
        while (node = nodes.pop()) {
            for (var i = 0; i < 4; ++i) {
                if (child = node.source[i]) {
                    if (child.length)
                        nodes.push({ source: child, target: node.target[i] = new Array(4) });
                    else
                        node.target[i] = leaf_copy(child);
                }
            }
        }
        return copy;
    };
    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function x$2(d) {
        return d.x + d.vx;
    }
    function y$1(d) {
        return d.y + d.vy;
    }
    function collide (radius) {
        var nodes, radii, strength = 1, iterations = 1;
        if (typeof radius !== "function")
            radius = constant$9(radius == null ? 1 : +radius);
        function force() {
            var i, n = nodes.length, tree, node, xi, yi, ri, ri2;
            for (var k = 0; k < iterations; ++k) {
                tree = quadtree(nodes, x$2, y$1).visitAfter(prepare);
                for (i = 0; i < n; ++i) {
                    node = nodes[i];
                    ri = radii[node.index], ri2 = ri * ri;
                    xi = node.x + node.vx;
                    yi = node.y + node.vy;
                    tree.visit(apply);
                }
            }
            function apply(quad, x0, y0, x1, y1) {
                var data = quad.data, rj = quad.r, r = ri + rj;
                if (data) {
                    if (data.index > node.index) {
                        var x = xi - data.x - data.vx, y = yi - data.y - data.vy, l = x * x + y * y;
                        if (l < r * r) {
                            if (x === 0)
                                x = jiggle(), l += x * x;
                            if (y === 0)
                                y = jiggle(), l += y * y;
                            l = (r - (l = Math.sqrt(l))) / l * strength;
                            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                            node.vy += (y *= l) * r;
                            data.vx -= x * (r = 1 - r);
                            data.vy -= y * r;
                        }
                    }
                    return;
                }
                return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
            }
        }
        function prepare(quad) {
            if (quad.data)
                return quad.r = radii[quad.data.index];
            for (var i = quad.r = 0; i < 4; ++i) {
                if (quad[i] && quad[i].r > quad.r) {
                    quad.r = quad[i].r;
                }
            }
        }
        function initialize() {
            if (!nodes)
                return;
            var i, n = nodes.length, node;
            radii = new Array(n);
            for (i = 0; i < n; ++i)
                node = nodes[i], radii[node.index] = +radius(node, i, nodes);
        }
        force.initialize = function (_) {
            nodes = _;
            initialize();
        };
        force.iterations = function (_) {
            return arguments.length ? (iterations = +_, force) : iterations;
        };
        force.strength = function (_) {
            return arguments.length ? (strength = +_, force) : strength;
        };
        force.radius = function (_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : radius;
        };
        return force;
    }

    function index(d) {
        return d.index;
    }
    function find(nodeById, nodeId) {
        var node = nodeById.get(nodeId);
        if (!node)
            throw new Error("missing: " + nodeId);
        return node;
    }
    function link$1 (links) {
        var id = index, strength = defaultStrength, strengths, distance = constant$9(30), distances, nodes, count, bias, iterations = 1;
        if (links == null)
            links = [];
        function defaultStrength(link) {
            return 1 / Math.min(count[link.source.index], count[link.target.index]);
        }
        function force(alpha) {
            for (var k = 0, n = links.length; k < iterations; ++k) {
                for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
                    link = links[i], source = link.source, target = link.target;
                    x = target.x + target.vx - source.x - source.vx || jiggle();
                    y = target.y + target.vy - source.y - source.vy || jiggle();
                    l = Math.sqrt(x * x + y * y);
                    l = (l - distances[i]) / l * alpha * strengths[i];
                    x *= l, y *= l;
                    target.vx -= x * (b = bias[i]);
                    target.vy -= y * b;
                    source.vx += x * (b = 1 - b);
                    source.vy += y * b;
                }
            }
        }
        function initialize() {
            if (!nodes)
                return;
            var i, n = nodes.length, m = links.length, nodeById = map(nodes, id), link;
            for (i = 0, count = new Array(n); i < m; ++i) {
                link = links[i], link.index = i;
                if (typeof link.source !== "object")
                    link.source = find(nodeById, link.source);
                if (typeof link.target !== "object")
                    link.target = find(nodeById, link.target);
                count[link.source.index] = (count[link.source.index] || 0) + 1;
                count[link.target.index] = (count[link.target.index] || 0) + 1;
            }
            for (i = 0, bias = new Array(m); i < m; ++i) {
                link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
            }
            strengths = new Array(m), initializeStrength();
            distances = new Array(m), initializeDistance();
        }
        function initializeStrength() {
            if (!nodes)
                return;
            for (var i = 0, n = links.length; i < n; ++i) {
                strengths[i] = +strength(links[i], i, links);
            }
        }
        function initializeDistance() {
            if (!nodes)
                return;
            for (var i = 0, n = links.length; i < n; ++i) {
                distances[i] = +distance(links[i], i, links);
            }
        }
        force.initialize = function (_) {
            nodes = _;
            initialize();
        };
        force.links = function (_) {
            return arguments.length ? (links = _, initialize(), force) : links;
        };
        force.id = function (_) {
            return arguments.length ? (id = _, force) : id;
        };
        force.iterations = function (_) {
            return arguments.length ? (iterations = +_, force) : iterations;
        };
        force.strength = function (_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant$9(+_), initializeStrength(), force) : strength;
        };
        force.distance = function (_) {
            return arguments.length ? (distance = typeof _ === "function" ? _ : constant$9(+_), initializeDistance(), force) : distance;
        };
        return force;
    }

    function x$3(d) {
        return d.x;
    }
    function y$2(d) {
        return d.y;
    }
    var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
    function simulation (nodes) {
        var simulation, alpha = 1, alphaMin = 0.001, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = map(), stepper = timer(step), event = dispatch("tick", "end");
        if (nodes == null)
            nodes = [];
        function step() {
            tick();
            event.call("tick", simulation);
            if (alpha < alphaMin) {
                stepper.stop();
                event.call("end", simulation);
            }
        }
        function tick() {
            var i, n = nodes.length, node;
            alpha += (alphaTarget - alpha) * alphaDecay;
            forces.each(function (force) {
                force(alpha);
            });
            for (i = 0; i < n; ++i) {
                node = nodes[i];
                if (node.fx == null)
                    node.x += node.vx *= velocityDecay;
                else
                    node.x = node.fx, node.vx = 0;
                if (node.fy == null)
                    node.y += node.vy *= velocityDecay;
                else
                    node.y = node.fy, node.vy = 0;
            }
        }
        function initializeNodes() {
            for (var i = 0, n = nodes.length, node; i < n; ++i) {
                node = nodes[i], node.index = i;
                if (isNaN(node.x) || isNaN(node.y)) {
                    var radius = initialRadius * Math.sqrt(i), angle = i * initialAngle;
                    node.x = radius * Math.cos(angle);
                    node.y = radius * Math.sin(angle);
                }
                if (isNaN(node.vx) || isNaN(node.vy)) {
                    node.vx = node.vy = 0;
                }
            }
        }
        function initializeForce(force) {
            if (force.initialize)
                force.initialize(nodes);
            return force;
        }
        initializeNodes();
        return simulation = {
            tick: tick,
            restart: function () {
                return stepper.restart(step), simulation;
            },
            stop: function () {
                return stepper.stop(), simulation;
            },
            nodes: function (_) {
                return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
            },
            alpha: function (_) {
                return arguments.length ? (alpha = +_, simulation) : alpha;
            },
            alphaMin: function (_) {
                return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
            },
            alphaDecay: function (_) {
                return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
            },
            alphaTarget: function (_) {
                return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
            },
            velocityDecay: function (_) {
                return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
            },
            force: function (name, _) {
                return arguments.length > 1 ? ((_ == null ? forces.remove(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
            },
            find: function (x, y, radius) {
                var i = 0, n = nodes.length, dx, dy, d2, node, closest;
                if (radius == null)
                    radius = Infinity;
                else
                    radius *= radius;
                for (i = 0; i < n; ++i) {
                    node = nodes[i];
                    dx = x - node.x;
                    dy = y - node.y;
                    d2 = dx * dx + dy * dy;
                    if (d2 < radius)
                        closest = node, radius = d2;
                }
                return closest;
            },
            on: function (name, _) {
                return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
            }
        };
    }

    function manyBody () {
        var nodes, node, alpha, strength = constant$9(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
        function force(_) {
            var i, n = nodes.length, tree = quadtree(nodes, x$3, y$2).visitAfter(accumulate);
            for (alpha = _, i = 0; i < n; ++i)
                node = nodes[i], tree.visit(apply);
        }
        function initialize() {
            if (!nodes)
                return;
            var i, n = nodes.length, node;
            strengths = new Array(n);
            for (i = 0; i < n; ++i)
                node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
        }
        function accumulate(quad) {
            var strength = 0, q, c, weight = 0, x, y, i;
            // For internal nodes, accumulate forces from child quadrants.
            if (quad.length) {
                for (x = y = i = 0; i < 4; ++i) {
                    if ((q = quad[i]) && (c = Math.abs(q.value))) {
                        strength += q.value, weight += c, x += c * q.x, y += c * q.y;
                    }
                }
                quad.x = x / weight;
                quad.y = y / weight;
            }
            // For leaf nodes, accumulate forces from coincident quadrants.
            else {
                q = quad;
                q.x = q.data.x;
                q.y = q.data.y;
                do
                    strength += strengths[q.data.index];
                while (q = q.next);
            }
            quad.value = strength;
        }
        function apply(quad, x1, _, x2) {
            if (!quad.value)
                return true;
            var x = quad.x - node.x, y = quad.y - node.y, w = x2 - x1, l = x * x + y * y;
            // Apply the Barnes-Hut approximation if possible.
            // Limit forces for very close nodes; randomize direction if coincident.
            if (w * w / theta2 < l) {
                if (l < distanceMax2) {
                    if (x === 0)
                        x = jiggle(), l += x * x;
                    if (y === 0)
                        y = jiggle(), l += y * y;
                    if (l < distanceMin2)
                        l = Math.sqrt(distanceMin2 * l);
                    node.vx += x * quad.value * alpha / l;
                    node.vy += y * quad.value * alpha / l;
                }
                return true;
            }
            // Otherwise, process points directly.
            else if (quad.length || l >= distanceMax2)
                return;
            // Limit forces for very close nodes; randomize direction if coincident.
            if (quad.data !== node || quad.next) {
                if (x === 0)
                    x = jiggle(), l += x * x;
                if (y === 0)
                    y = jiggle(), l += y * y;
                if (l < distanceMin2)
                    l = Math.sqrt(distanceMin2 * l);
            }
            do
                if (quad.data !== node) {
                    w = strengths[quad.data.index] * alpha / l;
                    node.vx += x * w;
                    node.vy += y * w;
                }
            while (quad = quad.next);
        }
        force.initialize = function (_) {
            nodes = _;
            initialize();
        };
        force.strength = function (_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : strength;
        };
        force.distanceMin = function (_) {
            return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
        };
        force.distanceMax = function (_) {
            return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
        };
        force.theta = function (_) {
            return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
        };
        return force;
    }

    function radial (radius, x, y) {
        var nodes, strength = constant$9(0.1), strengths, radiuses;
        if (typeof radius !== "function")
            radius = constant$9(+radius);
        if (x == null)
            x = 0;
        if (y == null)
            y = 0;
        function force(alpha) {
            for (var i = 0, n = nodes.length; i < n; ++i) {
                var node = nodes[i], dx = node.x - x || 1e-6, dy = node.y - y || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k = (radiuses[i] - r) * strengths[i] * alpha / r;
                node.vx += dx * k;
                node.vy += dy * k;
            }
        }
        function initialize() {
            if (!nodes)
                return;
            var i, n = nodes.length;
            strengths = new Array(n);
            radiuses = new Array(n);
            for (i = 0; i < n; ++i) {
                radiuses[i] = +radius(nodes[i], i, nodes);
                strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
            }
        }
        force.initialize = function (_) {
            nodes = _, initialize();
        };
        force.strength = function (_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : strength;
        };
        force.radius = function (_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : radius;
        };
        force.x = function (_) {
            return arguments.length ? (x = +_, force) : x;
        };
        force.y = function (_) {
            return arguments.length ? (y = +_, force) : y;
        };
        return force;
    }

    function x$4 (x) {
        var strength = constant$9(0.1), nodes, strengths, xz;
        if (typeof x !== "function")
            x = constant$9(x == null ? 0 : +x);
        function force(alpha) {
            for (var i = 0, n = nodes.length, node; i < n; ++i) {
                node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
            }
        }
        function initialize() {
            if (!nodes)
                return;
            var i, n = nodes.length;
            strengths = new Array(n);
            xz = new Array(n);
            for (i = 0; i < n; ++i) {
                strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
            }
        }
        force.initialize = function (_) {
            nodes = _;
            initialize();
        };
        force.strength = function (_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : strength;
        };
        force.x = function (_) {
            return arguments.length ? (x = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : x;
        };
        return force;
    }

    function y$3 (y) {
        var strength = constant$9(0.1), nodes, strengths, yz;
        if (typeof y !== "function")
            y = constant$9(y == null ? 0 : +y);
        function force(alpha) {
            for (var i = 0, n = nodes.length, node; i < n; ++i) {
                node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
            }
        }
        function initialize() {
            if (!nodes)
                return;
            var i, n = nodes.length;
            strengths = new Array(n);
            yz = new Array(n);
            for (i = 0; i < n; ++i) {
                strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
            }
        }
        force.initialize = function (_) {
            nodes = _;
            initialize();
        };
        force.strength = function (_) {
            return arguments.length ? (strength = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : strength;
        };
        force.y = function (_) {
            return arguments.length ? (y = typeof _ === "function" ? _ : constant$9(+_), initialize(), force) : y;
        };
        return force;
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimal(1.23) returns ["123", 0].
    function formatDecimal$1 (x, p) {
        if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
            return null; // NaN, ±Infinity
        var i, coefficient = x.slice(0, i);
        // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
        // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
        return [
            coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
            +x.slice(i + 1)
        ];
    }

    function exponent$2 (x) {
        return x = formatDecimal$1(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup$1 (grouping, thousands) {
        return function (value, width) {
            var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
            while (i > 0 && g > 0) {
                if (length + g + 1 > width)
                    g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width)
                    break;
                g = grouping[j = (j + 1) % grouping.length];
            }
            return t.reverse().join(thousands);
        };
    }

    function formatNumerals$1 (numerals) {
        return function (value) {
            return value.replace(/[0-9]/g, function (i) {
                return numerals[+i];
            });
        };
    }

    function formatDefault (x, p) {
        x = x.toPrecision(p);
        out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
            switch (x[i]) {
                case ".":
                    i0 = i1 = i;
                    break;
                case "0":
                    if (i0 === 0)
                        i0 = i;
                    i1 = i;
                    break;
                case "e": break out;
                default:
                    if (i0 > 0)
                        i0 = 0;
                    break;
            }
        }
        return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
    }

    var prefixExponent$1;
    function formatPrefixAuto$1 (x, p) {
        var d = formatDecimal$1(x, p);
        if (!d)
            return x + "";
        var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent$1 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
        return i === n ? coefficient
            : i > n ? coefficient + new Array(i - n + 1).join("0")
                : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
                    : "0." + new Array(1 - i).join("0") + formatDecimal$1(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded$1 (x, p) {
        var d = formatDecimal$1(x, p);
        if (!d)
            return x + "";
        var coefficient = d[0], exponent = d[1];
        return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
            : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
                : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes$1 = {
        "": formatDefault,
        "%": function (x, p) { return (x * 100).toFixed(p); },
        "b": function (x) { return Math.round(x).toString(2); },
        "c": function (x) { return x + ""; },
        "d": function (x) { return Math.round(x).toString(10); },
        "e": function (x, p) { return x.toExponential(p); },
        "f": function (x, p) { return x.toFixed(p); },
        "g": function (x, p) { return x.toPrecision(p); },
        "o": function (x) { return Math.round(x).toString(8); },
        "p": function (x, p) { return formatRounded$1(x * 100, p); },
        "r": formatRounded$1,
        "s": formatPrefixAuto$1,
        "X": function (x) { return Math.round(x).toString(16).toUpperCase(); },
        "x": function (x) { return Math.round(x).toString(16); }
    };

    // [[fill]align][sign][symbol][0][width][,][.precision][type]
    var re$1 = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;
    function formatSpecifier$1(specifier) {
        return new FormatSpecifier$1(specifier);
    }
    formatSpecifier$1.prototype = FormatSpecifier$1.prototype; // instanceof
    function FormatSpecifier$1(specifier) {
        if (!(match = re$1.exec(specifier)))
            throw new Error("invalid format: " + specifier);
        var match, fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zero = !!match[5], width = match[6] && +match[6], comma = !!match[7], precision = match[8] && +match[8].slice(1), type = match[9] || "";
        // The "n" type is an alias for ",g".
        if (type === "n")
            comma = true, type = "g";
        // Map invalid types to the default format.
        else if (!formatTypes$1[type])
            type = "";
        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "="))
            zero = true, fill = "0", align = "=";
        this.fill = fill;
        this.align = align;
        this.sign = sign;
        this.symbol = symbol;
        this.zero = zero;
        this.width = width;
        this.comma = comma;
        this.precision = precision;
        this.type = type;
    }
    FormatSpecifier$1.prototype.toString = function () {
        return this.fill
            + this.align
            + this.sign
            + this.symbol
            + (this.zero ? "0" : "")
            + (this.width == null ? "" : Math.max(1, this.width | 0))
            + (this.comma ? "," : "")
            + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
            + this.type;
    };

    function identity$7 (x) {
        return x;
    }

    var prefixes$1 = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale$2 (locale) {
        var group = locale.grouping && locale.thousands ? formatGroup$1(locale.grouping, locale.thousands) : identity$7, currency = locale.currency, decimal = locale.decimal, numerals = locale.numerals ? formatNumerals$1(locale.numerals) : identity$7, percent = locale.percent || "%";
        function newFormat(specifier) {
            specifier = formatSpecifier$1(specifier);
            var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, type = specifier.type;
            // Compute the prefix and suffix.
            // For SI-prefix, the suffix is lazily computed.
            var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : "";
            // What format function should we use?
            // Is this an integer type?
            // Can this type generate exponential notation?
            var formatType = formatTypes$1[type], maybeSuffix = !type || /[defgprs%]/.test(type);
            // Set the default precision if not specified,
            // or clamp the specified precision to the supported range.
            // For significant precision, it must be in [1, 21].
            // For fixed precision, it must be in [0, 20].
            precision = precision == null ? (type ? 6 : 12)
                : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
                    : Math.max(0, Math.min(20, precision));
            function format(value) {
                var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
                if (type === "c") {
                    valueSuffix = formatType(value) + valueSuffix;
                    value = "";
                }
                else {
                    value = +value;
                    // Perform the initial formatting.
                    var valueNegative = value < 0;
                    value = formatType(Math.abs(value), precision);
                    // If a negative value rounds to zero during formatting, treat as positive.
                    if (valueNegative && +value === 0)
                        valueNegative = false;
                    // Compute the prefix and suffix.
                    valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                    valueSuffix = (type === "s" ? prefixes$1[8 + prefixExponent$1 / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                    // Break the formatted value into the integer “value” part that can be
                    // grouped, and fractional or exponential “suffix” part that is not.
                    if (maybeSuffix) {
                        i = -1, n = value.length;
                        while (++i < n) {
                            if (c = value.charCodeAt(i), 48 > c || c > 57) {
                                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                                value = value.slice(0, i);
                                break;
                            }
                        }
                    }
                }
                // If the fill character is not "0", grouping is applied before padding.
                if (comma && !zero)
                    value = group(value, Infinity);
                // Compute the padding.
                var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
                // If the fill character is "0", grouping is applied after padding.
                if (comma && zero)
                    value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
                // Reconstruct the final output based on the desired alignment.
                switch (align) {
                    case "<":
                        value = valuePrefix + value + valueSuffix + padding;
                        break;
                    case "=":
                        value = valuePrefix + padding + value + valueSuffix;
                        break;
                    case "^":
                        value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                        break;
                    default:
                        value = padding + valuePrefix + value + valueSuffix;
                        break;
                }
                return numerals(value);
            }
            format.toString = function () {
                return specifier + "";
            };
            return format;
        }
        function formatPrefix(specifier, value) {
            var f = newFormat((specifier = formatSpecifier$1(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent$2(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes$1[8 + e / 3];
            return function (value) {
                return f(k * value) + prefix;
            };
        }
        return {
            format: newFormat,
            formatPrefix: formatPrefix
        };
    }

    var locale$2;
    var format$1;
    var formatPrefix$1;
    defaultLocale$2({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""]
    });
    function defaultLocale$2(definition) {
        locale$2 = formatLocale$2(definition);
        format$1 = locale$2.format;
        formatPrefix$1 = locale$2.formatPrefix;
        return locale$2;
    }

    function precisionFixed$1 (step) {
        return Math.max(0, -exponent$2(Math.abs(step)));
    }

    function precisionPrefix$1 (step, value) {
        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$2(value) / 3))) * 3 - exponent$2(Math.abs(step)));
    }

    function precisionRound$1 (step, max) {
        step = Math.abs(step), max = Math.abs(max) - step;
        return Math.max(0, exponent$2(max) - exponent$2(step)) + 1;
    }

    // Adds floating point numbers with twice the normal precision.
    // Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
    // Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
    // 305–363 (1997).
    // Code adapted from GeographicLib by Charles F. F. Karney,
    // http://geographiclib.sourceforge.net/
    function adder () {
        return new Adder;
    }
    function Adder() {
        this.reset();
    }
    Adder.prototype = {
        constructor: Adder,
        reset: function () {
            this.s = // rounded value
                this.t = 0; // exact error
        },
        add: function (y) {
            add$1(temp$1, y, this.t);
            add$1(this, temp$1.s, this.s);
            if (this.s)
                this.t += temp$1.t;
            else
                this.s = temp$1.t;
        },
        valueOf: function () {
            return this.s;
        }
    };
    var temp$1 = new Adder;
    function add$1(adder, a, b) {
        var x = adder.s = a + b, bv = x - a, av = x - bv;
        adder.t = (a - av) + (b - bv);
    }

    var epsilon$4 = 1e-6;
    var epsilon2$1 = 1e-12;
    var pi$4 = Math.PI;
    var halfPi$2 = pi$4 / 2;
    var quarterPi = pi$4 / 4;
    var tau$4 = pi$4 * 2;
    var degrees$1 = 180 / pi$4;
    var radians = pi$4 / 180;
    var abs = Math.abs;
    var atan = Math.atan;
    var atan2 = Math.atan2;
    var cos$1 = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var log = Math.log;
    var pow$1 = Math.pow;
    var sin$1 = Math.sin;
    var sign$1 = Math.sign || function (x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$1 = Math.sqrt;
    var tan = Math.tan;
    function acos(x) {
        return x > 1 ? 0 : x < -1 ? pi$4 : Math.acos(x);
    }
    function asin(x) {
        return x > 1 ? halfPi$2 : x < -1 ? -halfPi$2 : Math.asin(x);
    }
    function haversin(x) {
        return (x = sin$1(x / 2)) * x;
    }

    function noop$3() { }

    function streamGeometry(geometry, stream) {
        if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
            streamGeometryType[geometry.type](geometry, stream);
        }
    }
    var streamObjectType = {
        Feature: function (object, stream) {
            streamGeometry(object.geometry, stream);
        },
        FeatureCollection: function (object, stream) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n)
                streamGeometry(features[i].geometry, stream);
        }
    };
    var streamGeometryType = {
        Sphere: function (object, stream) {
            stream.sphere();
        },
        Point: function (object, stream) {
            object = object.coordinates;
            stream.point(object[0], object[1], object[2]);
        },
        MultiPoint: function (object, stream) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                object = coordinates[i], stream.point(object[0], object[1], object[2]);
        },
        LineString: function (object, stream) {
            streamLine(object.coordinates, stream, 0);
        },
        MultiLineString: function (object, stream) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                streamLine(coordinates[i], stream, 0);
        },
        Polygon: function (object, stream) {
            streamPolygon(object.coordinates, stream);
        },
        MultiPolygon: function (object, stream) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                streamPolygon(coordinates[i], stream);
        },
        GeometryCollection: function (object, stream) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n)
                streamGeometry(geometries[i], stream);
        }
    };
    function streamLine(coordinates, stream, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        stream.lineStart();
        while (++i < n)
            coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
        stream.lineEnd();
    }
    function streamPolygon(coordinates, stream) {
        var i = -1, n = coordinates.length;
        stream.polygonStart();
        while (++i < n)
            streamLine(coordinates[i], stream, 1);
        stream.polygonEnd();
    }
    function geoStream (object, stream) {
        if (object && streamObjectType.hasOwnProperty(object.type)) {
            streamObjectType[object.type](object, stream);
        }
        else {
            streamGeometry(object, stream);
        }
    }

    var areaRingSum = adder();
    var areaSum = adder(), lambda00, phi00, lambda0, cosPhi0, sinPhi0;
    var areaStream = {
        point: noop$3,
        lineStart: noop$3,
        lineEnd: noop$3,
        polygonStart: function () {
            areaRingSum.reset();
            areaStream.lineStart = areaRingStart;
            areaStream.lineEnd = areaRingEnd;
        },
        polygonEnd: function () {
            var areaRing = +areaRingSum;
            areaSum.add(areaRing < 0 ? tau$4 + areaRing : areaRing);
            this.lineStart = this.lineEnd = this.point = noop$3;
        },
        sphere: function () {
            areaSum.add(tau$4);
        }
    };
    function areaRingStart() {
        areaStream.point = areaPointFirst;
    }
    function areaRingEnd() {
        areaPoint(lambda00, phi00);
    }
    function areaPointFirst(lambda, phi) {
        areaStream.point = areaPoint;
        lambda00 = lambda, phi00 = phi;
        lambda *= radians, phi *= radians;
        lambda0 = lambda, cosPhi0 = cos$1(phi = phi / 2 + quarterPi), sinPhi0 = sin$1(phi);
    }
    function areaPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        phi = phi / 2 + quarterPi; // half the angular distance from south pole
        // Spherical excess E for a spherical triangle with vertices: south pole,
        // previous point, current point.  Uses a formula derived from Cagnoli’s
        // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
        var dLambda = lambda - lambda0, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos$1(phi), sinPhi = sin$1(phi), k = sinPhi0 * sinPhi, u = cosPhi0 * cosPhi + k * cos$1(adLambda), v = k * sdLambda * sin$1(adLambda);
        areaRingSum.add(atan2(v, u));
        // Advance the previous points.
        lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
    }
    function area (object) {
        areaSum.reset();
        geoStream(object, areaStream);
        return areaSum * 2;
    }

    function spherical(cartesian) {
        return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];
    }
    function cartesian(spherical) {
        var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
        return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }
    function cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }
    // TODO return a
    function cartesianAddInPlace(a, b) {
        a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }
    function cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
    }
    // TODO return d
    function cartesianNormalizeInPlace(d) {
        var l = sqrt$1(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
    lambda2, // previous lambda-coordinate
    lambda00$1, phi00$1, // first point
    p0, // previous 3D point
    deltaSum = adder(), ranges, range$2;
    var boundsStream = {
        point: boundsPoint,
        lineStart: boundsLineStart,
        lineEnd: boundsLineEnd,
        polygonStart: function () {
            boundsStream.point = boundsRingPoint;
            boundsStream.lineStart = boundsRingStart;
            boundsStream.lineEnd = boundsRingEnd;
            deltaSum.reset();
            areaStream.polygonStart();
        },
        polygonEnd: function () {
            areaStream.polygonEnd();
            boundsStream.point = boundsPoint;
            boundsStream.lineStart = boundsLineStart;
            boundsStream.lineEnd = boundsLineEnd;
            if (areaRingSum < 0)
                lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
            else if (deltaSum > epsilon$4)
                phi1 = 90;
            else if (deltaSum < -epsilon$4)
                phi0 = -90;
            range$2[0] = lambda0$1, range$2[1] = lambda1;
        }
    };
    function boundsPoint(lambda, phi) {
        ranges.push(range$2 = [lambda0$1 = lambda, lambda1 = lambda]);
        if (phi < phi0)
            phi0 = phi;
        if (phi > phi1)
            phi1 = phi;
    }
    function linePoint(lambda, phi) {
        var p = cartesian([lambda * radians, phi * radians]);
        if (p0) {
            var normal = cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = cartesianCross(equatorial, normal);
            cartesianNormalizeInPlace(inflection);
            inflection = spherical(inflection);
            var delta = lambda - lambda2, sign = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees$1 * sign, phii, antimeridian = abs(delta) > 180;
            if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
                phii = inflection[1] * degrees$1;
                if (phii > phi1)
                    phi1 = phii;
            }
            else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
                phii = -inflection[1] * degrees$1;
                if (phii < phi0)
                    phi0 = phii;
            }
            else {
                if (phi < phi0)
                    phi0 = phi;
                if (phi > phi1)
                    phi1 = phi;
            }
            if (antimeridian) {
                if (lambda < lambda2) {
                    if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                        lambda1 = lambda;
                }
                else {
                    if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                        lambda0$1 = lambda;
                }
            }
            else {
                if (lambda1 >= lambda0$1) {
                    if (lambda < lambda0$1)
                        lambda0$1 = lambda;
                    if (lambda > lambda1)
                        lambda1 = lambda;
                }
                else {
                    if (lambda > lambda2) {
                        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
                            lambda1 = lambda;
                    }
                    else {
                        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
                            lambda0$1 = lambda;
                    }
                }
            }
        }
        else {
            ranges.push(range$2 = [lambda0$1 = lambda, lambda1 = lambda]);
        }
        if (phi < phi0)
            phi0 = phi;
        if (phi > phi1)
            phi1 = phi;
        p0 = p, lambda2 = lambda;
    }
    function boundsLineStart() {
        boundsStream.point = linePoint;
    }
    function boundsLineEnd() {
        range$2[0] = lambda0$1, range$2[1] = lambda1;
        boundsStream.point = boundsPoint;
        p0 = null;
    }
    function boundsRingPoint(lambda, phi) {
        if (p0) {
            var delta = lambda - lambda2;
            deltaSum.add(abs(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
        }
        else {
            lambda00$1 = lambda, phi00$1 = phi;
        }
        areaStream.point(lambda, phi);
        linePoint(lambda, phi);
    }
    function boundsRingStart() {
        areaStream.lineStart();
    }
    function boundsRingEnd() {
        boundsRingPoint(lambda00$1, phi00$1);
        areaStream.lineEnd();
        if (abs(deltaSum) > epsilon$4)
            lambda0$1 = -(lambda1 = 180);
        range$2[0] = lambda0$1, range$2[1] = lambda1;
        p0 = null;
    }
    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
    // the distance between ±180° to be 360°.
    function angle(lambda0, lambda1) {
        return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }
    function rangeCompare(a, b) {
        return a[0] - b[0];
    }
    function rangeContains(range, x) {
        return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    function bounds (feature) {
        var i, n, a, b, merged, deltaMax, delta;
        phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
        ranges = [];
        geoStream(feature, boundsStream);
        // First, sort ranges by their minimum longitudes.
        if (n = ranges.length) {
            ranges.sort(rangeCompare);
            // Then, merge any ranges that overlap.
            for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
                b = ranges[i];
                if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
                    if (angle(a[0], b[1]) > angle(a[0], a[1]))
                        a[1] = b[1];
                    if (angle(b[0], a[1]) > angle(a[0], a[1]))
                        a[0] = b[0];
                }
                else {
                    merged.push(a = b);
                }
            }
            // Finally, find the largest gap between the merged ranges.
            // The final bounding box will be the inverse of this gap.
            for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
                b = merged[i];
                if ((delta = angle(a[1], b[0])) > deltaMax)
                    deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
            }
        }
        ranges = range$2 = null;
        return lambda0$1 === Infinity || phi0 === Infinity
            ? [[NaN, NaN], [NaN, NaN]]
            : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00$2, phi00$2, // first point
    x0, y0, z0; // previous point
    var centroidStream = {
        sphere: noop$3,
        point: centroidPoint,
        lineStart: centroidLineStart,
        lineEnd: centroidLineEnd,
        polygonStart: function () {
            centroidStream.lineStart = centroidRingStart;
            centroidStream.lineEnd = centroidRingEnd;
        },
        polygonEnd: function () {
            centroidStream.lineStart = centroidLineStart;
            centroidStream.lineEnd = centroidLineEnd;
        }
    };
    // Arithmetic mean of Cartesian vectors.
    function centroidPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos$1(phi);
        centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
    }
    function centroidPointCartesian(x, y, z) {
        ++W0;
        X0 += (x - X0) / W0;
        Y0 += (y - Y0) / W0;
        Z0 += (z - Z0) / W0;
    }
    function centroidLineStart() {
        centroidStream.point = centroidLinePointFirst;
    }
    function centroidLinePointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos$1(phi);
        x0 = cosPhi * cos$1(lambda);
        y0 = cosPhi * sin$1(lambda);
        z0 = sin$1(phi);
        centroidStream.point = centroidLinePoint;
        centroidPointCartesian(x0, y0, z0);
    }
    function centroidLinePoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos$1(phi), x = cosPhi * cos$1(lambda), y = cosPhi * sin$1(lambda), z = sin$1(phi), w = atan2(sqrt$1((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
        W1 += w;
        X1 += w * (x0 + (x0 = x));
        Y1 += w * (y0 + (y0 = y));
        Z1 += w * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
    }
    function centroidLineEnd() {
        centroidStream.point = centroidPoint;
    }
    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart() {
        centroidStream.point = centroidRingPointFirst;
    }
    function centroidRingEnd() {
        centroidRingPoint(lambda00$2, phi00$2);
        centroidStream.point = centroidPoint;
    }
    function centroidRingPointFirst(lambda, phi) {
        lambda00$2 = lambda, phi00$2 = phi;
        lambda *= radians, phi *= radians;
        centroidStream.point = centroidRingPoint;
        var cosPhi = cos$1(phi);
        x0 = cosPhi * cos$1(lambda);
        y0 = cosPhi * sin$1(lambda);
        z0 = sin$1(phi);
        centroidPointCartesian(x0, y0, z0);
    }
    function centroidRingPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var cosPhi = cos$1(phi), x = cosPhi * cos$1(lambda), y = cosPhi * sin$1(lambda), z = sin$1(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = sqrt$1(cx * cx + cy * cy + cz * cz), w = asin(m), // line weight = angle
        v = m && -w / m; // area weight multiplier
        X2 += v * cx;
        Y2 += v * cy;
        Z2 += v * cz;
        W1 += w;
        X1 += w * (x0 + (x0 = x));
        Y1 += w * (y0 + (y0 = y));
        Z1 += w * (z0 + (z0 = z));
        centroidPointCartesian(x0, y0, z0);
    }
    function centroid (object) {
        W0 = W1 =
            X0 = Y0 = Z0 =
                X1 = Y1 = Z1 =
                    X2 = Y2 = Z2 = 0;
        geoStream(object, centroidStream);
        var x = X2, y = Y2, z = Z2, m = x * x + y * y + z * z;
        // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
        if (m < epsilon2$1) {
            x = X1, y = Y1, z = Z1;
            // If the feature has zero length, fall back to arithmetic mean of point vectors.
            if (W1 < epsilon$4)
                x = X0, y = Y0, z = Z0;
            m = x * x + y * y + z * z;
            // If the feature still has an undefined ccentroid, then return.
            if (m < epsilon2$1)
                return [NaN, NaN];
        }
        return [atan2(y, x) * degrees$1, asin(z / sqrt$1(m)) * degrees$1];
    }

    function constant$a (x) {
        return function () {
            return x;
        };
    }

    function compose (a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
            compose.invert = function (x, y) {
                return x = b.invert(x, y), x && a.invert(x[0], x[1]);
            };
        return compose;
    }

    function rotationIdentity(lambda, phi) {
        return [lambda > pi$4 ? lambda - tau$4 : lambda < -pi$4 ? lambda + tau$4 : lambda, phi];
    }
    rotationIdentity.invert = rotationIdentity;
    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
        return (deltaLambda %= tau$4) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
            : rotationLambda(deltaLambda))
            : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
                : rotationIdentity);
    }
    function forwardRotationLambda(deltaLambda) {
        return function (lambda, phi) {
            return lambda += deltaLambda, [lambda > pi$4 ? lambda - tau$4 : lambda < -pi$4 ? lambda + tau$4 : lambda, phi];
        };
    }
    function rotationLambda(deltaLambda) {
        var rotation = forwardRotationLambda(deltaLambda);
        rotation.invert = forwardRotationLambda(-deltaLambda);
        return rotation;
    }
    function rotationPhiGamma(deltaPhi, deltaGamma) {
        var cosDeltaPhi = cos$1(deltaPhi), sinDeltaPhi = sin$1(deltaPhi), cosDeltaGamma = cos$1(deltaGamma), sinDeltaGamma = sin$1(deltaGamma);
        function rotation(lambda, phi) {
            var cosPhi = cos$1(phi), x = cos$1(lambda) * cosPhi, y = sin$1(lambda) * cosPhi, z = sin$1(phi), k = z * cosDeltaPhi + x * sinDeltaPhi;
            return [
                atan2(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
                asin(k * cosDeltaGamma + y * sinDeltaGamma)
            ];
        }
        rotation.invert = function (lambda, phi) {
            var cosPhi = cos$1(phi), x = cos$1(lambda) * cosPhi, y = sin$1(lambda) * cosPhi, z = sin$1(phi), k = z * cosDeltaGamma - y * sinDeltaGamma;
            return [
                atan2(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
                asin(k * cosDeltaPhi - x * sinDeltaPhi)
            ];
        };
        return rotation;
    }
    function rotation (rotate) {
        rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
            return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
        }
        forward.invert = function (coordinates) {
            coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
            return coordinates[0] *= degrees$1, coordinates[1] *= degrees$1, coordinates;
        };
        return forward;
    }

    // Generates a circle centered at [0°, 0°], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
        if (!delta)
            return;
        var cosRadius = cos$1(radius), sinRadius = sin$1(radius), step = direction * delta;
        if (t0 == null) {
            t0 = radius + direction * tau$4;
            t1 = radius - step / 2;
        }
        else {
            t0 = circleRadius(cosRadius, t0);
            t1 = circleRadius(cosRadius, t1);
            if (direction > 0 ? t0 < t1 : t0 > t1)
                t0 += direction * tau$4;
        }
        for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
            point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
            stream.point(point[0], point[1]);
        }
    }
    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
        point = cartesian(point), point[0] -= cosRadius;
        cartesianNormalizeInPlace(point);
        var radius = acos(-point[1]);
        return ((-point[2] < 0 ? -radius : radius) + tau$4 - epsilon$4) % tau$4;
    }
    function circle () {
        var center = constant$a([0, 0]), radius = constant$a(90), precision = constant$a(6), ring, rotate, stream = { point: point };
        function point(x, y) {
            ring.push(x = rotate(x, y));
            x[0] *= degrees$1, x[1] *= degrees$1;
        }
        function circle() {
            var c = center.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
            ring = [];
            rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
            circleStream(stream, r, p, 1);
            c = { type: "Polygon", coordinates: [ring] };
            ring = rotate = null;
            return c;
        }
        circle.center = function (_) {
            return arguments.length ? (center = typeof _ === "function" ? _ : constant$a([+_[0], +_[1]]), circle) : center;
        };
        circle.radius = function (_) {
            return arguments.length ? (radius = typeof _ === "function" ? _ : constant$a(+_), circle) : radius;
        };
        circle.precision = function (_) {
            return arguments.length ? (precision = typeof _ === "function" ? _ : constant$a(+_), circle) : precision;
        };
        return circle;
    }

    function clipBuffer () {
        var lines = [], line;
        return {
            point: function (x, y) {
                line.push([x, y]);
            },
            lineStart: function () {
                lines.push(line = []);
            },
            lineEnd: noop$3,
            rejoin: function () {
                if (lines.length > 1)
                    lines.push(lines.pop().concat(lines.shift()));
            },
            result: function () {
                var result = lines;
                lines = [];
                line = null;
                return result;
            }
        };
    }

    function pointEqual (a, b) {
        return abs(a[0] - b[0]) < epsilon$4 && abs(a[1] - b[1]) < epsilon$4;
    }

    function Intersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other; // another intersection
        this.e = entry; // is an entry?
        this.v = false; // visited
        this.n = this.p = null; // next & previous
    }
    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin (segments, compareIntersection, startInside, interpolate, stream) {
        var subject = [], clip = [], i, n;
        segments.forEach(function (segment) {
            if ((n = segment.length - 1) <= 0)
                return;
            var n, p0 = segment[0], p1 = segment[n], x;
            // If the first and last points of a segment are coincident, then treat as a
            // closed ring. TODO if all rings are closed, then the winding order of the
            // exterior ring should be checked.
            if (pointEqual(p0, p1)) {
                stream.lineStart();
                for (i = 0; i < n; ++i)
                    stream.point((p0 = segment[i])[0], p0[1]);
                stream.lineEnd();
                return;
            }
            subject.push(x = new Intersection(p0, segment, null, true));
            clip.push(x.o = new Intersection(p0, null, x, false));
            subject.push(x = new Intersection(p1, segment, null, false));
            clip.push(x.o = new Intersection(p1, null, x, true));
        });
        if (!subject.length)
            return;
        clip.sort(compareIntersection);
        link$2(subject);
        link$2(clip);
        for (i = 0, n = clip.length; i < n; ++i) {
            clip[i].e = startInside = !startInside;
        }
        var start = subject[0], points, point;
        while (1) {
            // Find first unvisited intersection.
            var current = start, isSubject = true;
            while (current.v)
                if ((current = current.n) === start)
                    return;
            points = current.z;
            stream.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (i = 0, n = points.length; i < n; ++i)
                            stream.point((point = points[i])[0], point[1]);
                    }
                    else {
                        interpolate(current.x, current.n.x, 1, stream);
                    }
                    current = current.n;
                }
                else {
                    if (isSubject) {
                        points = current.p.z;
                        for (i = points.length - 1; i >= 0; --i)
                            stream.point((point = points[i])[0], point[1]);
                    }
                    else {
                        interpolate(current.x, current.p.x, -1, stream);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);
            stream.lineEnd();
        }
    }
    function link$2(array) {
        if (!(n = array.length))
            return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }

    var sum$2 = adder();
    function polygonContains (polygon, point) {
        var lambda = point[0], phi = point[1], normal = [sin$1(lambda), -cos$1(lambda), 0], angle = 0, winding = 0;
        sum$2.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
            if (!(m = (ring = polygon[i]).length))
                continue;
            var ring, m, point0 = ring[m - 1], lambda0 = point0[0], phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin$1(phi0), cosPhi0 = cos$1(phi0);
            for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
                var point1 = ring[j], lambda1 = point1[0], phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin$1(phi1), cosPhi1 = cos$1(phi1), delta = lambda1 - lambda0, sign = delta >= 0 ? 1 : -1, absDelta = sign * delta, antimeridian = absDelta > pi$4, k = sinPhi0 * sinPhi1;
                sum$2.add(atan2(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
                angle += antimeridian ? delta + sign * tau$4 : delta;
                // Are the longitudes either side of the point’s meridian (lambda),
                // and are the latitudes smaller than the parallel (phi)?
                if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
                    var arc = cartesianCross(cartesian(point0), cartesian(point1));
                    cartesianNormalizeInPlace(arc);
                    var intersection = cartesianCross(normal, arc);
                    cartesianNormalizeInPlace(intersection);
                    var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);
                    if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ delta >= 0 ? 1 : -1;
                    }
                }
            }
        }
        // First, determine whether the South pole is inside or outside:
        //
        // It is inside if:
        // * the polygon winds around it in a clockwise direction.
        // * the polygon does not (cumulatively) wind around it, but has a negative
        //   (counter-clockwise) area.
        //
        // Second, count the (signed) number of times a segment crosses a lambda
        // from the point to the South pole.  If it is zero, then the point is the
        // same side as the South pole.
        return (angle < -epsilon$4 || angle < epsilon$4 && sum$2 < -epsilon$4) ^ (winding & 1);
    }

    function clip (pointVisible, clipLine, interpolate, start) {
        return function (sink) {
            var line = clipLine(sink), ringBuffer = clipBuffer(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function () {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = merge(segments);
                    var startInside = polygonContains(polygon, start);
                    if (segments.length) {
                        if (!polygonStarted)
                            sink.polygonStart(), polygonStarted = true;
                        clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
                    }
                    else if (startInside) {
                        if (!polygonStarted)
                            sink.polygonStart(), polygonStarted = true;
                        sink.lineStart();
                        interpolate(null, null, 1, sink);
                        sink.lineEnd();
                    }
                    if (polygonStarted)
                        sink.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function () {
                    sink.polygonStart();
                    sink.lineStart();
                    interpolate(null, null, 1, sink);
                    sink.lineEnd();
                    sink.polygonEnd();
                }
            };
            function point(lambda, phi) {
                if (pointVisible(lambda, phi))
                    sink.point(lambda, phi);
            }
            function pointLine(lambda, phi) {
                line.point(lambda, phi);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            function pointRing(lambda, phi) {
                ring.push([lambda, phi]);
                ringSink.point(lambda, phi);
            }
            function ringStart() {
                ringSink.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringSink.lineEnd();
                var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n)
                    return;
                // No intersections.
                if (clean & 1) {
                    segment = ringSegments[0];
                    if ((m = segment.length - 1) > 0) {
                        if (!polygonStarted)
                            sink.polygonStart(), polygonStarted = true;
                        sink.lineStart();
                        for (i = 0; i < m; ++i)
                            sink.point((point = segment[i])[0], point[1]);
                        sink.lineEnd();
                    }
                    return;
                }
                // Rejoin connected segments.
                // TODO reuse ringBuffer.rejoin()?
                if (n > 1 && clean & 2)
                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(validSegment));
            }
            return clip;
        };
    }
    function validSegment(segment) {
        return segment.length > 1;
    }
    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfPi$2 - epsilon$4 : halfPi$2 - a[1])
            - ((b = b.x)[0] < 0 ? b[1] - halfPi$2 - epsilon$4 : halfPi$2 - b[1]);
    }

    var clipAntimeridian = clip(function () { return true; }, clipAntimeridianLine, clipAntimeridianInterpolate, [-pi$4, -halfPi$2]);
    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
        var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean; // no intersections
        return {
            lineStart: function () {
                stream.lineStart();
                clean = 1;
            },
            point: function (lambda1, phi1) {
                var sign1 = lambda1 > 0 ? pi$4 : -pi$4, delta = abs(lambda1 - lambda0);
                if (abs(delta - pi$4) < epsilon$4) { // line crosses a pole
                    stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$2 : -halfPi$2);
                    stream.point(sign0, phi0);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi0);
                    stream.point(lambda1, phi0);
                    clean = 0;
                }
                else if (sign0 !== sign1 && delta >= pi$4) { // line crosses antimeridian
                    if (abs(lambda0 - sign0) < epsilon$4)
                        lambda0 -= sign0 * epsilon$4; // handle degeneracies
                    if (abs(lambda1 - sign1) < epsilon$4)
                        lambda1 -= sign1 * epsilon$4;
                    phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
                    stream.point(sign0, phi0);
                    stream.lineEnd();
                    stream.lineStart();
                    stream.point(sign1, phi0);
                    clean = 0;
                }
                stream.point(lambda0 = lambda1, phi0 = phi1);
                sign0 = sign1;
            },
            lineEnd: function () {
                stream.lineEnd();
                lambda0 = phi0 = NaN;
            },
            clean: function () {
                return 2 - clean; // if intersections, rejoin first and last segments
            }
        };
    }
    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
        var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
        return abs(sinLambda0Lambda1) > epsilon$4
            ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
                - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
                / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
            : (phi0 + phi1) / 2;
    }
    function clipAntimeridianInterpolate(from, to, direction, stream) {
        var phi;
        if (from == null) {
            phi = direction * halfPi$2;
            stream.point(-pi$4, phi);
            stream.point(0, phi);
            stream.point(pi$4, phi);
            stream.point(pi$4, 0);
            stream.point(pi$4, -phi);
            stream.point(0, -phi);
            stream.point(-pi$4, -phi);
            stream.point(-pi$4, 0);
            stream.point(-pi$4, phi);
        }
        else if (abs(from[0] - to[0]) > epsilon$4) {
            var lambda = from[0] < to[0] ? pi$4 : -pi$4;
            phi = direction * lambda / 2;
            stream.point(-lambda, phi);
            stream.point(0, phi);
            stream.point(lambda, phi);
        }
        else {
            stream.point(to[0], to[1]);
        }
    }

    function clipCircle (radius) {
        var cr = cos$1(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon$4; // TODO optimise for this common case
        function interpolate(from, to, direction, stream) {
            circleStream(stream, radius, delta, direction, from, to);
        }
        function visible(lambda, phi) {
            return cos$1(lambda) * cos$1(phi) > cr;
        }
        // Takes a line and cuts into visible segments. Return values used for polygon
        // clipping: 0 - there were intersections or the line was empty; 1 - no
        // intersections 2 - there were intersections, and the first and last segments
        // should be rejoined.
        function clipLine(stream) {
            var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
            return {
                lineStart: function () {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function (lambda, phi) {
                    var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius
                        ? v ? 0 : code(lambda, phi)
                        : v ? code(lambda + (lambda < 0 ? pi$4 : -pi$4), phi) : 0;
                    if (!point0 && (v00 = v0 = v))
                        stream.lineStart();
                    // Handle degeneracies.
                    // TODO ignore if not clipping polygons.
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2)) {
                            point1[0] += epsilon$4;
                            point1[1] += epsilon$4;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            // outside going in
                            stream.lineStart();
                            point2 = intersect(point1, point0);
                            stream.point(point2[0], point2[1]);
                        }
                        else {
                            // inside going out
                            point2 = intersect(point0, point1);
                            stream.point(point2[0], point2[1]);
                            stream.lineEnd();
                        }
                        point0 = point2;
                    }
                    else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        // If the codes for two points are different, or are both zero,
                        // and there this segment intersects with the small circle.
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                stream.lineStart();
                                stream.point(t[0][0], t[0][1]);
                                stream.point(t[1][0], t[1][1]);
                                stream.lineEnd();
                            }
                            else {
                                stream.point(t[1][0], t[1][1]);
                                stream.lineEnd();
                                stream.lineStart();
                                stream.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !pointEqual(point0, point1))) {
                        stream.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function () {
                    if (v0)
                        stream.lineEnd();
                    point0 = null;
                },
                // Rejoin first and last segments if there were intersections and the first
                // and last points were visible.
                clean: function () {
                    return clean | ((v00 && v0) << 1);
                }
            };
        }
        // Intersects the great circle between a and b with the clip circle.
        function intersect(a, b, two) {
            var pa = cartesian(a), pb = cartesian(b);
            // We have two planes, n1.p = d1 and n2.p = d2.
            // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).
            var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;
            // Two polar points.
            if (!determinant)
                return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c2);
            cartesianAddInPlace(A, B);
            // Solve |p(t)|^2 = 1.
            var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
            if (t2 < 0)
                return;
            var t = sqrt$1(t2), q = cartesianScale(u, (-w - t) / uu);
            cartesianAddInPlace(q, A);
            q = spherical(q);
            if (!two)
                return q;
            // Two intersection points.
            var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;
            if (lambda1 < lambda0)
                z = lambda0, lambda0 = lambda1, lambda1 = z;
            var delta = lambda1 - lambda0, polar = abs(delta - pi$4) < epsilon$4, meridian = polar || delta < epsilon$4;
            if (!polar && phi1 < phi0)
                z = phi0, phi0 = phi1, phi1 = z;
            // Check that the first point is between a and b.
            if (meridian
                ? polar
                    ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon$4 ? phi0 : phi1)
                    : phi0 <= q[1] && q[1] <= phi1
                : delta > pi$4 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
                var q1 = cartesianScale(u, (-w + t) / uu);
                cartesianAddInPlace(q1, A);
                return [q, spherical(q1)];
            }
        }
        // Generates a 4-bit vector representing the location of a point relative to
        // the small circle's bounding box.
        function code(lambda, phi) {
            var r = smallRadius ? radius : pi$4 - radius, code = 0;
            if (lambda < -r)
                code |= 1; // left
            else if (lambda > r)
                code |= 2; // right
            if (phi < -r)
                code |= 4; // below
            else if (phi > r)
                code |= 8; // above
            return code;
        }
        return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$4, radius - pi$4]);
    }

    function clipLine (a, b, x0, y0, x1, y1) {
        var ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
        r = x0 - ax;
        if (!dx && r > 0)
            return;
        r /= dx;
        if (dx < 0) {
            if (r < t0)
                return;
            if (r < t1)
                t1 = r;
        }
        else if (dx > 0) {
            if (r > t1)
                return;
            if (r > t0)
                t0 = r;
        }
        r = x1 - ax;
        if (!dx && r < 0)
            return;
        r /= dx;
        if (dx < 0) {
            if (r > t1)
                return;
            if (r > t0)
                t0 = r;
        }
        else if (dx > 0) {
            if (r < t0)
                return;
            if (r < t1)
                t1 = r;
        }
        r = y0 - ay;
        if (!dy && r > 0)
            return;
        r /= dy;
        if (dy < 0) {
            if (r < t0)
                return;
            if (r < t1)
                t1 = r;
        }
        else if (dy > 0) {
            if (r > t1)
                return;
            if (r > t0)
                t0 = r;
        }
        r = y1 - ay;
        if (!dy && r < 0)
            return;
        r /= dy;
        if (dy < 0) {
            if (r > t1)
                return;
            if (r > t0)
                t0 = r;
        }
        else if (dy > 0) {
            if (r < t0)
                return;
            if (r < t1)
                t1 = r;
        }
        if (t0 > 0)
            a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
        if (t1 < 1)
            b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
        return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;
    // TODO Use d3-polygon’s polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?
    function clipRectangle(x0, y0, x1, y1) {
        function visible(x, y) {
            return x0 <= x && x <= x1 && y0 <= y && y <= y1;
        }
        function interpolate(from, to, direction, stream) {
            var a = 0, a1 = 0;
            if (from == null
                || (a = corner(from, direction)) !== (a1 = corner(to, direction))
                || comparePoint(from, to) < 0 ^ direction > 0) {
                do
                    stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                while ((a = (a + direction + 4) % 4) !== a1);
            }
            else {
                stream.point(to[0], to[1]);
            }
        }
        function corner(p, direction) {
            return abs(p[0] - x0) < epsilon$4 ? direction > 0 ? 0 : 3
                : abs(p[0] - x1) < epsilon$4 ? direction > 0 ? 2 : 1
                    : abs(p[1] - y0) < epsilon$4 ? direction > 0 ? 1 : 0
                        : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
        }
        function compareIntersection(a, b) {
            return comparePoint(a.x, b.x);
        }
        function comparePoint(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb
                : ca === 0 ? b[1] - a[1]
                    : ca === 1 ? a[0] - b[0]
                        : ca === 2 ? a[1] - b[1]
                            : b[0] - a[0];
        }
        return function (stream) {
            var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first, clean;
            var clipStream = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: polygonStart,
                polygonEnd: polygonEnd
            };
            function point(x, y) {
                if (visible(x, y))
                    activeStream.point(x, y);
            }
            function polygonInside() {
                var winding = 0;
                for (var i = 0, n = polygon.length; i < n; ++i) {
                    for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
                        a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
                        if (a1 <= y1) {
                            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0))
                                ++winding;
                        }
                        else {
                            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0))
                                --winding;
                        }
                    }
                }
                return winding;
            }
            // Buffer geometry within a polygon and then clip it en masse.
            function polygonStart() {
                activeStream = bufferStream, segments = [], polygon = [], clean = true;
            }
            function polygonEnd() {
                var startInside = polygonInside(), cleanInside = clean && startInside, visible = (segments = merge(segments)).length;
                if (cleanInside || visible) {
                    stream.polygonStart();
                    if (cleanInside) {
                        stream.lineStart();
                        interpolate(null, null, 1, stream);
                        stream.lineEnd();
                    }
                    if (visible) {
                        clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
                    }
                    stream.polygonEnd();
                }
                activeStream = stream, segments = polygon = ring = null;
            }
            function lineStart() {
                clipStream.point = linePoint;
                if (polygon)
                    polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            // TODO rather than special-case polygons, simply handle them separately.
            // Ideally, coincident intersection points should be jittered to avoid
            // clipping issues.
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_)
                        bufferStream.rejoin();
                    segments.push(bufferStream.result());
                }
                clipStream.point = point;
                if (v_)
                    activeStream.lineEnd();
            }
            function linePoint(x, y) {
                var v = visible(x, y);
                if (polygon)
                    ring.push([x, y]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        activeStream.lineStart();
                        activeStream.point(x, y);
                    }
                }
                else {
                    if (v && v_)
                        activeStream.point(x, y);
                    else {
                        var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
                        if (clipLine(a, b, x0, y0, x1, y1)) {
                            if (!v_) {
                                activeStream.lineStart();
                                activeStream.point(a[0], a[1]);
                            }
                            activeStream.point(b[0], b[1]);
                            if (!v)
                                activeStream.lineEnd();
                            clean = false;
                        }
                        else if (v) {
                            activeStream.lineStart();
                            activeStream.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clipStream;
        };
    }

    function extent$1 () {
        var x0 = 0, y0 = 0, x1 = 960, y1 = 500, cache, cacheStream, clip;
        return clip = {
            stream: function (stream) {
                return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
            },
            extent: function (_) {
                return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
            }
        };
    }

    var lengthSum = adder(), lambda0$2, sinPhi0$1, cosPhi0$1;
    var lengthStream = {
        sphere: noop$3,
        point: noop$3,
        lineStart: lengthLineStart,
        lineEnd: noop$3,
        polygonStart: noop$3,
        polygonEnd: noop$3
    };
    function lengthLineStart() {
        lengthStream.point = lengthPointFirst;
        lengthStream.lineEnd = lengthLineEnd;
    }
    function lengthLineEnd() {
        lengthStream.point = lengthStream.lineEnd = noop$3;
    }
    function lengthPointFirst(lambda, phi) {
        lambda *= radians, phi *= radians;
        lambda0$2 = lambda, sinPhi0$1 = sin$1(phi), cosPhi0$1 = cos$1(phi);
        lengthStream.point = lengthPoint;
    }
    function lengthPoint(lambda, phi) {
        lambda *= radians, phi *= radians;
        var sinPhi = sin$1(phi), cosPhi = cos$1(phi), delta = abs(lambda - lambda0$2), cosDelta = cos$1(delta), sinDelta = sin$1(delta), x = cosPhi * sinDelta, y = cosPhi0$1 * sinPhi - sinPhi0$1 * cosPhi * cosDelta, z = sinPhi0$1 * sinPhi + cosPhi0$1 * cosPhi * cosDelta;
        lengthSum.add(atan2(sqrt$1(x * x + y * y), z));
        lambda0$2 = lambda, sinPhi0$1 = sinPhi, cosPhi0$1 = cosPhi;
    }
    function length$1 (object) {
        lengthSum.reset();
        geoStream(object, lengthStream);
        return +lengthSum;
    }

    var coordinates = [null, null], object$1 = { type: "LineString", coordinates: coordinates };
    function distance (a, b) {
        coordinates[0] = a;
        coordinates[1] = b;
        return length$1(object$1);
    }

    var containsObjectType = {
        Feature: function (object, point) {
            return containsGeometry(object.geometry, point);
        },
        FeatureCollection: function (object, point) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n)
                if (containsGeometry(features[i].geometry, point))
                    return true;
            return false;
        }
    };
    var containsGeometryType = {
        Sphere: function () {
            return true;
        },
        Point: function (object, point) {
            return containsPoint(object.coordinates, point);
        },
        MultiPoint: function (object, point) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                if (containsPoint(coordinates[i], point))
                    return true;
            return false;
        },
        LineString: function (object, point) {
            return containsLine(object.coordinates, point);
        },
        MultiLineString: function (object, point) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                if (containsLine(coordinates[i], point))
                    return true;
            return false;
        },
        Polygon: function (object, point) {
            return containsPolygon(object.coordinates, point);
        },
        MultiPolygon: function (object, point) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                if (containsPolygon(coordinates[i], point))
                    return true;
            return false;
        },
        GeometryCollection: function (object, point) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n)
                if (containsGeometry(geometries[i], point))
                    return true;
            return false;
        }
    };
    function containsGeometry(geometry, point) {
        return geometry && containsGeometryType.hasOwnProperty(geometry.type)
            ? containsGeometryType[geometry.type](geometry, point)
            : false;
    }
    function containsPoint(coordinates, point) {
        return distance(coordinates, point) === 0;
    }
    function containsLine(coordinates, point) {
        var ab = distance(coordinates[0], coordinates[1]), ao = distance(coordinates[0], point), ob = distance(point, coordinates[1]);
        return ao + ob <= ab + epsilon$4;
    }
    function containsPolygon(coordinates, point) {
        return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }
    function ringRadians(ring) {
        return ring = ring.map(pointRadians), ring.pop(), ring;
    }
    function pointRadians(point) {
        return [point[0] * radians, point[1] * radians];
    }
    function contains (object, point) {
        return (object && containsObjectType.hasOwnProperty(object.type)
            ? containsObjectType[object.type]
            : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
        var y = range(y0, y1 - epsilon$4, dy).concat(y1);
        return function (x) { return y.map(function (y) { return [x, y]; }); };
    }
    function graticuleY(x0, x1, dx) {
        var x = range(x0, x1 - epsilon$4, dx).concat(x1);
        return function (y) { return x.map(function (x) { return [x, y]; }); };
    }
    function graticule() {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return { type: "MultiLineString", coordinates: lines() };
        }
        function lines() {
            return range(ceil(X0 / DX) * DX, X1, DX).map(X)
                .concat(range(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
                .concat(range(ceil(x0 / dx) * dx, x1, dx).filter(function (x) { return abs(x % DX) > epsilon$4; }).map(x))
                .concat(range(ceil(y0 / dy) * dy, y1, dy).filter(function (y) { return abs(y % DY) > epsilon$4; }).map(y));
        }
        graticule.lines = function () {
            return lines().map(function (coordinates) { return { type: "LineString", coordinates: coordinates }; });
        };
        graticule.outline = function () {
            return {
                type: "Polygon",
                coordinates: [
                    X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))
                ]
            };
        };
        graticule.extent = function (_) {
            if (!arguments.length)
                return graticule.extentMinor();
            return graticule.extentMajor(_).extentMinor(_);
        };
        graticule.extentMajor = function (_) {
            if (!arguments.length)
                return [[X0, Y0], [X1, Y1]];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1)
                _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1)
                _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.extentMinor = function (_) {
            if (!arguments.length)
                return [[x0, y0], [x1, y1]];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1)
                _ = x0, x0 = x1, x1 = _;
            if (y0 > y1)
                _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function (_) {
            if (!arguments.length)
                return graticule.stepMinor();
            return graticule.stepMajor(_).stepMinor(_);
        };
        graticule.stepMajor = function (_) {
            if (!arguments.length)
                return [DX, DY];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.stepMinor = function (_) {
            if (!arguments.length)
                return [dx, dy];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function (_) {
            if (!arguments.length)
                return precision;
            precision = +_;
            x = graticuleX(y0, y1, 90);
            y = graticuleY(x0, x1, precision);
            X = graticuleX(Y0, Y1, 90);
            Y = graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule
            .extentMajor([[-180, -90 + epsilon$4], [180, 90 - epsilon$4]])
            .extentMinor([[-180, -80 - epsilon$4], [180, 80 + epsilon$4]]);
    }
    function graticule10() {
        return graticule()();
    }

    function interpolate$3 (a, b) {
        var x0 = a[0] * radians, y0 = a[1] * radians, x1 = b[0] * radians, y1 = b[1] * radians, cy0 = cos$1(y0), sy0 = sin$1(y0), cy1 = cos$1(y1), sy1 = sin$1(y1), kx0 = cy0 * cos$1(x0), ky0 = cy0 * sin$1(x0), kx1 = cy1 * cos$1(x1), ky1 = cy1 * sin$1(x1), d = 2 * asin(sqrt$1(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))), k = sin$1(d);
        var interpolate = d ? function (t) {
            var B = sin$1(t *= d) / k, A = sin$1(d - t) / k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [
                atan2(y, x) * degrees$1,
                atan2(z, sqrt$1(x * x + y * y)) * degrees$1
            ];
        } : function () {
            return [x0 * degrees$1, y0 * degrees$1];
        };
        interpolate.distance = d;
        return interpolate;
    }

    function identity$8 (x) {
        return x;
    }

    var areaSum$1 = adder(), areaRingSum$1 = adder(), x00, y00, x0$1, y0$1;
    var areaStream$1 = {
        point: noop$3,
        lineStart: noop$3,
        lineEnd: noop$3,
        polygonStart: function () {
            areaStream$1.lineStart = areaRingStart$1;
            areaStream$1.lineEnd = areaRingEnd$1;
        },
        polygonEnd: function () {
            areaStream$1.lineStart = areaStream$1.lineEnd = areaStream$1.point = noop$3;
            areaSum$1.add(abs(areaRingSum$1));
            areaRingSum$1.reset();
        },
        result: function () {
            var area = areaSum$1 / 2;
            areaSum$1.reset();
            return area;
        }
    };
    function areaRingStart$1() {
        areaStream$1.point = areaPointFirst$1;
    }
    function areaPointFirst$1(x, y) {
        areaStream$1.point = areaPoint$1;
        x00 = x0$1 = x, y00 = y0$1 = y;
    }
    function areaPoint$1(x, y) {
        areaRingSum$1.add(y0$1 * x - x0$1 * y);
        x0$1 = x, y0$1 = y;
    }
    function areaRingEnd$1() {
        areaPoint$1(x00, y00);
    }

    var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
    var boundsStream$1 = {
        point: boundsPoint$1,
        lineStart: noop$3,
        lineEnd: noop$3,
        polygonStart: noop$3,
        polygonEnd: noop$3,
        result: function () {
            var bounds = [[x0$2, y0$2], [x1, y1]];
            x1 = y1 = -(y0$2 = x0$2 = Infinity);
            return bounds;
        }
    };
    function boundsPoint$1(x, y) {
        if (x < x0$2)
            x0$2 = x;
        if (x > x1)
            x1 = x;
        if (y < y0$2)
            y0$2 = y;
        if (y > y1)
            y1 = y;
    }

    // TODO Enforce positive area for exterior, negative area for interior?
    var X0$1 = 0, Y0$1 = 0, Z0$1 = 0, X1$1 = 0, Y1$1 = 0, Z1$1 = 0, X2$1 = 0, Y2$1 = 0, Z2$1 = 0, x00$1, y00$1, x0$3, y0$3;
    var centroidStream$1 = {
        point: centroidPoint$1,
        lineStart: centroidLineStart$1,
        lineEnd: centroidLineEnd$1,
        polygonStart: function () {
            centroidStream$1.lineStart = centroidRingStart$1;
            centroidStream$1.lineEnd = centroidRingEnd$1;
        },
        polygonEnd: function () {
            centroidStream$1.point = centroidPoint$1;
            centroidStream$1.lineStart = centroidLineStart$1;
            centroidStream$1.lineEnd = centroidLineEnd$1;
        },
        result: function () {
            var centroid = Z2$1 ? [X2$1 / Z2$1, Y2$1 / Z2$1]
                : Z1$1 ? [X1$1 / Z1$1, Y1$1 / Z1$1]
                    : Z0$1 ? [X0$1 / Z0$1, Y0$1 / Z0$1]
                        : [NaN, NaN];
            X0$1 = Y0$1 = Z0$1 =
                X1$1 = Y1$1 = Z1$1 =
                    X2$1 = Y2$1 = Z2$1 = 0;
            return centroid;
        }
    };
    function centroidPoint$1(x, y) {
        X0$1 += x;
        Y0$1 += y;
        ++Z0$1;
    }
    function centroidLineStart$1() {
        centroidStream$1.point = centroidPointFirstLine;
    }
    function centroidPointFirstLine(x, y) {
        centroidStream$1.point = centroidPointLine;
        centroidPoint$1(x0$3 = x, y0$3 = y);
    }
    function centroidPointLine(x, y) {
        var dx = x - x0$3, dy = y - y0$3, z = sqrt$1(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;
        centroidPoint$1(x0$3 = x, y0$3 = y);
    }
    function centroidLineEnd$1() {
        centroidStream$1.point = centroidPoint$1;
    }
    function centroidRingStart$1() {
        centroidStream$1.point = centroidPointFirstRing;
    }
    function centroidRingEnd$1() {
        centroidPointRing(x00$1, y00$1);
    }
    function centroidPointFirstRing(x, y) {
        centroidStream$1.point = centroidPointRing;
        centroidPoint$1(x00$1 = x0$3 = x, y00$1 = y0$3 = y);
    }
    function centroidPointRing(x, y) {
        var dx = x - x0$3, dy = y - y0$3, z = sqrt$1(dx * dx + dy * dy);
        X1$1 += z * (x0$3 + x) / 2;
        Y1$1 += z * (y0$3 + y) / 2;
        Z1$1 += z;
        z = y0$3 * x - x0$3 * y;
        X2$1 += z * (x0$3 + x);
        Y2$1 += z * (y0$3 + y);
        Z2$1 += z * 3;
        centroidPoint$1(x0$3 = x, y0$3 = y);
    }

    function PathContext(context) {
        this._context = context;
    }
    PathContext.prototype = {
        _radius: 4.5,
        pointRadius: function (_) {
            return this._radius = _, this;
        },
        polygonStart: function () {
            this._line = 0;
        },
        polygonEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._point = 0;
        },
        lineEnd: function () {
            if (this._line === 0)
                this._context.closePath();
            this._point = NaN;
        },
        point: function (x, y) {
            switch (this._point) {
                case 0: {
                    this._context.moveTo(x, y);
                    this._point = 1;
                    break;
                }
                case 1: {
                    this._context.lineTo(x, y);
                    break;
                }
                default: {
                    this._context.moveTo(x + this._radius, y);
                    this._context.arc(x, y, this._radius, 0, tau$4);
                    break;
                }
            }
        },
        result: noop$3
    };

    var lengthSum$1 = adder(), lengthRing, x00$2, y00$2, x0$4, y0$4;
    var lengthStream$1 = {
        point: noop$3,
        lineStart: function () {
            lengthStream$1.point = lengthPointFirst$1;
        },
        lineEnd: function () {
            if (lengthRing)
                lengthPoint$1(x00$2, y00$2);
            lengthStream$1.point = noop$3;
        },
        polygonStart: function () {
            lengthRing = true;
        },
        polygonEnd: function () {
            lengthRing = null;
        },
        result: function () {
            var length = +lengthSum$1;
            lengthSum$1.reset();
            return length;
        }
    };
    function lengthPointFirst$1(x, y) {
        lengthStream$1.point = lengthPoint$1;
        x00$2 = x0$4 = x, y00$2 = y0$4 = y;
    }
    function lengthPoint$1(x, y) {
        x0$4 -= x, y0$4 -= y;
        lengthSum$1.add(sqrt$1(x0$4 * x0$4 + y0$4 * y0$4));
        x0$4 = x, y0$4 = y;
    }

    function PathString() {
        this._string = [];
    }
    PathString.prototype = {
        _radius: 4.5,
        _circle: circle$1(4.5),
        pointRadius: function (_) {
            if ((_ = +_) !== this._radius)
                this._radius = _, this._circle = null;
            return this;
        },
        polygonStart: function () {
            this._line = 0;
        },
        polygonEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._point = 0;
        },
        lineEnd: function () {
            if (this._line === 0)
                this._string.push("Z");
            this._point = NaN;
        },
        point: function (x, y) {
            switch (this._point) {
                case 0: {
                    this._string.push("M", x, ",", y);
                    this._point = 1;
                    break;
                }
                case 1: {
                    this._string.push("L", x, ",", y);
                    break;
                }
                default: {
                    if (this._circle == null)
                        this._circle = circle$1(this._radius);
                    this._string.push("M", x, ",", y, this._circle);
                    break;
                }
            }
        },
        result: function () {
            if (this._string.length) {
                var result = this._string.join("");
                this._string = [];
                return result;
            }
            else {
                return null;
            }
        }
    };
    function circle$1(radius) {
        return "m0," + radius
            + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
            + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
            + "z";
    }

    function index$1 (projection, context) {
        var pointRadius = 4.5, projectionStream, contextStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === "function")
                    contextStream.pointRadius(+pointRadius.apply(this, arguments));
                geoStream(object, projectionStream(contextStream));
            }
            return contextStream.result();
        }
        path.area = function (object) {
            geoStream(object, projectionStream(areaStream$1));
            return areaStream$1.result();
        };
        path.measure = function (object) {
            geoStream(object, projectionStream(lengthStream$1));
            return lengthStream$1.result();
        };
        path.bounds = function (object) {
            geoStream(object, projectionStream(boundsStream$1));
            return boundsStream$1.result();
        };
        path.centroid = function (object) {
            geoStream(object, projectionStream(centroidStream$1));
            return centroidStream$1.result();
        };
        path.projection = function (_) {
            return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$8) : (projection = _).stream, path) : projection;
        };
        path.context = function (_) {
            if (!arguments.length)
                return context;
            contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
            if (typeof pointRadius !== "function")
                contextStream.pointRadius(pointRadius);
            return path;
        };
        path.pointRadius = function (_) {
            if (!arguments.length)
                return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };
        return path.projection(projection).context(context);
    }

    function transform$1 (methods) {
        return {
            stream: transformer$1(methods)
        };
    }
    function transformer$1(methods) {
        return function (stream) {
            var s = new TransformStream;
            for (var key in methods)
                s[key] = methods[key];
            s.stream = stream;
            return s;
        };
    }
    function TransformStream() { }
    TransformStream.prototype = {
        constructor: TransformStream,
        point: function (x, y) { this.stream.point(x, y); },
        sphere: function () { this.stream.sphere(); },
        lineStart: function () { this.stream.lineStart(); },
        lineEnd: function () { this.stream.lineEnd(); },
        polygonStart: function () { this.stream.polygonStart(); },
        polygonEnd: function () { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
        var clip = projection.clipExtent && projection.clipExtent();
        projection.scale(150).translate([0, 0]);
        if (clip != null)
            projection.clipExtent(null);
        geoStream(object, projection.stream(boundsStream$1));
        fitBounds(boundsStream$1.result());
        if (clip != null)
            projection.clipExtent(clip);
        return projection;
    }
    function fitExtent(projection, extent, object) {
        return fit(projection, function (b) {
            var w = extent[1][0] - extent[0][0], h = extent[1][1] - extent[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
            projection.scale(150 * k).translate([x, y]);
        }, object);
    }
    function fitSize(projection, size, object) {
        return fitExtent(projection, [[0, 0], size], object);
    }
    function fitWidth(projection, width, object) {
        return fit(projection, function (b) {
            var w = +width, k = w / (b[1][0] - b[0][0]), x = (w - k * (b[1][0] + b[0][0])) / 2, y = -k * b[0][1];
            projection.scale(150 * k).translate([x, y]);
        }, object);
    }
    function fitHeight(projection, height, object) {
        return fit(projection, function (b) {
            var h = +height, k = h / (b[1][1] - b[0][1]), x = -k * b[0][0], y = (h - k * (b[1][1] + b[0][1])) / 2;
            projection.scale(150 * k).translate([x, y]);
        }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
    cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)
    function resample (project, delta2) {
        return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }
    function resampleNone(project) {
        return transformer$1({
            point: function (x, y) {
                x = project(x, y);
                this.stream.point(x[0], x[1]);
            }
        });
    }
    function resample$1(project, delta2) {
        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * delta2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = sqrt$1(a * a + b * b + c * c), phi2 = asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon$4 || abs(lambda0 - lambda1) < epsilon$4 ? (lambda0 + lambda1) / 2 : atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > delta2 // perpendicular projected distance
                    || abs((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
                    || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
                    resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
                }
            }
        }
        return function (stream) {
            var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point
            var resampleStream = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () { stream.polygonStart(); resampleStream.lineStart = ringStart; },
                polygonEnd: function () { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resampleStream.point = linePoint;
                stream.lineStart();
            }
            function linePoint(lambda, phi) {
                var c = cartesian([lambda, phi]), p = project(lambda, phi);
                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resampleStream.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resampleStream.point = ringPoint;
                resampleStream.lineEnd = ringEnd;
            }
            function ringPoint(lambda, phi) {
                linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resampleStream.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
                resampleStream.lineEnd = lineEnd;
                lineEnd();
            }
            return resampleStream;
        };
    }

    var transformRadians = transformer$1({
        point: function (x, y) {
            this.stream.point(x * radians, y * radians);
        }
    });
    function transformRotate(rotate) {
        return transformer$1({
            point: function (x, y) {
                var r = rotate(x, y);
                return this.stream.point(r[0], r[1]);
            }
        });
    }
    function projection(project) {
        return projectionMutator(function () { return project; })();
    }
    function projectionMutator(projectAt) {
        var project, k = 150, // scale
        x = 480, y = 250, // translate
        dx, dy, lambda = 0, phi = 0, // center
        deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, projectRotate, // rotate
        theta = null, preclip = clipAntimeridian, // clip angle
        x0 = null, y0, x1, y1, postclip = identity$8, // clip extent
        delta2 = 0.5, projectResample = resample(projectTransform, delta2), // precision
        cache, cacheStream;
        function projection(point) {
            point = projectRotate(point[0] * radians, point[1] * radians);
            return [point[0] * k + dx, dy - point[1] * k];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
            return point && [point[0] * degrees$1, point[1] * degrees$1];
        }
        function projectTransform(x, y) {
            return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
        }
        projection.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
        };
        projection.preclip = function (_) {
            return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
        };
        projection.postclip = function (_) {
            return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
        };
        projection.clipAngle = function (_) {
            return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees$1;
        };
        projection.clipExtent = function (_) {
            return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$8) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
        };
        projection.scale = function (_) {
            return arguments.length ? (k = +_, recenter()) : k;
        };
        projection.translate = function (_) {
            return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
        };
        projection.center = function (_) {
            return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees$1, phi * degrees$1];
        };
        projection.rotate = function (_) {
            return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees$1, deltaPhi * degrees$1, deltaGamma * degrees$1];
        };
        projection.precision = function (_) {
            return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$1(delta2);
        };
        projection.fitExtent = function (extent, object) {
            return fitExtent(projection, extent, object);
        };
        projection.fitSize = function (size, object) {
            return fitSize(projection, size, object);
        };
        projection.fitWidth = function (width, object) {
            return fitWidth(projection, width, object);
        };
        projection.fitHeight = function (height, object) {
            return fitHeight(projection, height, object);
        };
        function recenter() {
            projectRotate = compose(rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma), project);
            var center = project(lambda, phi);
            dx = x - center[0] * k;
            dy = y + center[1] * k;
            return reset();
        }
        function reset() {
            cache = cacheStream = null;
            return projection;
        }
        return function () {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return recenter();
        };
    }

    function conicProjection(projectAt) {
        var phi0 = 0, phi1 = pi$4 / 3, m = projectionMutator(projectAt), p = m(phi0, phi1);
        p.parallels = function (_) {
            return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees$1, phi1 * degrees$1];
        };
        return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
        var cosPhi0 = cos$1(phi0);
        function forward(lambda, phi) {
            return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
        }
        forward.invert = function (x, y) {
            return [x / cosPhi0, asin(y * cosPhi0)];
        };
        return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
        var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;
        // Are the parallels symmetrical around the Equator?
        if (abs(n) < epsilon$4)
            return cylindricalEqualAreaRaw(y0);
        var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$1(c) / n;
        function project(x, y) {
            var r = sqrt$1(c - 2 * n * sin$1(y)) / n;
            return [r * sin$1(x *= n), r0 - r * cos$1(x)];
        }
        project.invert = function (x, y) {
            var r0y = r0 - y;
            return [atan2(x, abs(r0y)) / n * sign$1(r0y), asin((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
        };
        return project;
    }
    function conicEqualArea () {
        return conicProjection(conicEqualAreaRaw)
            .scale(155.424)
            .center([0, 33.6442]);
    }

    function albers () {
        return conicEqualArea()
            .parallels([29.5, 45.5])
            .scale(1070)
            .translate([480, 250])
            .rotate([96, 0])
            .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
        var n = streams.length;
        return {
            point: function (x, y) { var i = -1; while (++i < n)
                streams[i].point(x, y); },
            sphere: function () { var i = -1; while (++i < n)
                streams[i].sphere(); },
            lineStart: function () { var i = -1; while (++i < n)
                streams[i].lineStart(); },
            lineEnd: function () { var i = -1; while (++i < n)
                streams[i].lineEnd(); },
            polygonStart: function () { var i = -1; while (++i < n)
                streams[i].polygonStart(); },
            polygonEnd: function () { var i = -1; while (++i < n)
                streams[i].polygonEnd(); }
        };
    }
    // A composite projection for the United States, configured by default for
    // 960×500. The projection also works quite well at 960×600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa () {
        var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
        hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
        point, pointStream = { point: function (x, y) { point = [x, y]; } };
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            return point = null,
                (lower48Point.point(x, y), point)
                    || (alaskaPoint.point(x, y), point)
                    || (hawaiiPoint.point(x, y), point);
        }
        albersUsa.invert = function (coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
                : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
                    : lower48).invert(coordinates);
        };
        albersUsa.stream = function (stream) {
            return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
        };
        albersUsa.precision = function (_) {
            if (!arguments.length)
                return lower48.precision();
            lower48.precision(_), alaska.precision(_), hawaii.precision(_);
            return reset();
        };
        albersUsa.scale = function (_) {
            if (!arguments.length)
                return lower48.scale();
            lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function (_) {
            if (!arguments.length)
                return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48
                .translate(_)
                .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
                .stream(pointStream);
            alaskaPoint = alaska
                .translate([x - 0.307 * k, y + 0.201 * k])
                .clipExtent([[x - 0.425 * k + epsilon$4, y + 0.120 * k + epsilon$4], [x - 0.214 * k - epsilon$4, y + 0.234 * k - epsilon$4]])
                .stream(pointStream);
            hawaiiPoint = hawaii
                .translate([x - 0.205 * k, y + 0.212 * k])
                .clipExtent([[x - 0.214 * k + epsilon$4, y + 0.166 * k + epsilon$4], [x - 0.115 * k - epsilon$4, y + 0.234 * k - epsilon$4]])
                .stream(pointStream);
            return reset();
        };
        albersUsa.fitExtent = function (extent, object) {
            return fitExtent(albersUsa, extent, object);
        };
        albersUsa.fitSize = function (size, object) {
            return fitSize(albersUsa, size, object);
        };
        albersUsa.fitWidth = function (width, object) {
            return fitWidth(albersUsa, width, object);
        };
        albersUsa.fitHeight = function (height, object) {
            return fitHeight(albersUsa, height, object);
        };
        function reset() {
            cache = cacheStream = null;
            return albersUsa;
        }
        return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
        return function (x, y) {
            var cx = cos$1(x), cy = cos$1(y), k = scale(cx * cy);
            return [
                k * cy * sin$1(x),
                k * sin$1(y)
            ];
        };
    }
    function azimuthalInvert(angle) {
        return function (x, y) {
            var z = sqrt$1(x * x + y * y), c = angle(z), sc = sin$1(c), cc = cos$1(c);
            return [
                atan2(x * sc, z * cc),
                asin(z && y * sc / z)
            ];
        };
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function (cxcy) {
        return sqrt$1(2 / (1 + cxcy));
    });
    azimuthalEqualAreaRaw.invert = azimuthalInvert(function (z) {
        return 2 * asin(z / 2);
    });
    function azimuthalEqualArea () {
        return projection(azimuthalEqualAreaRaw)
            .scale(124.75)
            .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function (c) {
        return (c = acos(c)) && c / sin$1(c);
    });
    azimuthalEquidistantRaw.invert = azimuthalInvert(function (z) {
        return z;
    });
    function azimuthalEquidistant () {
        return projection(azimuthalEquidistantRaw)
            .scale(79.4188)
            .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
        return [lambda, log(tan((halfPi$2 + phi) / 2))];
    }
    mercatorRaw.invert = function (x, y) {
        return [x, 2 * atan(exp(y)) - halfPi$2];
    };
    function mercator () {
        return mercatorProjection(mercatorRaw)
            .scale(961 / tau$4);
    }
    function mercatorProjection(project) {
        var m = projection(project), center = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x0 = null, y0, x1, y1; // clip extent
        m.scale = function (_) {
            return arguments.length ? (scale(_), reclip()) : scale();
        };
        m.translate = function (_) {
            return arguments.length ? (translate(_), reclip()) : translate();
        };
        m.center = function (_) {
            return arguments.length ? (center(_), reclip()) : center();
        };
        m.clipExtent = function (_) {
            return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
        };
        function reclip() {
            var k = pi$4 * scale(), t = m(rotation(m.rotate()).invert([0, 0]));
            return clipExtent(x0 == null
                ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
                ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
                : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
        }
        return reclip();
    }

    function tany(y) {
        return tan((halfPi$2 + y) / 2);
    }
    function conicConformalRaw(y0, y1) {
        var cy0 = cos$1(y0), n = y0 === y1 ? sin$1(y0) : log(cy0 / cos$1(y1)) / log(tany(y1) / tany(y0)), f = cy0 * pow$1(tany(y0), n) / n;
        if (!n)
            return mercatorRaw;
        function project(x, y) {
            if (f > 0) {
                if (y < -halfPi$2 + epsilon$4)
                    y = -halfPi$2 + epsilon$4;
            }
            else {
                if (y > halfPi$2 - epsilon$4)
                    y = halfPi$2 - epsilon$4;
            }
            var r = f / pow$1(tany(y), n);
            return [r * sin$1(n * x), f - r * cos$1(n * x)];
        }
        project.invert = function (x, y) {
            var fy = f - y, r = sign$1(n) * sqrt$1(x * x + fy * fy);
            return [atan2(x, abs(fy)) / n * sign$1(fy), 2 * atan(pow$1(f / r, 1 / n)) - halfPi$2];
        };
        return project;
    }
    function conicConformal () {
        return conicProjection(conicConformalRaw)
            .scale(109.5)
            .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
        return [lambda, phi];
    }
    equirectangularRaw.invert = equirectangularRaw;
    function equirectangular () {
        return projection(equirectangularRaw)
            .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
        var cy0 = cos$1(y0), n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0), g = cy0 / n + y0;
        if (abs(n) < epsilon$4)
            return equirectangularRaw;
        function project(x, y) {
            var gy = g - y, nx = n * x;
            return [gy * sin$1(nx), g - gy * cos$1(nx)];
        }
        project.invert = function (x, y) {
            var gy = g - y;
            return [atan2(x, abs(gy)) / n * sign$1(gy), g - sign$1(n) * sqrt$1(x * x + gy * gy)];
        };
        return project;
    }
    function conicEquidistant () {
        return conicProjection(conicEquidistantRaw)
            .scale(131.154)
            .center([0, 13.9389]);
    }

    function gnomonicRaw(x, y) {
        var cy = cos$1(y), k = cos$1(x) * cy;
        return [cy * sin$1(x) / k, sin$1(y) / k];
    }
    gnomonicRaw.invert = azimuthalInvert(atan);
    function gnomonic () {
        return projection(gnomonicRaw)
            .scale(144.049)
            .clipAngle(60);
    }

    function scaleTranslate(kx, ky, tx, ty) {
        return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? identity$8 : transformer$1({
            point: function (x, y) {
                this.stream.point(x * kx + tx, y * ky + ty);
            }
        });
    }
    function identity$9 () {
        var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, transform = identity$8, // scale, translate and reflect
        x0 = null, y0, x1, y1, // clip extent
        postclip = identity$8, cache, cacheStream, projection;
        function reset() {
            cache = cacheStream = null;
            return projection;
        }
        return projection = {
            stream: function (stream) {
                return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
            },
            postclip: function (_) {
                return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
            },
            clipExtent: function (_) {
                return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$8) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
            },
            scale: function (_) {
                return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
            },
            translate: function (_) {
                return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
            },
            reflectX: function (_) {
                return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
            },
            reflectY: function (_) {
                return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
            },
            fitExtent: function (extent, object) {
                return fitExtent(projection, extent, object);
            },
            fitSize: function (size, object) {
                return fitSize(projection, size, object);
            },
            fitWidth: function (width, object) {
                return fitWidth(projection, width, object);
            },
            fitHeight: function (height, object) {
                return fitHeight(projection, height, object);
            }
        };
    }

    function naturalEarth1Raw(lambda, phi) {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        return [
            lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
            phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
        ];
    }
    naturalEarth1Raw.invert = function (x, y) {
        var phi = y, i = 25, delta;
        do {
            var phi2 = phi * phi, phi4 = phi2 * phi2;
            phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
                (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
        } while (abs(delta) > epsilon$4 && --i > 0);
        return [
            x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
            phi
        ];
    };
    function naturalEarth1 () {
        return projection(naturalEarth1Raw)
            .scale(175.295);
    }

    function orthographicRaw(x, y) {
        return [cos$1(y) * sin$1(x), sin$1(y)];
    }
    orthographicRaw.invert = azimuthalInvert(asin);
    function orthographic () {
        return projection(orthographicRaw)
            .scale(249.5)
            .clipAngle(90 + epsilon$4);
    }

    function stereographicRaw(x, y) {
        var cy = cos$1(y), k = 1 + cos$1(x) * cy;
        return [cy * sin$1(x) / k, sin$1(y) / k];
    }
    stereographicRaw.invert = azimuthalInvert(function (z) {
        return 2 * atan(z);
    });
    function stereographic () {
        return projection(stereographicRaw)
            .scale(250)
            .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
        return [log(tan((halfPi$2 + phi) / 2)), -lambda];
    }
    transverseMercatorRaw.invert = function (x, y) {
        return [-y, 2 * atan(exp(x)) - halfPi$2];
    };
    function transverseMercator () {
        var m = mercatorProjection(transverseMercatorRaw), center = m.center, rotate = m.rotate;
        m.center = function (_) {
            return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        m.rotate = function (_) {
            return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90])
            .scale(159.155);
    }

    function defaultSeparation(a, b) {
        return a.parent === b.parent ? 1 : 2;
    }
    function meanX(children) {
        return children.reduce(meanXReduce, 0) / children.length;
    }
    function meanXReduce(x, c) {
        return x + c.x;
    }
    function maxY(children) {
        return 1 + children.reduce(maxYReduce, 0);
    }
    function maxYReduce(y, c) {
        return Math.max(y, c.y);
    }
    function leafLeft(node) {
        var children;
        while (children = node.children)
            node = children[0];
        return node;
    }
    function leafRight(node) {
        var children;
        while (children = node.children)
            node = children[children.length - 1];
        return node;
    }
    function cluster () {
        var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
        function cluster(root) {
            var previousNode, x = 0;
            // First walk, computing the initial x & y values.
            root.eachAfter(function (node) {
                var children = node.children;
                if (children) {
                    node.x = meanX(children);
                    node.y = maxY(children);
                }
                else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = leafLeft(root), right = leafRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            // Second walk, normalizing x & y to the desired size.
            return root.eachAfter(nodeSize ? function (node) {
                node.x = (node.x - root.x) * dx;
                node.y = (root.y - node.y) * dy;
            } : function (node) {
                node.x = (node.x - x0) / (x1 - x0) * dx;
                node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
            });
        }
        cluster.separation = function (x) {
            return arguments.length ? (separation = x, cluster) : separation;
        };
        cluster.size = function (x) {
            return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
        };
        cluster.nodeSize = function (x) {
            return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
        };
        return cluster;
    }

    function count(node) {
        var sum = 0, children = node.children, i = children && children.length;
        if (!i)
            sum = 1;
        else
            while (--i >= 0)
                sum += children[i].value;
        node.value = sum;
    }
    function node_count () {
        return this.eachAfter(count);
    }

    function node_each (callback) {
        var node = this, current, next = [node], children, i, n;
        do {
            current = next.reverse(), next = [];
            while (node = current.pop()) {
                callback(node), children = node.children;
                if (children)
                    for (i = 0, n = children.length; i < n; ++i) {
                        next.push(children[i]);
                    }
            }
        } while (next.length);
        return this;
    }

    function node_eachBefore (callback) {
        var node = this, nodes = [node], children, i;
        while (node = nodes.pop()) {
            callback(node), children = node.children;
            if (children)
                for (i = children.length - 1; i >= 0; --i) {
                    nodes.push(children[i]);
                }
        }
        return this;
    }

    function node_eachAfter (callback) {
        var node = this, nodes = [node], next = [], children, i, n;
        while (node = nodes.pop()) {
            next.push(node), children = node.children;
            if (children)
                for (i = 0, n = children.length; i < n; ++i) {
                    nodes.push(children[i]);
                }
        }
        while (node = next.pop()) {
            callback(node);
        }
        return this;
    }

    function node_sum (value) {
        return this.eachAfter(function (node) {
            var sum = +value(node.data) || 0, children = node.children, i = children && children.length;
            while (--i >= 0)
                sum += children[i].value;
            node.value = sum;
        });
    }

    function node_sort (compare) {
        return this.eachBefore(function (node) {
            if (node.children) {
                node.children.sort(compare);
            }
        });
    }

    function node_path (end) {
        var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
        while (start !== ancestor) {
            start = start.parent;
            nodes.push(start);
        }
        var k = nodes.length;
        while (end !== ancestor) {
            nodes.splice(k, 0, end);
            end = end.parent;
        }
        return nodes;
    }
    function leastCommonAncestor(a, b) {
        if (a === b)
            return a;
        var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
        a = aNodes.pop();
        b = bNodes.pop();
        while (a === b) {
            c = a;
            a = aNodes.pop();
            b = bNodes.pop();
        }
        return c;
    }

    function node_ancestors () {
        var node = this, nodes = [node];
        while (node = node.parent) {
            nodes.push(node);
        }
        return nodes;
    }

    function node_descendants () {
        var nodes = [];
        this.each(function (node) {
            nodes.push(node);
        });
        return nodes;
    }

    function node_leaves () {
        var leaves = [];
        this.eachBefore(function (node) {
            if (!node.children) {
                leaves.push(node);
            }
        });
        return leaves;
    }

    function node_links () {
        var root = this, links = [];
        root.each(function (node) {
            if (node !== root) { // Don’t include the root’s parent, if any.
                links.push({ source: node.parent, target: node });
            }
        });
        return links;
    }

    function hierarchy(data, children) {
        var root = new Node(data), valued = +data.value && (root.value = data.value), node, nodes = [root], child, childs, i, n;
        if (children == null)
            children = defaultChildren;
        while (node = nodes.pop()) {
            if (valued)
                node.value = +node.data.value;
            if ((childs = children(node.data)) && (n = childs.length)) {
                node.children = new Array(n);
                for (i = n - 1; i >= 0; --i) {
                    nodes.push(child = node.children[i] = new Node(childs[i]));
                    child.parent = node;
                    child.depth = node.depth + 1;
                }
            }
        }
        return root.eachBefore(computeHeight);
    }
    function node_copy() {
        return hierarchy(this).eachBefore(copyData);
    }
    function defaultChildren(d) {
        return d.children;
    }
    function copyData(node) {
        node.data = node.data.data;
    }
    function computeHeight(node) {
        var height = 0;
        do
            node.height = height;
        while ((node = node.parent) && (node.height < ++height));
    }
    function Node(data) {
        this.data = data;
        this.depth =
            this.height = 0;
        this.parent = null;
    }
    Node.prototype = hierarchy.prototype = {
        constructor: Node,
        count: node_count,
        each: node_each,
        eachAfter: node_eachAfter,
        eachBefore: node_eachBefore,
        sum: node_sum,
        sort: node_sort,
        path: node_path,
        ancestors: node_ancestors,
        descendants: node_descendants,
        leaves: node_leaves,
        links: node_links,
        copy: node_copy
    };

    var slice$6 = Array.prototype.slice;
    function shuffle$1(array) {
        var m = array.length, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m];
            array[m] = array[i];
            array[i] = t;
        }
        return array;
    }

    function enclose (circles) {
        var i = 0, n = (circles = shuffle$1(slice$6.call(circles))).length, B = [], p, e;
        while (i < n) {
            p = circles[i];
            if (e && enclosesWeak(e, p))
                ++i;
            else
                e = encloseBasis(B = extendBasis(B, p)), i = 0;
        }
        return e;
    }
    function extendBasis(B, p) {
        var i, j;
        if (enclosesWeakAll(p, B))
            return [p];
        // If we get here then B must have at least one element.
        for (i = 0; i < B.length; ++i) {
            if (enclosesNot(p, B[i])
                && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
                return [B[i], p];
            }
        }
        // If we get here then B must have at least two elements.
        for (i = 0; i < B.length - 1; ++i) {
            for (j = i + 1; j < B.length; ++j) {
                if (enclosesNot(encloseBasis2(B[i], B[j]), p)
                    && enclosesNot(encloseBasis2(B[i], p), B[j])
                    && enclosesNot(encloseBasis2(B[j], p), B[i])
                    && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
                    return [B[i], B[j], p];
                }
            }
        }
        // If we get here then something is very wrong.
        throw new Error;
    }
    function enclosesNot(a, b) {
        var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
        return dr < 0 || dr * dr < dx * dx + dy * dy;
    }
    function enclosesWeak(a, b) {
        var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
        return dr > 0 && dr * dr > dx * dx + dy * dy;
    }
    function enclosesWeakAll(a, B) {
        for (var i = 0; i < B.length; ++i) {
            if (!enclosesWeak(a, B[i])) {
                return false;
            }
        }
        return true;
    }
    function encloseBasis(B) {
        switch (B.length) {
            case 1: return encloseBasis1(B[0]);
            case 2: return encloseBasis2(B[0], B[1]);
            case 3: return encloseBasis3(B[0], B[1], B[2]);
        }
    }
    function encloseBasis1(a) {
        return {
            x: a.x,
            y: a.y,
            r: a.r
        };
    }
    function encloseBasis2(a, b) {
        var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
        return {
            x: (x1 + x2 + x21 / l * r21) / 2,
            y: (y1 + y2 + y21 / l * r21) / 2,
            r: (l + r1 + r2) / 2
        };
    }
    function encloseBasis3(a, b, c) {
        var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b2 = y1 - y2, b3 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b2 - a2 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1, xb = (b3 * c2 - b2 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
        return {
            x: x1 + xa + xb * r,
            y: y1 + ya + yb * r,
            r: r
        };
    }

    function place(a, b, c) {
        var ax = a.x, ay = a.y, da = b.r + c.r, db = a.r + c.r, dx = b.x - ax, dy = b.y - ay, dc = dx * dx + dy * dy;
        if (dc) {
            var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = ax + x * dx + y * dy;
            c.y = ay + x * dy - y * dx;
        }
        else {
            c.x = ax + db;
            c.y = ay;
        }
    }
    function intersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return dr * dr - 1e-6 > dx * dx + dy * dy;
    }
    function score(node) {
        var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;
        return dx * dx + dy * dy;
    }
    function Node$1(circle) {
        this._ = circle;
        this.next = null;
        this.previous = null;
    }
    function packEnclose(circles) {
        if (!(n = circles.length))
            return 0;
        var a, b, c, n, aa, ca, i, j, k, sj, sk;
        // Place the first circle.
        a = circles[0], a.x = 0, a.y = 0;
        if (!(n > 1))
            return a.r;
        // Place the second circle.
        b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
        if (!(n > 2))
            return a.r + b.r;
        // Place the third circle.
        place(b, a, c = circles[2]);
        // Initialize the front-chain using the first three circles a, b and c.
        a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
        a.next = c.previous = b;
        b.next = a.previous = c;
        c.next = b.previous = a;
        // Attempt to place each remaining circle…
        pack: for (i = 3; i < n; ++i) {
            place(a._, b._, c = circles[i]), c = new Node$1(c);
            // Find the closest intersecting circle on the front-chain, if any.
            // “Closeness” is determined by linear distance along the front-chain.
            // “Ahead” or “behind” is likewise determined by linear distance.
            j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
            do {
                if (sj <= sk) {
                    if (intersects(j._, c._)) {
                        b = j, a.next = b, b.previous = a, --i;
                        continue pack;
                    }
                    sj += j._.r, j = j.next;
                }
                else {
                    if (intersects(k._, c._)) {
                        a = k, a.next = b, b.previous = a, --i;
                        continue pack;
                    }
                    sk += k._.r, k = k.previous;
                }
            } while (j !== k.next);
            // Success! Insert the new circle c between a and b.
            c.previous = a, c.next = b, a.next = b.previous = b = c;
            // Compute the new closest circle pair to the centroid.
            aa = score(a);
            while ((c = c.next) !== b) {
                if ((ca = score(c)) < aa) {
                    a = c, aa = ca;
                }
            }
            b = a.next;
        }
        // Compute the enclosing circle of the front chain.
        a = [b._], c = b;
        while ((c = c.next) !== b)
            a.push(c._);
        c = enclose(a);
        // Translate the circles to put the enclosing circle around the origin.
        for (i = 0; i < n; ++i)
            a = circles[i], a.x -= c.x, a.y -= c.y;
        return c.r;
    }
    function siblings (circles) {
        packEnclose(circles);
        return circles;
    }

    function optional(f) {
        return f == null ? null : required(f);
    }
    function required(f) {
        if (typeof f !== "function")
            throw new Error;
        return f;
    }

    function constantZero() {
        return 0;
    }
    function constant$b (x) {
        return function () {
            return x;
        };
    }

    function defaultRadius$1(d) {
        return Math.sqrt(d.value);
    }
    function index$2 () {
        var radius = null, dx = 1, dy = 1, padding = constantZero;
        function pack(root) {
            root.x = dx / 2, root.y = dy / 2;
            if (radius) {
                root.eachBefore(radiusLeaf(radius))
                    .eachAfter(packChildren(padding, 0.5))
                    .eachBefore(translateChild(1));
            }
            else {
                root.eachBefore(radiusLeaf(defaultRadius$1))
                    .eachAfter(packChildren(constantZero, 1))
                    .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
                    .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
            }
            return root;
        }
        pack.radius = function (x) {
            return arguments.length ? (radius = optional(x), pack) : radius;
        };
        pack.size = function (x) {
            return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
        };
        pack.padding = function (x) {
            return arguments.length ? (padding = typeof x === "function" ? x : constant$b(+x), pack) : padding;
        };
        return pack;
    }
    function radiusLeaf(radius) {
        return function (node) {
            if (!node.children) {
                node.r = Math.max(0, +radius(node) || 0);
            }
        };
    }
    function packChildren(padding, k) {
        return function (node) {
            if (children = node.children) {
                var children, i, n = children.length, r = padding(node) * k || 0, e;
                if (r)
                    for (i = 0; i < n; ++i)
                        children[i].r += r;
                e = packEnclose(children);
                if (r)
                    for (i = 0; i < n; ++i)
                        children[i].r -= r;
                node.r = e + r;
            }
        };
    }
    function translateChild(k) {
        return function (node) {
            var parent = node.parent;
            node.r *= k;
            if (parent) {
                node.x = parent.x + k * node.x;
                node.y = parent.y + k * node.y;
            }
        };
    }

    function roundNode (node) {
        node.x0 = Math.round(node.x0);
        node.y0 = Math.round(node.y0);
        node.x1 = Math.round(node.x1);
        node.y1 = Math.round(node.y1);
    }

    function treemapDice (parent, x0, y0, x1, y1) {
        var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
        while (++i < n) {
            node = nodes[i], node.y0 = y0, node.y1 = y1;
            node.x0 = x0, node.x1 = x0 += node.value * k;
        }
    }

    function partition () {
        var dx = 1, dy = 1, padding = 0, round = false;
        function partition(root) {
            var n = root.height + 1;
            root.x0 =
                root.y0 = padding;
            root.x1 = dx;
            root.y1 = dy / n;
            root.eachBefore(positionNode(dy, n));
            if (round)
                root.eachBefore(roundNode);
            return root;
        }
        function positionNode(dy, n) {
            return function (node) {
                if (node.children) {
                    treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
                }
                var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding, y1 = node.y1 - padding;
                if (x1 < x0)
                    x0 = x1 = (x0 + x1) / 2;
                if (y1 < y0)
                    y0 = y1 = (y0 + y1) / 2;
                node.x0 = x0;
                node.y0 = y0;
                node.x1 = x1;
                node.y1 = y1;
            };
        }
        partition.round = function (x) {
            return arguments.length ? (round = !!x, partition) : round;
        };
        partition.size = function (x) {
            return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
        };
        partition.padding = function (x) {
            return arguments.length ? (padding = +x, partition) : padding;
        };
        return partition;
    }

    var keyPrefix$2 = "$", // Protect against keys like “__proto__”.
    preroot = { depth: -1 }, ambiguous = {};
    function defaultId(d) {
        return d.id;
    }
    function defaultParentId(d) {
        return d.parentId;
    }
    function stratify () {
        var id = defaultId, parentId = defaultParentId;
        function stratify(data) {
            var d, i, n = data.length, root, parent, node, nodes = new Array(n), nodeId, nodeKey, nodeByKey = {};
            for (i = 0; i < n; ++i) {
                d = data[i], node = nodes[i] = new Node(d);
                if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
                    nodeKey = keyPrefix$2 + (node.id = nodeId);
                    nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
                }
            }
            for (i = 0; i < n; ++i) {
                node = nodes[i], nodeId = parentId(data[i], i, data);
                if (nodeId == null || !(nodeId += "")) {
                    if (root)
                        throw new Error("multiple roots");
                    root = node;
                }
                else {
                    parent = nodeByKey[keyPrefix$2 + nodeId];
                    if (!parent)
                        throw new Error("missing: " + nodeId);
                    if (parent === ambiguous)
                        throw new Error("ambiguous: " + nodeId);
                    if (parent.children)
                        parent.children.push(node);
                    else
                        parent.children = [node];
                    node.parent = parent;
                }
            }
            if (!root)
                throw new Error("no root");
            root.parent = preroot;
            root.eachBefore(function (node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
            root.parent = null;
            if (n > 0)
                throw new Error("cycle");
            return root;
        }
        stratify.id = function (x) {
            return arguments.length ? (id = required(x), stratify) : id;
        };
        stratify.parentId = function (x) {
            return arguments.length ? (parentId = required(x), stratify) : parentId;
        };
        return stratify;
    }

    function defaultSeparation$1(a, b) {
        return a.parent === b.parent ? 1 : 2;
    }
    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }
    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
        var children = v.children;
        return children ? children[0] : v.t;
    }
    // This function works analogously to nextLeft.
    function nextRight(v) {
        var children = v.children;
        return children ? children[children.length - 1] : v.t;
    }
    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    function TreeNode(node, i) {
        this._ = node;
        this.parent = null;
        this.children = null;
        this.A = null; // default ancestor
        this.a = this; // ancestor
        this.z = 0; // prelim
        this.m = 0; // mod
        this.c = 0; // change
        this.s = 0; // shift
        this.t = null; // thread
        this.i = i; // number
    }
    TreeNode.prototype = Object.create(Node.prototype);
    function treeRoot(root) {
        var tree = new TreeNode(root, 0), node, nodes = [tree], child, children, i, n;
        while (node = nodes.pop()) {
            if (children = node._.children) {
                node.children = new Array(n = children.length);
                for (i = n - 1; i >= 0; --i) {
                    nodes.push(child = node.children[i] = new TreeNode(children[i], i));
                    child.parent = node;
                }
            }
        }
        (tree.parent = new TreeNode(null, 0)).children = [tree];
        return tree;
    }
    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree () {
        var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = null;
        function tree(root) {
            var t = treeRoot(root);
            // Compute the layout using Buchheim et al.’s algorithm.
            t.eachAfter(firstWalk), t.parent.m = -t.z;
            t.eachBefore(secondWalk);
            // If a fixed node size is specified, scale x and y.
            if (nodeSize)
                root.eachBefore(sizeNode);
            // If a fixed tree size is specified, scale x and y based on the extent.
            // Compute the left-most, right-most, and depth-most nodes for extents.
            else {
                var left = root, right = root, bottom = root;
                root.eachBefore(function (node) {
                    if (node.x < left.x)
                        left = node;
                    if (node.x > right.x)
                        right = node;
                    if (node.depth > bottom.depth)
                        bottom = node;
                });
                var s = left === right ? 1 : separation(left, right) / 2, tx = s - left.x, kx = dx / (right.x + s + tx), ky = dy / (bottom.depth || 1);
                root.eachBefore(function (node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return root;
        }
        // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
        // applied recursively to the children of v, as well as the function
        // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
        // node v is placed to the midpoint of its outermost children.
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children) {
                executeShifts(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                }
                else {
                    v.z = midpoint;
                }
            }
            else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        // Computes all real x-coordinates by summing up the modifiers recursively.
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        // The core of the algorithm. Here, a new subtree is combined with the
        // previous subtrees. Threads are used to traverse the inside and outside
        // contours of the left and right subtree up to the highest common level. The
        // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
        // superscript o means outside and i means inside, the subscript - means left
        // subtree and + means right subtree. For summing up the modifiers along the
        // contour, we use respective variables si+, si-, so-, and so+. Whenever two
        // nodes of the inside contours conflict, we compute the left one of the
        // greatest uncommon ancestors using the function ANCESTOR and call MOVE
        // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
        // Finally, we add a new thread (if necessary).
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
                    vom = nextLeft(vom);
                    vop = nextRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !nextRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !nextLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= dx;
            node.y = node.depth * dy;
        }
        tree.separation = function (x) {
            return arguments.length ? (separation = x, tree) : separation;
        };
        tree.size = function (x) {
            return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
        };
        tree.nodeSize = function (x) {
            return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
        };
        return tree;
    }

    function treemapSlice (parent, x0, y0, x1, y1) {
        var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
        while (++i < n) {
            node = nodes[i], node.x0 = x0, node.x1 = x1;
            node.y0 = y0, node.y1 = y0 += node.value * k;
        }
    }

    var phi = (1 + Math.sqrt(5)) / 2;
    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
        var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
        while (i0 < n) {
            dx = x1 - x0, dy = y1 - y0;
            // Find the next non-empty node.
            do
                sumValue = nodes[i1++].value;
            while (!sumValue && i1 < n);
            minValue = maxValue = sumValue;
            alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
            beta = sumValue * sumValue * alpha;
            minRatio = Math.max(maxValue / beta, beta / minValue);
            // Keep adding nodes while the aspect ratio maintains or improves.
            for (; i1 < n; ++i1) {
                sumValue += nodeValue = nodes[i1].value;
                if (nodeValue < minValue)
                    minValue = nodeValue;
                if (nodeValue > maxValue)
                    maxValue = nodeValue;
                beta = sumValue * sumValue * alpha;
                newRatio = Math.max(maxValue / beta, beta / minValue);
                if (newRatio > minRatio) {
                    sumValue -= nodeValue;
                    break;
                }
                minRatio = newRatio;
            }
            // Position and record the row orientation.
            rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
            if (row.dice)
                treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
            else
                treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
            value -= sumValue, i0 = i1;
        }
        return rows;
    }
    var squarify = (function custom(ratio) {
        function squarify(parent, x0, y0, x1, y1) {
            squarifyRatio(ratio, parent, x0, y0, x1, y1);
        }
        squarify.ratio = function (x) {
            return custom((x = +x) > 1 ? x : 1);
        };
        return squarify;
    })(phi);

    function index$3 () {
        var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
        function treemap(root) {
            root.x0 =
                root.y0 = 0;
            root.x1 = dx;
            root.y1 = dy;
            root.eachBefore(positionNode);
            paddingStack = [0];
            if (round)
                root.eachBefore(roundNode);
            return root;
        }
        function positionNode(node) {
            var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
            if (x1 < x0)
                x0 = x1 = (x0 + x1) / 2;
            if (y1 < y0)
                y0 = y1 = (y0 + y1) / 2;
            node.x0 = x0;
            node.y0 = y0;
            node.x1 = x1;
            node.y1 = y1;
            if (node.children) {
                p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
                x0 += paddingLeft(node) - p;
                y0 += paddingTop(node) - p;
                x1 -= paddingRight(node) - p;
                y1 -= paddingBottom(node) - p;
                if (x1 < x0)
                    x0 = x1 = (x0 + x1) / 2;
                if (y1 < y0)
                    y0 = y1 = (y0 + y1) / 2;
                tile(node, x0, y0, x1, y1);
            }
        }
        treemap.round = function (x) {
            return arguments.length ? (round = !!x, treemap) : round;
        };
        treemap.size = function (x) {
            return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
        };
        treemap.tile = function (x) {
            return arguments.length ? (tile = required(x), treemap) : tile;
        };
        treemap.padding = function (x) {
            return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
        };
        treemap.paddingInner = function (x) {
            return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$b(+x), treemap) : paddingInner;
        };
        treemap.paddingOuter = function (x) {
            return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
        };
        treemap.paddingTop = function (x) {
            return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$b(+x), treemap) : paddingTop;
        };
        treemap.paddingRight = function (x) {
            return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$b(+x), treemap) : paddingRight;
        };
        treemap.paddingBottom = function (x) {
            return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$b(+x), treemap) : paddingBottom;
        };
        treemap.paddingLeft = function (x) {
            return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$b(+x), treemap) : paddingLeft;
        };
        return treemap;
    }

    function binary (parent, x0, y0, x1, y1) {
        var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1);
        for (sums[0] = sum = i = 0; i < n; ++i) {
            sums[i + 1] = sum += nodes[i].value;
        }
        partition(0, n, parent.value, x0, y0, x1, y1);
        function partition(i, j, value, x0, y0, x1, y1) {
            if (i >= j - 1) {
                var node = nodes[i];
                node.x0 = x0, node.y0 = y0;
                node.x1 = x1, node.y1 = y1;
                return;
            }
            var valueOffset = sums[i], valueTarget = (value / 2) + valueOffset, k = i + 1, hi = j - 1;
            while (k < hi) {
                var mid = k + hi >>> 1;
                if (sums[mid] < valueTarget)
                    k = mid + 1;
                else
                    hi = mid;
            }
            if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k)
                --k;
            var valueLeft = sums[k] - valueOffset, valueRight = value - valueLeft;
            if ((x1 - x0) > (y1 - y0)) {
                var xk = (x0 * valueRight + x1 * valueLeft) / value;
                partition(i, k, valueLeft, x0, y0, xk, y1);
                partition(k, j, valueRight, xk, y0, x1, y1);
            }
            else {
                var yk = (y0 * valueRight + y1 * valueLeft) / value;
                partition(i, k, valueLeft, x0, y0, x1, yk);
                partition(k, j, valueRight, x0, yk, x1, y1);
            }
        }
    }

    function sliceDice (parent, x0, y0, x1, y1) {
        (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {
        function resquarify(parent, x0, y0, x1, y1) {
            if ((rows = parent._squarify) && (rows.ratio === ratio)) {
                var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value;
                while (++j < m) {
                    row = rows[j], nodes = row.children;
                    for (i = row.value = 0, n = nodes.length; i < n; ++i)
                        row.value += nodes[i].value;
                    if (row.dice)
                        treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);
                    else
                        treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
                    value -= row.value;
                }
            }
            else {
                parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
                rows.ratio = ratio;
            }
        }
        resquarify.ratio = function (x) {
            return custom((x = +x) > 1 ? x : 1);
        };
        return resquarify;
    })(phi);

    function define$2 (constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
    }
    function extend$2(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition)
            prototype[key] = definition[key];
        return prototype;
    }

    function Color$2() { }
    var darker$2 = 0.7;
    var brighter$2 = 1 / darker$2;
    var reI$2 = "\\s*([+-]?\\d+)\\s*", reN$2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$2 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex$1 = /^#([0-9a-f]{3,8})$/, reRgbInteger$2 = new RegExp("^rgb\\(" + [reI$2, reI$2, reI$2] + "\\)$"), reRgbPercent$2 = new RegExp("^rgb\\(" + [reP$2, reP$2, reP$2] + "\\)$"), reRgbaInteger$2 = new RegExp("^rgba\\(" + [reI$2, reI$2, reI$2, reN$2] + "\\)$"), reRgbaPercent$2 = new RegExp("^rgba\\(" + [reP$2, reP$2, reP$2, reN$2] + "\\)$"), reHslPercent$2 = new RegExp("^hsl\\(" + [reN$2, reP$2, reP$2] + "\\)$"), reHslaPercent$2 = new RegExp("^hsla\\(" + [reN$2, reP$2, reP$2, reN$2] + "\\)$");
    var named$2 = {
        aliceblue: 0xf0f8ff,
        antiquewhite: 0xfaebd7,
        aqua: 0x00ffff,
        aquamarine: 0x7fffd4,
        azure: 0xf0ffff,
        beige: 0xf5f5dc,
        bisque: 0xffe4c4,
        black: 0x000000,
        blanchedalmond: 0xffebcd,
        blue: 0x0000ff,
        blueviolet: 0x8a2be2,
        brown: 0xa52a2a,
        burlywood: 0xdeb887,
        cadetblue: 0x5f9ea0,
        chartreuse: 0x7fff00,
        chocolate: 0xd2691e,
        coral: 0xff7f50,
        cornflowerblue: 0x6495ed,
        cornsilk: 0xfff8dc,
        crimson: 0xdc143c,
        cyan: 0x00ffff,
        darkblue: 0x00008b,
        darkcyan: 0x008b8b,
        darkgoldenrod: 0xb8860b,
        darkgray: 0xa9a9a9,
        darkgreen: 0x006400,
        darkgrey: 0xa9a9a9,
        darkkhaki: 0xbdb76b,
        darkmagenta: 0x8b008b,
        darkolivegreen: 0x556b2f,
        darkorange: 0xff8c00,
        darkorchid: 0x9932cc,
        darkred: 0x8b0000,
        darksalmon: 0xe9967a,
        darkseagreen: 0x8fbc8f,
        darkslateblue: 0x483d8b,
        darkslategray: 0x2f4f4f,
        darkslategrey: 0x2f4f4f,
        darkturquoise: 0x00ced1,
        darkviolet: 0x9400d3,
        deeppink: 0xff1493,
        deepskyblue: 0x00bfff,
        dimgray: 0x696969,
        dimgrey: 0x696969,
        dodgerblue: 0x1e90ff,
        firebrick: 0xb22222,
        floralwhite: 0xfffaf0,
        forestgreen: 0x228b22,
        fuchsia: 0xff00ff,
        gainsboro: 0xdcdcdc,
        ghostwhite: 0xf8f8ff,
        gold: 0xffd700,
        goldenrod: 0xdaa520,
        gray: 0x808080,
        green: 0x008000,
        greenyellow: 0xadff2f,
        grey: 0x808080,
        honeydew: 0xf0fff0,
        hotpink: 0xff69b4,
        indianred: 0xcd5c5c,
        indigo: 0x4b0082,
        ivory: 0xfffff0,
        khaki: 0xf0e68c,
        lavender: 0xe6e6fa,
        lavenderblush: 0xfff0f5,
        lawngreen: 0x7cfc00,
        lemonchiffon: 0xfffacd,
        lightblue: 0xadd8e6,
        lightcoral: 0xf08080,
        lightcyan: 0xe0ffff,
        lightgoldenrodyellow: 0xfafad2,
        lightgray: 0xd3d3d3,
        lightgreen: 0x90ee90,
        lightgrey: 0xd3d3d3,
        lightpink: 0xffb6c1,
        lightsalmon: 0xffa07a,
        lightseagreen: 0x20b2aa,
        lightskyblue: 0x87cefa,
        lightslategray: 0x778899,
        lightslategrey: 0x778899,
        lightsteelblue: 0xb0c4de,
        lightyellow: 0xffffe0,
        lime: 0x00ff00,
        limegreen: 0x32cd32,
        linen: 0xfaf0e6,
        magenta: 0xff00ff,
        maroon: 0x800000,
        mediumaquamarine: 0x66cdaa,
        mediumblue: 0x0000cd,
        mediumorchid: 0xba55d3,
        mediumpurple: 0x9370db,
        mediumseagreen: 0x3cb371,
        mediumslateblue: 0x7b68ee,
        mediumspringgreen: 0x00fa9a,
        mediumturquoise: 0x48d1cc,
        mediumvioletred: 0xc71585,
        midnightblue: 0x191970,
        mintcream: 0xf5fffa,
        mistyrose: 0xffe4e1,
        moccasin: 0xffe4b5,
        navajowhite: 0xffdead,
        navy: 0x000080,
        oldlace: 0xfdf5e6,
        olive: 0x808000,
        olivedrab: 0x6b8e23,
        orange: 0xffa500,
        orangered: 0xff4500,
        orchid: 0xda70d6,
        palegoldenrod: 0xeee8aa,
        palegreen: 0x98fb98,
        paleturquoise: 0xafeeee,
        palevioletred: 0xdb7093,
        papayawhip: 0xffefd5,
        peachpuff: 0xffdab9,
        peru: 0xcd853f,
        pink: 0xffc0cb,
        plum: 0xdda0dd,
        powderblue: 0xb0e0e6,
        purple: 0x800080,
        rebeccapurple: 0x663399,
        red: 0xff0000,
        rosybrown: 0xbc8f8f,
        royalblue: 0x4169e1,
        saddlebrown: 0x8b4513,
        salmon: 0xfa8072,
        sandybrown: 0xf4a460,
        seagreen: 0x2e8b57,
        seashell: 0xfff5ee,
        sienna: 0xa0522d,
        silver: 0xc0c0c0,
        skyblue: 0x87ceeb,
        slateblue: 0x6a5acd,
        slategray: 0x708090,
        slategrey: 0x708090,
        snow: 0xfffafa,
        springgreen: 0x00ff7f,
        steelblue: 0x4682b4,
        tan: 0xd2b48c,
        teal: 0x008080,
        thistle: 0xd8bfd8,
        tomato: 0xff6347,
        turquoise: 0x40e0d0,
        violet: 0xee82ee,
        wheat: 0xf5deb3,
        white: 0xffffff,
        whitesmoke: 0xf5f5f5,
        yellow: 0xffff00,
        yellowgreen: 0x9acd32
    };
    define$2(Color$2, color$2, {
        copy: function (channels) {
            return Object.assign(new this.constructor, this, channels);
        },
        displayable: function () {
            return this.rgb().displayable();
        },
        hex: color_formatHex$1,
        formatHex: color_formatHex$1,
        formatHsl: color_formatHsl$1,
        formatRgb: color_formatRgb$1,
        toString: color_formatRgb$1
    });
    function color_formatHex$1() {
        return this.rgb().formatHex();
    }
    function color_formatHsl$1() {
        return hslConvert$2(this).formatHsl();
    }
    function color_formatRgb$1() {
        return this.rgb().formatRgb();
    }
    function color$2(format) {
        var m, l;
        format = (format + "").trim().toLowerCase();
        return (m = reHex$1.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$2(m) // #ff0000
            : l === 3 ? new Rgb$2((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
                : l === 8 ? rgba$2(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
                    : l === 4 ? rgba$2((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
                        : null) // invalid hex
            : (m = reRgbInteger$2.exec(format)) ? new Rgb$2(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
                : (m = reRgbPercent$2.exec(format)) ? new Rgb$2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
                    : (m = reRgbaInteger$2.exec(format)) ? rgba$2(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
                        : (m = reRgbaPercent$2.exec(format)) ? rgba$2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
                            : (m = reHslPercent$2.exec(format)) ? hsla$2(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
                                : (m = reHslaPercent$2.exec(format)) ? hsla$2(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
                                    : named$2.hasOwnProperty(format) ? rgbn$2(named$2[format]) // eslint-disable-line no-prototype-builtins
                                        : format === "transparent" ? new Rgb$2(NaN, NaN, NaN, 0)
                                            : null;
    }
    function rgbn$2(n) {
        return new Rgb$2(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }
    function rgba$2(r, g, b, a) {
        if (a <= 0)
            r = g = b = NaN;
        return new Rgb$2(r, g, b, a);
    }
    function rgbConvert$2(o) {
        if (!(o instanceof Color$2))
            o = color$2(o);
        if (!o)
            return new Rgb$2;
        o = o.rgb();
        return new Rgb$2(o.r, o.g, o.b, o.opacity);
    }
    function rgb$2(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert$2(r) : new Rgb$2(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb$2(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
    }
    define$2(Rgb$2, rgb$2, extend$2(Color$2, {
        brighter: function (k) {
            k = k == null ? brighter$2 : Math.pow(brighter$2, k);
            return new Rgb$2(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$2 : Math.pow(darker$2, k);
            return new Rgb$2(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function () {
            return this;
        },
        displayable: function () {
            return (-0.5 <= this.r && this.r < 255.5)
                && (-0.5 <= this.g && this.g < 255.5)
                && (-0.5 <= this.b && this.b < 255.5)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        hex: rgb_formatHex$1,
        formatHex: rgb_formatHex$1,
        formatRgb: rgb_formatRgb$1,
        toString: rgb_formatRgb$1
    }));
    function rgb_formatHex$1() {
        return "#" + hex$1(this.r) + hex$1(this.g) + hex$1(this.b);
    }
    function rgb_formatRgb$1() {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "rgb(" : "rgba(")
            + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.b) || 0))
            + (a === 1 ? ")" : ", " + a + ")");
    }
    function hex$1(value) {
        value = Math.max(0, Math.min(255, Math.round(value) || 0));
        return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla$2(h, s, l, a) {
        if (a <= 0)
            h = s = l = NaN;
        else if (l <= 0 || l >= 1)
            h = s = NaN;
        else if (s <= 0)
            h = NaN;
        return new Hsl$2(h, s, l, a);
    }
    function hslConvert$2(o) {
        if (o instanceof Hsl$2)
            return new Hsl$2(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color$2))
            o = color$2(o);
        if (!o)
            return new Hsl$2;
        if (o instanceof Hsl$2)
            return o;
        o = o.rgb();
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
        if (s) {
            if (r === max)
                h = (g - b) / s + (g < b) * 6;
            else if (g === max)
                h = (b - r) / s + 2;
            else
                h = (r - g) / s + 4;
            s /= l < 0.5 ? max + min : 2 - max - min;
            h *= 60;
        }
        else {
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl$2(h, s, l, o.opacity);
    }
    function hsl$2(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert$2(h) : new Hsl$2(h, s, l, opacity == null ? 1 : opacity);
    }
    function Hsl$2(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define$2(Hsl$2, hsl$2, extend$2(Color$2, {
        brighter: function (k) {
            k = k == null ? brighter$2 : Math.pow(brighter$2, k);
            return new Hsl$2(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$2 : Math.pow(darker$2, k);
            return new Hsl$2(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
            return new Rgb$2(hsl2rgb$2(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb$2(h, m1, m2), hsl2rgb$2(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
        },
        displayable: function () {
            return (0 <= this.s && this.s <= 1 || isNaN(this.s))
                && (0 <= this.l && this.l <= 1)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        formatHsl: function () {
            var a = this.opacity;
            a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
            return (a === 1 ? "hsl(" : "hsla(")
                + (this.h || 0) + ", "
                + (this.s || 0) * 100 + "%, "
                + (this.l || 0) * 100 + "%"
                + (a === 1 ? ")" : ", " + a + ")");
        }
    }));
    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb$2(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60
            : h < 180 ? m2
                : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
                    : m1) * 255;
    }

    var deg2rad$2 = Math.PI / 180;
    var rad2deg$2 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    var K$1 = 18, Xn$2 = 0.96422, Yn$2 = 1, Zn$2 = 0.82521, t0$3 = 4 / 29, t1$3 = 6 / 29, t2$2 = 3 * t1$3 * t1$3, t3$2 = t1$3 * t1$3 * t1$3;
    function labConvert$2(o) {
        if (o instanceof Lab$2)
            return new Lab$2(o.l, o.a, o.b, o.opacity);
        if (o instanceof Hcl$2)
            return hcl2lab$1(o);
        if (!(o instanceof Rgb$2))
            o = rgbConvert$2(o);
        var r = rgb2lrgb$1(o.r), g = rgb2lrgb$1(o.g), b = rgb2lrgb$1(o.b), y = xyz2lab$2((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn$2), x, z;
        if (r === g && g === b)
            x = z = y;
        else {
            x = xyz2lab$2((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn$2);
            z = xyz2lab$2((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn$2);
        }
        return new Lab$2(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }
    function lab$2(l, a, b, opacity) {
        return arguments.length === 1 ? labConvert$2(l) : new Lab$2(l, a, b, opacity == null ? 1 : opacity);
    }
    function Lab$2(l, a, b, opacity) {
        this.l = +l;
        this.a = +a;
        this.b = +b;
        this.opacity = +opacity;
    }
    define$2(Lab$2, lab$2, extend$2(Color$2, {
        brighter: function (k) {
            return new Lab$2(this.l + K$1 * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        darker: function (k) {
            return new Lab$2(this.l - K$1 * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        rgb: function () {
            var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
            x = Xn$2 * lab2xyz$2(x);
            y = Yn$2 * lab2xyz$2(y);
            z = Zn$2 * lab2xyz$2(z);
            return new Rgb$2(lrgb2rgb$1(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb$1(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb$1(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
        }
    }));
    function xyz2lab$2(t) {
        return t > t3$2 ? Math.pow(t, 1 / 3) : t / t2$2 + t0$3;
    }
    function lab2xyz$2(t) {
        return t > t1$3 ? t * t * t : t2$2 * (t - t0$3);
    }
    function lrgb2rgb$1(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }
    function rgb2lrgb$1(x) {
        return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }
    function hclConvert$2(o) {
        if (o instanceof Hcl$2)
            return new Hcl$2(o.h, o.c, o.l, o.opacity);
        if (!(o instanceof Lab$2))
            o = labConvert$2(o);
        if (o.a === 0 && o.b === 0)
            return new Hcl$2(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
        var h = Math.atan2(o.b, o.a) * rad2deg$2;
        return new Hcl$2(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }
    function hcl$2(h, c, l, opacity) {
        return arguments.length === 1 ? hclConvert$2(h) : new Hcl$2(h, c, l, opacity == null ? 1 : opacity);
    }
    function Hcl$2(h, c, l, opacity) {
        this.h = +h;
        this.c = +c;
        this.l = +l;
        this.opacity = +opacity;
    }
    function hcl2lab$1(o) {
        if (isNaN(o.h))
            return new Lab$2(o.l, 0, 0, o.opacity);
        var h = o.h * deg2rad$2;
        return new Lab$2(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }
    define$2(Hcl$2, hcl$2, extend$2(Color$2, {
        brighter: function (k) {
            return new Hcl$2(this.h, this.c, this.l + K$1 * (k == null ? 1 : k), this.opacity);
        },
        darker: function (k) {
            return new Hcl$2(this.h, this.c, this.l - K$1 * (k == null ? 1 : k), this.opacity);
        },
        rgb: function () {
            return hcl2lab$1(this).rgb();
        }
    }));

    var A$2 = -0.14861, B$2 = +1.78277, C$2 = -0.29227, D$2 = -0.90649, E$2 = +1.97294, ED$2 = E$2 * D$2, EB$2 = E$2 * B$2, BC_DA$2 = B$2 * C$2 - D$2 * A$2;
    function cubehelixConvert$2(o) {
        if (o instanceof Cubehelix$2)
            return new Cubehelix$2(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Rgb$2))
            o = rgbConvert$2(o);
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA$2 * b + ED$2 * r - EB$2 * g) / (BC_DA$2 + ED$2 - EB$2), bl = b - l, k = (E$2 * (g - l) - C$2 * bl) / D$2, s = Math.sqrt(k * k + bl * bl) / (E$2 * l * (1 - l)), // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * rad2deg$2 - 120 : NaN;
        return new Cubehelix$2(h < 0 ? h + 360 : h, s, l, o.opacity);
    }
    function cubehelix$2(h, s, l, opacity) {
        return arguments.length === 1 ? cubehelixConvert$2(h) : new Cubehelix$2(h, s, l, opacity == null ? 1 : opacity);
    }
    function Cubehelix$2(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define$2(Cubehelix$2, cubehelix$2, extend$2(Color$2, {
        brighter: function (k) {
            k = k == null ? brighter$2 : Math.pow(brighter$2, k);
            return new Cubehelix$2(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$2 : Math.pow(darker$2, k);
            return new Cubehelix$2(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad$2, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
            return new Rgb$2(255 * (l + a * (A$2 * cosh + B$2 * sinh)), 255 * (l + a * (C$2 * cosh + D$2 * sinh)), 255 * (l + a * (E$2 * cosh)), this.opacity);
        }
    }));

    function basis(t1, v0, v1, v2, v3) {
        var t2 = t1 * t1, t3 = t2 * t1;
        return ((1 - 3 * t1 + 3 * t2 - t3) * v0
            + (4 - 6 * t2 + 3 * t3) * v1
            + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
            + t3 * v3) / 6;
    }
    function basis$1 (values) {
        var n = values.length - 1;
        return function (t) {
            var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
            return basis((t - i / n) * n, v0, v1, v2, v3);
        };
    }

    function basisClosed (values) {
        var n = values.length;
        return function (t) {
            var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
            return basis((t - i / n) * n, v0, v1, v2, v3);
        };
    }

    function constant$c (x) {
        return function () {
            return x;
        };
    }

    function linear$3(a, d) {
        return function (t) {
            return a + t * d;
        };
    }
    function exponential$1(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
            return Math.pow(a + t * b, y);
        };
    }
    function hue(a, b) {
        var d = b - a;
        return d ? linear$3(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$c(isNaN(a) ? b : a);
    }
    function gamma$1(y) {
        return (y = +y) === 1 ? nogamma$1 : function (a, b) {
            return b - a ? exponential$1(a, b, y) : constant$c(isNaN(a) ? b : a);
        };
    }
    function nogamma$1(a, b) {
        var d = b - a;
        return d ? linear$3(a, d) : constant$c(isNaN(a) ? b : a);
    }

    var rgb$3 = (function rgbGamma(y) {
        var color = gamma$1(y);
        function rgb(start, end) {
            var r = color((start = rgb$2(start)).r, (end = rgb$2(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = nogamma$1(start.opacity, end.opacity);
            return function (t) {
                start.r = r(t);
                start.g = g(t);
                start.b = b(t);
                start.opacity = opacity(t);
                return start + "";
            };
        }
        rgb.gamma = rgbGamma;
        return rgb;
    })(1);
    function rgbSpline(spline) {
        return function (colors) {
            var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color;
            for (i = 0; i < n; ++i) {
                color = rgb$2(colors[i]);
                r[i] = color.r || 0;
                g[i] = color.g || 0;
                b[i] = color.b || 0;
            }
            r = spline(r);
            g = spline(g);
            b = spline(b);
            color.opacity = 1;
            return function (t) {
                color.r = r(t);
                color.g = g(t);
                color.b = b(t);
                return color + "";
            };
        };
    }
    var rgbBasis = rgbSpline(basis$1);
    var rgbBasisClosed = rgbSpline(basisClosed);

    function array$2 (a, b) {
        var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
        for (i = 0; i < na; ++i)
            x[i] = value(a[i], b[i]);
        for (; i < nb; ++i)
            c[i] = b[i];
        return function (t) {
            for (i = 0; i < na; ++i)
                c[i] = x[i](t);
            return c;
        };
    }

    function date$1 (a, b) {
        var d = new Date;
        return a = +a, b -= a, function (t) {
            return d.setTime(a + b * t), d;
        };
    }

    function number$5 (a, b) {
        return a = +a, b -= a, function (t) {
            return a + b * t;
        };
    }

    function object$2 (a, b) {
        var i = {}, c = {}, k;
        if (a === null || typeof a !== "object")
            a = {};
        if (b === null || typeof b !== "object")
            b = {};
        for (k in b) {
            if (k in a) {
                i[k] = value(a[k], b[k]);
            }
            else {
                c[k] = b[k];
            }
        }
        return function (t) {
            for (k in i)
                c[k] = i[k](t);
            return c;
        };
    }

    var reA$1 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB$1 = new RegExp(reA$1.source, "g");
    function zero$1(b) {
        return function () {
            return b;
        };
    }
    function one$1(b) {
        return function (t) {
            return b(t) + "";
        };
    }
    function string (a, b) {
        var bi = reA$1.lastIndex = reB$1.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators
        // Coerce inputs to strings.
        a = a + "", b = b + "";
        // Interpolate pairs of numbers in a & b.
        while ((am = reA$1.exec(a))
            && (bm = reB$1.exec(b))) {
            if ((bs = bm.index) > bi) { // a string precedes the next number in b
                bs = b.slice(bi, bs);
                if (s[i])
                    s[i] += bs; // coalesce with previous string
                else
                    s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
                if (s[i])
                    s[i] += bm; // coalesce with previous string
                else
                    s[++i] = bm;
            }
            else { // interpolate non-matching numbers
                s[++i] = null;
                q.push({ i: i, x: number$5(am, bm) });
            }
            bi = reB$1.lastIndex;
        }
        // Add remains of b.
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
                s[i] += bs; // coalesce with previous string
            else
                s[++i] = bs;
        }
        // Special optimization for only a single match.
        // Otherwise, interpolate each of the numbers and rejoin the string.
        return s.length < 2 ? (q[0]
            ? one$1(q[0].x)
            : zero$1(b))
            : (b = q.length, function (t) {
                for (var i = 0, o; i < b; ++i)
                    s[(o = q[i]).i] = o.x(t);
                return s.join("");
            });
    }

    function value (a, b) {
        var t = typeof b, c;
        return b == null || t === "boolean" ? constant$c(b)
            : (t === "number" ? number$5
                : t === "string" ? ((c = color$2(b)) ? (b = c, rgb$3) : string)
                    : b instanceof color$2 ? rgb$3
                        : b instanceof Date ? date$1
                            : Array.isArray(b) ? array$2
                                : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$2
                                    : number$5)(a, b);
    }

    function round (a, b) {
        return a = +a, b -= a, function (t) {
            return Math.round(a + b * t);
        };
    }

    var degrees$2 = 180 / Math.PI;
    var identity$a = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        scaleX: 1,
        scaleY: 1
    };
    function decompose$1 (a, b, c, d, e, f) {
        var scaleX, scaleY, skewX;
        if (scaleX = Math.sqrt(a * a + b * b))
            a /= scaleX, b /= scaleX;
        if (skewX = a * c + b * d)
            c -= a * skewX, d -= b * skewX;
        if (scaleY = Math.sqrt(c * c + d * d))
            c /= scaleY, d /= scaleY, skewX /= scaleY;
        if (a * d < b * c)
            a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
        return {
            translateX: e,
            translateY: f,
            rotate: Math.atan2(b, a) * degrees$2,
            skewX: Math.atan(skewX) * degrees$2,
            scaleX: scaleX,
            scaleY: scaleY
        };
    }

    var cssNode$1, cssRoot$1, cssView$1, svgNode$1;
    function parseCss$1(value) {
        if (value === "none")
            return identity$a;
        if (!cssNode$1)
            cssNode$1 = document.createElement("DIV"), cssRoot$1 = document.documentElement, cssView$1 = document.defaultView;
        cssNode$1.style.transform = value;
        value = cssView$1.getComputedStyle(cssRoot$1.appendChild(cssNode$1), null).getPropertyValue("transform");
        cssRoot$1.removeChild(cssNode$1);
        value = value.slice(7, -1).split(",");
        return decompose$1(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
    }
    function parseSvg$1(value) {
        if (value == null)
            return identity$a;
        if (!svgNode$1)
            svgNode$1 = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svgNode$1.setAttribute("transform", value);
        if (!(value = svgNode$1.transform.baseVal.consolidate()))
            return identity$a;
        value = value.matrix;
        return decompose$1(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform$1(parse, pxComma, pxParen, degParen) {
        function pop(s) {
            return s.length ? s.pop() + " " : "";
        }
        function translate(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push("translate(", null, pxComma, null, pxParen);
                q.push({ i: i - 4, x: number$5(xa, xb) }, { i: i - 2, x: number$5(ya, yb) });
            }
            else if (xb || yb) {
                s.push("translate(" + xb + pxComma + yb + pxParen);
            }
        }
        function rotate(a, b, s, q) {
            if (a !== b) {
                if (a - b > 180)
                    b += 360;
                else if (b - a > 180)
                    a += 360; // shortest path
                q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number$5(a, b) });
            }
            else if (b) {
                s.push(pop(s) + "rotate(" + b + degParen);
            }
        }
        function skewX(a, b, s, q) {
            if (a !== b) {
                q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number$5(a, b) });
            }
            else if (b) {
                s.push(pop(s) + "skewX(" + b + degParen);
            }
        }
        function scale(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push(pop(s) + "scale(", null, ",", null, ")");
                q.push({ i: i - 4, x: number$5(xa, xb) }, { i: i - 2, x: number$5(ya, yb) });
            }
            else if (xb !== 1 || yb !== 1) {
                s.push(pop(s) + "scale(" + xb + "," + yb + ")");
            }
        }
        return function (a, b) {
            var s = [], // string constants and placeholders
            q = []; // number interpolators
            a = parse(a), b = parse(b);
            translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
            rotate(a.rotate, b.rotate, s, q);
            skewX(a.skewX, b.skewX, s, q);
            scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
            a = b = null; // gc
            return function (t) {
                var i = -1, n = q.length, o;
                while (++i < n)
                    s[(o = q[i]).i] = o.x(t);
                return s.join("");
            };
        };
    }
    var interpolateTransformCss$1 = interpolateTransform$1(parseCss$1, "px, ", "px)", "deg)");
    var interpolateTransformSvg$1 = interpolateTransform$1(parseSvg$1, ", ", ")", ")");

    var rho$1 = Math.SQRT2, rho2$1 = 2, rho4$1 = 4, epsilon2$2 = 1e-12;
    function cosh$1(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function sinh$1(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function tanh$1(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    // p0 = [ux0, uy0, w0]
    // p1 = [ux1, uy1, w1]
    function zoom (p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        // Special case for u0 ≅ u1.
        if (d2 < epsilon2$2) {
            S = Math.log(w1 / w0) / rho$1;
            i = function (t) {
                return [
                    ux0 + t * dx,
                    uy0 + t * dy,
                    w0 * Math.exp(rho$1 * t * S)
                ];
            };
        }
        // General case.
        else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4$1 * d2) / (2 * w0 * rho2$1 * d1), b1 = (w1 * w1 - w0 * w0 - rho4$1 * d2) / (2 * w1 * rho2$1 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / rho$1;
            i = function (t) {
                var s = t * S, coshr0 = cosh$1(r0), u = w0 / (rho2$1 * d1) * (coshr0 * tanh$1(rho$1 * s + r0) - sinh$1(r0));
                return [
                    ux0 + u * dx,
                    uy0 + u * dy,
                    w0 * coshr0 / cosh$1(rho$1 * s + r0)
                ];
            };
        }
        i.duration = S * 1000;
        return i;
    }

    function hsl$3(hue) {
        return function (start, end) {
            var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h), s = nogamma$1(start.s, end.s), l = nogamma$1(start.l, end.l), opacity = nogamma$1(start.opacity, end.opacity);
            return function (t) {
                start.h = h(t);
                start.s = s(t);
                start.l = l(t);
                start.opacity = opacity(t);
                return start + "";
            };
        };
    }
    var hsl$4 = hsl$3(hue);
    var hslLong = hsl$3(nogamma$1);

    function lab$3(start, end) {
        var l = nogamma$1((start = lab$2(start)).l, (end = lab$2(end)).l), a = nogamma$1(start.a, end.a), b = nogamma$1(start.b, end.b), opacity = nogamma$1(start.opacity, end.opacity);
        return function (t) {
            start.l = l(t);
            start.a = a(t);
            start.b = b(t);
            start.opacity = opacity(t);
            return start + "";
        };
    }

    function hcl$3(hue) {
        return function (start, end) {
            var h = hue((start = hcl$2(start)).h, (end = hcl$2(end)).h), c = nogamma$1(start.c, end.c), l = nogamma$1(start.l, end.l), opacity = nogamma$1(start.opacity, end.opacity);
            return function (t) {
                start.h = h(t);
                start.c = c(t);
                start.l = l(t);
                start.opacity = opacity(t);
                return start + "";
            };
        };
    }
    var hcl$4 = hcl$3(hue);
    var hclLong = hcl$3(nogamma$1);

    function cubehelix$3(hue) {
        return (function cubehelixGamma(y) {
            y = +y;
            function cubehelix(start, end) {
                var h = hue((start = cubehelix$2(start)).h, (end = cubehelix$2(end)).h), s = nogamma$1(start.s, end.s), l = nogamma$1(start.l, end.l), opacity = nogamma$1(start.opacity, end.opacity);
                return function (t) {
                    start.h = h(t);
                    start.s = s(t);
                    start.l = l(Math.pow(t, y));
                    start.opacity = opacity(t);
                    return start + "";
                };
            }
            cubehelix.gamma = cubehelixGamma;
            return cubehelix;
        })(1);
    }
    var cubehelix$4 = cubehelix$3(hue);
    var cubehelixLong = cubehelix$3(nogamma$1);

    function quantize$1 (interpolator, n) {
        var samples = new Array(n);
        for (var i = 0; i < n; ++i)
            samples[i] = interpolator(i / (n - 1));
        return samples;
    }

    var pi$5 = Math.PI, tau$5 = 2 * pi$5, epsilon$5 = 1e-6, tauEpsilon$1 = tau$5 - epsilon$5;
    function Path$1() {
        this._x0 = this._y0 = // start of current subpath
            this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
    }
    function path$1() {
        return new Path$1;
    }
    Path$1.prototype = path$1.prototype = {
        constructor: Path$1,
        moveTo: function (x, y) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
        },
        closePath: function () {
            if (this._x1 !== null) {
                this._x1 = this._x0, this._y1 = this._y0;
                this._ += "Z";
            }
        },
        lineTo: function (x, y) {
            this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        quadraticCurveTo: function (x1, y1, x, y) {
            this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        bezierCurveTo: function (x1, y1, x2, y2, x, y) {
            this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        arcTo: function (x1, y1, x2, y2, r) {
            x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
            var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
            // Is the radius negative? Error.
            if (r < 0)
                throw new Error("negative radius: " + r);
            // Is this path empty? Move to (x1,y1).
            if (this._x1 === null) {
                this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
            }
            // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
            else if (!(l01_2 > epsilon$5)) ;
            // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
            // Equivalently, is (x1,y1) coincident with (x2,y2)?
            // Or, is the radius zero? Line to (x1,y1).
            else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$5) || !r) {
                this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
            }
            // Otherwise, draw an arc!
            else {
                var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$5 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
                // If the start tangent is not coincident with (x0,y0), line to.
                if (Math.abs(t01 - 1) > epsilon$5) {
                    this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
                }
                this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
            }
        },
        arc: function (x, y, r, a0, a1, ccw) {
            x = +x, y = +y, r = +r;
            var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
            // Is the radius negative? Error.
            if (r < 0)
                throw new Error("negative radius: " + r);
            // Is this path empty? Move to (x0,y0).
            if (this._x1 === null) {
                this._ += "M" + x0 + "," + y0;
            }
            // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
            else if (Math.abs(this._x1 - x0) > epsilon$5 || Math.abs(this._y1 - y0) > epsilon$5) {
                this._ += "L" + x0 + "," + y0;
            }
            // Is this arc empty? We’re done.
            if (!r)
                return;
            // Does the angle go the wrong way? Flip the direction.
            if (da < 0)
                da = da % tau$5 + tau$5;
            // Is this a complete circle? Draw two arcs to complete the circle.
            if (da > tauEpsilon$1) {
                this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
            }
            // Is this arc non-empty? Draw an arc!
            else if (da > epsilon$5) {
                this._ += "A" + r + "," + r + ",0," + (+(da >= pi$5)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
            }
        },
        rect: function (x, y, w, h) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
        },
        toString: function () {
            return this._;
        }
    };

    function area$1 (polygon) {
        var i = -1, n = polygon.length, a, b = polygon[n - 1], area = 0;
        while (++i < n) {
            a = b;
            b = polygon[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area / 2;
    }

    function centroid$1 (polygon) {
        var i = -1, n = polygon.length, x = 0, y = 0, a, b = polygon[n - 1], c, k = 0;
        while (++i < n) {
            a = b;
            b = polygon[i];
            k += c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$1 (a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
        var n = points.length, indexes = [0, 1], size = 2;
        for (var i = 2; i < n; ++i) {
            while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0)
                --size;
            indexes[size++] = i;
        }
        return indexes.slice(0, size); // remove popped points
    }
    function hull (points) {
        if ((n = points.length) < 3)
            return null;
        var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
        for (i = 0; i < n; ++i)
            sortedPoints[i] = [+points[i][0], +points[i][1], i];
        sortedPoints.sort(lexicographicOrder);
        for (i = 0; i < n; ++i)
            flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
        var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
        // Construct the hull polygon, removing possible duplicate endpoints.
        var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull = [];
        // Add upper hull in right-to-l order.
        // Then add lower hull in left-to-right order.
        for (i = upperIndexes.length - 1; i >= 0; --i)
            hull.push(points[sortedPoints[upperIndexes[i]][2]]);
        for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)
            hull.push(points[sortedPoints[lowerIndexes[i]][2]]);
        return hull;
    }

    function contains$1 (polygon, point) {
        var n = polygon.length, p = polygon[n - 1], x = point[0], y = point[1], x0 = p[0], y0 = p[1], x1, y1, inside = false;
        for (var i = 0; i < n; ++i) {
            p = polygon[i], x1 = p[0], y1 = p[1];
            if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1))
                inside = !inside;
            x0 = x1, y0 = y1;
        }
        return inside;
    }

    function length$2 (polygon) {
        var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
        while (++i < n) {
            xa = xb;
            ya = yb;
            b = polygon[i];
            xb = b[0];
            yb = b[1];
            xa -= xb;
            ya -= yb;
            perimeter += Math.sqrt(xa * xa + ya * ya);
        }
        return perimeter;
    }

    function tree_add$1 (d) {
        var x = +this._x.call(null, d), y = +this._y.call(null, d);
        return add$2(this.cover(x, y), x, y, d);
    }
    function add$2(tree, x, y, d) {
        if (isNaN(x) || isNaN(y))
            return tree; // ignore invalid points
        var parent, node = tree._root, leaf = { data: d }, x0 = tree._x0, y0 = tree._y0, x1 = tree._x1, y1 = tree._y1, xm, ym, xp, yp, right, bottom, i, j;
        // If the tree is empty, initialize the root as a leaf.
        if (!node)
            return tree._root = leaf, tree;
        // Find the existing leaf for the new point, or add it.
        while (node.length) {
            if (right = x >= (xm = (x0 + x1) / 2))
                x0 = xm;
            else
                x1 = xm;
            if (bottom = y >= (ym = (y0 + y1) / 2))
                y0 = ym;
            else
                y1 = ym;
            if (parent = node, !(node = node[i = bottom << 1 | right]))
                return parent[i] = leaf, tree;
        }
        // Is the new point is exactly coincident with the existing point?
        xp = +tree._x.call(null, node.data);
        yp = +tree._y.call(null, node.data);
        if (x === xp && y === yp)
            return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
        // Otherwise, split the leaf node until the old and new point are separated.
        do {
            parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
            if (right = x >= (xm = (x0 + x1) / 2))
                x0 = xm;
            else
                x1 = xm;
            if (bottom = y >= (ym = (y0 + y1) / 2))
                y0 = ym;
            else
                y1 = ym;
        } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
        return parent[j] = node, parent[i] = leaf, tree;
    }
    function addAll$1(data) {
        var d, i, n = data.length, x, y, xz = new Array(n), yz = new Array(n), x0 = Infinity, y0 = Infinity, x1 = -Infinity, y1 = -Infinity;
        // Compute the points and their extent.
        for (i = 0; i < n; ++i) {
            if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d)))
                continue;
            xz[i] = x;
            yz[i] = y;
            if (x < x0)
                x0 = x;
            if (x > x1)
                x1 = x;
            if (y < y0)
                y0 = y;
            if (y > y1)
                y1 = y;
        }
        // If there were no (valid) points, inherit the existing extent.
        if (x1 < x0)
            x0 = this._x0, x1 = this._x1;
        if (y1 < y0)
            y0 = this._y0, y1 = this._y1;
        // Expand the tree to cover the new points.
        this.cover(x0, y0).cover(x1, y1);
        // Add the new points.
        for (i = 0; i < n; ++i) {
            add$2(this, xz[i], yz[i], data[i]);
        }
        return this;
    }

    function tree_cover$1 (x, y) {
        if (isNaN(x = +x) || isNaN(y = +y))
            return this; // ignore invalid points
        var x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1;
        // If the quadtree has no extent, initialize them.
        // Integer extent are necessary so that if we later double the extent,
        // the existing quadrant boundaries don’t change due to floating point error!
        if (isNaN(x0)) {
            x1 = (x0 = Math.floor(x)) + 1;
            y1 = (y0 = Math.floor(y)) + 1;
        }
        // Otherwise, double repeatedly to cover.
        else if (x0 > x || x > x1 || y0 > y || y > y1) {
            var z = x1 - x0, node = this._root, parent, i;
            switch (i = (y < (y0 + y1) / 2) << 1 | (x < (x0 + x1) / 2)) {
                case 0: {
                    do
                        parent = new Array(4), parent[i] = node, node = parent;
                    while (z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1);
                    break;
                }
                case 1: {
                    do
                        parent = new Array(4), parent[i] = node, node = parent;
                    while (z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1);
                    break;
                }
                case 2: {
                    do
                        parent = new Array(4), parent[i] = node, node = parent;
                    while (z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y);
                    break;
                }
                case 3: {
                    do
                        parent = new Array(4), parent[i] = node, node = parent;
                    while (z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y);
                    break;
                }
            }
            if (this._root && this._root.length)
                this._root = node;
        }
        // If the quadtree covers the point already, just return.
        else
            return this;
        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        return this;
    }

    function tree_data$1 () {
        var data = [];
        this.visit(function (node) {
            if (!node.length)
                do
                    data.push(node.data);
                while (node = node.next);
        });
        return data;
    }

    function tree_extent$1 (_) {
        return arguments.length
            ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
            : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad$1 (node, x0, y0, x1, y1) {
        this.node = node;
        this.x0 = x0;
        this.y0 = y0;
        this.x1 = x1;
        this.y1 = y1;
    }

    function tree_find$1 (x, y, radius) {
        var data, x0 = this._x0, y0 = this._y0, x1, y1, x2, y2, x3 = this._x1, y3 = this._y1, quads = [], node = this._root, q, i;
        if (node)
            quads.push(new Quad$1(node, x0, y0, x3, y3));
        if (radius == null)
            radius = Infinity;
        else {
            x0 = x - radius, y0 = y - radius;
            x3 = x + radius, y3 = y + radius;
            radius *= radius;
        }
        while (q = quads.pop()) {
            // Stop searching if this quadrant can’t contain a closer node.
            if (!(node = q.node)
                || (x1 = q.x0) > x3
                || (y1 = q.y0) > y3
                || (x2 = q.x1) < x0
                || (y2 = q.y1) < y0)
                continue;
            // Bisect the current quadrant.
            if (node.length) {
                var xm = (x1 + x2) / 2, ym = (y1 + y2) / 2;
                quads.push(new Quad$1(node[3], xm, ym, x2, y2), new Quad$1(node[2], x1, ym, xm, y2), new Quad$1(node[1], xm, y1, x2, ym), new Quad$1(node[0], x1, y1, xm, ym));
                // Visit the closest quadrant first.
                if (i = (y >= ym) << 1 | (x >= xm)) {
                    q = quads[quads.length - 1];
                    quads[quads.length - 1] = quads[quads.length - 1 - i];
                    quads[quads.length - 1 - i] = q;
                }
            }
            // Visit this point. (Visiting coincident points isn’t necessary!)
            else {
                var dx = x - +this._x.call(null, node.data), dy = y - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
                if (d2 < radius) {
                    var d = Math.sqrt(radius = d2);
                    x0 = x - d, y0 = y - d;
                    x3 = x + d, y3 = y + d;
                    data = node.data;
                }
            }
        }
        return data;
    }

    function tree_remove$1 (d) {
        if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d)))
            return this; // ignore invalid points
        var parent, node = this._root, retainer, previous, next, x0 = this._x0, y0 = this._y0, x1 = this._x1, y1 = this._y1, x, y, xm, ym, right, bottom, i, j;
        // If the tree is empty, initialize the root as a leaf.
        if (!node)
            return this;
        // Find the leaf node for the point.
        // While descending, also retain the deepest parent with a non-removed sibling.
        if (node.length)
            while (true) {
                if (right = x >= (xm = (x0 + x1) / 2))
                    x0 = xm;
                else
                    x1 = xm;
                if (bottom = y >= (ym = (y0 + y1) / 2))
                    y0 = ym;
                else
                    y1 = ym;
                if (!(parent = node, node = node[i = bottom << 1 | right]))
                    return this;
                if (!node.length)
                    break;
                if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3])
                    retainer = parent, j = i;
            }
        // Find the point to remove.
        while (node.data !== d)
            if (!(previous = node, node = node.next))
                return this;
        if (next = node.next)
            delete node.next;
        // If there are multiple coincident points, remove just the point.
        if (previous)
            return (next ? previous.next = next : delete previous.next), this;
        // If this is the root point, remove it.
        if (!parent)
            return this._root = next, this;
        // Remove this leaf.
        next ? parent[i] = next : delete parent[i];
        // If the parent now contains exactly one leaf, collapse superfluous parents.
        if ((node = parent[0] || parent[1] || parent[2] || parent[3])
            && node === (parent[3] || parent[2] || parent[1] || parent[0])
            && !node.length) {
            if (retainer)
                retainer[j] = node;
            else
                this._root = node;
        }
        return this;
    }
    function removeAll$1(data) {
        for (var i = 0, n = data.length; i < n; ++i)
            this.remove(data[i]);
        return this;
    }

    function tree_root$1 () {
        return this._root;
    }

    function tree_size$1 () {
        var size = 0;
        this.visit(function (node) {
            if (!node.length)
                do
                    ++size;
                while (node = node.next);
        });
        return size;
    }

    function tree_visit$1 (callback) {
        var quads = [], q, node = this._root, child, x0, y0, x1, y1;
        if (node)
            quads.push(new Quad$1(node, this._x0, this._y0, this._x1, this._y1));
        while (q = quads.pop()) {
            if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
                var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
                if (child = node[3])
                    quads.push(new Quad$1(child, xm, ym, x1, y1));
                if (child = node[2])
                    quads.push(new Quad$1(child, x0, ym, xm, y1));
                if (child = node[1])
                    quads.push(new Quad$1(child, xm, y0, x1, ym));
                if (child = node[0])
                    quads.push(new Quad$1(child, x0, y0, xm, ym));
            }
        }
        return this;
    }

    function tree_visitAfter$1 (callback) {
        var quads = [], next = [], q;
        if (this._root)
            quads.push(new Quad$1(this._root, this._x0, this._y0, this._x1, this._y1));
        while (q = quads.pop()) {
            var node = q.node;
            if (node.length) {
                var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
                if (child = node[0])
                    quads.push(new Quad$1(child, x0, y0, xm, ym));
                if (child = node[1])
                    quads.push(new Quad$1(child, xm, y0, x1, ym));
                if (child = node[2])
                    quads.push(new Quad$1(child, x0, ym, xm, y1));
                if (child = node[3])
                    quads.push(new Quad$1(child, xm, ym, x1, y1));
            }
            next.push(q);
        }
        while (q = next.pop()) {
            callback(q.node, q.x0, q.y0, q.x1, q.y1);
        }
        return this;
    }

    function defaultX$1(d) {
        return d[0];
    }
    function tree_x$1 (_) {
        return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY$1(d) {
        return d[1];
    }
    function tree_y$1 (_) {
        return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree$1(nodes, x, y) {
        var tree = new Quadtree$1(x == null ? defaultX$1 : x, y == null ? defaultY$1 : y, NaN, NaN, NaN, NaN);
        return nodes == null ? tree : tree.addAll(nodes);
    }
    function Quadtree$1(x, y, x0, y0, x1, y1) {
        this._x = x;
        this._y = y;
        this._x0 = x0;
        this._y0 = y0;
        this._x1 = x1;
        this._y1 = y1;
        this._root = undefined;
    }
    function leaf_copy$1(leaf) {
        var copy = { data: leaf.data }, next = copy;
        while (leaf = leaf.next)
            next = next.next = { data: leaf.data };
        return copy;
    }
    var treeProto$1 = quadtree$1.prototype = Quadtree$1.prototype;
    treeProto$1.copy = function () {
        var copy = new Quadtree$1(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
        if (!node)
            return copy;
        if (!node.length)
            return copy._root = leaf_copy$1(node), copy;
        nodes = [{ source: node, target: copy._root = new Array(4) }];
        while (node = nodes.pop()) {
            for (var i = 0; i < 4; ++i) {
                if (child = node.source[i]) {
                    if (child.length)
                        nodes.push({ source: child, target: node.target[i] = new Array(4) });
                    else
                        node.target[i] = leaf_copy$1(child);
                }
            }
        }
        return copy;
    };
    treeProto$1.add = tree_add$1;
    treeProto$1.addAll = addAll$1;
    treeProto$1.cover = tree_cover$1;
    treeProto$1.data = tree_data$1;
    treeProto$1.extent = tree_extent$1;
    treeProto$1.find = tree_find$1;
    treeProto$1.remove = tree_remove$1;
    treeProto$1.removeAll = removeAll$1;
    treeProto$1.root = tree_root$1;
    treeProto$1.size = tree_size$1;
    treeProto$1.visit = tree_visit$1;
    treeProto$1.visitAfter = tree_visitAfter$1;
    treeProto$1.x = tree_x$1;
    treeProto$1.y = tree_y$1;

    var slice$7 = [].slice;

    var noabort = {};
    function Queue(size) {
        this._size = size;
        this._call =
            this._error = null;
        this._tasks = [];
        this._data = [];
        this._waiting =
            this._active =
                this._ended =
                    this._start = 0; // inside a synchronous task callback?
    }
    Queue.prototype = queue.prototype = {
        constructor: Queue,
        defer: function (callback) {
            if (typeof callback !== "function")
                throw new Error("invalid callback");
            if (this._call)
                throw new Error("defer after await");
            if (this._error != null)
                return this;
            var t = slice$7.call(arguments, 1);
            t.push(callback);
            ++this._waiting, this._tasks.push(t);
            poke$1(this);
            return this;
        },
        abort: function () {
            if (this._error == null)
                abort(this, new Error("abort"));
            return this;
        },
        await: function (callback) {
            if (typeof callback !== "function")
                throw new Error("invalid callback");
            if (this._call)
                throw new Error("multiple await");
            this._call = function (error, results) { callback.apply(null, [error].concat(results)); };
            maybeNotify(this);
            return this;
        },
        awaitAll: function (callback) {
            if (typeof callback !== "function")
                throw new Error("invalid callback");
            if (this._call)
                throw new Error("multiple await");
            this._call = callback;
            maybeNotify(this);
            return this;
        }
    };
    function poke$1(q) {
        if (!q._start) {
            try {
                start$2(q);
            } // let the current task complete
            catch (e) {
                if (q._tasks[q._ended + q._active - 1])
                    abort(q, e); // task errored synchronously
                else if (!q._data)
                    throw e; // await callback errored synchronously
            }
        }
    }
    function start$2(q) {
        while (q._start = q._waiting && q._active < q._size) {
            var i = q._ended + q._active, t = q._tasks[i], j = t.length - 1, c = t[j];
            t[j] = end(q, i);
            --q._waiting, ++q._active;
            t = c.apply(null, t);
            if (!q._tasks[i])
                continue; // task finished synchronously
            q._tasks[i] = t || noabort;
        }
    }
    function end(q, i) {
        return function (e, r) {
            if (!q._tasks[i])
                return; // ignore multiple callbacks
            --q._active, ++q._ended;
            q._tasks[i] = null;
            if (q._error != null)
                return; // ignore secondary errors
            if (e != null) {
                abort(q, e);
            }
            else {
                q._data[i] = r;
                if (q._waiting)
                    poke$1(q);
                else
                    maybeNotify(q);
            }
        };
    }
    function abort(q, e) {
        var i = q._tasks.length, t;
        q._error = e; // ignore active callbacks
        q._data = undefined; // allow gc
        q._waiting = NaN; // prevent starting
        while (--i >= 0) {
            if (t = q._tasks[i]) {
                q._tasks[i] = null;
                if (t.abort) {
                    try {
                        t.abort();
                    }
                    catch (e) { /* ignore */ }
                }
            }
        }
        q._active = NaN; // allow notification
        maybeNotify(q);
    }
    function maybeNotify(q) {
        if (!q._active && q._call) {
            var d = q._data;
            q._data = undefined; // allow gc
            q._call(q._error, d);
        }
    }
    function queue(concurrency) {
        if (concurrency == null)
            concurrency = Infinity;
        else if (!((concurrency = +concurrency) >= 1))
            throw new Error("invalid concurrency");
        return new Queue(concurrency);
    }

    function defaultSource$1 () {
        return Math.random();
    }

    var uniform = (function sourceRandomUniform(source) {
        function randomUniform(min, max) {
            min = min == null ? 0 : +min;
            max = max == null ? 1 : +max;
            if (arguments.length === 1)
                max = min, min = 0;
            else
                max -= min;
            return function () {
                return source() * max + min;
            };
        }
        randomUniform.source = sourceRandomUniform;
        return randomUniform;
    })(defaultSource$1);

    var normal = (function sourceRandomNormal(source) {
        function randomNormal(mu, sigma) {
            var x, r;
            mu = mu == null ? 0 : +mu;
            sigma = sigma == null ? 1 : +sigma;
            return function () {
                var y;
                // If available, use the second previously-generated uniform random.
                if (x != null)
                    y = x, x = null;
                // Otherwise, generate a new x and y.
                else
                    do {
                        x = source() * 2 - 1;
                        y = source() * 2 - 1;
                        r = x * x + y * y;
                    } while (!r || r > 1);
                return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
            };
        }
        randomNormal.source = sourceRandomNormal;
        return randomNormal;
    })(defaultSource$1);

    var logNormal = (function sourceRandomLogNormal(source) {
        function randomLogNormal() {
            var randomNormal = normal.source(source).apply(this, arguments);
            return function () {
                return Math.exp(randomNormal());
            };
        }
        randomLogNormal.source = sourceRandomLogNormal;
        return randomLogNormal;
    })(defaultSource$1);

    var irwinHall = (function sourceRandomIrwinHall(source) {
        function randomIrwinHall(n) {
            return function () {
                for (var sum = 0, i = 0; i < n; ++i)
                    sum += source();
                return sum;
            };
        }
        randomIrwinHall.source = sourceRandomIrwinHall;
        return randomIrwinHall;
    })(defaultSource$1);

    var bates = (function sourceRandomBates(source) {
        function randomBates(n) {
            var randomIrwinHall = irwinHall.source(source)(n);
            return function () {
                return randomIrwinHall() / n;
            };
        }
        randomBates.source = sourceRandomBates;
        return randomBates;
    })(defaultSource$1);

    var exponential$2 = (function sourceRandomExponential(source) {
        function randomExponential(lambda) {
            return function () {
                return -Math.log(1 - source()) / lambda;
            };
        }
        randomExponential.source = sourceRandomExponential;
        return randomExponential;
    })(defaultSource$1);

    function request (url, callback) {
        var request, event = dispatch("beforesend", "progress", "load", "error"), mimeType, headers = map(), xhr = new XMLHttpRequest, user = null, password = null, response, responseType, timeout = 0;
        // If IE does not support CORS, use XDomainRequest.
        if (typeof XDomainRequest !== "undefined"
            && !("withCredentials" in xhr)
            && /^(http(s)?:)?\/\//.test(url))
            xhr = new XDomainRequest;
        "onload" in xhr
            ? xhr.onload = xhr.onerror = xhr.ontimeout = respond
            : xhr.onreadystatechange = function (o) { xhr.readyState > 3 && respond(o); };
        function respond(o) {
            var status = xhr.status, result;
            if (!status && hasResponse(xhr)
                || status >= 200 && status < 300
                || status === 304) {
                if (response) {
                    try {
                        result = response.call(request, xhr);
                    }
                    catch (e) {
                        event.call("error", request, e);
                        return;
                    }
                }
                else {
                    result = xhr;
                }
                event.call("load", request, result);
            }
            else {
                event.call("error", request, o);
            }
        }
        xhr.onprogress = function (e) {
            event.call("progress", request, e);
        };
        request = {
            header: function (name, value) {
                name = (name + "").toLowerCase();
                if (arguments.length < 2)
                    return headers.get(name);
                if (value == null)
                    headers.remove(name);
                else
                    headers.set(name, value + "");
                return request;
            },
            // If mimeType is non-null and no Accept header is set, a default is used.
            mimeType: function (value) {
                if (!arguments.length)
                    return mimeType;
                mimeType = value == null ? null : value + "";
                return request;
            },
            // Specifies what type the response value should take;
            // for instance, arraybuffer, blob, document, or text.
            responseType: function (value) {
                if (!arguments.length)
                    return responseType;
                responseType = value;
                return request;
            },
            timeout: function (value) {
                if (!arguments.length)
                    return timeout;
                timeout = +value;
                return request;
            },
            user: function (value) {
                return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
            },
            password: function (value) {
                return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
            },
            // Specify how to convert the response content to a specific type;
            // changes the callback value on "load" events.
            response: function (value) {
                response = value;
                return request;
            },
            // Alias for send("GET", …).
            get: function (data, callback) {
                return request.send("GET", data, callback);
            },
            // Alias for send("POST", …).
            post: function (data, callback) {
                return request.send("POST", data, callback);
            },
            // If callback is non-null, it will be used for error and load events.
            send: function (method, data, callback) {
                xhr.open(method, url, true, user, password);
                if (mimeType != null && !headers.has("accept"))
                    headers.set("accept", mimeType + ",*/*");
                if (xhr.setRequestHeader)
                    headers.each(function (value, name) { xhr.setRequestHeader(name, value); });
                if (mimeType != null && xhr.overrideMimeType)
                    xhr.overrideMimeType(mimeType);
                if (responseType != null)
                    xhr.responseType = responseType;
                if (timeout > 0)
                    xhr.timeout = timeout;
                if (callback == null && typeof data === "function")
                    callback = data, data = null;
                if (callback != null && callback.length === 1)
                    callback = fixCallback(callback);
                if (callback != null)
                    request.on("error", callback).on("load", function (xhr) { callback(null, xhr); });
                event.call("beforesend", request, xhr);
                xhr.send(data == null ? null : data);
                return request;
            },
            abort: function () {
                xhr.abort();
                return request;
            },
            on: function () {
                var value = event.on.apply(event, arguments);
                return value === event ? request : value;
            }
        };
        if (callback != null) {
            if (typeof callback !== "function")
                throw new Error("invalid callback: " + callback);
            return request.get(callback);
        }
        return request;
    }
    function fixCallback(callback) {
        return function (error, xhr) {
            callback(error == null ? xhr : null);
        };
    }
    function hasResponse(xhr) {
        var type = xhr.responseType;
        return type && type !== "text"
            ? xhr.response // null on error
            : xhr.responseText; // "" on error
    }

    function type$1 (defaultMimeType, response) {
        return function (url, callback) {
            var r = request(url).mimeType(defaultMimeType).response(response);
            if (callback != null) {
                if (typeof callback !== "function")
                    throw new Error("invalid callback: " + callback);
                return r.get(callback);
            }
            return r;
        };
    }

    var html = type$1("text/html", function (xhr) {
        return document.createRange().createContextualFragment(xhr.responseText);
    });

    var json = type$1("application/json", function (xhr) {
        return JSON.parse(xhr.responseText);
    });

    var text = type$1("text/plain", function (xhr) {
        return xhr.responseText;
    });

    var xml = type$1("application/xml", function (xhr) {
        var xml = xhr.responseXML;
        if (!xml)
            throw new Error("parse error");
        return xml;
    });

    var EOL$1 = {}, EOF$1 = {}, QUOTE$1 = 34, NEWLINE$1 = 10, RETURN$1 = 13;
    function objectConverter$1(columns) {
        return new Function("d", "return {" + columns.map(function (name, i) {
            return JSON.stringify(name) + ": d[" + i + "] || \"\"";
        }).join(",") + "}");
    }
    function customConverter$1(columns, f) {
        var object = objectConverter$1(columns);
        return function (row, i) {
            return f(object(row), i, columns);
        };
    }
    // Compute unique columns in order of discovery.
    function inferColumns$1(rows) {
        var columnSet = Object.create(null), columns = [];
        rows.forEach(function (row) {
            for (var column in row) {
                if (!(column in columnSet)) {
                    columns.push(columnSet[column] = column);
                }
            }
        });
        return columns;
    }
    function pad$1(value, width) {
        var s = value + "", length = s.length;
        return length < width ? new Array(width - length + 1).join(0) + s : s;
    }
    function formatYear$1(year) {
        return year < 0 ? "-" + pad$1(-year, 6)
            : year > 9999 ? "+" + pad$1(year, 6)
                : pad$1(year, 4);
    }
    function formatDate$1(date) {
        var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
        return isNaN(date) ? "Invalid Date"
            : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
                + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
                    : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
                        : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
                            : "");
    }
    function dsv$1 (delimiter) {
        var reFormat = new RegExp("[\"" + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
        function parse(text, f) {
            var convert, columns, rows = parseRows(text, function (row, i) {
                if (convert)
                    return convert(row, i - 1);
                columns = row, convert = f ? customConverter$1(row, f) : objectConverter$1(row);
            });
            rows.columns = columns || [];
            return rows;
        }
        function parseRows(text, f) {
            var rows = [], // output rows
            N = text.length, I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?
            // Strip the trailing newline.
            if (text.charCodeAt(N - 1) === NEWLINE$1)
                --N;
            if (text.charCodeAt(N - 1) === RETURN$1)
                --N;
            function token() {
                if (eof)
                    return EOF$1;
                if (eol)
                    return eol = false, EOL$1;
                // Unescape quotes.
                var i, j = I, c;
                if (text.charCodeAt(j) === QUOTE$1) {
                    while (I++ < N && text.charCodeAt(I) !== QUOTE$1 || text.charCodeAt(++I) === QUOTE$1)
                        ;
                    if ((i = I) >= N)
                        eof = true;
                    else if ((c = text.charCodeAt(I++)) === NEWLINE$1)
                        eol = true;
                    else if (c === RETURN$1) {
                        eol = true;
                        if (text.charCodeAt(I) === NEWLINE$1)
                            ++I;
                    }
                    return text.slice(j + 1, i - 1).replace(/""/g, "\"");
                }
                // Find next delimiter or newline.
                while (I < N) {
                    if ((c = text.charCodeAt(i = I++)) === NEWLINE$1)
                        eol = true;
                    else if (c === RETURN$1) {
                        eol = true;
                        if (text.charCodeAt(I) === NEWLINE$1)
                            ++I;
                    }
                    else if (c !== DELIMITER)
                        continue;
                    return text.slice(j, i);
                }
                // Return last token before EOF.
                return eof = true, text.slice(j, N);
            }
            while ((t = token()) !== EOF$1) {
                var row = [];
                while (t !== EOL$1 && t !== EOF$1)
                    row.push(t), t = token();
                if (f && (row = f(row, n++)) == null)
                    continue;
                rows.push(row);
            }
            return rows;
        }
        function preformatBody(rows, columns) {
            return rows.map(function (row) {
                return columns.map(function (column) {
                    return formatValue(row[column]);
                }).join(delimiter);
            });
        }
        function format(rows, columns) {
            if (columns == null)
                columns = inferColumns$1(rows);
            return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
        }
        function formatBody(rows, columns) {
            if (columns == null)
                columns = inferColumns$1(rows);
            return preformatBody(rows, columns).join("\n");
        }
        function formatRows(rows) {
            return rows.map(formatRow).join("\n");
        }
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(value) {
            return value == null ? ""
                : value instanceof Date ? formatDate$1(value)
                    : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
                        : value;
        }
        return {
            parse: parse,
            parseRows: parseRows,
            format: format,
            formatBody: formatBody,
            formatRows: formatRows,
            formatRow: formatRow,
            formatValue: formatValue
        };
    }

    var csv$1 = dsv$1(",");
    var csvParse$1 = csv$1.parse;

    var tsv$1 = dsv$1("\t");
    var tsvParse$1 = tsv$1.parse;

    // https://github.com/d3/d3-dsv/issues/45
    new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function dsv$2 (defaultMimeType, parse) {
        return function (url, row, callback) {
            if (arguments.length < 3)
                callback = row, row = null;
            var r = request(url).mimeType(defaultMimeType);
            r.row = function (_) { return arguments.length ? r.response(responseOf(parse, row = _)) : row; };
            r.row(row);
            return callback ? r.get(callback) : r;
        };
    }
    function responseOf(parse, row) {
        return function (request) {
            return parse(request.responseText, row);
        };
    }

    var csv$2 = dsv$2("text/csv", csvParse$1);

    var tsv$2 = dsv$2("text/tab-separated-values", tsvParse$1);

    function ascending$4 (a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function bisector$2 (compare) {
        if (compare.length === 1)
            compare = ascendingComparator$2(compare);
        return {
            left: function (a, x, lo, hi) {
                if (lo == null)
                    lo = 0;
                if (hi == null)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                        lo = mid + 1;
                    else
                        hi = mid;
                }
                return lo;
            },
            right: function (a, x, lo, hi) {
                if (lo == null)
                    lo = 0;
                if (hi == null)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                        hi = mid;
                    else
                        lo = mid + 1;
                }
                return lo;
            }
        };
    }
    function ascendingComparator$2(f) {
        return function (d, x) {
            return ascending$4(f(d), x);
        };
    }

    var ascendingBisect$2 = bisector$2(ascending$4);
    var bisectRight$2 = ascendingBisect$2.right;

    function number$6 (x) {
        return x === null ? NaN : +x;
    }

    function sequence (start, stop, step) {
        start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
        var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range = new Array(n);
        while (++i < n) {
            range[i] = start + i * step;
        }
        return range;
    }

    var e10$2 = Math.sqrt(50), e5$2 = Math.sqrt(10), e2$2 = Math.sqrt(2);
    function ticks$2 (start, stop, count) {
        var reverse, i = -1, n, ticks, step;
        stop = +stop, start = +start, count = +count;
        if (start === stop && count > 0)
            return [start];
        if (reverse = stop < start)
            n = start, start = stop, stop = n;
        if ((step = tickIncrement$2(start, stop, count)) === 0 || !isFinite(step))
            return [];
        if (step > 0) {
            start = Math.ceil(start / step);
            stop = Math.floor(stop / step);
            ticks = new Array(n = Math.ceil(stop - start + 1));
            while (++i < n)
                ticks[i] = (start + i) * step;
        }
        else {
            start = Math.floor(start * step);
            stop = Math.ceil(stop * step);
            ticks = new Array(n = Math.ceil(start - stop + 1));
            while (++i < n)
                ticks[i] = (start - i) / step;
        }
        if (reverse)
            ticks.reverse();
        return ticks;
    }
    function tickIncrement$2(start, stop, count) {
        var step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log(step) / Math.LN10), error = step / Math.pow(10, power);
        return power >= 0
            ? (error >= e10$2 ? 10 : error >= e5$2 ? 5 : error >= e2$2 ? 2 : 1) * Math.pow(10, power)
            : -Math.pow(10, -power) / (error >= e10$2 ? 10 : error >= e5$2 ? 5 : error >= e2$2 ? 2 : 1);
    }
    function tickStep$2(start, stop, count) {
        var step0 = Math.abs(stop - start) / Math.max(0, count), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
        if (error >= e10$2)
            step1 *= 10;
        else if (error >= e5$2)
            step1 *= 5;
        else if (error >= e2$2)
            step1 *= 2;
        return stop < start ? -step1 : step1;
    }

    function threshold (values, p, valueof) {
        if (valueof == null)
            valueof = number$6;
        if (!(n = values.length))
            return;
        if ((p = +p) <= 0 || n < 2)
            return +valueof(values[0], 0, values);
        if (p >= 1)
            return +valueof(values[n - 1], n - 1, values);
        var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
        return value0 + (value1 - value0) * (i - i0);
    }

    var prefix$2 = "$";
    function Map$3() { }
    Map$3.prototype = map$5.prototype = {
        constructor: Map$3,
        has: function (key) {
            return (prefix$2 + key) in this;
        },
        get: function (key) {
            return this[prefix$2 + key];
        },
        set: function (key, value) {
            this[prefix$2 + key] = value;
            return this;
        },
        remove: function (key) {
            var property = prefix$2 + key;
            return property in this && delete this[property];
        },
        clear: function () {
            for (var property in this)
                if (property[0] === prefix$2)
                    delete this[property];
        },
        keys: function () {
            var keys = [];
            for (var property in this)
                if (property[0] === prefix$2)
                    keys.push(property.slice(1));
            return keys;
        },
        values: function () {
            var values = [];
            for (var property in this)
                if (property[0] === prefix$2)
                    values.push(this[property]);
            return values;
        },
        entries: function () {
            var entries = [];
            for (var property in this)
                if (property[0] === prefix$2)
                    entries.push({ key: property.slice(1), value: this[property] });
            return entries;
        },
        size: function () {
            var size = 0;
            for (var property in this)
                if (property[0] === prefix$2)
                    ++size;
            return size;
        },
        empty: function () {
            for (var property in this)
                if (property[0] === prefix$2)
                    return false;
            return true;
        },
        each: function (f) {
            for (var property in this)
                if (property[0] === prefix$2)
                    f(this[property], property.slice(1), this);
        }
    };
    function map$5(object, f) {
        var map = new Map$3;
        // Copy constructor.
        if (object instanceof Map$3)
            object.each(function (value, key) { map.set(key, value); });
        // Index array by numeric index or specified key function.
        else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (f == null)
                while (++i < n)
                    map.set(i, object[i]);
            else
                while (++i < n)
                    map.set(f(o = object[i], i, object), o);
        }
        // Convert object to map.
        else if (object)
            for (var key in object)
                map.set(key, object[key]);
        return map;
    }

    var array$3 = Array.prototype;
    var map$6 = array$3.map;
    var slice$8 = array$3.slice;

    var implicit$1 = { name: "implicit" };
    function ordinal$1(range) {
        var index = map$5(), domain = [], unknown = implicit$1;
        range = range == null ? [] : slice$8.call(range);
        function scale(d) {
            var key = d + "", i = index.get(key);
            if (!i) {
                if (unknown !== implicit$1)
                    return unknown;
                index.set(key, i = domain.push(d));
            }
            return range[(i - 1) % range.length];
        }
        scale.domain = function (_) {
            if (!arguments.length)
                return domain.slice();
            domain = [], index = map$5();
            var i = -1, n = _.length, d, key;
            while (++i < n)
                if (!index.has(key = (d = _[i]) + ""))
                    index.set(key, domain.push(d));
            return scale;
        };
        scale.range = function (_) {
            return arguments.length ? (range = slice$8.call(_), scale) : range.slice();
        };
        scale.unknown = function (_) {
            return arguments.length ? (unknown = _, scale) : unknown;
        };
        scale.copy = function () {
            return ordinal$1()
                .domain(domain)
                .range(range)
                .unknown(unknown);
        };
        return scale;
    }

    function band() {
        var scale = ordinal$1().unknown(undefined), domain = scale.domain, ordinalRange = scale.range, range = [0, 1], step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
        delete scale.unknown;
        function rescale() {
            var n = domain().length, reverse = range[1] < range[0], start = range[reverse - 0], stop = range[1 - reverse];
            step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
            if (round)
                step = Math.floor(step);
            start += (stop - start - step * (n - paddingInner)) * align;
            bandwidth = step * (1 - paddingInner);
            if (round)
                start = Math.round(start), bandwidth = Math.round(bandwidth);
            var values = sequence(n).map(function (i) { return start + step * i; });
            return ordinalRange(reverse ? values.reverse() : values);
        }
        scale.domain = function (_) {
            return arguments.length ? (domain(_), rescale()) : domain();
        };
        scale.range = function (_) {
            return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
        };
        scale.rangeRound = function (_) {
            return range = [+_[0], +_[1]], round = true, rescale();
        };
        scale.bandwidth = function () {
            return bandwidth;
        };
        scale.step = function () {
            return step;
        };
        scale.round = function (_) {
            return arguments.length ? (round = !!_, rescale()) : round;
        };
        scale.padding = function (_) {
            return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
        };
        scale.paddingInner = function (_) {
            return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
        };
        scale.paddingOuter = function (_) {
            return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
        };
        scale.align = function (_) {
            return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
        };
        scale.copy = function () {
            return band()
                .domain(domain())
                .range(range)
                .round(round)
                .paddingInner(paddingInner)
                .paddingOuter(paddingOuter)
                .align(align);
        };
        return rescale();
    }
    function pointish(scale) {
        var copy = scale.copy;
        scale.padding = scale.paddingOuter;
        delete scale.paddingInner;
        delete scale.paddingOuter;
        scale.copy = function () {
            return pointish(copy());
        };
        return scale;
    }
    function point$3() {
        return pointish(band().paddingInner(1));
    }

    function define$3 (constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
    }
    function extend$3(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition)
            prototype[key] = definition[key];
        return prototype;
    }

    function Color$3() { }
    var darker$3 = 0.7;
    var brighter$3 = 1 / darker$3;
    var reI$3 = "\\s*([+-]?\\d+)\\s*", reN$3 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$3 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex$2 = /^#([0-9a-f]{3,8})$/, reRgbInteger$3 = new RegExp("^rgb\\(" + [reI$3, reI$3, reI$3] + "\\)$"), reRgbPercent$3 = new RegExp("^rgb\\(" + [reP$3, reP$3, reP$3] + "\\)$"), reRgbaInteger$3 = new RegExp("^rgba\\(" + [reI$3, reI$3, reI$3, reN$3] + "\\)$"), reRgbaPercent$3 = new RegExp("^rgba\\(" + [reP$3, reP$3, reP$3, reN$3] + "\\)$"), reHslPercent$3 = new RegExp("^hsl\\(" + [reN$3, reP$3, reP$3] + "\\)$"), reHslaPercent$3 = new RegExp("^hsla\\(" + [reN$3, reP$3, reP$3, reN$3] + "\\)$");
    var named$3 = {
        aliceblue: 0xf0f8ff,
        antiquewhite: 0xfaebd7,
        aqua: 0x00ffff,
        aquamarine: 0x7fffd4,
        azure: 0xf0ffff,
        beige: 0xf5f5dc,
        bisque: 0xffe4c4,
        black: 0x000000,
        blanchedalmond: 0xffebcd,
        blue: 0x0000ff,
        blueviolet: 0x8a2be2,
        brown: 0xa52a2a,
        burlywood: 0xdeb887,
        cadetblue: 0x5f9ea0,
        chartreuse: 0x7fff00,
        chocolate: 0xd2691e,
        coral: 0xff7f50,
        cornflowerblue: 0x6495ed,
        cornsilk: 0xfff8dc,
        crimson: 0xdc143c,
        cyan: 0x00ffff,
        darkblue: 0x00008b,
        darkcyan: 0x008b8b,
        darkgoldenrod: 0xb8860b,
        darkgray: 0xa9a9a9,
        darkgreen: 0x006400,
        darkgrey: 0xa9a9a9,
        darkkhaki: 0xbdb76b,
        darkmagenta: 0x8b008b,
        darkolivegreen: 0x556b2f,
        darkorange: 0xff8c00,
        darkorchid: 0x9932cc,
        darkred: 0x8b0000,
        darksalmon: 0xe9967a,
        darkseagreen: 0x8fbc8f,
        darkslateblue: 0x483d8b,
        darkslategray: 0x2f4f4f,
        darkslategrey: 0x2f4f4f,
        darkturquoise: 0x00ced1,
        darkviolet: 0x9400d3,
        deeppink: 0xff1493,
        deepskyblue: 0x00bfff,
        dimgray: 0x696969,
        dimgrey: 0x696969,
        dodgerblue: 0x1e90ff,
        firebrick: 0xb22222,
        floralwhite: 0xfffaf0,
        forestgreen: 0x228b22,
        fuchsia: 0xff00ff,
        gainsboro: 0xdcdcdc,
        ghostwhite: 0xf8f8ff,
        gold: 0xffd700,
        goldenrod: 0xdaa520,
        gray: 0x808080,
        green: 0x008000,
        greenyellow: 0xadff2f,
        grey: 0x808080,
        honeydew: 0xf0fff0,
        hotpink: 0xff69b4,
        indianred: 0xcd5c5c,
        indigo: 0x4b0082,
        ivory: 0xfffff0,
        khaki: 0xf0e68c,
        lavender: 0xe6e6fa,
        lavenderblush: 0xfff0f5,
        lawngreen: 0x7cfc00,
        lemonchiffon: 0xfffacd,
        lightblue: 0xadd8e6,
        lightcoral: 0xf08080,
        lightcyan: 0xe0ffff,
        lightgoldenrodyellow: 0xfafad2,
        lightgray: 0xd3d3d3,
        lightgreen: 0x90ee90,
        lightgrey: 0xd3d3d3,
        lightpink: 0xffb6c1,
        lightsalmon: 0xffa07a,
        lightseagreen: 0x20b2aa,
        lightskyblue: 0x87cefa,
        lightslategray: 0x778899,
        lightslategrey: 0x778899,
        lightsteelblue: 0xb0c4de,
        lightyellow: 0xffffe0,
        lime: 0x00ff00,
        limegreen: 0x32cd32,
        linen: 0xfaf0e6,
        magenta: 0xff00ff,
        maroon: 0x800000,
        mediumaquamarine: 0x66cdaa,
        mediumblue: 0x0000cd,
        mediumorchid: 0xba55d3,
        mediumpurple: 0x9370db,
        mediumseagreen: 0x3cb371,
        mediumslateblue: 0x7b68ee,
        mediumspringgreen: 0x00fa9a,
        mediumturquoise: 0x48d1cc,
        mediumvioletred: 0xc71585,
        midnightblue: 0x191970,
        mintcream: 0xf5fffa,
        mistyrose: 0xffe4e1,
        moccasin: 0xffe4b5,
        navajowhite: 0xffdead,
        navy: 0x000080,
        oldlace: 0xfdf5e6,
        olive: 0x808000,
        olivedrab: 0x6b8e23,
        orange: 0xffa500,
        orangered: 0xff4500,
        orchid: 0xda70d6,
        palegoldenrod: 0xeee8aa,
        palegreen: 0x98fb98,
        paleturquoise: 0xafeeee,
        palevioletred: 0xdb7093,
        papayawhip: 0xffefd5,
        peachpuff: 0xffdab9,
        peru: 0xcd853f,
        pink: 0xffc0cb,
        plum: 0xdda0dd,
        powderblue: 0xb0e0e6,
        purple: 0x800080,
        rebeccapurple: 0x663399,
        red: 0xff0000,
        rosybrown: 0xbc8f8f,
        royalblue: 0x4169e1,
        saddlebrown: 0x8b4513,
        salmon: 0xfa8072,
        sandybrown: 0xf4a460,
        seagreen: 0x2e8b57,
        seashell: 0xfff5ee,
        sienna: 0xa0522d,
        silver: 0xc0c0c0,
        skyblue: 0x87ceeb,
        slateblue: 0x6a5acd,
        slategray: 0x708090,
        slategrey: 0x708090,
        snow: 0xfffafa,
        springgreen: 0x00ff7f,
        steelblue: 0x4682b4,
        tan: 0xd2b48c,
        teal: 0x008080,
        thistle: 0xd8bfd8,
        tomato: 0xff6347,
        turquoise: 0x40e0d0,
        violet: 0xee82ee,
        wheat: 0xf5deb3,
        white: 0xffffff,
        whitesmoke: 0xf5f5f5,
        yellow: 0xffff00,
        yellowgreen: 0x9acd32
    };
    define$3(Color$3, color$3, {
        copy: function (channels) {
            return Object.assign(new this.constructor, this, channels);
        },
        displayable: function () {
            return this.rgb().displayable();
        },
        hex: color_formatHex$2,
        formatHex: color_formatHex$2,
        formatHsl: color_formatHsl$2,
        formatRgb: color_formatRgb$2,
        toString: color_formatRgb$2
    });
    function color_formatHex$2() {
        return this.rgb().formatHex();
    }
    function color_formatHsl$2() {
        return hslConvert$3(this).formatHsl();
    }
    function color_formatRgb$2() {
        return this.rgb().formatRgb();
    }
    function color$3(format) {
        var m, l;
        format = (format + "").trim().toLowerCase();
        return (m = reHex$2.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$3(m) // #ff0000
            : l === 3 ? new Rgb$3((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
                : l === 8 ? rgba$3(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
                    : l === 4 ? rgba$3((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
                        : null) // invalid hex
            : (m = reRgbInteger$3.exec(format)) ? new Rgb$3(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
                : (m = reRgbPercent$3.exec(format)) ? new Rgb$3(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
                    : (m = reRgbaInteger$3.exec(format)) ? rgba$3(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
                        : (m = reRgbaPercent$3.exec(format)) ? rgba$3(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
                            : (m = reHslPercent$3.exec(format)) ? hsla$3(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
                                : (m = reHslaPercent$3.exec(format)) ? hsla$3(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
                                    : named$3.hasOwnProperty(format) ? rgbn$3(named$3[format]) // eslint-disable-line no-prototype-builtins
                                        : format === "transparent" ? new Rgb$3(NaN, NaN, NaN, 0)
                                            : null;
    }
    function rgbn$3(n) {
        return new Rgb$3(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }
    function rgba$3(r, g, b, a) {
        if (a <= 0)
            r = g = b = NaN;
        return new Rgb$3(r, g, b, a);
    }
    function rgbConvert$3(o) {
        if (!(o instanceof Color$3))
            o = color$3(o);
        if (!o)
            return new Rgb$3;
        o = o.rgb();
        return new Rgb$3(o.r, o.g, o.b, o.opacity);
    }
    function rgb$4(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert$3(r) : new Rgb$3(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb$3(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
    }
    define$3(Rgb$3, rgb$4, extend$3(Color$3, {
        brighter: function (k) {
            k = k == null ? brighter$3 : Math.pow(brighter$3, k);
            return new Rgb$3(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$3 : Math.pow(darker$3, k);
            return new Rgb$3(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function () {
            return this;
        },
        displayable: function () {
            return (-0.5 <= this.r && this.r < 255.5)
                && (-0.5 <= this.g && this.g < 255.5)
                && (-0.5 <= this.b && this.b < 255.5)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        hex: rgb_formatHex$2,
        formatHex: rgb_formatHex$2,
        formatRgb: rgb_formatRgb$2,
        toString: rgb_formatRgb$2
    }));
    function rgb_formatHex$2() {
        return "#" + hex$2(this.r) + hex$2(this.g) + hex$2(this.b);
    }
    function rgb_formatRgb$2() {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "rgb(" : "rgba(")
            + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.b) || 0))
            + (a === 1 ? ")" : ", " + a + ")");
    }
    function hex$2(value) {
        value = Math.max(0, Math.min(255, Math.round(value) || 0));
        return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla$3(h, s, l, a) {
        if (a <= 0)
            h = s = l = NaN;
        else if (l <= 0 || l >= 1)
            h = s = NaN;
        else if (s <= 0)
            h = NaN;
        return new Hsl$3(h, s, l, a);
    }
    function hslConvert$3(o) {
        if (o instanceof Hsl$3)
            return new Hsl$3(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color$3))
            o = color$3(o);
        if (!o)
            return new Hsl$3;
        if (o instanceof Hsl$3)
            return o;
        o = o.rgb();
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
        if (s) {
            if (r === max)
                h = (g - b) / s + (g < b) * 6;
            else if (g === max)
                h = (b - r) / s + 2;
            else
                h = (r - g) / s + 4;
            s /= l < 0.5 ? max + min : 2 - max - min;
            h *= 60;
        }
        else {
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl$3(h, s, l, o.opacity);
    }
    function hsl$5(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert$3(h) : new Hsl$3(h, s, l, opacity == null ? 1 : opacity);
    }
    function Hsl$3(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define$3(Hsl$3, hsl$5, extend$3(Color$3, {
        brighter: function (k) {
            k = k == null ? brighter$3 : Math.pow(brighter$3, k);
            return new Hsl$3(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$3 : Math.pow(darker$3, k);
            return new Hsl$3(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
            return new Rgb$3(hsl2rgb$3(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb$3(h, m1, m2), hsl2rgb$3(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
        },
        displayable: function () {
            return (0 <= this.s && this.s <= 1 || isNaN(this.s))
                && (0 <= this.l && this.l <= 1)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        formatHsl: function () {
            var a = this.opacity;
            a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
            return (a === 1 ? "hsl(" : "hsla(")
                + (this.h || 0) + ", "
                + (this.s || 0) * 100 + "%, "
                + (this.l || 0) * 100 + "%"
                + (a === 1 ? ")" : ", " + a + ")");
        }
    }));
    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb$3(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60
            : h < 180 ? m2
                : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
                    : m1) * 255;
    }

    var deg2rad$3 = Math.PI / 180;
    var rad2deg$3 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    var K$2 = 18, Xn$3 = 0.96422, Yn$3 = 1, Zn$3 = 0.82521, t0$4 = 4 / 29, t1$4 = 6 / 29, t2$3 = 3 * t1$4 * t1$4, t3$3 = t1$4 * t1$4 * t1$4;
    function labConvert$3(o) {
        if (o instanceof Lab$3)
            return new Lab$3(o.l, o.a, o.b, o.opacity);
        if (o instanceof Hcl$3)
            return hcl2lab$2(o);
        if (!(o instanceof Rgb$3))
            o = rgbConvert$3(o);
        var r = rgb2lrgb$2(o.r), g = rgb2lrgb$2(o.g), b = rgb2lrgb$2(o.b), y = xyz2lab$3((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn$3), x, z;
        if (r === g && g === b)
            x = z = y;
        else {
            x = xyz2lab$3((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn$3);
            z = xyz2lab$3((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn$3);
        }
        return new Lab$3(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }
    function lab$4(l, a, b, opacity) {
        return arguments.length === 1 ? labConvert$3(l) : new Lab$3(l, a, b, opacity == null ? 1 : opacity);
    }
    function Lab$3(l, a, b, opacity) {
        this.l = +l;
        this.a = +a;
        this.b = +b;
        this.opacity = +opacity;
    }
    define$3(Lab$3, lab$4, extend$3(Color$3, {
        brighter: function (k) {
            return new Lab$3(this.l + K$2 * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        darker: function (k) {
            return new Lab$3(this.l - K$2 * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        rgb: function () {
            var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
            x = Xn$3 * lab2xyz$3(x);
            y = Yn$3 * lab2xyz$3(y);
            z = Zn$3 * lab2xyz$3(z);
            return new Rgb$3(lrgb2rgb$2(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb$2(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb$2(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
        }
    }));
    function xyz2lab$3(t) {
        return t > t3$3 ? Math.pow(t, 1 / 3) : t / t2$3 + t0$4;
    }
    function lab2xyz$3(t) {
        return t > t1$4 ? t * t * t : t2$3 * (t - t0$4);
    }
    function lrgb2rgb$2(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }
    function rgb2lrgb$2(x) {
        return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }
    function hclConvert$3(o) {
        if (o instanceof Hcl$3)
            return new Hcl$3(o.h, o.c, o.l, o.opacity);
        if (!(o instanceof Lab$3))
            o = labConvert$3(o);
        if (o.a === 0 && o.b === 0)
            return new Hcl$3(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
        var h = Math.atan2(o.b, o.a) * rad2deg$3;
        return new Hcl$3(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }
    function hcl$5(h, c, l, opacity) {
        return arguments.length === 1 ? hclConvert$3(h) : new Hcl$3(h, c, l, opacity == null ? 1 : opacity);
    }
    function Hcl$3(h, c, l, opacity) {
        this.h = +h;
        this.c = +c;
        this.l = +l;
        this.opacity = +opacity;
    }
    function hcl2lab$2(o) {
        if (isNaN(o.h))
            return new Lab$3(o.l, 0, 0, o.opacity);
        var h = o.h * deg2rad$3;
        return new Lab$3(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }
    define$3(Hcl$3, hcl$5, extend$3(Color$3, {
        brighter: function (k) {
            return new Hcl$3(this.h, this.c, this.l + K$2 * (k == null ? 1 : k), this.opacity);
        },
        darker: function (k) {
            return new Hcl$3(this.h, this.c, this.l - K$2 * (k == null ? 1 : k), this.opacity);
        },
        rgb: function () {
            return hcl2lab$2(this).rgb();
        }
    }));

    var A$3 = -0.14861, B$3 = +1.78277, C$3 = -0.29227, D$3 = -0.90649, E$3 = +1.97294, ED$3 = E$3 * D$3, EB$3 = E$3 * B$3, BC_DA$3 = B$3 * C$3 - D$3 * A$3;
    function cubehelixConvert$3(o) {
        if (o instanceof Cubehelix$3)
            return new Cubehelix$3(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Rgb$3))
            o = rgbConvert$3(o);
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA$3 * b + ED$3 * r - EB$3 * g) / (BC_DA$3 + ED$3 - EB$3), bl = b - l, k = (E$3 * (g - l) - C$3 * bl) / D$3, s = Math.sqrt(k * k + bl * bl) / (E$3 * l * (1 - l)), // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * rad2deg$3 - 120 : NaN;
        return new Cubehelix$3(h < 0 ? h + 360 : h, s, l, o.opacity);
    }
    function cubehelix$5(h, s, l, opacity) {
        return arguments.length === 1 ? cubehelixConvert$3(h) : new Cubehelix$3(h, s, l, opacity == null ? 1 : opacity);
    }
    function Cubehelix$3(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define$3(Cubehelix$3, cubehelix$5, extend$3(Color$3, {
        brighter: function (k) {
            k = k == null ? brighter$3 : Math.pow(brighter$3, k);
            return new Cubehelix$3(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$3 : Math.pow(darker$3, k);
            return new Cubehelix$3(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad$3, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
            return new Rgb$3(255 * (l + a * (A$3 * cosh + B$3 * sinh)), 255 * (l + a * (C$3 * cosh + D$3 * sinh)), 255 * (l + a * (E$3 * cosh)), this.opacity);
        }
    }));

    function constant$d (x) {
        return function () {
            return x;
        };
    }

    function linear$4(a, d) {
        return function (t) {
            return a + t * d;
        };
    }
    function exponential$3(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
            return Math.pow(a + t * b, y);
        };
    }
    function hue$1(a, b) {
        var d = b - a;
        return d ? linear$4(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$d(isNaN(a) ? b : a);
    }
    function gamma$2(y) {
        return (y = +y) === 1 ? nogamma$2 : function (a, b) {
            return b - a ? exponential$3(a, b, y) : constant$d(isNaN(a) ? b : a);
        };
    }
    function nogamma$2(a, b) {
        var d = b - a;
        return d ? linear$4(a, d) : constant$d(isNaN(a) ? b : a);
    }

    var rgb$5 = (function rgbGamma(y) {
        var color = gamma$2(y);
        function rgb(start, end) {
            var r = color((start = rgb$4(start)).r, (end = rgb$4(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = nogamma$2(start.opacity, end.opacity);
            return function (t) {
                start.r = r(t);
                start.g = g(t);
                start.b = b(t);
                start.opacity = opacity(t);
                return start + "";
            };
        }
        rgb.gamma = rgbGamma;
        return rgb;
    })(1);

    function numberArray$1 (a, b) {
        if (!b)
            b = [];
        var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
        return function (t) {
            for (i = 0; i < n; ++i)
                c[i] = a[i] * (1 - t) + b[i] * t;
            return c;
        };
    }
    function isNumberArray$1(x) {
        return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function genericArray$1(a, b) {
        var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
        for (i = 0; i < na; ++i)
            x[i] = interpolateValue(a[i], b[i]);
        for (; i < nb; ++i)
            c[i] = b[i];
        return function (t) {
            for (i = 0; i < na; ++i)
                c[i] = x[i](t);
            return c;
        };
    }

    function date$2 (a, b) {
        var d = new Date;
        return a = +a, b = +b, function (t) {
            return d.setTime(a * (1 - t) + b * t), d;
        };
    }

    function reinterpolate (a, b) {
        return a = +a, b = +b, function (t) {
            return a * (1 - t) + b * t;
        };
    }

    function object$3 (a, b) {
        var i = {}, c = {}, k;
        if (a === null || typeof a !== "object")
            a = {};
        if (b === null || typeof b !== "object")
            b = {};
        for (k in b) {
            if (k in a) {
                i[k] = interpolateValue(a[k], b[k]);
            }
            else {
                c[k] = b[k];
            }
        }
        return function (t) {
            for (k in i)
                c[k] = i[k](t);
            return c;
        };
    }

    var reA$2 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB$2 = new RegExp(reA$2.source, "g");
    function zero$2(b) {
        return function () {
            return b;
        };
    }
    function one$2(b) {
        return function (t) {
            return b(t) + "";
        };
    }
    function string$1 (a, b) {
        var bi = reA$2.lastIndex = reB$2.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators
        // Coerce inputs to strings.
        a = a + "", b = b + "";
        // Interpolate pairs of numbers in a & b.
        while ((am = reA$2.exec(a))
            && (bm = reB$2.exec(b))) {
            if ((bs = bm.index) > bi) { // a string precedes the next number in b
                bs = b.slice(bi, bs);
                if (s[i])
                    s[i] += bs; // coalesce with previous string
                else
                    s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
                if (s[i])
                    s[i] += bm; // coalesce with previous string
                else
                    s[++i] = bm;
            }
            else { // interpolate non-matching numbers
                s[++i] = null;
                q.push({ i: i, x: reinterpolate(am, bm) });
            }
            bi = reB$2.lastIndex;
        }
        // Add remains of b.
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
                s[i] += bs; // coalesce with previous string
            else
                s[++i] = bs;
        }
        // Special optimization for only a single match.
        // Otherwise, interpolate each of the numbers and rejoin the string.
        return s.length < 2 ? (q[0]
            ? one$2(q[0].x)
            : zero$2(b))
            : (b = q.length, function (t) {
                for (var i = 0, o; i < b; ++i)
                    s[(o = q[i]).i] = o.x(t);
                return s.join("");
            });
    }

    function interpolateValue (a, b) {
        var t = typeof b, c;
        return b == null || t === "boolean" ? constant$d(b)
            : (t === "number" ? reinterpolate
                : t === "string" ? ((c = color$3(b)) ? (b = c, rgb$5) : string$1)
                    : b instanceof color$3 ? rgb$5
                        : b instanceof Date ? date$2
                            : isNumberArray$1(b) ? numberArray$1
                                : Array.isArray(b) ? genericArray$1
                                    : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$3
                                        : reinterpolate)(a, b);
    }

    function interpolateRound$1 (a, b) {
        return a = +a, b = +b, function (t) {
            return Math.round(a * (1 - t) + b * t);
        };
    }

    function cubehelix$6(hue) {
        return (function cubehelixGamma(y) {
            y = +y;
            function cubehelix(start, end) {
                var h = hue((start = cubehelix$5(start)).h, (end = cubehelix$5(end)).h), s = nogamma$2(start.s, end.s), l = nogamma$2(start.l, end.l), opacity = nogamma$2(start.opacity, end.opacity);
                return function (t) {
                    start.h = h(t);
                    start.s = s(t);
                    start.l = l(Math.pow(t, y));
                    start.opacity = opacity(t);
                    return start + "";
                };
            }
            cubehelix.gamma = cubehelixGamma;
            return cubehelix;
        })(1);
    }
    cubehelix$6(hue$1);
    var cubehelixLong$1 = cubehelix$6(nogamma$2);

    function constant$e (x) {
        return function () {
            return x;
        };
    }

    function number$7 (x) {
        return +x;
    }

    var unit$1 = [0, 1];
    function deinterpolateLinear(a, b) {
        return (b -= (a = +a))
            ? function (x) { return (x - a) / b; }
            : constant$e(b);
    }
    function deinterpolateClamp(deinterpolate) {
        return function (a, b) {
            var d = deinterpolate(a = +a, b = +b);
            return function (x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
        };
    }
    function reinterpolateClamp(reinterpolate) {
        return function (a, b) {
            var r = reinterpolate(a = +a, b = +b);
            return function (t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
        };
    }
    function bimap$1(domain, range, deinterpolate, reinterpolate) {
        var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
        if (d1 < d0)
            d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
        else
            d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
        return function (x) { return r0(d0(x)); };
    }
    function polymap$1(domain, range, deinterpolate, reinterpolate) {
        var j = Math.min(domain.length, range.length) - 1, d = new Array(j), r = new Array(j), i = -1;
        // Reverse descending domains.
        if (domain[j] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++i < j) {
            d[i] = deinterpolate(domain[i], domain[i + 1]);
            r[i] = reinterpolate(range[i], range[i + 1]);
        }
        return function (x) {
            var i = bisectRight$2(domain, x, 1, j) - 1;
            return r[i](d[i](x));
        };
    }
    function copy$1(source, target) {
        return target
            .domain(source.domain())
            .range(source.range())
            .interpolate(source.interpolate())
            .clamp(source.clamp());
    }
    // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
    function continuous$1(deinterpolate, reinterpolate) {
        var domain = unit$1, range = unit$1, interpolate = interpolateValue, clamp = false, piecewise, output, input;
        function rescale() {
            piecewise = Math.min(domain.length, range.length) > 2 ? polymap$1 : bimap$1;
            output = input = null;
            return scale;
        }
        function scale(x) {
            return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
        }
        scale.invert = function (y) {
            return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
        };
        scale.domain = function (_) {
            return arguments.length ? (domain = map$6.call(_, number$7), rescale()) : domain.slice();
        };
        scale.range = function (_) {
            return arguments.length ? (range = slice$8.call(_), rescale()) : range.slice();
        };
        scale.rangeRound = function (_) {
            return range = slice$8.call(_), interpolate = interpolateRound$1, rescale();
        };
        scale.clamp = function (_) {
            return arguments.length ? (clamp = !!_, rescale()) : clamp;
        };
        scale.interpolate = function (_) {
            return arguments.length ? (interpolate = _, rescale()) : interpolate;
        };
        return rescale();
    }

    function formatDecimal$2 (x) {
        return Math.abs(x = Math.round(x)) >= 1e21
            ? x.toLocaleString("en").replace(/,/g, "")
            : x.toString(10);
    }
    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts$1(x, p) {
        if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
            return null; // NaN, ±Infinity
        var i, coefficient = x.slice(0, i);
        // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
        // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
        return [
            coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
            +x.slice(i + 1)
        ];
    }

    function exponent$3 (x) {
        return x = formatDecimalParts$1(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup$2 (grouping, thousands) {
        return function (value, width) {
            var i = value.length, t = [], j = 0, g = grouping[0], length = 0;
            while (i > 0 && g > 0) {
                if (length + g + 1 > width)
                    g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width)
                    break;
                g = grouping[j = (j + 1) % grouping.length];
            }
            return t.reverse().join(thousands);
        };
    }

    function formatNumerals$2 (numerals) {
        return function (value) {
            return value.replace(/[0-9]/g, function (i) {
                return numerals[+i];
            });
        };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re$2 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function formatSpecifier$2(specifier) {
        if (!(match = re$2.exec(specifier)))
            throw new Error("invalid format: " + specifier);
        var match;
        return new FormatSpecifier$2({
            fill: match[1],
            align: match[2],
            sign: match[3],
            symbol: match[4],
            zero: match[5],
            width: match[6],
            comma: match[7],
            precision: match[8] && match[8].slice(1),
            trim: match[9],
            type: match[10]
        });
    }
    formatSpecifier$2.prototype = FormatSpecifier$2.prototype; // instanceof
    function FormatSpecifier$2(specifier) {
        this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
        this.align = specifier.align === undefined ? ">" : specifier.align + "";
        this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
        this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
        this.zero = !!specifier.zero;
        this.width = specifier.width === undefined ? undefined : +specifier.width;
        this.comma = !!specifier.comma;
        this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
        this.trim = !!specifier.trim;
        this.type = specifier.type === undefined ? "" : specifier.type + "";
    }
    FormatSpecifier$2.prototype.toString = function () {
        return this.fill
            + this.align
            + this.sign
            + this.symbol
            + (this.zero ? "0" : "")
            + (this.width === undefined ? "" : Math.max(1, this.width | 0))
            + (this.comma ? "," : "")
            + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
            + (this.trim ? "~" : "")
            + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim$1 (s) {
        out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
            switch (s[i]) {
                case ".":
                    i0 = i1 = i;
                    break;
                case "0":
                    if (i0 === 0)
                        i0 = i;
                    i1 = i;
                    break;
                default:
                    if (!+s[i])
                        break out;
                    if (i0 > 0)
                        i0 = 0;
                    break;
            }
        }
        return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent$2;
    function formatPrefixAuto$2 (x, p) {
        var d = formatDecimalParts$1(x, p);
        if (!d)
            return x + "";
        var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent$2 = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
        return i === n ? coefficient
            : i > n ? coefficient + new Array(i - n + 1).join("0")
                : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
                    : "0." + new Array(1 - i).join("0") + formatDecimalParts$1(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded$2 (x, p) {
        var d = formatDecimalParts$1(x, p);
        if (!d)
            return x + "";
        var coefficient = d[0], exponent = d[1];
        return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
            : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
                : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes$2 = {
        "%": function (x, p) { return (x * 100).toFixed(p); },
        "b": function (x) { return Math.round(x).toString(2); },
        "c": function (x) { return x + ""; },
        "d": formatDecimal$2,
        "e": function (x, p) { return x.toExponential(p); },
        "f": function (x, p) { return x.toFixed(p); },
        "g": function (x, p) { return x.toPrecision(p); },
        "o": function (x) { return Math.round(x).toString(8); },
        "p": function (x, p) { return formatRounded$2(x * 100, p); },
        "r": formatRounded$2,
        "s": formatPrefixAuto$2,
        "X": function (x) { return Math.round(x).toString(16).toUpperCase(); },
        "x": function (x) { return Math.round(x).toString(16); }
    };

    function identity$b (x) {
        return x;
    }

    var map$7 = Array.prototype.map, prefixes$2 = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
    function formatLocale$3 (locale) {
        var group = locale.grouping === undefined || locale.thousands === undefined ? identity$b : formatGroup$2(map$7.call(locale.grouping, Number), locale.thousands + ""), currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "", currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "", decimal = locale.decimal === undefined ? "." : locale.decimal + "", numerals = locale.numerals === undefined ? identity$b : formatNumerals$2(map$7.call(locale.numerals, String)), percent = locale.percent === undefined ? "%" : locale.percent + "", minus = locale.minus === undefined ? "-" : locale.minus + "", nan = locale.nan === undefined ? "NaN" : locale.nan + "";
        function newFormat(specifier) {
            specifier = formatSpecifier$2(specifier);
            var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
            // The "n" type is an alias for ",g".
            if (type === "n")
                comma = true, type = "g";
            // The "" type, and any invalid type, is an alias for ".12~g".
            else if (!formatTypes$2[type])
                precision === undefined && (precision = 12), trim = true, type = "g";
            // If zero fill is specified, padding goes after sign and before digits.
            if (zero || (fill === "0" && align === "="))
                zero = true, fill = "0", align = "=";
            // Compute the prefix and suffix.
            // For SI-prefix, the suffix is lazily computed.
            var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
            // What format function should we use?
            // Is this an integer type?
            // Can this type generate exponential notation?
            var formatType = formatTypes$2[type], maybeSuffix = /[defgprs%]/.test(type);
            // Set the default precision if not specified,
            // or clamp the specified precision to the supported range.
            // For significant precision, it must be in [1, 21].
            // For fixed precision, it must be in [0, 20].
            precision = precision === undefined ? 6
                : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
                    : Math.max(0, Math.min(20, precision));
            function format(value) {
                var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
                if (type === "c") {
                    valueSuffix = formatType(value) + valueSuffix;
                    value = "";
                }
                else {
                    value = +value;
                    // Determine the sign. -0 is not less than 0, but 1 / -0 is!
                    var valueNegative = value < 0 || 1 / value < 0;
                    // Perform the initial formatting.
                    value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
                    // Trim insignificant zeros.
                    if (trim)
                        value = formatTrim$1(value);
                    // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
                    if (valueNegative && +value === 0 && sign !== "+")
                        valueNegative = false;
                    // Compute the prefix and suffix.
                    valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
                    valueSuffix = (type === "s" ? prefixes$2[8 + prefixExponent$2 / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
                    // Break the formatted value into the integer “value” part that can be
                    // grouped, and fractional or exponential “suffix” part that is not.
                    if (maybeSuffix) {
                        i = -1, n = value.length;
                        while (++i < n) {
                            if (c = value.charCodeAt(i), 48 > c || c > 57) {
                                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                                value = value.slice(0, i);
                                break;
                            }
                        }
                    }
                }
                // If the fill character is not "0", grouping is applied before padding.
                if (comma && !zero)
                    value = group(value, Infinity);
                // Compute the padding.
                var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
                // If the fill character is "0", grouping is applied after padding.
                if (comma && zero)
                    value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
                // Reconstruct the final output based on the desired alignment.
                switch (align) {
                    case "<":
                        value = valuePrefix + value + valueSuffix + padding;
                        break;
                    case "=":
                        value = valuePrefix + padding + value + valueSuffix;
                        break;
                    case "^":
                        value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
                        break;
                    default:
                        value = padding + valuePrefix + value + valueSuffix;
                        break;
                }
                return numerals(value);
            }
            format.toString = function () {
                return specifier + "";
            };
            return format;
        }
        function formatPrefix(specifier, value) {
            var f = newFormat((specifier = formatSpecifier$2(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent$3(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes$2[8 + e / 3];
            return function (value) {
                return f(k * value) + prefix;
            };
        }
        return {
            format: newFormat,
            formatPrefix: formatPrefix
        };
    }

    var locale$3;
    var format$2;
    var formatPrefix$2;
    defaultLocale$3({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        minus: "-"
    });
    function defaultLocale$3(definition) {
        locale$3 = formatLocale$3(definition);
        format$2 = locale$3.format;
        formatPrefix$2 = locale$3.formatPrefix;
        return locale$3;
    }

    function precisionFixed$2 (step) {
        return Math.max(0, -exponent$3(Math.abs(step)));
    }

    function precisionPrefix$2 (step, value) {
        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$3(value) / 3))) * 3 - exponent$3(Math.abs(step)));
    }

    function precisionRound$2 (step, max) {
        step = Math.abs(step), max = Math.abs(max) - step;
        return Math.max(0, exponent$3(max) - exponent$3(step)) + 1;
    }

    function tickFormat$2 (domain, count, specifier) {
        var start = domain[0], stop = domain[domain.length - 1], step = tickStep$2(start, stop, count == null ? 10 : count), precision;
        specifier = formatSpecifier$2(specifier == null ? ",f" : specifier);
        switch (specifier.type) {
            case "s": {
                var value = Math.max(Math.abs(start), Math.abs(stop));
                if (specifier.precision == null && !isNaN(precision = precisionPrefix$2(step, value)))
                    specifier.precision = precision;
                return formatPrefix$2(specifier, value);
            }
            case "":
            case "e":
            case "g":
            case "p":
            case "r": {
                if (specifier.precision == null && !isNaN(precision = precisionRound$2(step, Math.max(Math.abs(start), Math.abs(stop)))))
                    specifier.precision = precision - (specifier.type === "e");
                break;
            }
            case "f":
            case "%": {
                if (specifier.precision == null && !isNaN(precision = precisionFixed$2(step)))
                    specifier.precision = precision - (specifier.type === "%") * 2;
                break;
            }
        }
        return format$2(specifier);
    }

    function linearish$1(scale) {
        var domain = scale.domain;
        scale.ticks = function (count) {
            var d = domain();
            return ticks$2(d[0], d[d.length - 1], count == null ? 10 : count);
        };
        scale.tickFormat = function (count, specifier) {
            return tickFormat$2(domain(), count, specifier);
        };
        scale.nice = function (count) {
            if (count == null)
                count = 10;
            var d = domain(), i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], step;
            if (stop < start) {
                step = start, start = stop, stop = step;
                step = i0, i0 = i1, i1 = step;
            }
            step = tickIncrement$2(start, stop, count);
            if (step > 0) {
                start = Math.floor(start / step) * step;
                stop = Math.ceil(stop / step) * step;
                step = tickIncrement$2(start, stop, count);
            }
            else if (step < 0) {
                start = Math.ceil(start * step) / step;
                stop = Math.floor(stop * step) / step;
                step = tickIncrement$2(start, stop, count);
            }
            if (step > 0) {
                d[i0] = Math.floor(start / step) * step;
                d[i1] = Math.ceil(stop / step) * step;
                domain(d);
            }
            else if (step < 0) {
                d[i0] = Math.ceil(start * step) / step;
                d[i1] = Math.floor(stop * step) / step;
                domain(d);
            }
            return scale;
        };
        return scale;
    }
    function linear$5() {
        var scale = continuous$1(deinterpolateLinear, reinterpolate);
        scale.copy = function () {
            return copy$1(scale, linear$5());
        };
        return linearish$1(scale);
    }

    function identity$c() {
        var domain = [0, 1];
        function scale(x) {
            return +x;
        }
        scale.invert = scale;
        scale.domain = scale.range = function (_) {
            return arguments.length ? (domain = map$6.call(_, number$7), scale) : domain.slice();
        };
        scale.copy = function () {
            return identity$c().domain(domain);
        };
        return linearish$1(scale);
    }

    function nice (domain, interval) {
        domain = domain.slice();
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
        if (x1 < x0) {
            t = i0, i0 = i1, i1 = t;
            t = x0, x0 = x1, x1 = t;
        }
        domain[i0] = interval.floor(x0);
        domain[i1] = interval.ceil(x1);
        return domain;
    }

    function deinterpolate(a, b) {
        return (b = Math.log(b / a))
            ? function (x) { return Math.log(x / a) / b; }
            : constant$e(b);
    }
    function reinterpolate$1(a, b) {
        return a < 0
            ? function (t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
            : function (t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
    }
    function pow10(x) {
        return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }
    function powp(base) {
        return base === 10 ? pow10
            : base === Math.E ? Math.exp
                : function (x) { return Math.pow(base, x); };
    }
    function logp(base) {
        return base === Math.E ? Math.log
            : base === 10 && Math.log10
                || base === 2 && Math.log2
                || (base = Math.log(base), function (x) { return Math.log(x) / base; });
    }
    function reflect(f) {
        return function (x) {
            return -f(-x);
        };
    }
    function log$1() {
        var scale = continuous$1(deinterpolate, reinterpolate$1).domain([1, 10]), domain = scale.domain, base = 10, logs = logp(10), pows = powp(10);
        function rescale() {
            logs = logp(base), pows = powp(base);
            if (domain()[0] < 0)
                logs = reflect(logs), pows = reflect(pows);
            return scale;
        }
        scale.base = function (_) {
            return arguments.length ? (base = +_, rescale()) : base;
        };
        scale.domain = function (_) {
            return arguments.length ? (domain(_), rescale()) : domain();
        };
        scale.ticks = function (count) {
            var d = domain(), u = d[0], v = d[d.length - 1], r;
            if (r = v < u)
                i = u, u = v, v = i;
            var i = logs(u), j = logs(v), p, k, t, n = count == null ? 10 : +count, z = [];
            if (!(base % 1) && j - i < n) {
                i = Math.round(i) - 1, j = Math.round(j) + 1;
                if (u > 0)
                    for (; i < j; ++i) {
                        for (k = 1, p = pows(i); k < base; ++k) {
                            t = p * k;
                            if (t < u)
                                continue;
                            if (t > v)
                                break;
                            z.push(t);
                        }
                    }
                else
                    for (; i < j; ++i) {
                        for (k = base - 1, p = pows(i); k >= 1; --k) {
                            t = p * k;
                            if (t < u)
                                continue;
                            if (t > v)
                                break;
                            z.push(t);
                        }
                    }
            }
            else {
                z = ticks$2(i, j, Math.min(j - i, n)).map(pows);
            }
            return r ? z.reverse() : z;
        };
        scale.tickFormat = function (count, specifier) {
            if (specifier == null)
                specifier = base === 10 ? ".0e" : ",";
            if (typeof specifier !== "function")
                specifier = format$2(specifier);
            if (count === Infinity)
                return specifier;
            if (count == null)
                count = 10;
            var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
            return function (d) {
                var i = d / pows(Math.round(logs(d)));
                if (i * base < base - 0.5)
                    i *= base;
                return i <= k ? specifier(d) : "";
            };
        };
        scale.nice = function () {
            return domain(nice(domain(), {
                floor: function (x) { return pows(Math.floor(logs(x))); },
                ceil: function (x) { return pows(Math.ceil(logs(x))); }
            }));
        };
        scale.copy = function () {
            return copy$1(scale, log$1().base(base));
        };
        return scale;
    }

    function raise$2(x, exponent) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
    }
    function pow$2() {
        var exponent = 1, scale = continuous$1(deinterpolate, reinterpolate), domain = scale.domain;
        function deinterpolate(a, b) {
            return (b = raise$2(b, exponent) - (a = raise$2(a, exponent)))
                ? function (x) { return (raise$2(x, exponent) - a) / b; }
                : constant$e(b);
        }
        function reinterpolate(a, b) {
            b = raise$2(b, exponent) - (a = raise$2(a, exponent));
            return function (t) { return raise$2(a + b * t, 1 / exponent); };
        }
        scale.exponent = function (_) {
            return arguments.length ? (exponent = +_, domain(domain())) : exponent;
        };
        scale.copy = function () {
            return copy$1(scale, pow$2().exponent(exponent));
        };
        return linearish$1(scale);
    }
    function sqrt$2() {
        return pow$2().exponent(0.5);
    }

    function quantile$1() {
        var domain = [], range = [], thresholds = [];
        function rescale() {
            var i = 0, n = Math.max(1, range.length);
            thresholds = new Array(n - 1);
            while (++i < n)
                thresholds[i - 1] = threshold(domain, i / n);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x))
                return range[bisectRight$2(thresholds, x)];
        }
        scale.invertExtent = function (y) {
            var i = range.indexOf(y);
            return i < 0 ? [NaN, NaN] : [
                i > 0 ? thresholds[i - 1] : domain[0],
                i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
            ];
        };
        scale.domain = function (_) {
            if (!arguments.length)
                return domain.slice();
            domain = [];
            for (var i = 0, n = _.length, d; i < n; ++i)
                if (d = _[i], d != null && !isNaN(d = +d))
                    domain.push(d);
            domain.sort(ascending$4);
            return rescale();
        };
        scale.range = function (_) {
            return arguments.length ? (range = slice$8.call(_), rescale()) : range.slice();
        };
        scale.quantiles = function () {
            return thresholds.slice();
        };
        scale.copy = function () {
            return quantile$1()
                .domain(domain)
                .range(range);
        };
        return scale;
    }

    function quantize$2() {
        var x0 = 0, x1 = 1, n = 1, domain = [0.5], range = [0, 1];
        function scale(x) {
            if (x <= x)
                return range[bisectRight$2(domain, x, 0, n)];
        }
        function rescale() {
            var i = -1;
            domain = new Array(n);
            while (++i < n)
                domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
            return scale;
        }
        scale.domain = function (_) {
            return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
        };
        scale.range = function (_) {
            return arguments.length ? (n = (range = slice$8.call(_)).length - 1, rescale()) : range.slice();
        };
        scale.invertExtent = function (y) {
            var i = range.indexOf(y);
            return i < 0 ? [NaN, NaN]
                : i < 1 ? [x0, domain[0]]
                    : i >= n ? [domain[n - 1], x1]
                        : [domain[i - 1], domain[i]];
        };
        scale.copy = function () {
            return quantize$2()
                .domain([x0, x1])
                .range(range);
        };
        return linearish$1(scale);
    }

    function threshold$1() {
        var domain = [0.5], range = [0, 1], n = 1;
        function scale(x) {
            if (x <= x)
                return range[bisectRight$2(domain, x, 0, n)];
        }
        scale.domain = function (_) {
            return arguments.length ? (domain = slice$8.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
        };
        scale.range = function (_) {
            return arguments.length ? (range = slice$8.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
        };
        scale.invertExtent = function (y) {
            var i = range.indexOf(y);
            return [domain[i - 1], domain[i]];
        };
        scale.copy = function () {
            return threshold$1()
                .domain(domain)
                .range(range);
        };
        return scale;
    }

    var t0$5 = new Date, t1$5 = new Date;
    function newInterval$1(floori, offseti, count, field) {
        function interval(date) {
            return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
        }
        interval.floor = function (date) {
            return floori(date = new Date(+date)), date;
        };
        interval.ceil = function (date) {
            return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
        };
        interval.round = function (date) {
            var d0 = interval(date), d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1;
        };
        interval.offset = function (date, step) {
            return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
        };
        interval.range = function (start, stop, step) {
            var range = [], previous;
            start = interval.ceil(start);
            step = step == null ? 1 : Math.floor(step);
            if (!(start < stop) || !(step > 0))
                return range; // also handles Invalid Date
            do
                range.push(previous = new Date(+start)), offseti(start, step), floori(start);
            while (previous < start && start < stop);
            return range;
        };
        interval.filter = function (test) {
            return newInterval$1(function (date) {
                if (date >= date)
                    while (floori(date), !test(date))
                        date.setTime(date - 1);
            }, function (date, step) {
                if (date >= date) {
                    if (step < 0)
                        while (++step <= 0) {
                            while (offseti(date, -1), !test(date)) { } // eslint-disable-line no-empty
                        }
                    else
                        while (--step >= 0) {
                            while (offseti(date, +1), !test(date)) { } // eslint-disable-line no-empty
                        }
                }
            });
        };
        if (count) {
            interval.count = function (start, end) {
                t0$5.setTime(+start), t1$5.setTime(+end);
                floori(t0$5), floori(t1$5);
                return Math.floor(count(t0$5, t1$5));
            };
            interval.every = function (step) {
                step = Math.floor(step);
                return !isFinite(step) || !(step > 0) ? null
                    : !(step > 1) ? interval
                        : interval.filter(field
                            ? function (d) { return field(d) % step === 0; }
                            : function (d) { return interval.count(0, d) % step === 0; });
            };
        }
        return interval;
    }

    var millisecond$1 = newInterval$1(function () {
        // noop
    }, function (date, step) {
        date.setTime(+date + step);
    }, function (start, end) {
        return end - start;
    });
    // An optimized implementation for this simple case.
    millisecond$1.every = function (k) {
        k = Math.floor(k);
        if (!isFinite(k) || !(k > 0))
            return null;
        if (!(k > 1))
            return millisecond$1;
        return newInterval$1(function (date) {
            date.setTime(Math.floor(date / k) * k);
        }, function (date, step) {
            date.setTime(+date + step * k);
        }, function (start, end) {
            return (end - start) / k;
        });
    };

    var durationSecond$1 = 1e3;
    var durationMinute$1 = 6e4;
    var durationHour$1 = 36e5;
    var durationDay$1 = 864e5;
    var durationWeek$1 = 6048e5;

    var second$1 = newInterval$1(function (date) {
        date.setTime(date - date.getMilliseconds());
    }, function (date, step) {
        date.setTime(+date + step * durationSecond$1);
    }, function (start, end) {
        return (end - start) / durationSecond$1;
    }, function (date) {
        return date.getUTCSeconds();
    });

    var minute$1 = newInterval$1(function (date) {
        date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1);
    }, function (date, step) {
        date.setTime(+date + step * durationMinute$1);
    }, function (start, end) {
        return (end - start) / durationMinute$1;
    }, function (date) {
        return date.getMinutes();
    });

    var hour$1 = newInterval$1(function (date) {
        date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$1 - date.getMinutes() * durationMinute$1);
    }, function (date, step) {
        date.setTime(+date + step * durationHour$1);
    }, function (start, end) {
        return (end - start) / durationHour$1;
    }, function (date) {
        return date.getHours();
    });

    var day$1 = newInterval$1(function (date) {
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setDate(date.getDate() + step);
    }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
    }, function (date) {
        return date.getDate() - 1;
    });

    function weekday$1(i) {
        return newInterval$1(function (date) {
            date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
            date.setHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setDate(date.getDate() + step * 7);
        }, function (start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
        });
    }
    var sunday$1 = weekday$1(0);
    var monday$1 = weekday$1(1);
    weekday$1(2);
    weekday$1(3);
    var thursday$1 = weekday$1(4);
    weekday$1(5);
    weekday$1(6);

    var month$1 = newInterval$1(function (date) {
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setMonth(date.getMonth() + step);
    }, function (start, end) {
        return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function (date) {
        return date.getMonth();
    });

    var year$1 = newInterval$1(function (date) {
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setFullYear(date.getFullYear() + step);
    }, function (start, end) {
        return end.getFullYear() - start.getFullYear();
    }, function (date) {
        return date.getFullYear();
    });
    // An optimized implementation for this simple case.
    year$1.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval$1(function (date) {
            date.setFullYear(Math.floor(date.getFullYear() / k) * k);
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setFullYear(date.getFullYear() + step * k);
        });
    };

    var utcMinute$1 = newInterval$1(function (date) {
        date.setUTCSeconds(0, 0);
    }, function (date, step) {
        date.setTime(+date + step * durationMinute$1);
    }, function (start, end) {
        return (end - start) / durationMinute$1;
    }, function (date) {
        return date.getUTCMinutes();
    });

    var utcHour$1 = newInterval$1(function (date) {
        date.setUTCMinutes(0, 0, 0);
    }, function (date, step) {
        date.setTime(+date + step * durationHour$1);
    }, function (start, end) {
        return (end - start) / durationHour$1;
    }, function (date) {
        return date.getUTCHours();
    });

    var utcDay$1 = newInterval$1(function (date) {
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCDate(date.getUTCDate() + step);
    }, function (start, end) {
        return (end - start) / durationDay$1;
    }, function (date) {
        return date.getUTCDate() - 1;
    });

    function utcWeekday$1(i) {
        return newInterval$1(function (date) {
            date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
            date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setUTCDate(date.getUTCDate() + step * 7);
        }, function (start, end) {
            return (end - start) / durationWeek$1;
        });
    }
    var utcSunday$1 = utcWeekday$1(0);
    var utcMonday$1 = utcWeekday$1(1);
    utcWeekday$1(2);
    utcWeekday$1(3);
    var utcThursday$1 = utcWeekday$1(4);
    utcWeekday$1(5);
    utcWeekday$1(6);

    var utcMonth$1 = newInterval$1(function (date) {
        date.setUTCDate(1);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCMonth(date.getUTCMonth() + step);
    }, function (start, end) {
        return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function (date) {
        return date.getUTCMonth();
    });

    var utcYear$1 = newInterval$1(function (date) {
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function (start, end) {
        return end.getUTCFullYear() - start.getUTCFullYear();
    }, function (date) {
        return date.getUTCFullYear();
    });
    // An optimized implementation for this simple case.
    utcYear$1.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval$1(function (date) {
            date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step * k);
        });
    };

    function localDate$1(d) {
        if (0 <= d.y && d.y < 100) {
            var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
            date.setFullYear(d.y);
            return date;
        }
        return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }
    function utcDate$1(d) {
        if (0 <= d.y && d.y < 100) {
            var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
            date.setUTCFullYear(d.y);
            return date;
        }
        return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }
    function newDate$1(y, m, d) {
        return { y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0 };
    }
    function formatLocale$4(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_weekdays = locale.days, locale_shortWeekdays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        var periodRe = formatRe$1(locale_periods), periodLookup = formatLookup$1(locale_periods), weekdayRe = formatRe$1(locale_weekdays), weekdayLookup = formatLookup$1(locale_weekdays), shortWeekdayRe = formatRe$1(locale_shortWeekdays), shortWeekdayLookup = formatLookup$1(locale_shortWeekdays), monthRe = formatRe$1(locale_months), monthLookup = formatLookup$1(locale_months), shortMonthRe = formatRe$1(locale_shortMonths), shortMonthLookup = formatLookup$1(locale_shortMonths);
        var formats = {
            "a": formatShortWeekday,
            "A": formatWeekday,
            "b": formatShortMonth,
            "B": formatMonth,
            "c": null,
            "d": formatDayOfMonth$1,
            "e": formatDayOfMonth$1,
            "f": formatMicroseconds$1,
            "g": formatYearISO$1,
            "G": formatFullYearISO$1,
            "H": formatHour24$1,
            "I": formatHour12$1,
            "j": formatDayOfYear$1,
            "L": formatMilliseconds$1,
            "m": formatMonthNumber$1,
            "M": formatMinutes$1,
            "p": formatPeriod,
            "q": formatQuarter,
            "Q": formatUnixTimestamp$1,
            "s": formatUnixTimestampSeconds$1,
            "S": formatSeconds$1,
            "u": formatWeekdayNumberMonday$1,
            "U": formatWeekNumberSunday$1,
            "V": formatWeekNumberISO$1,
            "w": formatWeekdayNumberSunday$1,
            "W": formatWeekNumberMonday$1,
            "x": null,
            "X": null,
            "y": formatYear$2,
            "Y": formatFullYear$1,
            "Z": formatZone$1,
            "%": formatLiteralPercent$1
        };
        var utcFormats = {
            "a": formatUTCShortWeekday,
            "A": formatUTCWeekday,
            "b": formatUTCShortMonth,
            "B": formatUTCMonth,
            "c": null,
            "d": formatUTCDayOfMonth$1,
            "e": formatUTCDayOfMonth$1,
            "f": formatUTCMicroseconds$1,
            "g": formatUTCYearISO$1,
            "G": formatUTCFullYearISO$1,
            "H": formatUTCHour24$1,
            "I": formatUTCHour12$1,
            "j": formatUTCDayOfYear$1,
            "L": formatUTCMilliseconds$1,
            "m": formatUTCMonthNumber$1,
            "M": formatUTCMinutes$1,
            "p": formatUTCPeriod,
            "q": formatUTCQuarter,
            "Q": formatUnixTimestamp$1,
            "s": formatUnixTimestampSeconds$1,
            "S": formatUTCSeconds$1,
            "u": formatUTCWeekdayNumberMonday$1,
            "U": formatUTCWeekNumberSunday$1,
            "V": formatUTCWeekNumberISO$1,
            "w": formatUTCWeekdayNumberSunday$1,
            "W": formatUTCWeekNumberMonday$1,
            "x": null,
            "X": null,
            "y": formatUTCYear$1,
            "Y": formatUTCFullYear$1,
            "Z": formatUTCZone$1,
            "%": formatLiteralPercent$1
        };
        var parses = {
            "a": parseShortWeekday,
            "A": parseWeekday,
            "b": parseShortMonth,
            "B": parseMonth,
            "c": parseLocaleDateTime,
            "d": parseDayOfMonth$1,
            "e": parseDayOfMonth$1,
            "f": parseMicroseconds$1,
            "g": parseYear$1,
            "G": parseFullYear$1,
            "H": parseHour24$1,
            "I": parseHour24$1,
            "j": parseDayOfYear$1,
            "L": parseMilliseconds$1,
            "m": parseMonthNumber$1,
            "M": parseMinutes$1,
            "p": parsePeriod,
            "q": parseQuarter$1,
            "Q": parseUnixTimestamp$1,
            "s": parseUnixTimestampSeconds$1,
            "S": parseSeconds$1,
            "u": parseWeekdayNumberMonday$1,
            "U": parseWeekNumberSunday$1,
            "V": parseWeekNumberISO$1,
            "w": parseWeekdayNumberSunday$1,
            "W": parseWeekNumberMonday$1,
            "x": parseLocaleDate,
            "X": parseLocaleTime,
            "y": parseYear$1,
            "Y": parseFullYear$1,
            "Z": parseZone$1,
            "%": parseLiteralPercent$1
        };
        // These recursive directive definitions must be deferred.
        formats.x = newFormat(locale_date, formats);
        formats.X = newFormat(locale_time, formats);
        formats.c = newFormat(locale_dateTime, formats);
        utcFormats.x = newFormat(locale_date, utcFormats);
        utcFormats.X = newFormat(locale_time, utcFormats);
        utcFormats.c = newFormat(locale_dateTime, utcFormats);
        function newFormat(specifier, formats) {
            return function (date) {
                var string = [], i = -1, j = 0, n = specifier.length, c, pad, format;
                if (!(date instanceof Date))
                    date = new Date(+date);
                while (++i < n) {
                    if (specifier.charCodeAt(i) === 37) {
                        string.push(specifier.slice(j, i));
                        if ((pad = pads$1[c = specifier.charAt(++i)]) != null)
                            c = specifier.charAt(++i);
                        else
                            pad = c === "e" ? " " : "0";
                        if (format = formats[c])
                            c = format(date, pad);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(specifier.slice(j, i));
                return string.join("");
            };
        }
        function newParse(specifier, Z) {
            return function (string) {
                var d = newDate$1(1900, undefined, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
                if (i != string.length)
                    return null;
                // If a UNIX timestamp is specified, return it.
                if ("Q" in d)
                    return new Date(d.Q);
                if ("s" in d)
                    return new Date(d.s * 1000 + ("L" in d ? d.L : 0));
                // If this is utcParse, never use the local timezone.
                if (Z && !("Z" in d))
                    d.Z = 0;
                // The am-pm flag is 0 for AM, and 1 for PM.
                if ("p" in d)
                    d.H = d.H % 12 + d.p * 12;
                // If the month was not specified, inherit from the quarter.
                if (d.m === undefined)
                    d.m = "q" in d ? d.q : 0;
                // Convert day-of-week and week-of-year to day-of-year.
                if ("V" in d) {
                    if (d.V < 1 || d.V > 53)
                        return null;
                    if (!("w" in d))
                        d.w = 1;
                    if ("Z" in d) {
                        week = utcDate$1(newDate$1(d.y, 0, 1)), day = week.getUTCDay();
                        week = day > 4 || day === 0 ? utcMonday$1.ceil(week) : utcMonday$1(week);
                        week = utcDay$1.offset(week, (d.V - 1) * 7);
                        d.y = week.getUTCFullYear();
                        d.m = week.getUTCMonth();
                        d.d = week.getUTCDate() + (d.w + 6) % 7;
                    }
                    else {
                        week = localDate$1(newDate$1(d.y, 0, 1)), day = week.getDay();
                        week = day > 4 || day === 0 ? monday$1.ceil(week) : monday$1(week);
                        week = day$1.offset(week, (d.V - 1) * 7);
                        d.y = week.getFullYear();
                        d.m = week.getMonth();
                        d.d = week.getDate() + (d.w + 6) % 7;
                    }
                }
                else if ("W" in d || "U" in d) {
                    if (!("w" in d))
                        d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
                    day = "Z" in d ? utcDate$1(newDate$1(d.y, 0, 1)).getUTCDay() : localDate$1(newDate$1(d.y, 0, 1)).getDay();
                    d.m = 0;
                    d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
                }
                // If a time zone is specified, all fields are interpreted as UTC and then
                // offset according to the specified time zone.
                if ("Z" in d) {
                    d.H += d.Z / 100 | 0;
                    d.M += d.Z % 100;
                    return utcDate$1(d);
                }
                // Otherwise, all fields are in local time.
                return localDate$1(d);
            };
        }
        function parseSpecifier(d, specifier, string, j) {
            var i = 0, n = specifier.length, m = string.length, c, parse;
            while (i < n) {
                if (j >= m)
                    return -1;
                c = specifier.charCodeAt(i++);
                if (c === 37) {
                    c = specifier.charAt(i++);
                    parse = parses[c in pads$1 ? specifier.charAt(i++) : c];
                    if (!parse || ((j = parse(d, string, j)) < 0))
                        return -1;
                }
                else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        function parsePeriod(d, string, i) {
            var n = periodRe.exec(string.slice(i));
            return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseShortWeekday(d, string, i) {
            var n = shortWeekdayRe.exec(string.slice(i));
            return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseWeekday(d, string, i) {
            var n = weekdayRe.exec(string.slice(i));
            return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseShortMonth(d, string, i) {
            var n = shortMonthRe.exec(string.slice(i));
            return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseMonth(d, string, i) {
            var n = monthRe.exec(string.slice(i));
            return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseLocaleDateTime(d, string, i) {
            return parseSpecifier(d, locale_dateTime, string, i);
        }
        function parseLocaleDate(d, string, i) {
            return parseSpecifier(d, locale_date, string, i);
        }
        function parseLocaleTime(d, string, i) {
            return parseSpecifier(d, locale_time, string, i);
        }
        function formatShortWeekday(d) {
            return locale_shortWeekdays[d.getDay()];
        }
        function formatWeekday(d) {
            return locale_weekdays[d.getDay()];
        }
        function formatShortMonth(d) {
            return locale_shortMonths[d.getMonth()];
        }
        function formatMonth(d) {
            return locale_months[d.getMonth()];
        }
        function formatPeriod(d) {
            return locale_periods[+(d.getHours() >= 12)];
        }
        function formatQuarter(d) {
            return 1 + ~~(d.getMonth() / 3);
        }
        function formatUTCShortWeekday(d) {
            return locale_shortWeekdays[d.getUTCDay()];
        }
        function formatUTCWeekday(d) {
            return locale_weekdays[d.getUTCDay()];
        }
        function formatUTCShortMonth(d) {
            return locale_shortMonths[d.getUTCMonth()];
        }
        function formatUTCMonth(d) {
            return locale_months[d.getUTCMonth()];
        }
        function formatUTCPeriod(d) {
            return locale_periods[+(d.getUTCHours() >= 12)];
        }
        function formatUTCQuarter(d) {
            return 1 + ~~(d.getUTCMonth() / 3);
        }
        return {
            format: function (specifier) {
                var f = newFormat(specifier += "", formats);
                f.toString = function () { return specifier; };
                return f;
            },
            parse: function (specifier) {
                var p = newParse(specifier += "", false);
                p.toString = function () { return specifier; };
                return p;
            },
            utcFormat: function (specifier) {
                var f = newFormat(specifier += "", utcFormats);
                f.toString = function () { return specifier; };
                return f;
            },
            utcParse: function (specifier) {
                var p = newParse(specifier += "", true);
                p.toString = function () { return specifier; };
                return p;
            }
        };
    }
    var pads$1 = { "-": "", "_": " ", "0": "0" }, numberRe$1 = /^\s*\d+/, // note: ignores next directive
    percentRe$1 = /^%/, requoteRe$1 = /[\\^$*+?|[\]().{}]/g;
    function pad$2(value, fill, width) {
        var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function requote$1(s) {
        return s.replace(requoteRe$1, "\\$&");
    }
    function formatRe$1(names) {
        return new RegExp("^(?:" + names.map(requote$1).join("|") + ")", "i");
    }
    function formatLookup$1(names) {
        var map = {}, i = -1, n = names.length;
        while (++i < n)
            map[names[i].toLowerCase()] = i;
        return map;
    }
    function parseWeekdayNumberSunday$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 1));
        return n ? (d.w = +n[0], i + n[0].length) : -1;
    }
    function parseWeekdayNumberMonday$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 1));
        return n ? (d.u = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberSunday$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 2));
        return n ? (d.U = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberISO$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 2));
        return n ? (d.V = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberMonday$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 2));
        return n ? (d.W = +n[0], i + n[0].length) : -1;
    }
    function parseFullYear$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 4));
        return n ? (d.y = +n[0], i + n[0].length) : -1;
    }
    function parseYear$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 2));
        return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }
    function parseZone$1(d, string, i) {
        var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
        return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }
    function parseQuarter$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 1));
        return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }
    function parseMonthNumber$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 2));
        return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }
    function parseDayOfMonth$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 2));
        return n ? (d.d = +n[0], i + n[0].length) : -1;
    }
    function parseDayOfYear$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 3));
        return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }
    function parseHour24$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 2));
        return n ? (d.H = +n[0], i + n[0].length) : -1;
    }
    function parseMinutes$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 2));
        return n ? (d.M = +n[0], i + n[0].length) : -1;
    }
    function parseSeconds$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 2));
        return n ? (d.S = +n[0], i + n[0].length) : -1;
    }
    function parseMilliseconds$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 3));
        return n ? (d.L = +n[0], i + n[0].length) : -1;
    }
    function parseMicroseconds$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i, i + 6));
        return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }
    function parseLiteralPercent$1(d, string, i) {
        var n = percentRe$1.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function parseUnixTimestamp$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i));
        return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }
    function parseUnixTimestampSeconds$1(d, string, i) {
        var n = numberRe$1.exec(string.slice(i));
        return n ? (d.s = +n[0], i + n[0].length) : -1;
    }
    function formatDayOfMonth$1(d, p) {
        return pad$2(d.getDate(), p, 2);
    }
    function formatHour24$1(d, p) {
        return pad$2(d.getHours(), p, 2);
    }
    function formatHour12$1(d, p) {
        return pad$2(d.getHours() % 12 || 12, p, 2);
    }
    function formatDayOfYear$1(d, p) {
        return pad$2(1 + day$1.count(year$1(d), d), p, 3);
    }
    function formatMilliseconds$1(d, p) {
        return pad$2(d.getMilliseconds(), p, 3);
    }
    function formatMicroseconds$1(d, p) {
        return formatMilliseconds$1(d, p) + "000";
    }
    function formatMonthNumber$1(d, p) {
        return pad$2(d.getMonth() + 1, p, 2);
    }
    function formatMinutes$1(d, p) {
        return pad$2(d.getMinutes(), p, 2);
    }
    function formatSeconds$1(d, p) {
        return pad$2(d.getSeconds(), p, 2);
    }
    function formatWeekdayNumberMonday$1(d) {
        var day = d.getDay();
        return day === 0 ? 7 : day;
    }
    function formatWeekNumberSunday$1(d, p) {
        return pad$2(sunday$1.count(year$1(d) - 1, d), p, 2);
    }
    function dISO$1(d) {
        var day = d.getDay();
        return (day >= 4 || day === 0) ? thursday$1(d) : thursday$1.ceil(d);
    }
    function formatWeekNumberISO$1(d, p) {
        d = dISO$1(d);
        return pad$2(thursday$1.count(year$1(d), d) + (year$1(d).getDay() === 4), p, 2);
    }
    function formatWeekdayNumberSunday$1(d) {
        return d.getDay();
    }
    function formatWeekNumberMonday$1(d, p) {
        return pad$2(monday$1.count(year$1(d) - 1, d), p, 2);
    }
    function formatYear$2(d, p) {
        return pad$2(d.getFullYear() % 100, p, 2);
    }
    function formatYearISO$1(d, p) {
        d = dISO$1(d);
        return pad$2(d.getFullYear() % 100, p, 2);
    }
    function formatFullYear$1(d, p) {
        return pad$2(d.getFullYear() % 10000, p, 4);
    }
    function formatFullYearISO$1(d, p) {
        var day = d.getDay();
        d = (day >= 4 || day === 0) ? thursday$1(d) : thursday$1.ceil(d);
        return pad$2(d.getFullYear() % 10000, p, 4);
    }
    function formatZone$1(d) {
        var z = d.getTimezoneOffset();
        return (z > 0 ? "-" : (z *= -1, "+"))
            + pad$2(z / 60 | 0, "0", 2)
            + pad$2(z % 60, "0", 2);
    }
    function formatUTCDayOfMonth$1(d, p) {
        return pad$2(d.getUTCDate(), p, 2);
    }
    function formatUTCHour24$1(d, p) {
        return pad$2(d.getUTCHours(), p, 2);
    }
    function formatUTCHour12$1(d, p) {
        return pad$2(d.getUTCHours() % 12 || 12, p, 2);
    }
    function formatUTCDayOfYear$1(d, p) {
        return pad$2(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
    }
    function formatUTCMilliseconds$1(d, p) {
        return pad$2(d.getUTCMilliseconds(), p, 3);
    }
    function formatUTCMicroseconds$1(d, p) {
        return formatUTCMilliseconds$1(d, p) + "000";
    }
    function formatUTCMonthNumber$1(d, p) {
        return pad$2(d.getUTCMonth() + 1, p, 2);
    }
    function formatUTCMinutes$1(d, p) {
        return pad$2(d.getUTCMinutes(), p, 2);
    }
    function formatUTCSeconds$1(d, p) {
        return pad$2(d.getUTCSeconds(), p, 2);
    }
    function formatUTCWeekdayNumberMonday$1(d) {
        var dow = d.getUTCDay();
        return dow === 0 ? 7 : dow;
    }
    function formatUTCWeekNumberSunday$1(d, p) {
        return pad$2(utcSunday$1.count(utcYear$1(d) - 1, d), p, 2);
    }
    function UTCdISO$1(d) {
        var day = d.getUTCDay();
        return (day >= 4 || day === 0) ? utcThursday$1(d) : utcThursday$1.ceil(d);
    }
    function formatUTCWeekNumberISO$1(d, p) {
        d = UTCdISO$1(d);
        return pad$2(utcThursday$1.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
    }
    function formatUTCWeekdayNumberSunday$1(d) {
        return d.getUTCDay();
    }
    function formatUTCWeekNumberMonday$1(d, p) {
        return pad$2(utcMonday$1.count(utcYear$1(d) - 1, d), p, 2);
    }
    function formatUTCYear$1(d, p) {
        return pad$2(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCYearISO$1(d, p) {
        d = UTCdISO$1(d);
        return pad$2(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCFullYear$1(d, p) {
        return pad$2(d.getUTCFullYear() % 10000, p, 4);
    }
    function formatUTCFullYearISO$1(d, p) {
        var day = d.getUTCDay();
        d = (day >= 4 || day === 0) ? utcThursday$1(d) : utcThursday$1.ceil(d);
        return pad$2(d.getUTCFullYear() % 10000, p, 4);
    }
    function formatUTCZone$1() {
        return "+0000";
    }
    function formatLiteralPercent$1() {
        return "%";
    }
    function formatUnixTimestamp$1(d) {
        return +d;
    }
    function formatUnixTimestampSeconds$1(d) {
        return Math.floor(+d / 1000);
    }

    var locale$4;
    var timeFormat$1;
    var utcFormat$1;
    var utcParse$1;
    defaultLocale$4({
        dateTime: "%x, %X",
        date: "%-m/%-d/%Y",
        time: "%-I:%M:%S %p",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale$4(definition) {
        locale$4 = formatLocale$4(definition);
        timeFormat$1 = locale$4.format;
        utcFormat$1 = locale$4.utcFormat;
        utcParse$1 = locale$4.utcParse;
        return locale$4;
    }

    var isoSpecifier$1 = "%Y-%m-%dT%H:%M:%S.%LZ";
    function formatIsoNative$1(date) {
        return date.toISOString();
    }
    Date.prototype.toISOString
        ? formatIsoNative$1
        : utcFormat$1(isoSpecifier$1);

    function parseIsoNative$1(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    }
    +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative$1
        : utcParse$1(isoSpecifier$1);

    var durationSecond$2 = 1000, durationMinute$2 = durationSecond$2 * 60, durationHour$2 = durationMinute$2 * 60, durationDay$2 = durationHour$2 * 24, durationWeek$2 = durationDay$2 * 7, durationMonth = durationDay$2 * 30, durationYear = durationDay$2 * 365;
    function date$3(t) {
        return new Date(t);
    }
    function number$8(t) {
        return t instanceof Date ? +t : +new Date(+t);
    }
    function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
        var scale = continuous$1(deinterpolateLinear, reinterpolate), invert = scale.invert, domain = scale.domain;
        var formatMillisecond = format(".%L"), formatSecond = format(":%S"), formatMinute = format("%I:%M"), formatHour = format("%I %p"), formatDay = format("%a %d"), formatWeek = format("%b %d"), formatMonth = format("%B"), formatYear = format("%Y");
        var tickIntervals = [
            [second, 1, durationSecond$2],
            [second, 5, 5 * durationSecond$2],
            [second, 15, 15 * durationSecond$2],
            [second, 30, 30 * durationSecond$2],
            [minute, 1, durationMinute$2],
            [minute, 5, 5 * durationMinute$2],
            [minute, 15, 15 * durationMinute$2],
            [minute, 30, 30 * durationMinute$2],
            [hour, 1, durationHour$2],
            [hour, 3, 3 * durationHour$2],
            [hour, 6, 6 * durationHour$2],
            [hour, 12, 12 * durationHour$2],
            [day, 1, durationDay$2],
            [day, 2, 2 * durationDay$2],
            [week, 1, durationWeek$2],
            [month, 1, durationMonth],
            [month, 3, 3 * durationMonth],
            [year, 1, durationYear]
        ];
        function tickFormat(date) {
            return (second(date) < date ? formatMillisecond
                : minute(date) < date ? formatSecond
                    : hour(date) < date ? formatMinute
                        : day(date) < date ? formatHour
                            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
                                : year(date) < date ? formatMonth
                                    : formatYear)(date);
        }
        function tickInterval(interval, start, stop, step) {
            if (interval == null)
                interval = 10;
            // If a desired tick count is specified, pick a reasonable tick interval
            // based on the extent of the domain and a rough estimate of tick size.
            // Otherwise, assume interval is already a time interval and use it.
            if (typeof interval === "number") {
                var target = Math.abs(stop - start) / interval, i = bisector$2(function (i) { return i[2]; }).right(tickIntervals, target);
                if (i === tickIntervals.length) {
                    step = tickStep$2(start / durationYear, stop / durationYear, interval);
                    interval = year;
                }
                else if (i) {
                    i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
                    step = i[1];
                    interval = i[0];
                }
                else {
                    step = Math.max(tickStep$2(start, stop, interval), 1);
                    interval = millisecond;
                }
            }
            return step == null ? interval : interval.every(step);
        }
        scale.invert = function (y) {
            return new Date(invert(y));
        };
        scale.domain = function (_) {
            return arguments.length ? domain(map$6.call(_, number$8)) : domain().map(date$3);
        };
        scale.ticks = function (interval, step) {
            var d = domain(), t0 = d[0], t1 = d[d.length - 1], r = t1 < t0, t;
            if (r)
                t = t0, t0 = t1, t1 = t;
            t = tickInterval(interval, t0, t1, step);
            t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
            return r ? t.reverse() : t;
        };
        scale.tickFormat = function (count, specifier) {
            return specifier == null ? tickFormat : format(specifier);
        };
        scale.nice = function (interval, step) {
            var d = domain();
            return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
                ? domain(nice(d, interval))
                : scale;
        };
        scale.copy = function () {
            return copy$1(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
        };
        return scale;
    }
    function time () {
        return calendar(year$1, month$1, sunday$1, day$1, hour$1, minute$1, second$1, millisecond$1, timeFormat$1).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
    }

    function utcTime () {
        return calendar(utcYear$1, utcMonth$1, utcSunday$1, utcDay$1, utcHour$1, utcMinute$1, second$1, millisecond$1, utcFormat$1).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
    }

    function colors (s) {
        return s.match(/.{6}/g).map(function (x) {
            return "#" + x;
        });
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

    var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

    var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

    var cubehelix$7 = cubehelixLong$1(cubehelix$5(300, 0.5, 0.0), cubehelix$5(-240, 0.5, 1.0));

    var warm = cubehelixLong$1(cubehelix$5(-100, 0.75, 0.35), cubehelix$5(80, 1.50, 0.8));
    var cool = cubehelixLong$1(cubehelix$5(260, 0.75, 0.35), cubehelix$5(80, 1.50, 0.8));
    var rainbow = cubehelix$5();
    function rainbow$1 (t) {
        if (t < 0 || t > 1)
            t -= Math.floor(t);
        var ts = Math.abs(t - 0.5);
        rainbow.h = 360 * t - 100;
        rainbow.s = 1.5 - 1.5 * ts;
        rainbow.l = 0.8 - 0.9 * ts;
        return rainbow + "";
    }

    function ramp(range) {
        var n = range.length;
        return function (t) {
            return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
        };
    }
    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function sequential(interpolator) {
        var x0 = 0, x1 = 1, clamp = false;
        function scale(x) {
            var t = (x - x0) / (x1 - x0);
            return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
        }
        scale.domain = function (_) {
            return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
        };
        scale.clamp = function (_) {
            return arguments.length ? (clamp = !!_, scale) : clamp;
        };
        scale.interpolator = function (_) {
            return arguments.length ? (interpolator = _, scale) : interpolator;
        };
        scale.copy = function () {
            return sequential(interpolator).domain([x0, x1]).clamp(clamp);
        };
        return linearish$1(scale);
    }

    var xhtml$2 = "http://www.w3.org/1999/xhtml";
    var namespaces$2 = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml$2,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace$2 (name) {
        var prefix = name += "", i = prefix.indexOf(":");
        if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
            name = name.slice(i + 1);
        return namespaces$2.hasOwnProperty(prefix) ? { space: namespaces$2[prefix], local: name } : name;
    }

    function creatorInherit$2(name) {
        return function () {
            var document = this.ownerDocument, uri = this.namespaceURI;
            return uri === xhtml$2 && document.documentElement.namespaceURI === xhtml$2
                ? document.createElement(name)
                : document.createElementNS(uri, name);
        };
    }
    function creatorFixed$2(fullname) {
        return function () {
            return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
    }
    function creator$2 (name) {
        var fullname = namespace$2(name);
        return (fullname.local
            ? creatorFixed$2
            : creatorInherit$2)(fullname);
    }

    function none$2() { }
    function selector$2 (selector) {
        return selector == null ? none$2 : function () {
            return this.querySelector(selector);
        };
    }

    function selection_select$2 (select) {
        if (typeof select !== "function")
            select = selector$2(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                }
            }
        }
        return new Selection$4(subgroups, this._parents);
    }

    function empty$3() {
        return [];
    }
    function selectorAll$2 (selector) {
        return selector == null ? empty$3 : function () {
            return this.querySelectorAll(selector);
        };
    }

    function selection_selectAll$2 (select) {
        if (typeof select !== "function")
            select = selectorAll$2(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    subgroups.push(select.call(node, node.__data__, i, group));
                    parents.push(node);
                }
            }
        }
        return new Selection$4(subgroups, parents);
    }

    var matcher$2 = function (selector) {
        return function () {
            return this.matches(selector);
        };
    };
    if (typeof document !== "undefined") {
        var element$2 = document.documentElement;
        if (!element$2.matches) {
            var vendorMatches = element$2.webkitMatchesSelector
                || element$2.msMatchesSelector
                || element$2.mozMatchesSelector
                || element$2.oMatchesSelector;
            matcher$2 = function (selector) {
                return function () {
                    return vendorMatches.call(this, selector);
                };
            };
        }
    }
    var matcher$3 = matcher$2;

    function selection_filter$2 (match) {
        if (typeof match !== "function")
            match = matcher$3(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Selection$4(subgroups, this._parents);
    }

    function sparse$2 (update) {
        return new Array(update.length);
    }

    function selection_enter$2 () {
        return new Selection$4(this._enter || this._groups.map(sparse$2), this._parents);
    }
    function EnterNode$2(parent, datum) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum;
    }
    EnterNode$2.prototype = {
        constructor: EnterNode$2,
        appendChild: function (child) { return this._parent.insertBefore(child, this._next); },
        insertBefore: function (child, next) { return this._parent.insertBefore(child, next); },
        querySelector: function (selector) { return this._parent.querySelector(selector); },
        querySelectorAll: function (selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$f (x) {
        return function () {
            return x;
        };
    }

    var keyPrefix$3 = "$"; // Protect against keys like “__proto__”.
    function bindIndex$2(parent, group, enter, update, exit, data) {
        var i = 0, node, groupLength = group.length, dataLength = data.length;
        // Put any non-null nodes that fit into update.
        // Put any null nodes into enter.
        // Put any remaining data into enter.
        for (; i < dataLength; ++i) {
            if (node = group[i]) {
                node.__data__ = data[i];
                update[i] = node;
            }
            else {
                enter[i] = new EnterNode$2(parent, data[i]);
            }
        }
        // Put any non-null nodes that don’t fit into exit.
        for (; i < groupLength; ++i) {
            if (node = group[i]) {
                exit[i] = node;
            }
        }
    }
    function bindKey$2(parent, group, enter, update, exit, data, key) {
        var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
        // Compute the key for each node.
        // If multiple nodes have the same key, the duplicates are added to exit.
        for (i = 0; i < groupLength; ++i) {
            if (node = group[i]) {
                keyValues[i] = keyValue = keyPrefix$3 + key.call(node, node.__data__, i, group);
                if (keyValue in nodeByKeyValue) {
                    exit[i] = node;
                }
                else {
                    nodeByKeyValue[keyValue] = node;
                }
            }
        }
        // Compute the key for each datum.
        // If there a node associated with this key, join and add it to update.
        // If there is not (or the key is a duplicate), add it to enter.
        for (i = 0; i < dataLength; ++i) {
            keyValue = keyPrefix$3 + key.call(parent, data[i], i, data);
            if (node = nodeByKeyValue[keyValue]) {
                update[i] = node;
                node.__data__ = data[i];
                nodeByKeyValue[keyValue] = null;
            }
            else {
                enter[i] = new EnterNode$2(parent, data[i]);
            }
        }
        // Add any remaining nodes that were not bound to data to exit.
        for (i = 0; i < groupLength; ++i) {
            if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
                exit[i] = node;
            }
        }
    }
    function selection_data$2 (value, key) {
        if (!value) {
            data = new Array(this.size()), j = -1;
            this.each(function (d) { data[++j] = d; });
            return data;
        }
        var bind = key ? bindKey$2 : bindIndex$2, parents = this._parents, groups = this._groups;
        if (typeof value !== "function")
            value = constant$f(value);
        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
            var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
            bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
            // Now connect the enter nodes to their following update node, such that
            // appendChild can insert the materialized enter node before this node,
            // rather than at the end of the parent node.
            for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
                if (previous = enterGroup[i0]) {
                    if (i0 >= i1)
                        i1 = i0 + 1;
                    while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                        ;
                    previous._next = next || null;
                }
            }
        }
        update = new Selection$4(update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
    }

    function selection_exit$2 () {
        return new Selection$4(this._exit || this._groups.map(sparse$2), this._parents);
    }

    function selection_merge$2 (selection) {
        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Selection$4(merges, this._parents);
    }

    function selection_order$2 () {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
            for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    }

    function selection_sort$2 (compare) {
        if (!compare)
            compare = ascending$5;
        function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    sortgroup[i] = node;
                }
            }
            sortgroup.sort(compareNode);
        }
        return new Selection$4(sortgroups, this._parents).order();
    }
    function ascending$5(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call$2 () {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
    }

    function selection_nodes$2 () {
        var nodes = new Array(this.size()), i = -1;
        this.each(function () { nodes[++i] = this; });
        return nodes;
    }

    function selection_node$2 () {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    }

    function selection_size$2 () {
        var size = 0;
        this.each(function () { ++size; });
        return size;
    }

    function selection_empty$2 () {
        return !this.node();
    }

    function selection_each$2 (callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
                if (node = group[i])
                    callback.call(node, node.__data__, i, group);
            }
        }
        return this;
    }

    function attrRemove$4(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS$4(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant$4(name, value) {
        return function () {
            this.setAttribute(name, value);
        };
    }
    function attrConstantNS$4(fullname, value) {
        return function () {
            this.setAttributeNS(fullname.space, fullname.local, value);
        };
    }
    function attrFunction$4(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, v);
        };
    }
    function attrFunctionNS$4(fullname, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttributeNS(fullname.space, fullname.local);
            else
                this.setAttributeNS(fullname.space, fullname.local, v);
        };
    }
    function selection_attr$2 (name, value) {
        var fullname = namespace$2(name);
        if (arguments.length < 2) {
            var node = this.node();
            return fullname.local
                ? node.getAttributeNS(fullname.space, fullname.local)
                : node.getAttribute(fullname);
        }
        return this.each((value == null
            ? (fullname.local ? attrRemoveNS$4 : attrRemove$4) : (typeof value === "function"
            ? (fullname.local ? attrFunctionNS$4 : attrFunction$4)
            : (fullname.local ? attrConstantNS$4 : attrConstant$4)))(fullname, value));
    }

    function defaultView$2 (node) {
        return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
            || (node.document && node) // node is a Window
            || node.defaultView; // node is a Document
    }

    function styleRemove$4(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant$4(name, value, priority) {
        return function () {
            this.style.setProperty(name, value, priority);
        };
    }
    function styleFunction$4(name, value, priority) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, v, priority);
        };
    }
    function selection_style$2 (name, value, priority) {
        return arguments.length > 1
            ? this.each((value == null
                ? styleRemove$4 : typeof value === "function"
                ? styleFunction$4
                : styleConstant$4)(name, value, priority == null ? "" : priority))
            : styleValue$2(this.node(), name);
    }
    function styleValue$2(node, name) {
        return node.style.getPropertyValue(name)
            || defaultView$2(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove$2(name) {
        return function () {
            delete this[name];
        };
    }
    function propertyConstant$2(name, value) {
        return function () {
            this[name] = value;
        };
    }
    function propertyFunction$2(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                delete this[name];
            else
                this[name] = v;
        };
    }
    function selection_property$2 (name, value) {
        return arguments.length > 1
            ? this.each((value == null
                ? propertyRemove$2 : typeof value === "function"
                ? propertyFunction$2
                : propertyConstant$2)(name, value))
            : this.node()[name];
    }

    function classArray$2(string) {
        return string.trim().split(/^|\s+/);
    }
    function classList$2(node) {
        return node.classList || new ClassList$2(node);
    }
    function ClassList$2(node) {
        this._node = node;
        this._names = classArray$2(node.getAttribute("class") || "");
    }
    ClassList$2.prototype = {
        add: function (name) {
            var i = this._names.indexOf(name);
            if (i < 0) {
                this._names.push(name);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        remove: function (name) {
            var i = this._names.indexOf(name);
            if (i >= 0) {
                this._names.splice(i, 1);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        contains: function (name) {
            return this._names.indexOf(name) >= 0;
        }
    };
    function classedAdd$2(node, names) {
        var list = classList$2(node), i = -1, n = names.length;
        while (++i < n)
            list.add(names[i]);
    }
    function classedRemove$2(node, names) {
        var list = classList$2(node), i = -1, n = names.length;
        while (++i < n)
            list.remove(names[i]);
    }
    function classedTrue$2(names) {
        return function () {
            classedAdd$2(this, names);
        };
    }
    function classedFalse$2(names) {
        return function () {
            classedRemove$2(this, names);
        };
    }
    function classedFunction$2(names, value) {
        return function () {
            (value.apply(this, arguments) ? classedAdd$2 : classedRemove$2)(this, names);
        };
    }
    function selection_classed$2 (name, value) {
        var names = classArray$2(name + "");
        if (arguments.length < 2) {
            var list = classList$2(this.node()), i = -1, n = names.length;
            while (++i < n)
                if (!list.contains(names[i]))
                    return false;
            return true;
        }
        return this.each((typeof value === "function"
            ? classedFunction$2 : value
            ? classedTrue$2
            : classedFalse$2)(names, value));
    }

    function textRemove$2() {
        this.textContent = "";
    }
    function textConstant$4(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction$4(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        };
    }
    function selection_text$2 (value) {
        return arguments.length
            ? this.each(value == null
                ? textRemove$2 : (typeof value === "function"
                ? textFunction$4
                : textConstant$4)(value))
            : this.node().textContent;
    }

    function htmlRemove$2() {
        this.innerHTML = "";
    }
    function htmlConstant$2(value) {
        return function () {
            this.innerHTML = value;
        };
    }
    function htmlFunction$2(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        };
    }
    function selection_html$2 (value) {
        return arguments.length
            ? this.each(value == null
                ? htmlRemove$2 : (typeof value === "function"
                ? htmlFunction$2
                : htmlConstant$2)(value))
            : this.node().innerHTML;
    }

    function raise$3() {
        if (this.nextSibling)
            this.parentNode.appendChild(this);
    }
    function selection_raise$2 () {
        return this.each(raise$3);
    }

    function lower$2() {
        if (this.previousSibling)
            this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower$2 () {
        return this.each(lower$2);
    }

    function selection_append$2 (name) {
        var create = typeof name === "function" ? name : creator$2(name);
        return this.select(function () {
            return this.appendChild(create.apply(this, arguments));
        });
    }

    function constantNull$2() {
        return null;
    }
    function selection_insert$2 (name, before) {
        var create = typeof name === "function" ? name : creator$2(name), select = before == null ? constantNull$2 : typeof before === "function" ? before : selector$2(before);
        return this.select(function () {
            return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        });
    }

    function remove$2() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    function selection_remove$2 () {
        return this.each(remove$2);
    }

    function selection_cloneShallow$2() {
        return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
    }
    function selection_cloneDeep$2() {
        return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
    }
    function selection_clone$2 (deep) {
        return this.select(deep ? selection_cloneDeep$2 : selection_cloneShallow$2);
    }

    function selection_datum$2 (value) {
        return arguments.length
            ? this.property("__data__", value)
            : this.node().__data__;
    }

    var filterEvents$2 = {};
    var event$2 = null;
    if (typeof document !== "undefined") {
        var element$3 = document.documentElement;
        if (!("onmouseenter" in element$3)) {
            filterEvents$2 = { mouseenter: "mouseover", mouseleave: "mouseout" };
        }
    }
    function filterContextListener$2(listener, index, group) {
        listener = contextListener$2(listener, index, group);
        return function (event) {
            var related = event.relatedTarget;
            if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
                listener.call(this, event);
            }
        };
    }
    function contextListener$2(listener, index, group) {
        return function (event1) {
            var event0 = event$2; // Events can be reentrant (e.g., focus).
            event$2 = event1;
            try {
                listener.call(this, this.__data__, index, group);
            }
            finally {
                event$2 = event0;
            }
        };
    }
    function parseTypenames$5(typenames) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            return { type: t, name: name };
        });
    }
    function onRemove$2(typename) {
        return function () {
            var on = this.__on;
            if (!on)
                return;
            for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
                if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                    this.removeEventListener(o.type, o.listener, o.capture);
                }
                else {
                    on[++i] = o;
                }
            }
            if (++i)
                on.length = i;
            else
                delete this.__on;
        };
    }
    function onAdd$2(typename, value, capture) {
        var wrap = filterEvents$2.hasOwnProperty(typename.type) ? filterContextListener$2 : contextListener$2;
        return function (d, i, group) {
            var on = this.__on, o, listener = wrap(value, i, group);
            if (on)
                for (var j = 0, m = on.length; j < m; ++j) {
                    if ((o = on[j]).type === typename.type && o.name === typename.name) {
                        this.removeEventListener(o.type, o.listener, o.capture);
                        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                        o.value = value;
                        return;
                    }
                }
            this.addEventListener(typename.type, listener, capture);
            o = { type: typename.type, name: typename.name, value: value, listener: listener, capture: capture };
            if (!on)
                this.__on = [o];
            else
                on.push(o);
        };
    }
    function selection_on$2 (typename, value, capture) {
        var typenames = parseTypenames$5(typename + ""), i, n = typenames.length, t;
        if (arguments.length < 2) {
            var on = this.node().__on;
            if (on)
                for (var j = 0, m = on.length, o; j < m; ++j) {
                    for (i = 0, o = on[j]; i < n; ++i) {
                        if ((t = typenames[i]).type === o.type && t.name === o.name) {
                            return o.value;
                        }
                    }
                }
            return;
        }
        on = value ? onAdd$2 : onRemove$2;
        if (capture == null)
            capture = false;
        for (i = 0; i < n; ++i)
            this.each(on(typenames[i], value, capture));
        return this;
    }
    function customEvent$2(event1, listener, that, args) {
        var event0 = event$2;
        event1.sourceEvent = event$2;
        event$2 = event1;
        try {
            return listener.apply(that, args);
        }
        finally {
            event$2 = event0;
        }
    }

    function dispatchEvent$2(node, type, params) {
        var window = defaultView$2(node), event = window.CustomEvent;
        if (typeof event === "function") {
            event = new event(type, params);
        }
        else {
            event = window.document.createEvent("Event");
            if (params)
                event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
            else
                event.initEvent(type, false, false);
        }
        node.dispatchEvent(event);
    }
    function dispatchConstant$2(type, params) {
        return function () {
            return dispatchEvent$2(this, type, params);
        };
    }
    function dispatchFunction$2(type, params) {
        return function () {
            return dispatchEvent$2(this, type, params.apply(this, arguments));
        };
    }
    function selection_dispatch$2 (type, params) {
        return this.each((typeof params === "function"
            ? dispatchFunction$2
            : dispatchConstant$2)(type, params));
    }

    var root$2 = [null];
    function Selection$4(groups, parents) {
        this._groups = groups;
        this._parents = parents;
    }
    function selection$2() {
        return new Selection$4([[document.documentElement]], root$2);
    }
    Selection$4.prototype = selection$2.prototype = {
        constructor: Selection$4,
        select: selection_select$2,
        selectAll: selection_selectAll$2,
        filter: selection_filter$2,
        data: selection_data$2,
        enter: selection_enter$2,
        exit: selection_exit$2,
        merge: selection_merge$2,
        order: selection_order$2,
        sort: selection_sort$2,
        call: selection_call$2,
        nodes: selection_nodes$2,
        node: selection_node$2,
        size: selection_size$2,
        empty: selection_empty$2,
        each: selection_each$2,
        attr: selection_attr$2,
        style: selection_style$2,
        property: selection_property$2,
        classed: selection_classed$2,
        text: selection_text$2,
        html: selection_html$2,
        raise: selection_raise$2,
        lower: selection_lower$2,
        append: selection_append$2,
        insert: selection_insert$2,
        remove: selection_remove$2,
        clone: selection_clone$2,
        datum: selection_datum$2,
        on: selection_on$2,
        dispatch: selection_dispatch$2
    };

    function select$2 (selector) {
        return typeof selector === "string"
            ? new Selection$4([[document.querySelector(selector)]], [document.documentElement])
            : new Selection$4([[selector]], root$2);
    }

    function create$2 (name) {
        return select$2(creator$2(name).call(document.documentElement));
    }

    var nextId = 0;
    function local$1() {
        return new Local;
    }
    function Local() {
        this._ = "@" + (++nextId).toString(36);
    }
    Local.prototype = local$1.prototype = {
        constructor: Local,
        get: function (node) {
            var id = this._;
            while (!(id in node))
                if (!(node = node.parentNode))
                    return;
            return node[id];
        },
        set: function (node, value) {
            return node[this._] = value;
        },
        remove: function (node) {
            return this._ in node && delete node[this._];
        },
        toString: function () {
            return this._;
        }
    };

    function sourceEvent$2 () {
        var current = event$2, source;
        while (source = current.sourceEvent)
            current = source;
        return current;
    }

    function point$4 (node, event) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            point.x = event.clientX, point.y = event.clientY;
            point = point.matrixTransform(node.getScreenCTM().inverse());
            return [point.x, point.y];
        }
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }

    function mouse$2 (node) {
        var event = sourceEvent$2();
        if (event.changedTouches)
            event = event.changedTouches[0];
        return point$4(node, event);
    }

    function selectAll$1 (selector) {
        return typeof selector === "string"
            ? new Selection$4([document.querySelectorAll(selector)], [document.documentElement])
            : new Selection$4([selector == null ? [] : selector], root$2);
    }

    function touch$2 (node, touches, identifier) {
        if (arguments.length < 3)
            identifier = touches, touches = sourceEvent$2().changedTouches;
        for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
                return point$4(node, touch);
            }
        }
        return null;
    }

    function touches (node, touches) {
        if (touches == null)
            touches = sourceEvent$2().touches;
        for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
            points[i] = point$4(node, touches[i]);
        }
        return points;
    }

    var pi$6 = Math.PI, tau$6 = 2 * pi$6, epsilon$6 = 1e-6, tauEpsilon$2 = tau$6 - epsilon$6;
    function Path$2() {
        this._x0 = this._y0 = // start of current subpath
            this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
    }
    function path$2() {
        return new Path$2;
    }
    Path$2.prototype = path$2.prototype = {
        constructor: Path$2,
        moveTo: function (x, y) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
        },
        closePath: function () {
            if (this._x1 !== null) {
                this._x1 = this._x0, this._y1 = this._y0;
                this._ += "Z";
            }
        },
        lineTo: function (x, y) {
            this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        quadraticCurveTo: function (x1, y1, x, y) {
            this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        bezierCurveTo: function (x1, y1, x2, y2, x, y) {
            this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
        },
        arcTo: function (x1, y1, x2, y2, r) {
            x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
            var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
            // Is the radius negative? Error.
            if (r < 0)
                throw new Error("negative radius: " + r);
            // Is this path empty? Move to (x1,y1).
            if (this._x1 === null) {
                this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
            }
            // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
            else if (!(l01_2 > epsilon$6))
                ;
            // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
            // Equivalently, is (x1,y1) coincident with (x2,y2)?
            // Or, is the radius zero? Line to (x1,y1).
            else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$6) || !r) {
                this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
            }
            // Otherwise, draw an arc!
            else {
                var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$6 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
                // If the start tangent is not coincident with (x0,y0), line to.
                if (Math.abs(t01 - 1) > epsilon$6) {
                    this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
                }
                this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
            }
        },
        arc: function (x, y, r, a0, a1, ccw) {
            x = +x, y = +y, r = +r, ccw = !!ccw;
            var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x + dx, y0 = y + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
            // Is the radius negative? Error.
            if (r < 0)
                throw new Error("negative radius: " + r);
            // Is this path empty? Move to (x0,y0).
            if (this._x1 === null) {
                this._ += "M" + x0 + "," + y0;
            }
            // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
            else if (Math.abs(this._x1 - x0) > epsilon$6 || Math.abs(this._y1 - y0) > epsilon$6) {
                this._ += "L" + x0 + "," + y0;
            }
            // Is this arc empty? We’re done.
            if (!r)
                return;
            // Does the angle go the wrong way? Flip the direction.
            if (da < 0)
                da = da % tau$6 + tau$6;
            // Is this a complete circle? Draw two arcs to complete the circle.
            if (da > tauEpsilon$2) {
                this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
            }
            // Is this arc non-empty? Draw an arc!
            else if (da > epsilon$6) {
                this._ += "A" + r + "," + r + ",0," + (+(da >= pi$6)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
            }
        },
        rect: function (x, y, w, h) {
            this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
        },
        toString: function () {
            return this._;
        }
    };

    function constant$g (x) {
        return function constant() {
            return x;
        };
    }

    var abs$1 = Math.abs;
    var atan2$1 = Math.atan2;
    var cos$2 = Math.cos;
    var max$3 = Math.max;
    var min$2 = Math.min;
    var sin$2 = Math.sin;
    var sqrt$3 = Math.sqrt;
    var epsilon$7 = 1e-12;
    var pi$7 = Math.PI;
    var halfPi$3 = pi$7 / 2;
    var tau$7 = 2 * pi$7;
    function acos$1(x) {
        return x > 1 ? 0 : x < -1 ? pi$7 : Math.acos(x);
    }
    function asin$1(x) {
        return x >= 1 ? halfPi$3 : x <= -1 ? -halfPi$3 : Math.asin(x);
    }

    function arcInnerRadius(d) {
        return d.innerRadius;
    }
    function arcOuterRadius(d) {
        return d.outerRadius;
    }
    function arcStartAngle(d) {
        return d.startAngle;
    }
    function arcEndAngle(d) {
        return d.endAngle;
    }
    function arcPadAngle(d) {
        return d && d.padAngle; // Note: optional!
    }
    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
        var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
        return [x0 + t * x10, y0 + t * y10];
    }
    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
        var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / sqrt$3(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt$3(max$3(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
        // Pick the closer of the two intersection points.
        // TODO Is there a faster way to determine which intersection to use?
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
            cx0 = cx1, cy0 = cy1;
        return {
            cx: cx0,
            cy: cy0,
            x01: -ox,
            y01: -oy,
            x11: cx0 * (r1 / r - 1),
            y11: cy0 * (r1 / r - 1)
        };
    }
    function arc () {
        var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$g(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
        function arc() {
            var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi$3, a1 = endAngle.apply(this, arguments) - halfPi$3, da = abs$1(a1 - a0), cw = a1 > a0;
            if (!context)
                context = buffer = path$2();
            // Ensure that the outer radius is always larger than the inner radius.
            if (r1 < r0)
                r = r1, r1 = r0, r0 = r;
            // Is it a point?
            if (!(r1 > epsilon$7))
                context.moveTo(0, 0);
            // Or is it a circle or annulus?
            else if (da > tau$7 - epsilon$7) {
                context.moveTo(r1 * cos$2(a0), r1 * sin$2(a0));
                context.arc(0, 0, r1, a0, a1, !cw);
                if (r0 > epsilon$7) {
                    context.moveTo(r0 * cos$2(a1), r0 * sin$2(a1));
                    context.arc(0, 0, r0, a1, a0, cw);
                }
            }
            // Or is it a circular or annular sector?
            else {
                var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = (ap > epsilon$7) && (padRadius ? +padRadius.apply(this, arguments) : sqrt$3(r0 * r0 + r1 * r1)), rc = min$2(abs$1(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
                // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
                if (rp > epsilon$7) {
                    var p0 = asin$1(rp / r0 * sin$2(ap)), p1 = asin$1(rp / r1 * sin$2(ap));
                    if ((da0 -= p0 * 2) > epsilon$7)
                        p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
                    else
                        da0 = 0, a00 = a10 = (a0 + a1) / 2;
                    if ((da1 -= p1 * 2) > epsilon$7)
                        p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
                    else
                        da1 = 0, a01 = a11 = (a0 + a1) / 2;
                }
                var x01 = r1 * cos$2(a01), y01 = r1 * sin$2(a01), x10 = r0 * cos$2(a10), y10 = r0 * sin$2(a10);
                // Apply rounded corners?
                if (rc > epsilon$7) {
                    var x11 = r1 * cos$2(a11), y11 = r1 * sin$2(a11), x00 = r0 * cos$2(a00), y00 = r0 * sin$2(a00);
                    // Restrict the corner radius according to the sector angle.
                    if (da < pi$7) {
                        var oc = da0 > epsilon$7 ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10], ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin$2(acos$1((ax * bx + ay * by) / (sqrt$3(ax * ax + ay * ay) * sqrt$3(bx * bx + by * by))) / 2), lc = sqrt$3(oc[0] * oc[0] + oc[1] * oc[1]);
                        rc0 = min$2(rc, (r0 - lc) / (kc - 1));
                        rc1 = min$2(rc, (r1 - lc) / (kc + 1));
                    }
                }
                // Is the sector collapsed to a line?
                if (!(da1 > epsilon$7))
                    context.moveTo(x01, y01);
                // Does the sector’s outer ring have rounded corners?
                else if (rc1 > epsilon$7) {
                    t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
                    t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
                    context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
                    // Have the corners merged?
                    if (rc1 < rc)
                        context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);
                    // Otherwise, draw the two corners and the ring.
                    else {
                        context.arc(t0.cx, t0.cy, rc1, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
                        context.arc(0, 0, r1, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                        context.arc(t1.cx, t1.cy, rc1, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
                    }
                }
                // Or is the outer ring just a circular arc?
                else
                    context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
                // Is there no inner ring, and it’s a circular sector?
                // Or perhaps it’s an annular sector collapsed due to padding?
                if (!(r0 > epsilon$7) || !(da0 > epsilon$7))
                    context.lineTo(x10, y10);
                // Does the sector’s inner ring (or point) have rounded corners?
                else if (rc0 > epsilon$7) {
                    t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
                    t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
                    context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
                    // Have the corners merged?
                    if (rc0 < rc)
                        context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t1.y01, t1.x01), !cw);
                    // Otherwise, draw the two corners and the ring.
                    else {
                        context.arc(t0.cx, t0.cy, rc0, atan2$1(t0.y01, t0.x01), atan2$1(t0.y11, t0.x11), !cw);
                        context.arc(0, 0, r0, atan2$1(t0.cy + t0.y11, t0.cx + t0.x11), atan2$1(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                        context.arc(t1.cx, t1.cy, rc0, atan2$1(t1.y11, t1.x11), atan2$1(t1.y01, t1.x01), !cw);
                    }
                }
                // Or is the inner ring just a circular arc?
                else
                    context.arc(0, 0, r0, a10, a00, cw);
            }
            context.closePath();
            if (buffer)
                return context = null, buffer + "" || null;
        }
        arc.centroid = function () {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$7 / 2;
            return [cos$2(a) * r, sin$2(a) * r];
        };
        arc.innerRadius = function (_) {
            return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$g(+_), arc) : innerRadius;
        };
        arc.outerRadius = function (_) {
            return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$g(+_), arc) : outerRadius;
        };
        arc.cornerRadius = function (_) {
            return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$g(+_), arc) : cornerRadius;
        };
        arc.padRadius = function (_) {
            return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$g(+_), arc) : padRadius;
        };
        arc.startAngle = function (_) {
            return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$g(+_), arc) : startAngle;
        };
        arc.endAngle = function (_) {
            return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$g(+_), arc) : endAngle;
        };
        arc.padAngle = function (_) {
            return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$g(+_), arc) : padAngle;
        };
        arc.context = function (_) {
            return arguments.length ? ((context = _ == null ? null : _), arc) : context;
        };
        return arc;
    }

    function Linear(context) {
        this._context = context;
    }
    Linear.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._point = 0;
        },
        lineEnd: function () {
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1: this._point = 2; // proceed
                default:
                    this._context.lineTo(x, y);
                    break;
            }
        }
    };
    function curveLinear (context) {
        return new Linear(context);
    }

    function x$5(p) {
        return p[0];
    }
    function y$4(p) {
        return p[1];
    }

    function line () {
        var x = x$5, y = y$4, defined = constant$g(true), context = null, curve = curveLinear, output = null;
        function line(data) {
            var i, n = data.length, d, defined0 = false, buffer;
            if (context == null)
                output = curve(buffer = path$2());
            for (i = 0; i <= n; ++i) {
                if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                    if (defined0 = !defined0)
                        output.lineStart();
                    else
                        output.lineEnd();
                }
                if (defined0)
                    output.point(+x(d, i, data), +y(d, i, data));
            }
            if (buffer)
                return output = null, buffer + "" || null;
        }
        line.x = function (_) {
            return arguments.length ? (x = typeof _ === "function" ? _ : constant$g(+_), line) : x;
        };
        line.y = function (_) {
            return arguments.length ? (y = typeof _ === "function" ? _ : constant$g(+_), line) : y;
        };
        line.defined = function (_) {
            return arguments.length ? (defined = typeof _ === "function" ? _ : constant$g(!!_), line) : defined;
        };
        line.curve = function (_) {
            return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
        };
        line.context = function (_) {
            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
        };
        return line;
    }

    function area$2 () {
        var x0 = x$5, x1 = null, y0 = constant$g(0), y1 = y$4, defined = constant$g(true), context = null, curve = curveLinear, output = null;
        function area(data) {
            var i, j, k, n = data.length, d, defined0 = false, buffer, x0z = new Array(n), y0z = new Array(n);
            if (context == null)
                output = curve(buffer = path$2());
            for (i = 0; i <= n; ++i) {
                if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                    if (defined0 = !defined0) {
                        j = i;
                        output.areaStart();
                        output.lineStart();
                    }
                    else {
                        output.lineEnd();
                        output.lineStart();
                        for (k = i - 1; k >= j; --k) {
                            output.point(x0z[k], y0z[k]);
                        }
                        output.lineEnd();
                        output.areaEnd();
                    }
                }
                if (defined0) {
                    x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
                    output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
                }
            }
            if (buffer)
                return output = null, buffer + "" || null;
        }
        function arealine() {
            return line().defined(defined).curve(curve).context(context);
        }
        area.x = function (_) {
            return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$g(+_), x1 = null, area) : x0;
        };
        area.x0 = function (_) {
            return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$g(+_), area) : x0;
        };
        area.x1 = function (_) {
            return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$g(+_), area) : x1;
        };
        area.y = function (_) {
            return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$g(+_), y1 = null, area) : y0;
        };
        area.y0 = function (_) {
            return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$g(+_), area) : y0;
        };
        area.y1 = function (_) {
            return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$g(+_), area) : y1;
        };
        area.lineX0 =
            area.lineY0 = function () {
                return arealine().x(x0).y(y0);
            };
        area.lineY1 = function () {
            return arealine().x(x0).y(y1);
        };
        area.lineX1 = function () {
            return arealine().x(x1).y(y0);
        };
        area.defined = function (_) {
            return arguments.length ? (defined = typeof _ === "function" ? _ : constant$g(!!_), area) : defined;
        };
        area.curve = function (_) {
            return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
        };
        area.context = function (_) {
            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
        };
        return area;
    }

    function descending$1 (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$d (d) {
        return d;
    }

    function pie () {
        var value = identity$d, sortValues = descending$1, sort = null, startAngle = constant$g(0), endAngle = constant$g(tau$7), padAngle = constant$g(0);
        function pie(data) {
            var i, n = data.length, j, k, sum = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau$7, Math.max(-tau$7, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
            for (i = 0; i < n; ++i) {
                if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
                    sum += v;
                }
            }
            // Optionally sort the arcs by previously-computed values or by data.
            if (sortValues != null)
                index.sort(function (i, j) { return sortValues(arcs[i], arcs[j]); });
            else if (sort != null)
                index.sort(function (i, j) { return sort(data[i], data[j]); });
            // Compute the arcs! They are stored in the original data's order.
            for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
                j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
                    data: data[j],
                    index: i,
                    value: v,
                    startAngle: a0,
                    endAngle: a1,
                    padAngle: p
                };
            }
            return arcs;
        }
        pie.value = function (_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant$g(+_), pie) : value;
        };
        pie.sortValues = function (_) {
            return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
        };
        pie.sort = function (_) {
            return arguments.length ? (sort = _, sortValues = null, pie) : sort;
        };
        pie.startAngle = function (_) {
            return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$g(+_), pie) : startAngle;
        };
        pie.endAngle = function (_) {
            return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$g(+_), pie) : endAngle;
        };
        pie.padAngle = function (_) {
            return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$g(+_), pie) : padAngle;
        };
        return pie;
    }

    var curveRadialLinear = curveRadial(curveLinear);
    function Radial(curve) {
        this._curve = curve;
    }
    Radial.prototype = {
        areaStart: function () {
            this._curve.areaStart();
        },
        areaEnd: function () {
            this._curve.areaEnd();
        },
        lineStart: function () {
            this._curve.lineStart();
        },
        lineEnd: function () {
            this._curve.lineEnd();
        },
        point: function (a, r) {
            this._curve.point(r * Math.sin(a), r * -Math.cos(a));
        }
    };
    function curveRadial(curve) {
        function radial(context) {
            return new Radial(curve(context));
        }
        radial._curve = curve;
        return radial;
    }

    function lineRadial(l) {
        var c = l.curve;
        l.angle = l.x, delete l.x;
        l.radius = l.y, delete l.y;
        l.curve = function (_) {
            return arguments.length ? c(curveRadial(_)) : c()._curve;
        };
        return l;
    }
    function lineRadial$1 () {
        return lineRadial(line().curve(curveRadialLinear));
    }

    function areaRadial () {
        var a = area$2().curve(curveRadialLinear), c = a.curve, x0 = a.lineX0, x1 = a.lineX1, y0 = a.lineY0, y1 = a.lineY1;
        a.angle = a.x, delete a.x;
        a.startAngle = a.x0, delete a.x0;
        a.endAngle = a.x1, delete a.x1;
        a.radius = a.y, delete a.y;
        a.innerRadius = a.y0, delete a.y0;
        a.outerRadius = a.y1, delete a.y1;
        a.lineStartAngle = function () { return lineRadial(x0()); }, delete a.lineX0;
        a.lineEndAngle = function () { return lineRadial(x1()); }, delete a.lineX1;
        a.lineInnerRadius = function () { return lineRadial(y0()); }, delete a.lineY0;
        a.lineOuterRadius = function () { return lineRadial(y1()); }, delete a.lineY1;
        a.curve = function (_) {
            return arguments.length ? c(curveRadial(_)) : c()._curve;
        };
        return a;
    }

    function pointRadial (x, y) {
        return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    var slice$9 = Array.prototype.slice;

    function linkSource$1(d) {
        return d.source;
    }
    function linkTarget$1(d) {
        return d.target;
    }
    function link$3(curve) {
        var source = linkSource$1, target = linkTarget$1, x = x$5, y = y$4, context = null;
        function link() {
            var buffer, argv = slice$9.call(arguments), s = source.apply(this, argv), t = target.apply(this, argv);
            if (!context)
                context = buffer = path$2();
            curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
            if (buffer)
                return context = null, buffer + "" || null;
        }
        link.source = function (_) {
            return arguments.length ? (source = _, link) : source;
        };
        link.target = function (_) {
            return arguments.length ? (target = _, link) : target;
        };
        link.x = function (_) {
            return arguments.length ? (x = typeof _ === "function" ? _ : constant$g(+_), link) : x;
        };
        link.y = function (_) {
            return arguments.length ? (y = typeof _ === "function" ? _ : constant$g(+_), link) : y;
        };
        link.context = function (_) {
            return arguments.length ? ((context = _ == null ? null : _), link) : context;
        };
        return link;
    }
    function curveHorizontal$1(context, x0, y0, x1, y1) {
        context.moveTo(x0, y0);
        context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
    }
    function curveVertical(context, x0, y0, x1, y1) {
        context.moveTo(x0, y0);
        context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
    }
    function curveRadial$1(context, x0, y0, x1, y1) {
        var p0 = pointRadial(x0, y0), p1 = pointRadial(x0, y0 = (y0 + y1) / 2), p2 = pointRadial(x1, y0), p3 = pointRadial(x1, y1);
        context.moveTo(p0[0], p0[1]);
        context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }
    function linkHorizontal$1() {
        return link$3(curveHorizontal$1);
    }
    function linkVertical() {
        return link$3(curveVertical);
    }
    function linkRadial() {
        var l = link$3(curveRadial$1);
        l.angle = l.x, delete l.x;
        l.radius = l.y, delete l.y;
        return l;
    }

    var circle$2 = {
        draw: function (context, size) {
            var r = Math.sqrt(size / pi$7);
            context.moveTo(r, 0);
            context.arc(0, 0, r, 0, tau$7);
        }
    };

    var cross$2 = {
        draw: function (context, size) {
            var r = Math.sqrt(size / 5) / 2;
            context.moveTo(-3 * r, -r);
            context.lineTo(-r, -r);
            context.lineTo(-r, -3 * r);
            context.lineTo(r, -3 * r);
            context.lineTo(r, -r);
            context.lineTo(3 * r, -r);
            context.lineTo(3 * r, r);
            context.lineTo(r, r);
            context.lineTo(r, 3 * r);
            context.lineTo(-r, 3 * r);
            context.lineTo(-r, r);
            context.lineTo(-3 * r, r);
            context.closePath();
        }
    };

    var tan30$1 = Math.sqrt(1 / 3), tan30_2$1 = tan30$1 * 2;
    var diamond = {
        draw: function (context, size) {
            var y = Math.sqrt(size / tan30_2$1), x = y * tan30$1;
            context.moveTo(0, -y);
            context.lineTo(x, 0);
            context.lineTo(0, y);
            context.lineTo(-x, 0);
            context.closePath();
        }
    };

    var ka$1 = 0.89081309152928522810, kr$1 = Math.sin(pi$7 / 10) / Math.sin(7 * pi$7 / 10), kx$1 = Math.sin(tau$7 / 10) * kr$1, ky$1 = -Math.cos(tau$7 / 10) * kr$1;
    var star = {
        draw: function (context, size) {
            var r = Math.sqrt(size * ka$1), x = kx$1 * r, y = ky$1 * r;
            context.moveTo(0, -r);
            context.lineTo(x, y);
            for (var i = 1; i < 5; ++i) {
                var a = tau$7 * i / 5, c = Math.cos(a), s = Math.sin(a);
                context.lineTo(s * r, -c * r);
                context.lineTo(c * x - s * y, s * x + c * y);
            }
            context.closePath();
        }
    };

    var square = {
        draw: function (context, size) {
            var w = Math.sqrt(size), x = -w / 2;
            context.rect(x, x, w, w);
        }
    };

    var sqrt3$1 = Math.sqrt(3);
    var triangle = {
        draw: function (context, size) {
            var y = -Math.sqrt(size / (sqrt3$1 * 3));
            context.moveTo(0, y * 2);
            context.lineTo(-sqrt3$1 * y, -y);
            context.lineTo(sqrt3$1 * y, -y);
            context.closePath();
        }
    };

    var c = -0.5, s = Math.sqrt(3) / 2, k$1 = 1 / Math.sqrt(12), a = (k$1 / 2 + 1) * 3;
    var wye = {
        draw: function (context, size) {
            var r = Math.sqrt(size / a), x0 = r / 2, y0 = r * k$1, x1 = x0, y1 = r * k$1 + r, x2 = -x1, y2 = y1;
            context.moveTo(x0, y0);
            context.lineTo(x1, y1);
            context.lineTo(x2, y2);
            context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
            context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
            context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
            context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
            context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
            context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
            context.closePath();
        }
    };

    var symbols$1 = [
        circle$2,
        cross$2,
        diamond,
        square,
        star,
        triangle,
        wye
    ];
    function symbol () {
        var type = constant$g(circle$2), size = constant$g(64), context = null;
        function symbol() {
            var buffer;
            if (!context)
                context = buffer = path$2();
            type.apply(this, arguments).draw(context, +size.apply(this, arguments));
            if (buffer)
                return context = null, buffer + "" || null;
        }
        symbol.type = function (_) {
            return arguments.length ? (type = typeof _ === "function" ? _ : constant$g(_), symbol) : type;
        };
        symbol.size = function (_) {
            return arguments.length ? (size = typeof _ === "function" ? _ : constant$g(+_), symbol) : size;
        };
        symbol.context = function (_) {
            return arguments.length ? (context = _ == null ? null : _, symbol) : context;
        };
        return symbol;
    }

    function noop$4 () { }

    function point$5(that, x, y) {
        that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
    }
    function Basis(context) {
        this._context = context;
    }
    Basis.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 =
                this._y0 = this._y1 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 3: point$5(this, this._x1, this._y1); // proceed
                case 2:
                    this._context.lineTo(this._x1, this._y1);
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3;
                    this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // proceed
                default:
                    point$5(this, x, y);
                    break;
            }
            this._x0 = this._x1, this._x1 = x;
            this._y0 = this._y1, this._y1 = y;
        }
    };
    function basis$2 (context) {
        return new Basis(context);
    }

    function BasisClosed(context) {
        this._context = context;
    }
    BasisClosed.prototype = {
        areaStart: noop$4,
        areaEnd: noop$4,
        lineStart: function () {
            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
                this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 1: {
                    this._context.moveTo(this._x2, this._y2);
                    this._context.closePath();
                    break;
                }
                case 2: {
                    this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
                    this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
                    this._context.closePath();
                    break;
                }
                case 3: {
                    this.point(this._x2, this._y2);
                    this.point(this._x3, this._y3);
                    this.point(this._x4, this._y4);
                    break;
                }
            }
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._x2 = x, this._y2 = y;
                    break;
                case 1:
                    this._point = 2;
                    this._x3 = x, this._y3 = y;
                    break;
                case 2:
                    this._point = 3;
                    this._x4 = x, this._y4 = y;
                    this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);
                    break;
                default:
                    point$5(this, x, y);
                    break;
            }
            this._x0 = this._x1, this._x1 = x;
            this._y0 = this._y1, this._y1 = y;
        }
    };
    function basisClosed$1 (context) {
        return new BasisClosed(context);
    }

    function BasisOpen(context) {
        this._context = context;
    }
    BasisOpen.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 =
                this._y0 = this._y1 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            if (this._line || (this._line !== 0 && this._point === 3))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3;
                    var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6;
                    this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
                    break;
                case 3: this._point = 4; // proceed
                default:
                    point$5(this, x, y);
                    break;
            }
            this._x0 = this._x1, this._x1 = x;
            this._y0 = this._y1, this._y1 = y;
        }
    };
    function basisOpen (context) {
        return new BasisOpen(context);
    }

    function Bundle(context, beta) {
        this._basis = new Basis(context);
        this._beta = beta;
    }
    Bundle.prototype = {
        lineStart: function () {
            this._x = [];
            this._y = [];
            this._basis.lineStart();
        },
        lineEnd: function () {
            var x = this._x, y = this._y, j = x.length - 1;
            if (j > 0) {
                var x0 = x[0], y0 = y[0], dx = x[j] - x0, dy = y[j] - y0, i = -1, t;
                while (++i <= j) {
                    t = i / j;
                    this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
                }
            }
            this._x = this._y = null;
            this._basis.lineEnd();
        },
        point: function (x, y) {
            this._x.push(+x);
            this._y.push(+y);
        }
    };
    var bundle = (function custom(beta) {
        function bundle(context) {
            return beta === 1 ? new Basis(context) : new Bundle(context, beta);
        }
        bundle.beta = function (beta) {
            return custom(+beta);
        };
        return bundle;
    })(0.85);

    function point$6(that, x, y) {
        that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
    }
    function Cardinal(context, tension) {
        this._context = context;
        this._k = (1 - tension) / 6;
    }
    Cardinal.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 = this._x2 =
                this._y0 = this._y1 = this._y2 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 2:
                    this._context.lineTo(this._x2, this._y2);
                    break;
                case 3:
                    point$6(this, this._x1, this._y1);
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1:
                    this._point = 2;
                    this._x1 = x, this._y1 = y;
                    break;
                case 2: this._point = 3; // proceed
                default:
                    point$6(this, x, y);
                    break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
    };
    var cardinal = (function custom(tension) {
        function cardinal(context) {
            return new Cardinal(context, tension);
        }
        cardinal.tension = function (tension) {
            return custom(+tension);
        };
        return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
        this._context = context;
        this._k = (1 - tension) / 6;
    }
    CardinalClosed.prototype = {
        areaStart: noop$4,
        areaEnd: noop$4,
        lineStart: function () {
            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
                this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 1: {
                    this._context.moveTo(this._x3, this._y3);
                    this._context.closePath();
                    break;
                }
                case 2: {
                    this._context.lineTo(this._x3, this._y3);
                    this._context.closePath();
                    break;
                }
                case 3: {
                    this.point(this._x3, this._y3);
                    this.point(this._x4, this._y4);
                    this.point(this._x5, this._y5);
                    break;
                }
            }
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._x3 = x, this._y3 = y;
                    break;
                case 1:
                    this._point = 2;
                    this._context.moveTo(this._x4 = x, this._y4 = y);
                    break;
                case 2:
                    this._point = 3;
                    this._x5 = x, this._y5 = y;
                    break;
                default:
                    point$6(this, x, y);
                    break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
    };
    var cardinalClosed = (function custom(tension) {
        function cardinal(context) {
            return new CardinalClosed(context, tension);
        }
        cardinal.tension = function (tension) {
            return custom(+tension);
        };
        return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
        this._context = context;
        this._k = (1 - tension) / 6;
    }
    CardinalOpen.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 = this._x2 =
                this._y0 = this._y1 = this._y2 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            if (this._line || (this._line !== 0 && this._point === 3))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3;
                    this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                    break;
                case 3: this._point = 4; // proceed
                default:
                    point$6(this, x, y);
                    break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
    };
    var cardinalOpen = (function custom(tension) {
        function cardinal(context) {
            return new CardinalOpen(context, tension);
        }
        cardinal.tension = function (tension) {
            return custom(+tension);
        };
        return cardinal;
    })(0);

    function point$7(that, x, y) {
        var x1 = that._x1, y1 = that._y1, x2 = that._x2, y2 = that._y2;
        if (that._l01_a > epsilon$7) {
            var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
            x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
            y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
        }
        if (that._l23_a > epsilon$7) {
            var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
            x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
            y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
        }
        that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }
    function CatmullRom(context, alpha) {
        this._context = context;
        this._alpha = alpha;
    }
    CatmullRom.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 = this._x2 =
                this._y0 = this._y1 = this._y2 = NaN;
            this._l01_a = this._l12_a = this._l23_a =
                this._l01_2a = this._l12_2a = this._l23_2a =
                    this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 2:
                    this._context.lineTo(this._x2, this._y2);
                    break;
                case 3:
                    this.point(this._x2, this._y2);
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            if (this._point) {
                var x23 = this._x2 - x, y23 = this._y2 - y;
                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2: this._point = 3; // proceed
                default:
                    point$7(this, x, y);
                    break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
    };
    var catmullRom = (function custom(alpha) {
        function catmullRom(context) {
            return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
        }
        catmullRom.alpha = function (alpha) {
            return custom(+alpha);
        };
        return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
        this._context = context;
        this._alpha = alpha;
    }
    CatmullRomClosed.prototype = {
        areaStart: noop$4,
        areaEnd: noop$4,
        lineStart: function () {
            this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
                this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
            this._l01_a = this._l12_a = this._l23_a =
                this._l01_2a = this._l12_2a = this._l23_2a =
                    this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 1: {
                    this._context.moveTo(this._x3, this._y3);
                    this._context.closePath();
                    break;
                }
                case 2: {
                    this._context.lineTo(this._x3, this._y3);
                    this._context.closePath();
                    break;
                }
                case 3: {
                    this.point(this._x3, this._y3);
                    this.point(this._x4, this._y4);
                    this.point(this._x5, this._y5);
                    break;
                }
            }
        },
        point: function (x, y) {
            x = +x, y = +y;
            if (this._point) {
                var x23 = this._x2 - x, y23 = this._y2 - y;
                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._x3 = x, this._y3 = y;
                    break;
                case 1:
                    this._point = 2;
                    this._context.moveTo(this._x4 = x, this._y4 = y);
                    break;
                case 2:
                    this._point = 3;
                    this._x5 = x, this._y5 = y;
                    break;
                default:
                    point$7(this, x, y);
                    break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
    };
    var catmullRomClosed = (function custom(alpha) {
        function catmullRom(context) {
            return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
        }
        catmullRom.alpha = function (alpha) {
            return custom(+alpha);
        };
        return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
        this._context = context;
        this._alpha = alpha;
    }
    CatmullRomOpen.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 = this._x2 =
                this._y0 = this._y1 = this._y2 = NaN;
            this._l01_a = this._l12_a = this._l23_a =
                this._l01_2a = this._l12_2a = this._l23_2a =
                    this._point = 0;
        },
        lineEnd: function () {
            if (this._line || (this._line !== 0 && this._point === 3))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            if (this._point) {
                var x23 = this._x2 - x, y23 = this._y2 - y;
                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
                case 0:
                    this._point = 1;
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3;
                    this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
                    break;
                case 3: this._point = 4; // proceed
                default:
                    point$7(this, x, y);
                    break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
    };
    var catmullRomOpen = (function custom(alpha) {
        function catmullRom(context) {
            return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
        }
        catmullRom.alpha = function (alpha) {
            return custom(+alpha);
        };
        return catmullRom;
    })(0.5);

    function LinearClosed(context) {
        this._context = context;
    }
    LinearClosed.prototype = {
        areaStart: noop$4,
        areaEnd: noop$4,
        lineStart: function () {
            this._point = 0;
        },
        lineEnd: function () {
            if (this._point)
                this._context.closePath();
        },
        point: function (x, y) {
            x = +x, y = +y;
            if (this._point)
                this._context.lineTo(x, y);
            else
                this._point = 1, this._context.moveTo(x, y);
        }
    };
    function linearClosed (context) {
        return new LinearClosed(context);
    }

    function sign$2(x) {
        return x < 0 ? -1 : 1;
    }
    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3$1(that, x2, y2) {
        var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
        return (sign$2(s0) + sign$2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }
    // Calculate a one-sided slope.
    function slope2$1(that, t) {
        var h = that._x1 - that._x0;
        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }
    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point$8(that, t0, t1) {
        var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }
    function MonotoneX$1(context) {
        this._context = context;
    }
    MonotoneX$1.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 =
                this._y0 = this._y1 =
                    this._t0 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 2:
                    this._context.lineTo(this._x1, this._y1);
                    break;
                case 3:
                    point$8(this, this._t0, slope2$1(this, this._t0));
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            var t1 = NaN;
            x = +x, y = +y;
            if (x === this._x1 && y === this._y1)
                return; // Ignore coincident points.
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3;
                    point$8(this, slope2$1(this, t1 = slope3$1(this, x, y)), t1);
                    break;
                default:
                    point$8(this, this._t0, t1 = slope3$1(this, x, y));
                    break;
            }
            this._x0 = this._x1, this._x1 = x;
            this._y0 = this._y1, this._y1 = y;
            this._t0 = t1;
        }
    };
    function MonotoneY$1(context) {
        this._context = new ReflectContext$1(context);
    }
    (MonotoneY$1.prototype = Object.create(MonotoneX$1.prototype)).point = function (x, y) {
        MonotoneX$1.prototype.point.call(this, y, x);
    };
    function ReflectContext$1(context) {
        this._context = context;
    }
    ReflectContext$1.prototype = {
        moveTo: function (x, y) { this._context.moveTo(y, x); },
        closePath: function () { this._context.closePath(); },
        lineTo: function (x, y) { this._context.lineTo(y, x); },
        bezierCurveTo: function (x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };
    function monotoneX(context) {
        return new MonotoneX$1(context);
    }
    function monotoneY(context) {
        return new MonotoneY$1(context);
    }

    function Natural(context) {
        this._context = context;
    }
    Natural.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x = [];
            this._y = [];
        },
        lineEnd: function () {
            var x = this._x, y = this._y, n = x.length;
            if (n) {
                this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
                if (n === 2) {
                    this._context.lineTo(x[1], y[1]);
                }
                else {
                    var px = controlPoints(x), py = controlPoints(y);
                    for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
                        this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
                    }
                }
            }
            if (this._line || (this._line !== 0 && n === 1))
                this._context.closePath();
            this._line = 1 - this._line;
            this._x = this._y = null;
        },
        point: function (x, y) {
            this._x.push(+x);
            this._y.push(+y);
        }
    };
    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
        var i, n = x.length - 1, m, a = new Array(n), b = new Array(n), r = new Array(n);
        a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
        for (i = 1; i < n - 1; ++i)
            a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
        a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
        for (i = 1; i < n; ++i)
            m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
        a[n - 1] = r[n - 1] / b[n - 1];
        for (i = n - 2; i >= 0; --i)
            a[i] = (r[i] - a[i + 1]) / b[i];
        b[n - 1] = (x[n] + a[n - 1]) / 2;
        for (i = 0; i < n - 1; ++i)
            b[i] = 2 * x[i + 1] - a[i + 1];
        return [a, b];
    }
    function natural (context) {
        return new Natural(context);
    }

    function Step(context, t) {
        this._context = context;
        this._t = t;
    }
    Step.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x = this._y = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            if (0 < this._t && this._t < 1 && this._point === 2)
                this._context.lineTo(this._x, this._y);
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            if (this._line >= 0)
                this._t = 1 - this._t, this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1: this._point = 2; // proceed
                default: {
                    if (this._t <= 0) {
                        this._context.lineTo(this._x, y);
                        this._context.lineTo(x, y);
                    }
                    else {
                        var x1 = this._x * (1 - this._t) + x * this._t;
                        this._context.lineTo(x1, this._y);
                        this._context.lineTo(x1, y);
                    }
                    break;
                }
            }
            this._x = x, this._y = y;
        }
    };
    function step (context) {
        return new Step(context, 0.5);
    }
    function stepBefore(context) {
        return new Step(context, 0);
    }
    function stepAfter(context) {
        return new Step(context, 1);
    }

    function none$3 (series, order) {
        if (!((n = series.length) > 1))
            return;
        for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
            s0 = s1, s1 = series[order[i]];
            for (j = 0; j < m; ++j) {
                s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
            }
        }
    }

    function none$4 (series) {
        var n = series.length, o = new Array(n);
        while (--n >= 0)
            o[n] = n;
        return o;
    }

    function stackValue(d, key) {
        return d[key];
    }
    function stack () {
        var keys = constant$g([]), order = none$4, offset = none$3, value = stackValue;
        function stack(data) {
            var kz = keys.apply(this, arguments), i, m = data.length, n = kz.length, sz = new Array(n), oz;
            for (i = 0; i < n; ++i) {
                for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
                    si[j] = sij = [0, +value(data[j], ki, j, data)];
                    sij.data = data[j];
                }
                si.key = ki;
            }
            for (i = 0, oz = order(sz); i < n; ++i) {
                sz[oz[i]].index = i;
            }
            offset(sz, oz);
            return sz;
        }
        stack.keys = function (_) {
            return arguments.length ? (keys = typeof _ === "function" ? _ : constant$g(slice$9.call(_)), stack) : keys;
        };
        stack.value = function (_) {
            return arguments.length ? (value = typeof _ === "function" ? _ : constant$g(+_), stack) : value;
        };
        stack.order = function (_) {
            return arguments.length ? (order = _ == null ? none$4 : typeof _ === "function" ? _ : constant$g(slice$9.call(_)), stack) : order;
        };
        stack.offset = function (_) {
            return arguments.length ? (offset = _ == null ? none$3 : _, stack) : offset;
        };
        return stack;
    }

    function expand (series, order) {
        if (!((n = series.length) > 0))
            return;
        for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
            for (y = i = 0; i < n; ++i)
                y += series[i][j][1] || 0;
            if (y)
                for (i = 0; i < n; ++i)
                    series[i][j][1] /= y;
        }
        none$3(series, order);
    }

    function diverging (series, order) {
        if (!((n = series.length) > 1))
            return;
        for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
            for (yp = yn = 0, i = 0; i < n; ++i) {
                if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
                    d[0] = yp, d[1] = yp += dy;
                }
                else if (dy < 0) {
                    d[1] = yn, d[0] = yn += dy;
                }
                else {
                    d[0] = yp;
                }
            }
        }
    }

    function silhouette (series, order) {
        if (!((n = series.length) > 0))
            return;
        for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
            for (var i = 0, y = 0; i < n; ++i)
                y += series[i][j][1] || 0;
            s0[j][1] += s0[j][0] = -y / 2;
        }
        none$3(series, order);
    }

    function wiggle (series, order) {
        if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0))
            return;
        for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
            for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
                var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
                for (var k = 0; k < i; ++k) {
                    var sk = series[order[k]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
                    s3 += skj0 - skj1;
                }
                s1 += sij0, s2 += s3 * sij0;
            }
            s0[j - 1][1] += s0[j - 1][0] = y;
            if (s1)
                y -= s2 / s1;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        none$3(series, order);
    }

    function ascending$6 (series) {
        var sums = series.map(sum$3);
        return none$4(series).sort(function (a, b) { return sums[a] - sums[b]; });
    }
    function sum$3(series) {
        var s = 0, i = -1, n = series.length, v;
        while (++i < n)
            if (v = +series[i][1])
                s += v;
        return s;
    }

    function descending$2 (series) {
        return ascending$6(series).reverse();
    }

    function insideOut (series) {
        var n = series.length, i, j, sums = series.map(sum$3), order = none$4(series).sort(function (a, b) { return sums[b] - sums[a]; }), top = 0, bottom = 0, tops = [], bottoms = [];
        for (i = 0; i < n; ++i) {
            j = order[i];
            if (top < bottom) {
                top += sums[j];
                tops.push(j);
            }
            else {
                bottom += sums[j];
                bottoms.push(j);
            }
        }
        return bottoms.reverse().concat(tops);
    }

    function reverse (series) {
        return none$4(series).reverse();
    }

    var t0$6 = new Date, t1$6 = new Date;
    function newInterval$2(floori, offseti, count, field) {
        function interval(date) {
            return floori(date = new Date(+date)), date;
        }
        interval.floor = interval;
        interval.ceil = function (date) {
            return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
        };
        interval.round = function (date) {
            var d0 = interval(date), d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1;
        };
        interval.offset = function (date, step) {
            return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
        };
        interval.range = function (start, stop, step) {
            var range = [], previous;
            start = interval.ceil(start);
            step = step == null ? 1 : Math.floor(step);
            if (!(start < stop) || !(step > 0))
                return range; // also handles Invalid Date
            do
                range.push(previous = new Date(+start)), offseti(start, step), floori(start);
            while (previous < start && start < stop);
            return range;
        };
        interval.filter = function (test) {
            return newInterval$2(function (date) {
                if (date >= date)
                    while (floori(date), !test(date))
                        date.setTime(date - 1);
            }, function (date, step) {
                if (date >= date) {
                    if (step < 0)
                        while (++step <= 0) {
                            while (offseti(date, -1), !test(date)) { } // eslint-disable-line no-empty
                        }
                    else
                        while (--step >= 0) {
                            while (offseti(date, +1), !test(date)) { } // eslint-disable-line no-empty
                        }
                }
            });
        };
        if (count) {
            interval.count = function (start, end) {
                t0$6.setTime(+start), t1$6.setTime(+end);
                floori(t0$6), floori(t1$6);
                return Math.floor(count(t0$6, t1$6));
            };
            interval.every = function (step) {
                step = Math.floor(step);
                return !isFinite(step) || !(step > 0) ? null
                    : !(step > 1) ? interval
                        : interval.filter(field
                            ? function (d) { return field(d) % step === 0; }
                            : function (d) { return interval.count(0, d) % step === 0; });
            };
        }
        return interval;
    }

    var millisecond$2 = newInterval$2(function () {
        // noop
    }, function (date, step) {
        date.setTime(+date + step);
    }, function (start, end) {
        return end - start;
    });
    // An optimized implementation for this simple case.
    millisecond$2.every = function (k) {
        k = Math.floor(k);
        if (!isFinite(k) || !(k > 0))
            return null;
        if (!(k > 1))
            return millisecond$2;
        return newInterval$2(function (date) {
            date.setTime(Math.floor(date / k) * k);
        }, function (date, step) {
            date.setTime(+date + step * k);
        }, function (start, end) {
            return (end - start) / k;
        });
    };
    var milliseconds = millisecond$2.range;

    var durationSecond$3 = 1e3;
    var durationMinute$3 = 6e4;
    var durationHour$3 = 36e5;
    var durationDay$3 = 864e5;
    var durationWeek$3 = 6048e5;

    var second$2 = newInterval$2(function (date) {
        date.setTime(Math.floor(date / durationSecond$3) * durationSecond$3);
    }, function (date, step) {
        date.setTime(+date + step * durationSecond$3);
    }, function (start, end) {
        return (end - start) / durationSecond$3;
    }, function (date) {
        return date.getUTCSeconds();
    });
    var seconds = second$2.range;

    var minute$2 = newInterval$2(function (date) {
        date.setTime(Math.floor(date / durationMinute$3) * durationMinute$3);
    }, function (date, step) {
        date.setTime(+date + step * durationMinute$3);
    }, function (start, end) {
        return (end - start) / durationMinute$3;
    }, function (date) {
        return date.getMinutes();
    });
    var minutes = minute$2.range;

    var hour$2 = newInterval$2(function (date) {
        var offset = date.getTimezoneOffset() * durationMinute$3 % durationHour$3;
        if (offset < 0)
            offset += durationHour$3;
        date.setTime(Math.floor((+date - offset) / durationHour$3) * durationHour$3 + offset);
    }, function (date, step) {
        date.setTime(+date + step * durationHour$3);
    }, function (start, end) {
        return (end - start) / durationHour$3;
    }, function (date) {
        return date.getHours();
    });
    var hours = hour$2.range;

    var day$2 = newInterval$2(function (date) {
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setDate(date.getDate() + step);
    }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$3) / durationDay$3;
    }, function (date) {
        return date.getDate() - 1;
    });
    var days = day$2.range;

    function weekday$2(i) {
        return newInterval$2(function (date) {
            date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
            date.setHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setDate(date.getDate() + step * 7);
        }, function (start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$3) / durationWeek$3;
        });
    }
    var sunday$2 = weekday$2(0);
    var monday$2 = weekday$2(1);
    var tuesday$2 = weekday$2(2);
    var wednesday$2 = weekday$2(3);
    var thursday$2 = weekday$2(4);
    var friday$2 = weekday$2(5);
    var saturday$2 = weekday$2(6);
    var sundays = sunday$2.range;
    var mondays = monday$2.range;
    var tuesdays = tuesday$2.range;
    var wednesdays = wednesday$2.range;
    var thursdays = thursday$2.range;
    var fridays = friday$2.range;
    var saturdays = saturday$2.range;

    var month$2 = newInterval$2(function (date) {
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setMonth(date.getMonth() + step);
    }, function (start, end) {
        return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function (date) {
        return date.getMonth();
    });
    var months = month$2.range;

    var year$2 = newInterval$2(function (date) {
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setFullYear(date.getFullYear() + step);
    }, function (start, end) {
        return end.getFullYear() - start.getFullYear();
    }, function (date) {
        return date.getFullYear();
    });
    // An optimized implementation for this simple case.
    year$2.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval$2(function (date) {
            date.setFullYear(Math.floor(date.getFullYear() / k) * k);
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setFullYear(date.getFullYear() + step * k);
        });
    };
    var years = year$2.range;

    var utcMinute$2 = newInterval$2(function (date) {
        date.setUTCSeconds(0, 0);
    }, function (date, step) {
        date.setTime(+date + step * durationMinute$3);
    }, function (start, end) {
        return (end - start) / durationMinute$3;
    }, function (date) {
        return date.getUTCMinutes();
    });
    var utcMinutes = utcMinute$2.range;

    var utcHour$2 = newInterval$2(function (date) {
        date.setUTCMinutes(0, 0, 0);
    }, function (date, step) {
        date.setTime(+date + step * durationHour$3);
    }, function (start, end) {
        return (end - start) / durationHour$3;
    }, function (date) {
        return date.getUTCHours();
    });
    var utcHours = utcHour$2.range;

    var utcDay$2 = newInterval$2(function (date) {
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCDate(date.getUTCDate() + step);
    }, function (start, end) {
        return (end - start) / durationDay$3;
    }, function (date) {
        return date.getUTCDate() - 1;
    });
    var utcDays = utcDay$2.range;

    function utcWeekday$2(i) {
        return newInterval$2(function (date) {
            date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
            date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setUTCDate(date.getUTCDate() + step * 7);
        }, function (start, end) {
            return (end - start) / durationWeek$3;
        });
    }
    var utcSunday$2 = utcWeekday$2(0);
    var utcMonday$2 = utcWeekday$2(1);
    var utcTuesday$2 = utcWeekday$2(2);
    var utcWednesday$2 = utcWeekday$2(3);
    var utcThursday$2 = utcWeekday$2(4);
    var utcFriday$2 = utcWeekday$2(5);
    var utcSaturday$2 = utcWeekday$2(6);
    var utcSundays = utcSunday$2.range;
    var utcMondays = utcMonday$2.range;
    var utcTuesdays = utcTuesday$2.range;
    var utcWednesdays = utcWednesday$2.range;
    var utcThursdays = utcThursday$2.range;
    var utcFridays = utcFriday$2.range;
    var utcSaturdays = utcSaturday$2.range;

    var utcMonth$2 = newInterval$2(function (date) {
        date.setUTCDate(1);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCMonth(date.getUTCMonth() + step);
    }, function (start, end) {
        return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function (date) {
        return date.getUTCMonth();
    });
    var utcMonths = utcMonth$2.range;

    var utcYear$2 = newInterval$2(function (date) {
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function (start, end) {
        return end.getUTCFullYear() - start.getUTCFullYear();
    }, function (date) {
        return date.getUTCFullYear();
    });
    // An optimized implementation for this simple case.
    utcYear$2.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval$2(function (date) {
            date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step * k);
        });
    };
    var utcYears = utcYear$2.range;

    var t0$7 = new Date, t1$7 = new Date;
    function newInterval$3(floori, offseti, count, field) {
        function interval(date) {
            return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
        }
        interval.floor = function (date) {
            return floori(date = new Date(+date)), date;
        };
        interval.ceil = function (date) {
            return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
        };
        interval.round = function (date) {
            var d0 = interval(date), d1 = interval.ceil(date);
            return date - d0 < d1 - date ? d0 : d1;
        };
        interval.offset = function (date, step) {
            return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
        };
        interval.range = function (start, stop, step) {
            var range = [], previous;
            start = interval.ceil(start);
            step = step == null ? 1 : Math.floor(step);
            if (!(start < stop) || !(step > 0))
                return range; // also handles Invalid Date
            do
                range.push(previous = new Date(+start)), offseti(start, step), floori(start);
            while (previous < start && start < stop);
            return range;
        };
        interval.filter = function (test) {
            return newInterval$3(function (date) {
                if (date >= date)
                    while (floori(date), !test(date))
                        date.setTime(date - 1);
            }, function (date, step) {
                if (date >= date) {
                    if (step < 0)
                        while (++step <= 0) {
                            while (offseti(date, -1), !test(date)) { } // eslint-disable-line no-empty
                        }
                    else
                        while (--step >= 0) {
                            while (offseti(date, +1), !test(date)) { } // eslint-disable-line no-empty
                        }
                }
            });
        };
        if (count) {
            interval.count = function (start, end) {
                t0$7.setTime(+start), t1$7.setTime(+end);
                floori(t0$7), floori(t1$7);
                return Math.floor(count(t0$7, t1$7));
            };
            interval.every = function (step) {
                step = Math.floor(step);
                return !isFinite(step) || !(step > 0) ? null
                    : !(step > 1) ? interval
                        : interval.filter(field
                            ? function (d) { return field(d) % step === 0; }
                            : function (d) { return interval.count(0, d) % step === 0; });
            };
        }
        return interval;
    }

    var millisecond$3 = newInterval$3(function () {
        // noop
    }, function (date, step) {
        date.setTime(+date + step);
    }, function (start, end) {
        return end - start;
    });
    // An optimized implementation for this simple case.
    millisecond$3.every = function (k) {
        k = Math.floor(k);
        if (!isFinite(k) || !(k > 0))
            return null;
        if (!(k > 1))
            return millisecond$3;
        return newInterval$3(function (date) {
            date.setTime(Math.floor(date / k) * k);
        }, function (date, step) {
            date.setTime(+date + step * k);
        }, function (start, end) {
            return (end - start) / k;
        });
    };

    var durationSecond$4 = 1e3;
    var durationMinute$4 = 6e4;
    var durationHour$4 = 36e5;
    var durationDay$4 = 864e5;
    var durationWeek$4 = 6048e5;

    newInterval$3(function (date) {
        date.setTime(date - date.getMilliseconds());
    }, function (date, step) {
        date.setTime(+date + step * durationSecond$4);
    }, function (start, end) {
        return (end - start) / durationSecond$4;
    }, function (date) {
        return date.getUTCSeconds();
    });

    newInterval$3(function (date) {
        date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$4);
    }, function (date, step) {
        date.setTime(+date + step * durationMinute$4);
    }, function (start, end) {
        return (end - start) / durationMinute$4;
    }, function (date) {
        return date.getMinutes();
    });

    newInterval$3(function (date) {
        date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond$4 - date.getMinutes() * durationMinute$4);
    }, function (date, step) {
        date.setTime(+date + step * durationHour$4);
    }, function (start, end) {
        return (end - start) / durationHour$4;
    }, function (date) {
        return date.getHours();
    });

    var day$3 = newInterval$3(function (date) {
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setDate(date.getDate() + step);
    }, function (start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$4) / durationDay$4;
    }, function (date) {
        return date.getDate() - 1;
    });

    function weekday$3(i) {
        return newInterval$3(function (date) {
            date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
            date.setHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setDate(date.getDate() + step * 7);
        }, function (start, end) {
            return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute$4) / durationWeek$4;
        });
    }
    var sunday$3 = weekday$3(0);
    var monday$3 = weekday$3(1);
    weekday$3(2);
    weekday$3(3);
    var thursday$3 = weekday$3(4);
    weekday$3(5);
    weekday$3(6);

    newInterval$3(function (date) {
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setMonth(date.getMonth() + step);
    }, function (start, end) {
        return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function (date) {
        return date.getMonth();
    });

    var year$3 = newInterval$3(function (date) {
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setFullYear(date.getFullYear() + step);
    }, function (start, end) {
        return end.getFullYear() - start.getFullYear();
    }, function (date) {
        return date.getFullYear();
    });
    // An optimized implementation for this simple case.
    year$3.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval$3(function (date) {
            date.setFullYear(Math.floor(date.getFullYear() / k) * k);
            date.setMonth(0, 1);
            date.setHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setFullYear(date.getFullYear() + step * k);
        });
    };

    newInterval$3(function (date) {
        date.setUTCSeconds(0, 0);
    }, function (date, step) {
        date.setTime(+date + step * durationMinute$4);
    }, function (start, end) {
        return (end - start) / durationMinute$4;
    }, function (date) {
        return date.getUTCMinutes();
    });

    newInterval$3(function (date) {
        date.setUTCMinutes(0, 0, 0);
    }, function (date, step) {
        date.setTime(+date + step * durationHour$4);
    }, function (start, end) {
        return (end - start) / durationHour$4;
    }, function (date) {
        return date.getUTCHours();
    });

    var utcDay$3 = newInterval$3(function (date) {
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCDate(date.getUTCDate() + step);
    }, function (start, end) {
        return (end - start) / durationDay$4;
    }, function (date) {
        return date.getUTCDate() - 1;
    });

    function utcWeekday$3(i) {
        return newInterval$3(function (date) {
            date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
            date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setUTCDate(date.getUTCDate() + step * 7);
        }, function (start, end) {
            return (end - start) / durationWeek$4;
        });
    }
    var utcSunday$3 = utcWeekday$3(0);
    var utcMonday$3 = utcWeekday$3(1);
    utcWeekday$3(2);
    utcWeekday$3(3);
    var utcThursday$3 = utcWeekday$3(4);
    utcWeekday$3(5);
    utcWeekday$3(6);

    newInterval$3(function (date) {
        date.setUTCDate(1);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCMonth(date.getUTCMonth() + step);
    }, function (start, end) {
        return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function (date) {
        return date.getUTCMonth();
    });

    var utcYear$3 = newInterval$3(function (date) {
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
    }, function (date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function (start, end) {
        return end.getUTCFullYear() - start.getUTCFullYear();
    }, function (date) {
        return date.getUTCFullYear();
    });
    // An optimized implementation for this simple case.
    utcYear$3.every = function (k) {
        return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval$3(function (date) {
            date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
            date.setUTCMonth(0, 1);
            date.setUTCHours(0, 0, 0, 0);
        }, function (date, step) {
            date.setUTCFullYear(date.getUTCFullYear() + step * k);
        });
    };

    function localDate$2(d) {
        if (0 <= d.y && d.y < 100) {
            var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
            date.setFullYear(d.y);
            return date;
        }
        return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }
    function utcDate$2(d) {
        if (0 <= d.y && d.y < 100) {
            var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
            date.setUTCFullYear(d.y);
            return date;
        }
        return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }
    function newYear(y) {
        return { y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0 };
    }
    function formatLocale$5(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_weekdays = locale.days, locale_shortWeekdays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        var periodRe = formatRe$2(locale_periods), periodLookup = formatLookup$2(locale_periods), weekdayRe = formatRe$2(locale_weekdays), weekdayLookup = formatLookup$2(locale_weekdays), shortWeekdayRe = formatRe$2(locale_shortWeekdays), shortWeekdayLookup = formatLookup$2(locale_shortWeekdays), monthRe = formatRe$2(locale_months), monthLookup = formatLookup$2(locale_months), shortMonthRe = formatRe$2(locale_shortMonths), shortMonthLookup = formatLookup$2(locale_shortMonths);
        var formats = {
            "a": formatShortWeekday,
            "A": formatWeekday,
            "b": formatShortMonth,
            "B": formatMonth,
            "c": null,
            "d": formatDayOfMonth$2,
            "e": formatDayOfMonth$2,
            "f": formatMicroseconds$2,
            "H": formatHour24$2,
            "I": formatHour12$2,
            "j": formatDayOfYear$2,
            "L": formatMilliseconds$2,
            "m": formatMonthNumber$2,
            "M": formatMinutes$2,
            "p": formatPeriod,
            "Q": formatUnixTimestamp$2,
            "s": formatUnixTimestampSeconds$2,
            "S": formatSeconds$2,
            "u": formatWeekdayNumberMonday$2,
            "U": formatWeekNumberSunday$2,
            "V": formatWeekNumberISO$2,
            "w": formatWeekdayNumberSunday$2,
            "W": formatWeekNumberMonday$2,
            "x": null,
            "X": null,
            "y": formatYear$3,
            "Y": formatFullYear$2,
            "Z": formatZone$2,
            "%": formatLiteralPercent$2
        };
        var utcFormats = {
            "a": formatUTCShortWeekday,
            "A": formatUTCWeekday,
            "b": formatUTCShortMonth,
            "B": formatUTCMonth,
            "c": null,
            "d": formatUTCDayOfMonth$2,
            "e": formatUTCDayOfMonth$2,
            "f": formatUTCMicroseconds$2,
            "H": formatUTCHour24$2,
            "I": formatUTCHour12$2,
            "j": formatUTCDayOfYear$2,
            "L": formatUTCMilliseconds$2,
            "m": formatUTCMonthNumber$2,
            "M": formatUTCMinutes$2,
            "p": formatUTCPeriod,
            "Q": formatUnixTimestamp$2,
            "s": formatUnixTimestampSeconds$2,
            "S": formatUTCSeconds$2,
            "u": formatUTCWeekdayNumberMonday$2,
            "U": formatUTCWeekNumberSunday$2,
            "V": formatUTCWeekNumberISO$2,
            "w": formatUTCWeekdayNumberSunday$2,
            "W": formatUTCWeekNumberMonday$2,
            "x": null,
            "X": null,
            "y": formatUTCYear$2,
            "Y": formatUTCFullYear$2,
            "Z": formatUTCZone$2,
            "%": formatLiteralPercent$2
        };
        var parses = {
            "a": parseShortWeekday,
            "A": parseWeekday,
            "b": parseShortMonth,
            "B": parseMonth,
            "c": parseLocaleDateTime,
            "d": parseDayOfMonth$2,
            "e": parseDayOfMonth$2,
            "f": parseMicroseconds$2,
            "H": parseHour24$2,
            "I": parseHour24$2,
            "j": parseDayOfYear$2,
            "L": parseMilliseconds$2,
            "m": parseMonthNumber$2,
            "M": parseMinutes$2,
            "p": parsePeriod,
            "Q": parseUnixTimestamp$2,
            "s": parseUnixTimestampSeconds$2,
            "S": parseSeconds$2,
            "u": parseWeekdayNumberMonday$2,
            "U": parseWeekNumberSunday$2,
            "V": parseWeekNumberISO$2,
            "w": parseWeekdayNumberSunday$2,
            "W": parseWeekNumberMonday$2,
            "x": parseLocaleDate,
            "X": parseLocaleTime,
            "y": parseYear$2,
            "Y": parseFullYear$2,
            "Z": parseZone$2,
            "%": parseLiteralPercent$2
        };
        // These recursive directive definitions must be deferred.
        formats.x = newFormat(locale_date, formats);
        formats.X = newFormat(locale_time, formats);
        formats.c = newFormat(locale_dateTime, formats);
        utcFormats.x = newFormat(locale_date, utcFormats);
        utcFormats.X = newFormat(locale_time, utcFormats);
        utcFormats.c = newFormat(locale_dateTime, utcFormats);
        function newFormat(specifier, formats) {
            return function (date) {
                var string = [], i = -1, j = 0, n = specifier.length, c, pad, format;
                if (!(date instanceof Date))
                    date = new Date(+date);
                while (++i < n) {
                    if (specifier.charCodeAt(i) === 37) {
                        string.push(specifier.slice(j, i));
                        if ((pad = pads$2[c = specifier.charAt(++i)]) != null)
                            c = specifier.charAt(++i);
                        else
                            pad = c === "e" ? " " : "0";
                        if (format = formats[c])
                            c = format(date, pad);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(specifier.slice(j, i));
                return string.join("");
            };
        }
        function newParse(specifier, newDate) {
            return function (string) {
                var d = newYear(1900), i = parseSpecifier(d, specifier, string += "", 0), week, day;
                if (i != string.length)
                    return null;
                // If a UNIX timestamp is specified, return it.
                if ("Q" in d)
                    return new Date(d.Q);
                // The am-pm flag is 0 for AM, and 1 for PM.
                if ("p" in d)
                    d.H = d.H % 12 + d.p * 12;
                // Convert day-of-week and week-of-year to day-of-year.
                if ("V" in d) {
                    if (d.V < 1 || d.V > 53)
                        return null;
                    if (!("w" in d))
                        d.w = 1;
                    if ("Z" in d) {
                        week = utcDate$2(newYear(d.y)), day = week.getUTCDay();
                        week = day > 4 || day === 0 ? utcMonday$3.ceil(week) : utcMonday$3(week);
                        week = utcDay$3.offset(week, (d.V - 1) * 7);
                        d.y = week.getUTCFullYear();
                        d.m = week.getUTCMonth();
                        d.d = week.getUTCDate() + (d.w + 6) % 7;
                    }
                    else {
                        week = newDate(newYear(d.y)), day = week.getDay();
                        week = day > 4 || day === 0 ? monday$3.ceil(week) : monday$3(week);
                        week = day$3.offset(week, (d.V - 1) * 7);
                        d.y = week.getFullYear();
                        d.m = week.getMonth();
                        d.d = week.getDate() + (d.w + 6) % 7;
                    }
                }
                else if ("W" in d || "U" in d) {
                    if (!("w" in d))
                        d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
                    day = "Z" in d ? utcDate$2(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
                    d.m = 0;
                    d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
                }
                // If a time zone is specified, all fields are interpreted as UTC and then
                // offset according to the specified time zone.
                if ("Z" in d) {
                    d.H += d.Z / 100 | 0;
                    d.M += d.Z % 100;
                    return utcDate$2(d);
                }
                // Otherwise, all fields are in local time.
                return newDate(d);
            };
        }
        function parseSpecifier(d, specifier, string, j) {
            var i = 0, n = specifier.length, m = string.length, c, parse;
            while (i < n) {
                if (j >= m)
                    return -1;
                c = specifier.charCodeAt(i++);
                if (c === 37) {
                    c = specifier.charAt(i++);
                    parse = parses[c in pads$2 ? specifier.charAt(i++) : c];
                    if (!parse || ((j = parse(d, string, j)) < 0))
                        return -1;
                }
                else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        function parsePeriod(d, string, i) {
            var n = periodRe.exec(string.slice(i));
            return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseShortWeekday(d, string, i) {
            var n = shortWeekdayRe.exec(string.slice(i));
            return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseWeekday(d, string, i) {
            var n = weekdayRe.exec(string.slice(i));
            return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseShortMonth(d, string, i) {
            var n = shortMonthRe.exec(string.slice(i));
            return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseMonth(d, string, i) {
            var n = monthRe.exec(string.slice(i));
            return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
        }
        function parseLocaleDateTime(d, string, i) {
            return parseSpecifier(d, locale_dateTime, string, i);
        }
        function parseLocaleDate(d, string, i) {
            return parseSpecifier(d, locale_date, string, i);
        }
        function parseLocaleTime(d, string, i) {
            return parseSpecifier(d, locale_time, string, i);
        }
        function formatShortWeekday(d) {
            return locale_shortWeekdays[d.getDay()];
        }
        function formatWeekday(d) {
            return locale_weekdays[d.getDay()];
        }
        function formatShortMonth(d) {
            return locale_shortMonths[d.getMonth()];
        }
        function formatMonth(d) {
            return locale_months[d.getMonth()];
        }
        function formatPeriod(d) {
            return locale_periods[+(d.getHours() >= 12)];
        }
        function formatUTCShortWeekday(d) {
            return locale_shortWeekdays[d.getUTCDay()];
        }
        function formatUTCWeekday(d) {
            return locale_weekdays[d.getUTCDay()];
        }
        function formatUTCShortMonth(d) {
            return locale_shortMonths[d.getUTCMonth()];
        }
        function formatUTCMonth(d) {
            return locale_months[d.getUTCMonth()];
        }
        function formatUTCPeriod(d) {
            return locale_periods[+(d.getUTCHours() >= 12)];
        }
        return {
            format: function (specifier) {
                var f = newFormat(specifier += "", formats);
                f.toString = function () { return specifier; };
                return f;
            },
            parse: function (specifier) {
                var p = newParse(specifier += "", localDate$2);
                p.toString = function () { return specifier; };
                return p;
            },
            utcFormat: function (specifier) {
                var f = newFormat(specifier += "", utcFormats);
                f.toString = function () { return specifier; };
                return f;
            },
            utcParse: function (specifier) {
                var p = newParse(specifier, utcDate$2);
                p.toString = function () { return specifier; };
                return p;
            }
        };
    }
    var pads$2 = { "-": "", "_": " ", "0": "0" }, numberRe$2 = /^\s*\d+/, // note: ignores next directive
    percentRe$2 = /^%/, requoteRe$2 = /[\\^$*+?|[\]().{}]/g;
    function pad$3(value, fill, width) {
        var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function requote$2(s) {
        return s.replace(requoteRe$2, "\\$&");
    }
    function formatRe$2(names) {
        return new RegExp("^(?:" + names.map(requote$2).join("|") + ")", "i");
    }
    function formatLookup$2(names) {
        var map = {}, i = -1, n = names.length;
        while (++i < n)
            map[names[i].toLowerCase()] = i;
        return map;
    }
    function parseWeekdayNumberSunday$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 1));
        return n ? (d.w = +n[0], i + n[0].length) : -1;
    }
    function parseWeekdayNumberMonday$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 1));
        return n ? (d.u = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberSunday$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 2));
        return n ? (d.U = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberISO$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 2));
        return n ? (d.V = +n[0], i + n[0].length) : -1;
    }
    function parseWeekNumberMonday$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 2));
        return n ? (d.W = +n[0], i + n[0].length) : -1;
    }
    function parseFullYear$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 4));
        return n ? (d.y = +n[0], i + n[0].length) : -1;
    }
    function parseYear$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 2));
        return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }
    function parseZone$2(d, string, i) {
        var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
        return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }
    function parseMonthNumber$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 2));
        return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }
    function parseDayOfMonth$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 2));
        return n ? (d.d = +n[0], i + n[0].length) : -1;
    }
    function parseDayOfYear$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 3));
        return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }
    function parseHour24$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 2));
        return n ? (d.H = +n[0], i + n[0].length) : -1;
    }
    function parseMinutes$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 2));
        return n ? (d.M = +n[0], i + n[0].length) : -1;
    }
    function parseSeconds$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 2));
        return n ? (d.S = +n[0], i + n[0].length) : -1;
    }
    function parseMilliseconds$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 3));
        return n ? (d.L = +n[0], i + n[0].length) : -1;
    }
    function parseMicroseconds$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i, i + 6));
        return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }
    function parseLiteralPercent$2(d, string, i) {
        var n = percentRe$2.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function parseUnixTimestamp$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i));
        return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }
    function parseUnixTimestampSeconds$2(d, string, i) {
        var n = numberRe$2.exec(string.slice(i));
        return n ? (d.Q = (+n[0]) * 1000, i + n[0].length) : -1;
    }
    function formatDayOfMonth$2(d, p) {
        return pad$3(d.getDate(), p, 2);
    }
    function formatHour24$2(d, p) {
        return pad$3(d.getHours(), p, 2);
    }
    function formatHour12$2(d, p) {
        return pad$3(d.getHours() % 12 || 12, p, 2);
    }
    function formatDayOfYear$2(d, p) {
        return pad$3(1 + day$3.count(year$3(d), d), p, 3);
    }
    function formatMilliseconds$2(d, p) {
        return pad$3(d.getMilliseconds(), p, 3);
    }
    function formatMicroseconds$2(d, p) {
        return formatMilliseconds$2(d, p) + "000";
    }
    function formatMonthNumber$2(d, p) {
        return pad$3(d.getMonth() + 1, p, 2);
    }
    function formatMinutes$2(d, p) {
        return pad$3(d.getMinutes(), p, 2);
    }
    function formatSeconds$2(d, p) {
        return pad$3(d.getSeconds(), p, 2);
    }
    function formatWeekdayNumberMonday$2(d) {
        var day = d.getDay();
        return day === 0 ? 7 : day;
    }
    function formatWeekNumberSunday$2(d, p) {
        return pad$3(sunday$3.count(year$3(d), d), p, 2);
    }
    function formatWeekNumberISO$2(d, p) {
        var day = d.getDay();
        d = (day >= 4 || day === 0) ? thursday$3(d) : thursday$3.ceil(d);
        return pad$3(thursday$3.count(year$3(d), d) + (year$3(d).getDay() === 4), p, 2);
    }
    function formatWeekdayNumberSunday$2(d) {
        return d.getDay();
    }
    function formatWeekNumberMonday$2(d, p) {
        return pad$3(monday$3.count(year$3(d), d), p, 2);
    }
    function formatYear$3(d, p) {
        return pad$3(d.getFullYear() % 100, p, 2);
    }
    function formatFullYear$2(d, p) {
        return pad$3(d.getFullYear() % 10000, p, 4);
    }
    function formatZone$2(d) {
        var z = d.getTimezoneOffset();
        return (z > 0 ? "-" : (z *= -1, "+"))
            + pad$3(z / 60 | 0, "0", 2)
            + pad$3(z % 60, "0", 2);
    }
    function formatUTCDayOfMonth$2(d, p) {
        return pad$3(d.getUTCDate(), p, 2);
    }
    function formatUTCHour24$2(d, p) {
        return pad$3(d.getUTCHours(), p, 2);
    }
    function formatUTCHour12$2(d, p) {
        return pad$3(d.getUTCHours() % 12 || 12, p, 2);
    }
    function formatUTCDayOfYear$2(d, p) {
        return pad$3(1 + utcDay$3.count(utcYear$3(d), d), p, 3);
    }
    function formatUTCMilliseconds$2(d, p) {
        return pad$3(d.getUTCMilliseconds(), p, 3);
    }
    function formatUTCMicroseconds$2(d, p) {
        return formatUTCMilliseconds$2(d, p) + "000";
    }
    function formatUTCMonthNumber$2(d, p) {
        return pad$3(d.getUTCMonth() + 1, p, 2);
    }
    function formatUTCMinutes$2(d, p) {
        return pad$3(d.getUTCMinutes(), p, 2);
    }
    function formatUTCSeconds$2(d, p) {
        return pad$3(d.getUTCSeconds(), p, 2);
    }
    function formatUTCWeekdayNumberMonday$2(d) {
        var dow = d.getUTCDay();
        return dow === 0 ? 7 : dow;
    }
    function formatUTCWeekNumberSunday$2(d, p) {
        return pad$3(utcSunday$3.count(utcYear$3(d), d), p, 2);
    }
    function formatUTCWeekNumberISO$2(d, p) {
        var day = d.getUTCDay();
        d = (day >= 4 || day === 0) ? utcThursday$3(d) : utcThursday$3.ceil(d);
        return pad$3(utcThursday$3.count(utcYear$3(d), d) + (utcYear$3(d).getUTCDay() === 4), p, 2);
    }
    function formatUTCWeekdayNumberSunday$2(d) {
        return d.getUTCDay();
    }
    function formatUTCWeekNumberMonday$2(d, p) {
        return pad$3(utcMonday$3.count(utcYear$3(d), d), p, 2);
    }
    function formatUTCYear$2(d, p) {
        return pad$3(d.getUTCFullYear() % 100, p, 2);
    }
    function formatUTCFullYear$2(d, p) {
        return pad$3(d.getUTCFullYear() % 10000, p, 4);
    }
    function formatUTCZone$2() {
        return "+0000";
    }
    function formatLiteralPercent$2() {
        return "%";
    }
    function formatUnixTimestamp$2(d) {
        return +d;
    }
    function formatUnixTimestampSeconds$2(d) {
        return Math.floor(+d / 1000);
    }

    var locale$5;
    var timeFormat$2;
    var timeParse$2;
    var utcFormat$2;
    var utcParse$2;
    defaultLocale$5({
        dateTime: "%x, %X",
        date: "%-m/%-d/%Y",
        time: "%-I:%M:%S %p",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    function defaultLocale$5(definition) {
        locale$5 = formatLocale$5(definition);
        timeFormat$2 = locale$5.format;
        timeParse$2 = locale$5.parse;
        utcFormat$2 = locale$5.utcFormat;
        utcParse$2 = locale$5.utcParse;
        return locale$5;
    }

    var isoSpecifier$2 = "%Y-%m-%dT%H:%M:%S.%LZ";
    function formatIsoNative$2(date) {
        return date.toISOString();
    }
    var formatIso$2 = Date.prototype.toISOString
        ? formatIsoNative$2
        : utcFormat$2(isoSpecifier$2);

    function parseIsoNative$2(string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    }
    var parseIso$2 = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative$2
        : utcParse$2(isoSpecifier$2);

    var frame$1 = 0, // is an animation frame pending?
    timeout$2 = 0, // is a timeout pending?
    interval$1 = 0, // are any timers active?
    pokeDelay$1 = 1000, // how frequently we check for clock skew
    taskHead$1, taskTail$1, clockLast$1 = 0, clockNow$1 = 0, clockSkew$1 = 0, clock$1 = typeof performance === "object" && performance.now ? performance : Date, setFrame$1 = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) { setTimeout(f, 17); };
    function now$1() {
        return clockNow$1 || (setFrame$1(clearNow$1), clockNow$1 = clock$1.now() + clockSkew$1);
    }
    function clearNow$1() {
        clockNow$1 = 0;
    }
    function Timer$1() {
        this._call =
            this._time =
                this._next = null;
    }
    Timer$1.prototype = timer$1.prototype = {
        constructor: Timer$1,
        restart: function (callback, delay, time) {
            if (typeof callback !== "function")
                throw new TypeError("callback is not a function");
            time = (time == null ? now$1() : +time) + (delay == null ? 0 : +delay);
            if (!this._next && taskTail$1 !== this) {
                if (taskTail$1)
                    taskTail$1._next = this;
                else
                    taskHead$1 = this;
                taskTail$1 = this;
            }
            this._call = callback;
            this._time = time;
            sleep$1();
        },
        stop: function () {
            if (this._call) {
                this._call = null;
                this._time = Infinity;
                sleep$1();
            }
        }
    };
    function timer$1(callback, delay, time) {
        var t = new Timer$1;
        t.restart(callback, delay, time);
        return t;
    }
    function timerFlush$1() {
        now$1(); // Get the current time, if not already set.
        ++frame$1; // Pretend we’ve set an alarm, if we haven’t already.
        var t = taskHead$1, e;
        while (t) {
            if ((e = clockNow$1 - t._time) >= 0)
                t._call.call(null, e);
            t = t._next;
        }
        --frame$1;
    }
    function wake$1() {
        clockNow$1 = (clockLast$1 = clock$1.now()) + clockSkew$1;
        frame$1 = timeout$2 = 0;
        try {
            timerFlush$1();
        }
        finally {
            frame$1 = 0;
            nap$1();
            clockNow$1 = 0;
        }
    }
    function poke$2() {
        var now = clock$1.now(), delay = now - clockLast$1;
        if (delay > pokeDelay$1)
            clockSkew$1 -= delay, clockLast$1 = now;
    }
    function nap$1() {
        var t0, t1 = taskHead$1, t2, time = Infinity;
        while (t1) {
            if (t1._call) {
                if (time > t1._time)
                    time = t1._time;
                t0 = t1, t1 = t1._next;
            }
            else {
                t2 = t1._next, t1._next = null;
                t1 = t0 ? t0._next = t2 : taskHead$1 = t2;
            }
        }
        taskTail$1 = t0;
        sleep$1(time);
    }
    function sleep$1(time) {
        if (frame$1)
            return; // Soonest alarm already set, or will be.
        if (timeout$2)
            timeout$2 = clearTimeout(timeout$2);
        var delay = time - clockNow$1; // Strictly less than if we recomputed clockNow.
        if (delay > 24) {
            if (time < Infinity)
                timeout$2 = setTimeout(wake$1, time - clock$1.now() - clockSkew$1);
            if (interval$1)
                interval$1 = clearInterval(interval$1);
        }
        else {
            if (!interval$1)
                clockLast$1 = clock$1.now(), interval$1 = setInterval(poke$2, pokeDelay$1);
            frame$1 = 1, setFrame$1(wake$1);
        }
    }

    function timeout$3 (callback, delay, time) {
        var t = new Timer$1;
        delay = delay == null ? 0 : +delay;
        t.restart(function (elapsed) {
            t.stop();
            callback(elapsed + delay);
        }, delay, time);
        return t;
    }

    function interval$2 (callback, delay, time) {
        var t = new Timer$1, total = delay;
        if (delay == null)
            return t.restart(callback, delay, time), t;
        delay = +delay, time = time == null ? now$1() : +time;
        t.restart(function tick(elapsed) {
            elapsed += total;
            t.restart(tick, total += delay, time);
            callback(elapsed);
        }, delay, time);
        return t;
    }

    var xhtml$3 = "http://www.w3.org/1999/xhtml";
    var namespaces$3 = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml$3,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace$3 (name) {
        var prefix = name += "", i = prefix.indexOf(":");
        if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
            name = name.slice(i + 1);
        return namespaces$3.hasOwnProperty(prefix) ? { space: namespaces$3[prefix], local: name } : name;
    }

    function creatorInherit$3(name) {
        return function () {
            var document = this.ownerDocument, uri = this.namespaceURI;
            return uri === xhtml$3 && document.documentElement.namespaceURI === xhtml$3
                ? document.createElement(name)
                : document.createElementNS(uri, name);
        };
    }
    function creatorFixed$3(fullname) {
        return function () {
            return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
    }
    function creator$3 (name) {
        var fullname = namespace$3(name);
        return (fullname.local
            ? creatorFixed$3
            : creatorInherit$3)(fullname);
    }

    function none$5() { }
    function selector$3 (selector) {
        return selector == null ? none$5 : function () {
            return this.querySelector(selector);
        };
    }

    function selection_select$3 (select) {
        if (typeof select !== "function")
            select = selector$3(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                }
            }
        }
        return new Selection$5(subgroups, this._parents);
    }

    function empty$4() {
        return [];
    }
    function selectorAll$3 (selector) {
        return selector == null ? empty$4 : function () {
            return this.querySelectorAll(selector);
        };
    }

    function selection_selectAll$3 (select) {
        if (typeof select !== "function")
            select = selectorAll$3(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    subgroups.push(select.call(node, node.__data__, i, group));
                    parents.push(node);
                }
            }
        }
        return new Selection$5(subgroups, parents);
    }

    function matcher$4 (selector) {
        return function () {
            return this.matches(selector);
        };
    }

    function selection_filter$3 (match) {
        if (typeof match !== "function")
            match = matcher$4(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Selection$5(subgroups, this._parents);
    }

    function sparse$3 (update) {
        return new Array(update.length);
    }

    function selection_enter$3 () {
        return new Selection$5(this._enter || this._groups.map(sparse$3), this._parents);
    }
    function EnterNode$3(parent, datum) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum;
    }
    EnterNode$3.prototype = {
        constructor: EnterNode$3,
        appendChild: function (child) { return this._parent.insertBefore(child, this._next); },
        insertBefore: function (child, next) { return this._parent.insertBefore(child, next); },
        querySelector: function (selector) { return this._parent.querySelector(selector); },
        querySelectorAll: function (selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$h (x) {
        return function () {
            return x;
        };
    }

    var keyPrefix$4 = "$"; // Protect against keys like “__proto__”.
    function bindIndex$3(parent, group, enter, update, exit, data) {
        var i = 0, node, groupLength = group.length, dataLength = data.length;
        // Put any non-null nodes that fit into update.
        // Put any null nodes into enter.
        // Put any remaining data into enter.
        for (; i < dataLength; ++i) {
            if (node = group[i]) {
                node.__data__ = data[i];
                update[i] = node;
            }
            else {
                enter[i] = new EnterNode$3(parent, data[i]);
            }
        }
        // Put any non-null nodes that don’t fit into exit.
        for (; i < groupLength; ++i) {
            if (node = group[i]) {
                exit[i] = node;
            }
        }
    }
    function bindKey$3(parent, group, enter, update, exit, data, key) {
        var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
        // Compute the key for each node.
        // If multiple nodes have the same key, the duplicates are added to exit.
        for (i = 0; i < groupLength; ++i) {
            if (node = group[i]) {
                keyValues[i] = keyValue = keyPrefix$4 + key.call(node, node.__data__, i, group);
                if (keyValue in nodeByKeyValue) {
                    exit[i] = node;
                }
                else {
                    nodeByKeyValue[keyValue] = node;
                }
            }
        }
        // Compute the key for each datum.
        // If there a node associated with this key, join and add it to update.
        // If there is not (or the key is a duplicate), add it to enter.
        for (i = 0; i < dataLength; ++i) {
            keyValue = keyPrefix$4 + key.call(parent, data[i], i, data);
            if (node = nodeByKeyValue[keyValue]) {
                update[i] = node;
                node.__data__ = data[i];
                nodeByKeyValue[keyValue] = null;
            }
            else {
                enter[i] = new EnterNode$3(parent, data[i]);
            }
        }
        // Add any remaining nodes that were not bound to data to exit.
        for (i = 0; i < groupLength; ++i) {
            if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
                exit[i] = node;
            }
        }
    }
    function selection_data$3 (value, key) {
        if (!value) {
            data = new Array(this.size()), j = -1;
            this.each(function (d) { data[++j] = d; });
            return data;
        }
        var bind = key ? bindKey$3 : bindIndex$3, parents = this._parents, groups = this._groups;
        if (typeof value !== "function")
            value = constant$h(value);
        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
            var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
            bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
            // Now connect the enter nodes to their following update node, such that
            // appendChild can insert the materialized enter node before this node,
            // rather than at the end of the parent node.
            for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
                if (previous = enterGroup[i0]) {
                    if (i0 >= i1)
                        i1 = i0 + 1;
                    while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                        ;
                    previous._next = next || null;
                }
            }
        }
        update = new Selection$5(update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
    }

    function selection_exit$3 () {
        return new Selection$5(this._exit || this._groups.map(sparse$3), this._parents);
    }

    function selection_join$2 (onenter, onupdate, onexit) {
        var enter = this.enter(), update = this, exit = this.exit();
        enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
        if (onupdate != null)
            update = onupdate(update);
        if (onexit == null)
            exit.remove();
        else
            onexit(exit);
        return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge$3 (selection) {
        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Selection$5(merges, this._parents);
    }

    function selection_order$3 () {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
            for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && node.compareDocumentPosition(next) ^ 4)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    }

    function selection_sort$3 (compare) {
        if (!compare)
            compare = ascending$7;
        function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    sortgroup[i] = node;
                }
            }
            sortgroup.sort(compareNode);
        }
        return new Selection$5(sortgroups, this._parents).order();
    }
    function ascending$7(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call$3 () {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
    }

    function selection_nodes$3 () {
        var nodes = new Array(this.size()), i = -1;
        this.each(function () { nodes[++i] = this; });
        return nodes;
    }

    function selection_node$3 () {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    }

    function selection_size$3 () {
        var size = 0;
        this.each(function () { ++size; });
        return size;
    }

    function selection_empty$3 () {
        return !this.node();
    }

    function selection_each$3 (callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
                if (node = group[i])
                    callback.call(node, node.__data__, i, group);
            }
        }
        return this;
    }

    function attrRemove$5(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS$5(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant$5(name, value) {
        return function () {
            this.setAttribute(name, value);
        };
    }
    function attrConstantNS$5(fullname, value) {
        return function () {
            this.setAttributeNS(fullname.space, fullname.local, value);
        };
    }
    function attrFunction$5(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, v);
        };
    }
    function attrFunctionNS$5(fullname, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttributeNS(fullname.space, fullname.local);
            else
                this.setAttributeNS(fullname.space, fullname.local, v);
        };
    }
    function selection_attr$3 (name, value) {
        var fullname = namespace$3(name);
        if (arguments.length < 2) {
            var node = this.node();
            return fullname.local
                ? node.getAttributeNS(fullname.space, fullname.local)
                : node.getAttribute(fullname);
        }
        return this.each((value == null
            ? (fullname.local ? attrRemoveNS$5 : attrRemove$5) : (typeof value === "function"
            ? (fullname.local ? attrFunctionNS$5 : attrFunction$5)
            : (fullname.local ? attrConstantNS$5 : attrConstant$5)))(fullname, value));
    }

    function defaultView$3 (node) {
        return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
            || (node.document && node) // node is a Window
            || node.defaultView; // node is a Document
    }

    function styleRemove$5(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant$5(name, value, priority) {
        return function () {
            this.style.setProperty(name, value, priority);
        };
    }
    function styleFunction$5(name, value, priority) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, v, priority);
        };
    }
    function selection_style$3 (name, value, priority) {
        return arguments.length > 1
            ? this.each((value == null
                ? styleRemove$5 : typeof value === "function"
                ? styleFunction$5
                : styleConstant$5)(name, value, priority == null ? "" : priority))
            : styleValue$3(this.node(), name);
    }
    function styleValue$3(node, name) {
        return node.style.getPropertyValue(name)
            || defaultView$3(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove$3(name) {
        return function () {
            delete this[name];
        };
    }
    function propertyConstant$3(name, value) {
        return function () {
            this[name] = value;
        };
    }
    function propertyFunction$3(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                delete this[name];
            else
                this[name] = v;
        };
    }
    function selection_property$3 (name, value) {
        return arguments.length > 1
            ? this.each((value == null
                ? propertyRemove$3 : typeof value === "function"
                ? propertyFunction$3
                : propertyConstant$3)(name, value))
            : this.node()[name];
    }

    function classArray$3(string) {
        return string.trim().split(/^|\s+/);
    }
    function classList$3(node) {
        return node.classList || new ClassList$3(node);
    }
    function ClassList$3(node) {
        this._node = node;
        this._names = classArray$3(node.getAttribute("class") || "");
    }
    ClassList$3.prototype = {
        add: function (name) {
            var i = this._names.indexOf(name);
            if (i < 0) {
                this._names.push(name);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        remove: function (name) {
            var i = this._names.indexOf(name);
            if (i >= 0) {
                this._names.splice(i, 1);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        contains: function (name) {
            return this._names.indexOf(name) >= 0;
        }
    };
    function classedAdd$3(node, names) {
        var list = classList$3(node), i = -1, n = names.length;
        while (++i < n)
            list.add(names[i]);
    }
    function classedRemove$3(node, names) {
        var list = classList$3(node), i = -1, n = names.length;
        while (++i < n)
            list.remove(names[i]);
    }
    function classedTrue$3(names) {
        return function () {
            classedAdd$3(this, names);
        };
    }
    function classedFalse$3(names) {
        return function () {
            classedRemove$3(this, names);
        };
    }
    function classedFunction$3(names, value) {
        return function () {
            (value.apply(this, arguments) ? classedAdd$3 : classedRemove$3)(this, names);
        };
    }
    function selection_classed$3 (name, value) {
        var names = classArray$3(name + "");
        if (arguments.length < 2) {
            var list = classList$3(this.node()), i = -1, n = names.length;
            while (++i < n)
                if (!list.contains(names[i]))
                    return false;
            return true;
        }
        return this.each((typeof value === "function"
            ? classedFunction$3 : value
            ? classedTrue$3
            : classedFalse$3)(names, value));
    }

    function textRemove$3() {
        this.textContent = "";
    }
    function textConstant$5(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction$5(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        };
    }
    function selection_text$3 (value) {
        return arguments.length
            ? this.each(value == null
                ? textRemove$3 : (typeof value === "function"
                ? textFunction$5
                : textConstant$5)(value))
            : this.node().textContent;
    }

    function htmlRemove$3() {
        this.innerHTML = "";
    }
    function htmlConstant$3(value) {
        return function () {
            this.innerHTML = value;
        };
    }
    function htmlFunction$3(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        };
    }
    function selection_html$3 (value) {
        return arguments.length
            ? this.each(value == null
                ? htmlRemove$3 : (typeof value === "function"
                ? htmlFunction$3
                : htmlConstant$3)(value))
            : this.node().innerHTML;
    }

    function raise$4() {
        if (this.nextSibling)
            this.parentNode.appendChild(this);
    }
    function selection_raise$3 () {
        return this.each(raise$4);
    }

    function lower$3() {
        if (this.previousSibling)
            this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower$3 () {
        return this.each(lower$3);
    }

    function selection_append$3 (name) {
        var create = typeof name === "function" ? name : creator$3(name);
        return this.select(function () {
            return this.appendChild(create.apply(this, arguments));
        });
    }

    function constantNull$3() {
        return null;
    }
    function selection_insert$3 (name, before) {
        var create = typeof name === "function" ? name : creator$3(name), select = before == null ? constantNull$3 : typeof before === "function" ? before : selector$3(before);
        return this.select(function () {
            return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        });
    }

    function remove$3() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    function selection_remove$3 () {
        return this.each(remove$3);
    }

    function selection_cloneShallow$3() {
        var clone = this.cloneNode(false), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep$3() {
        var clone = this.cloneNode(true), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone$3 (deep) {
        return this.select(deep ? selection_cloneDeep$3 : selection_cloneShallow$3);
    }

    function selection_datum$3 (value) {
        return arguments.length
            ? this.property("__data__", value)
            : this.node().__data__;
    }

    var filterEvents$3 = {};
    if (typeof document !== "undefined") {
        var element$4 = document.documentElement;
        if (!("onmouseenter" in element$4)) {
            filterEvents$3 = { mouseenter: "mouseover", mouseleave: "mouseout" };
        }
    }
    function filterContextListener$3(listener, index, group) {
        listener = contextListener$3(listener, index, group);
        return function (event) {
            var related = event.relatedTarget;
            if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
                listener.call(this, event);
            }
        };
    }
    function contextListener$3(listener, index, group) {
        return function (event1) {
            try {
                listener.call(this, this.__data__, index, group);
            }
            finally {
            }
        };
    }
    function parseTypenames$6(typenames) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            return { type: t, name: name };
        });
    }
    function onRemove$3(typename) {
        return function () {
            var on = this.__on;
            if (!on)
                return;
            for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
                if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                    this.removeEventListener(o.type, o.listener, o.capture);
                }
                else {
                    on[++i] = o;
                }
            }
            if (++i)
                on.length = i;
            else
                delete this.__on;
        };
    }
    function onAdd$3(typename, value, capture) {
        var wrap = filterEvents$3.hasOwnProperty(typename.type) ? filterContextListener$3 : contextListener$3;
        return function (d, i, group) {
            var on = this.__on, o, listener = wrap(value, i, group);
            if (on)
                for (var j = 0, m = on.length; j < m; ++j) {
                    if ((o = on[j]).type === typename.type && o.name === typename.name) {
                        this.removeEventListener(o.type, o.listener, o.capture);
                        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                        o.value = value;
                        return;
                    }
                }
            this.addEventListener(typename.type, listener, capture);
            o = { type: typename.type, name: typename.name, value: value, listener: listener, capture: capture };
            if (!on)
                this.__on = [o];
            else
                on.push(o);
        };
    }
    function selection_on$3 (typename, value, capture) {
        var typenames = parseTypenames$6(typename + ""), i, n = typenames.length, t;
        if (arguments.length < 2) {
            var on = this.node().__on;
            if (on)
                for (var j = 0, m = on.length, o; j < m; ++j) {
                    for (i = 0, o = on[j]; i < n; ++i) {
                        if ((t = typenames[i]).type === o.type && t.name === o.name) {
                            return o.value;
                        }
                    }
                }
            return;
        }
        on = value ? onAdd$3 : onRemove$3;
        if (capture == null)
            capture = false;
        for (i = 0; i < n; ++i)
            this.each(on(typenames[i], value, capture));
        return this;
    }

    function dispatchEvent$3(node, type, params) {
        var window = defaultView$3(node), event = window.CustomEvent;
        if (typeof event === "function") {
            event = new event(type, params);
        }
        else {
            event = window.document.createEvent("Event");
            if (params)
                event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
            else
                event.initEvent(type, false, false);
        }
        node.dispatchEvent(event);
    }
    function dispatchConstant$3(type, params) {
        return function () {
            return dispatchEvent$3(this, type, params);
        };
    }
    function dispatchFunction$3(type, params) {
        return function () {
            return dispatchEvent$3(this, type, params.apply(this, arguments));
        };
    }
    function selection_dispatch$3 (type, params) {
        return this.each((typeof params === "function"
            ? dispatchFunction$3
            : dispatchConstant$3)(type, params));
    }

    var root$3 = [null];
    function Selection$5(groups, parents) {
        this._groups = groups;
        this._parents = parents;
    }
    function selection$3() {
        return new Selection$5([[document.documentElement]], root$3);
    }
    Selection$5.prototype = selection$3.prototype = {
        constructor: Selection$5,
        select: selection_select$3,
        selectAll: selection_selectAll$3,
        filter: selection_filter$3,
        data: selection_data$3,
        enter: selection_enter$3,
        exit: selection_exit$3,
        join: selection_join$2,
        merge: selection_merge$3,
        order: selection_order$3,
        sort: selection_sort$3,
        call: selection_call$3,
        nodes: selection_nodes$3,
        node: selection_node$3,
        size: selection_size$3,
        empty: selection_empty$3,
        each: selection_each$3,
        attr: selection_attr$3,
        style: selection_style$3,
        property: selection_property$3,
        classed: selection_classed$3,
        text: selection_text$3,
        html: selection_html$3,
        raise: selection_raise$3,
        lower: selection_lower$3,
        append: selection_append$3,
        insert: selection_insert$3,
        remove: selection_remove$3,
        clone: selection_clone$3,
        datum: selection_datum$3,
        on: selection_on$3,
        dispatch: selection_dispatch$3
    };

    var noop$5 = { value: function () { } };
    function dispatch$3() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
            if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t))
                throw new Error("illegal type: " + t);
            _[t] = [];
        }
        return new Dispatch$3(_);
    }
    function Dispatch$3(_) {
        this._ = _;
    }
    function parseTypenames$7(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            if (t && !types.hasOwnProperty(t))
                throw new Error("unknown type: " + t);
            return { type: t, name: name };
        });
    }
    Dispatch$3.prototype = dispatch$3.prototype = {
        constructor: Dispatch$3,
        on: function (typename, callback) {
            var _ = this._, T = parseTypenames$7(typename + "", _), t, i = -1, n = T.length;
            // If no callback was specified, return the callback of the given type and name.
            if (arguments.length < 2) {
                while (++i < n)
                    if ((t = (typename = T[i]).type) && (t = get$5(_[t], typename.name)))
                        return t;
                return;
            }
            // If a type was specified, set the callback for the given type and name.
            // Otherwise, if a null callback was specified, remove callbacks of the given name.
            if (callback != null && typeof callback !== "function")
                throw new Error("invalid callback: " + callback);
            while (++i < n) {
                if (t = (typename = T[i]).type)
                    _[t] = set$8(_[t], typename.name, callback);
                else if (callback == null)
                    for (t in _)
                        _[t] = set$8(_[t], typename.name, null);
            }
            return this;
        },
        copy: function () {
            var copy = {}, _ = this._;
            for (var t in _)
                copy[t] = _[t].slice();
            return new Dispatch$3(copy);
        },
        call: function (type, that) {
            if ((n = arguments.length - 2) > 0)
                for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                    args[i] = arguments[i + 2];
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        },
        apply: function (type, that, args) {
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        }
    };
    function get$5(type, name) {
        for (var i = 0, n = type.length, c; i < n; ++i) {
            if ((c = type[i]).name === name) {
                return c.value;
            }
        }
    }
    function set$8(type, name, callback) {
        for (var i = 0, n = type.length; i < n; ++i) {
            if (type[i].name === name) {
                type[i] = noop$5, type = type.slice(0, i).concat(type.slice(i + 1));
                break;
            }
        }
        if (callback != null)
            type.push({ name: name, value: callback });
        return type;
    }

    var frame$2 = 0, // is an animation frame pending?
    timeout$4 = 0, // is a timeout pending?
    interval$3 = 0, // are any timers active?
    pokeDelay$2 = 1000, // how frequently we check for clock skew
    taskHead$2, taskTail$2, clockLast$2 = 0, clockNow$2 = 0, clockSkew$2 = 0, clock$2 = typeof performance === "object" && performance.now ? performance : Date, setFrame$2 = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) { setTimeout(f, 17); };
    function now$2() {
        return clockNow$2 || (setFrame$2(clearNow$2), clockNow$2 = clock$2.now() + clockSkew$2);
    }
    function clearNow$2() {
        clockNow$2 = 0;
    }
    function Timer$2() {
        this._call =
            this._time =
                this._next = null;
    }
    Timer$2.prototype = timer$2.prototype = {
        constructor: Timer$2,
        restart: function (callback, delay, time) {
            if (typeof callback !== "function")
                throw new TypeError("callback is not a function");
            time = (time == null ? now$2() : +time) + (delay == null ? 0 : +delay);
            if (!this._next && taskTail$2 !== this) {
                if (taskTail$2)
                    taskTail$2._next = this;
                else
                    taskHead$2 = this;
                taskTail$2 = this;
            }
            this._call = callback;
            this._time = time;
            sleep$2();
        },
        stop: function () {
            if (this._call) {
                this._call = null;
                this._time = Infinity;
                sleep$2();
            }
        }
    };
    function timer$2(callback, delay, time) {
        var t = new Timer$2;
        t.restart(callback, delay, time);
        return t;
    }
    function timerFlush$2() {
        now$2(); // Get the current time, if not already set.
        ++frame$2; // Pretend we’ve set an alarm, if we haven’t already.
        var t = taskHead$2, e;
        while (t) {
            if ((e = clockNow$2 - t._time) >= 0)
                t._call.call(null, e);
            t = t._next;
        }
        --frame$2;
    }
    function wake$2() {
        clockNow$2 = (clockLast$2 = clock$2.now()) + clockSkew$2;
        frame$2 = timeout$4 = 0;
        try {
            timerFlush$2();
        }
        finally {
            frame$2 = 0;
            nap$2();
            clockNow$2 = 0;
        }
    }
    function poke$3() {
        var now = clock$2.now(), delay = now - clockLast$2;
        if (delay > pokeDelay$2)
            clockSkew$2 -= delay, clockLast$2 = now;
    }
    function nap$2() {
        var t0, t1 = taskHead$2, t2, time = Infinity;
        while (t1) {
            if (t1._call) {
                if (time > t1._time)
                    time = t1._time;
                t0 = t1, t1 = t1._next;
            }
            else {
                t2 = t1._next, t1._next = null;
                t1 = t0 ? t0._next = t2 : taskHead$2 = t2;
            }
        }
        taskTail$2 = t0;
        sleep$2(time);
    }
    function sleep$2(time) {
        if (frame$2)
            return; // Soonest alarm already set, or will be.
        if (timeout$4)
            timeout$4 = clearTimeout(timeout$4);
        var delay = time - clockNow$2; // Strictly less than if we recomputed clockNow.
        if (delay > 24) {
            if (time < Infinity)
                timeout$4 = setTimeout(wake$2, time - clock$2.now() - clockSkew$2);
            if (interval$3)
                interval$3 = clearInterval(interval$3);
        }
        else {
            if (!interval$3)
                clockLast$2 = clock$2.now(), interval$3 = setInterval(poke$3, pokeDelay$2);
            frame$2 = 1, setFrame$2(wake$2);
        }
    }

    function timeout$5 (callback, delay, time) {
        var t = new Timer$2;
        delay = delay == null ? 0 : +delay;
        t.restart(function (elapsed) {
            t.stop();
            callback(elapsed + delay);
        }, delay, time);
        return t;
    }

    var emptyOn$2 = dispatch$3("start", "end", "interrupt");
    var emptyTween$2 = [];
    var CREATED$2 = 0;
    var SCHEDULED$2 = 1;
    var STARTING$2 = 2;
    var STARTED$2 = 3;
    var RUNNING$2 = 4;
    var ENDING$2 = 5;
    var ENDED$2 = 6;
    function schedule$2 (node, name, id, index, group, timing) {
        var schedules = node.__transition;
        if (!schedules)
            node.__transition = {};
        else if (id in schedules)
            return;
        create$3(node, id, {
            name: name,
            index: index,
            group: group,
            on: emptyOn$2,
            tween: emptyTween$2,
            time: timing.time,
            delay: timing.delay,
            duration: timing.duration,
            ease: timing.ease,
            timer: null,
            state: CREATED$2
        });
    }
    function init$2(node, id) {
        var schedule = get$6(node, id);
        if (schedule.state > CREATED$2)
            throw new Error("too late; already scheduled");
        return schedule;
    }
    function set$9(node, id) {
        var schedule = get$6(node, id);
        if (schedule.state > STARTING$2)
            throw new Error("too late; already started");
        return schedule;
    }
    function get$6(node, id) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id]))
            throw new Error("transition not found");
        return schedule;
    }
    function create$3(node, id, self) {
        var schedules = node.__transition, tween;
        // Initialize the self timer when the transition is created.
        // Note the actual delay is not known until the first callback!
        schedules[id] = self;
        self.timer = timer$2(schedule, 0, self.time);
        function schedule(elapsed) {
            self.state = SCHEDULED$2;
            self.timer.restart(start, self.delay, self.time);
            // If the elapsed delay is less than our first sleep, start immediately.
            if (self.delay <= elapsed)
                start(elapsed - self.delay);
        }
        function start(elapsed) {
            var i, j, n, o;
            // If the state is not SCHEDULED, then we previously errored on start.
            if (self.state !== SCHEDULED$2)
                return stop();
            for (i in schedules) {
                o = schedules[i];
                if (o.name !== self.name)
                    continue;
                // While this element already has a starting transition during this frame,
                // defer starting an interrupting transition until that transition has a
                // chance to tick (and possibly end); see d3/d3-transition#54!
                if (o.state === STARTED$2)
                    return timeout$5(start);
                // Interrupt the active transition, if any.
                // Dispatch the interrupt event.
                if (o.state === RUNNING$2) {
                    o.state = ENDED$2;
                    o.timer.stop();
                    o.on.call("interrupt", node, node.__data__, o.index, o.group);
                    delete schedules[i];
                }
                // Cancel any pre-empted transitions. No interrupt event is dispatched
                // because the cancelled transitions never started. Note that this also
                // removes this transition from the pending list!
                else if (+i < id) {
                    o.state = ENDED$2;
                    o.timer.stop();
                    delete schedules[i];
                }
            }
            // Defer the first tick to end of the current frame; see d3/d3#1576.
            // Note the transition may be canceled after start and before the first tick!
            // Note this must be scheduled before the start event; see d3/d3-transition#16!
            // Assuming this is successful, subsequent callbacks go straight to tick.
            timeout$5(function () {
                if (self.state === STARTED$2) {
                    self.state = RUNNING$2;
                    self.timer.restart(tick, self.delay, self.time);
                    tick(elapsed);
                }
            });
            // Dispatch the start event.
            // Note this must be done before the tween are initialized.
            self.state = STARTING$2;
            self.on.call("start", node, node.__data__, self.index, self.group);
            if (self.state !== STARTING$2)
                return; // interrupted
            self.state = STARTED$2;
            // Initialize the tween, deleting null tween.
            tween = new Array(n = self.tween.length);
            for (i = 0, j = -1; i < n; ++i) {
                if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
                    tween[++j] = o;
                }
            }
            tween.length = j + 1;
        }
        function tick(elapsed) {
            var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING$2, 1), i = -1, n = tween.length;
            while (++i < n) {
                tween[i].call(null, t);
            }
            // Dispatch the end event.
            if (self.state === ENDING$2) {
                self.on.call("end", node, node.__data__, self.index, self.group);
                stop();
            }
        }
        function stop() {
            self.state = ENDED$2;
            self.timer.stop();
            delete schedules[id];
            for (var i in schedules)
                return; // eslint-disable-line no-unused-vars
            delete node.__transition;
        }
    }

    function interrupt$2 (node, name) {
        var schedules = node.__transition, schedule, active, empty = true, i;
        if (!schedules)
            return;
        name = name == null ? null : name + "";
        for (i in schedules) {
            if ((schedule = schedules[i]).name !== name) {
                empty = false;
                continue;
            }
            active = schedule.state > STARTING$2 && schedule.state < ENDING$2;
            schedule.state = ENDED$2;
            schedule.timer.stop();
            if (active)
                schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
            delete schedules[i];
        }
        if (empty)
            delete node.__transition;
    }

    function selection_interrupt$2 (name) {
        return this.each(function () {
            interrupt$2(this, name);
        });
    }

    function define$4 (constructor, factory, prototype) {
        constructor.prototype = factory.prototype = prototype;
        prototype.constructor = constructor;
    }
    function extend$4(parent, definition) {
        var prototype = Object.create(parent.prototype);
        for (var key in definition)
            prototype[key] = definition[key];
        return prototype;
    }

    function Color$4() { }
    var darker$4 = 0.7;
    var brighter$4 = 1 / darker$4;
    var reI$4 = "\\s*([+-]?\\d+)\\s*", reN$4 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP$4 = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex$3 = /^#([0-9a-f]{3,8})$/, reRgbInteger$4 = new RegExp("^rgb\\(" + [reI$4, reI$4, reI$4] + "\\)$"), reRgbPercent$4 = new RegExp("^rgb\\(" + [reP$4, reP$4, reP$4] + "\\)$"), reRgbaInteger$4 = new RegExp("^rgba\\(" + [reI$4, reI$4, reI$4, reN$4] + "\\)$"), reRgbaPercent$4 = new RegExp("^rgba\\(" + [reP$4, reP$4, reP$4, reN$4] + "\\)$"), reHslPercent$4 = new RegExp("^hsl\\(" + [reN$4, reP$4, reP$4] + "\\)$"), reHslaPercent$4 = new RegExp("^hsla\\(" + [reN$4, reP$4, reP$4, reN$4] + "\\)$");
    var named$4 = {
        aliceblue: 0xf0f8ff,
        antiquewhite: 0xfaebd7,
        aqua: 0x00ffff,
        aquamarine: 0x7fffd4,
        azure: 0xf0ffff,
        beige: 0xf5f5dc,
        bisque: 0xffe4c4,
        black: 0x000000,
        blanchedalmond: 0xffebcd,
        blue: 0x0000ff,
        blueviolet: 0x8a2be2,
        brown: 0xa52a2a,
        burlywood: 0xdeb887,
        cadetblue: 0x5f9ea0,
        chartreuse: 0x7fff00,
        chocolate: 0xd2691e,
        coral: 0xff7f50,
        cornflowerblue: 0x6495ed,
        cornsilk: 0xfff8dc,
        crimson: 0xdc143c,
        cyan: 0x00ffff,
        darkblue: 0x00008b,
        darkcyan: 0x008b8b,
        darkgoldenrod: 0xb8860b,
        darkgray: 0xa9a9a9,
        darkgreen: 0x006400,
        darkgrey: 0xa9a9a9,
        darkkhaki: 0xbdb76b,
        darkmagenta: 0x8b008b,
        darkolivegreen: 0x556b2f,
        darkorange: 0xff8c00,
        darkorchid: 0x9932cc,
        darkred: 0x8b0000,
        darksalmon: 0xe9967a,
        darkseagreen: 0x8fbc8f,
        darkslateblue: 0x483d8b,
        darkslategray: 0x2f4f4f,
        darkslategrey: 0x2f4f4f,
        darkturquoise: 0x00ced1,
        darkviolet: 0x9400d3,
        deeppink: 0xff1493,
        deepskyblue: 0x00bfff,
        dimgray: 0x696969,
        dimgrey: 0x696969,
        dodgerblue: 0x1e90ff,
        firebrick: 0xb22222,
        floralwhite: 0xfffaf0,
        forestgreen: 0x228b22,
        fuchsia: 0xff00ff,
        gainsboro: 0xdcdcdc,
        ghostwhite: 0xf8f8ff,
        gold: 0xffd700,
        goldenrod: 0xdaa520,
        gray: 0x808080,
        green: 0x008000,
        greenyellow: 0xadff2f,
        grey: 0x808080,
        honeydew: 0xf0fff0,
        hotpink: 0xff69b4,
        indianred: 0xcd5c5c,
        indigo: 0x4b0082,
        ivory: 0xfffff0,
        khaki: 0xf0e68c,
        lavender: 0xe6e6fa,
        lavenderblush: 0xfff0f5,
        lawngreen: 0x7cfc00,
        lemonchiffon: 0xfffacd,
        lightblue: 0xadd8e6,
        lightcoral: 0xf08080,
        lightcyan: 0xe0ffff,
        lightgoldenrodyellow: 0xfafad2,
        lightgray: 0xd3d3d3,
        lightgreen: 0x90ee90,
        lightgrey: 0xd3d3d3,
        lightpink: 0xffb6c1,
        lightsalmon: 0xffa07a,
        lightseagreen: 0x20b2aa,
        lightskyblue: 0x87cefa,
        lightslategray: 0x778899,
        lightslategrey: 0x778899,
        lightsteelblue: 0xb0c4de,
        lightyellow: 0xffffe0,
        lime: 0x00ff00,
        limegreen: 0x32cd32,
        linen: 0xfaf0e6,
        magenta: 0xff00ff,
        maroon: 0x800000,
        mediumaquamarine: 0x66cdaa,
        mediumblue: 0x0000cd,
        mediumorchid: 0xba55d3,
        mediumpurple: 0x9370db,
        mediumseagreen: 0x3cb371,
        mediumslateblue: 0x7b68ee,
        mediumspringgreen: 0x00fa9a,
        mediumturquoise: 0x48d1cc,
        mediumvioletred: 0xc71585,
        midnightblue: 0x191970,
        mintcream: 0xf5fffa,
        mistyrose: 0xffe4e1,
        moccasin: 0xffe4b5,
        navajowhite: 0xffdead,
        navy: 0x000080,
        oldlace: 0xfdf5e6,
        olive: 0x808000,
        olivedrab: 0x6b8e23,
        orange: 0xffa500,
        orangered: 0xff4500,
        orchid: 0xda70d6,
        palegoldenrod: 0xeee8aa,
        palegreen: 0x98fb98,
        paleturquoise: 0xafeeee,
        palevioletred: 0xdb7093,
        papayawhip: 0xffefd5,
        peachpuff: 0xffdab9,
        peru: 0xcd853f,
        pink: 0xffc0cb,
        plum: 0xdda0dd,
        powderblue: 0xb0e0e6,
        purple: 0x800080,
        rebeccapurple: 0x663399,
        red: 0xff0000,
        rosybrown: 0xbc8f8f,
        royalblue: 0x4169e1,
        saddlebrown: 0x8b4513,
        salmon: 0xfa8072,
        sandybrown: 0xf4a460,
        seagreen: 0x2e8b57,
        seashell: 0xfff5ee,
        sienna: 0xa0522d,
        silver: 0xc0c0c0,
        skyblue: 0x87ceeb,
        slateblue: 0x6a5acd,
        slategray: 0x708090,
        slategrey: 0x708090,
        snow: 0xfffafa,
        springgreen: 0x00ff7f,
        steelblue: 0x4682b4,
        tan: 0xd2b48c,
        teal: 0x008080,
        thistle: 0xd8bfd8,
        tomato: 0xff6347,
        turquoise: 0x40e0d0,
        violet: 0xee82ee,
        wheat: 0xf5deb3,
        white: 0xffffff,
        whitesmoke: 0xf5f5f5,
        yellow: 0xffff00,
        yellowgreen: 0x9acd32
    };
    define$4(Color$4, color$4, {
        copy: function (channels) {
            return Object.assign(new this.constructor, this, channels);
        },
        displayable: function () {
            return this.rgb().displayable();
        },
        hex: color_formatHex$3,
        formatHex: color_formatHex$3,
        formatHsl: color_formatHsl$3,
        formatRgb: color_formatRgb$3,
        toString: color_formatRgb$3
    });
    function color_formatHex$3() {
        return this.rgb().formatHex();
    }
    function color_formatHsl$3() {
        return hslConvert$4(this).formatHsl();
    }
    function color_formatRgb$3() {
        return this.rgb().formatRgb();
    }
    function color$4(format) {
        var m, l;
        format = (format + "").trim().toLowerCase();
        return (m = reHex$3.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn$4(m) // #ff0000
            : l === 3 ? new Rgb$4((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
                : l === 8 ? rgba$4(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
                    : l === 4 ? rgba$4((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
                        : null) // invalid hex
            : (m = reRgbInteger$4.exec(format)) ? new Rgb$4(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
                : (m = reRgbPercent$4.exec(format)) ? new Rgb$4(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
                    : (m = reRgbaInteger$4.exec(format)) ? rgba$4(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
                        : (m = reRgbaPercent$4.exec(format)) ? rgba$4(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
                            : (m = reHslPercent$4.exec(format)) ? hsla$4(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
                                : (m = reHslaPercent$4.exec(format)) ? hsla$4(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
                                    : named$4.hasOwnProperty(format) ? rgbn$4(named$4[format]) // eslint-disable-line no-prototype-builtins
                                        : format === "transparent" ? new Rgb$4(NaN, NaN, NaN, 0)
                                            : null;
    }
    function rgbn$4(n) {
        return new Rgb$4(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }
    function rgba$4(r, g, b, a) {
        if (a <= 0)
            r = g = b = NaN;
        return new Rgb$4(r, g, b, a);
    }
    function rgbConvert$4(o) {
        if (!(o instanceof Color$4))
            o = color$4(o);
        if (!o)
            return new Rgb$4;
        o = o.rgb();
        return new Rgb$4(o.r, o.g, o.b, o.opacity);
    }
    function rgb$6(r, g, b, opacity) {
        return arguments.length === 1 ? rgbConvert$4(r) : new Rgb$4(r, g, b, opacity == null ? 1 : opacity);
    }
    function Rgb$4(r, g, b, opacity) {
        this.r = +r;
        this.g = +g;
        this.b = +b;
        this.opacity = +opacity;
    }
    define$4(Rgb$4, rgb$6, extend$4(Color$4, {
        brighter: function (k) {
            k = k == null ? brighter$4 : Math.pow(brighter$4, k);
            return new Rgb$4(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$4 : Math.pow(darker$4, k);
            return new Rgb$4(this.r * k, this.g * k, this.b * k, this.opacity);
        },
        rgb: function () {
            return this;
        },
        displayable: function () {
            return (-0.5 <= this.r && this.r < 255.5)
                && (-0.5 <= this.g && this.g < 255.5)
                && (-0.5 <= this.b && this.b < 255.5)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        hex: rgb_formatHex$3,
        formatHex: rgb_formatHex$3,
        formatRgb: rgb_formatRgb$3,
        toString: rgb_formatRgb$3
    }));
    function rgb_formatHex$3() {
        return "#" + hex$3(this.r) + hex$3(this.g) + hex$3(this.b);
    }
    function rgb_formatRgb$3() {
        var a = this.opacity;
        a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
        return (a === 1 ? "rgb(" : "rgba(")
            + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
            + Math.max(0, Math.min(255, Math.round(this.b) || 0))
            + (a === 1 ? ")" : ", " + a + ")");
    }
    function hex$3(value) {
        value = Math.max(0, Math.min(255, Math.round(value) || 0));
        return (value < 16 ? "0" : "") + value.toString(16);
    }
    function hsla$4(h, s, l, a) {
        if (a <= 0)
            h = s = l = NaN;
        else if (l <= 0 || l >= 1)
            h = s = NaN;
        else if (s <= 0)
            h = NaN;
        return new Hsl$4(h, s, l, a);
    }
    function hslConvert$4(o) {
        if (o instanceof Hsl$4)
            return new Hsl$4(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Color$4))
            o = color$4(o);
        if (!o)
            return new Hsl$4;
        if (o instanceof Hsl$4)
            return o;
        o = o.rgb();
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), h = NaN, s = max - min, l = (max + min) / 2;
        if (s) {
            if (r === max)
                h = (g - b) / s + (g < b) * 6;
            else if (g === max)
                h = (b - r) / s + 2;
            else
                h = (r - g) / s + 4;
            s /= l < 0.5 ? max + min : 2 - max - min;
            h *= 60;
        }
        else {
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new Hsl$4(h, s, l, o.opacity);
    }
    function hsl$6(h, s, l, opacity) {
        return arguments.length === 1 ? hslConvert$4(h) : new Hsl$4(h, s, l, opacity == null ? 1 : opacity);
    }
    function Hsl$4(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define$4(Hsl$4, hsl$6, extend$4(Color$4, {
        brighter: function (k) {
            k = k == null ? brighter$4 : Math.pow(brighter$4, k);
            return new Hsl$4(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$4 : Math.pow(darker$4, k);
            return new Hsl$4(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
            return new Rgb$4(hsl2rgb$4(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb$4(h, m1, m2), hsl2rgb$4(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
        },
        displayable: function () {
            return (0 <= this.s && this.s <= 1 || isNaN(this.s))
                && (0 <= this.l && this.l <= 1)
                && (0 <= this.opacity && this.opacity <= 1);
        },
        formatHsl: function () {
            var a = this.opacity;
            a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
            return (a === 1 ? "hsl(" : "hsla(")
                + (this.h || 0) + ", "
                + (this.s || 0) * 100 + "%, "
                + (this.l || 0) * 100 + "%"
                + (a === 1 ? ")" : ", " + a + ")");
        }
    }));
    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb$4(h, m1, m2) {
        return (h < 60 ? m1 + (m2 - m1) * h / 60
            : h < 180 ? m2
                : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
                    : m1) * 255;
    }

    var deg2rad$4 = Math.PI / 180;
    var rad2deg$4 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    var K$3 = 18, Xn$4 = 0.96422, Yn$4 = 1, Zn$4 = 0.82521, t0$8 = 4 / 29, t1$8 = 6 / 29, t2$4 = 3 * t1$8 * t1$8, t3$4 = t1$8 * t1$8 * t1$8;
    function labConvert$4(o) {
        if (o instanceof Lab$4)
            return new Lab$4(o.l, o.a, o.b, o.opacity);
        if (o instanceof Hcl$4)
            return hcl2lab$3(o);
        if (!(o instanceof Rgb$4))
            o = rgbConvert$4(o);
        var r = rgb2lrgb$3(o.r), g = rgb2lrgb$3(o.g), b = rgb2lrgb$3(o.b), y = xyz2lab$4((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn$4), x, z;
        if (r === g && g === b)
            x = z = y;
        else {
            x = xyz2lab$4((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn$4);
            z = xyz2lab$4((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn$4);
        }
        return new Lab$4(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }
    function lab$5(l, a, b, opacity) {
        return arguments.length === 1 ? labConvert$4(l) : new Lab$4(l, a, b, opacity == null ? 1 : opacity);
    }
    function Lab$4(l, a, b, opacity) {
        this.l = +l;
        this.a = +a;
        this.b = +b;
        this.opacity = +opacity;
    }
    define$4(Lab$4, lab$5, extend$4(Color$4, {
        brighter: function (k) {
            return new Lab$4(this.l + K$3 * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        darker: function (k) {
            return new Lab$4(this.l - K$3 * (k == null ? 1 : k), this.a, this.b, this.opacity);
        },
        rgb: function () {
            var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
            x = Xn$4 * lab2xyz$4(x);
            y = Yn$4 * lab2xyz$4(y);
            z = Zn$4 * lab2xyz$4(z);
            return new Rgb$4(lrgb2rgb$3(3.1338561 * x - 1.6168667 * y - 0.4906146 * z), lrgb2rgb$3(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z), lrgb2rgb$3(0.0719453 * x - 0.2289914 * y + 1.4052427 * z), this.opacity);
        }
    }));
    function xyz2lab$4(t) {
        return t > t3$4 ? Math.pow(t, 1 / 3) : t / t2$4 + t0$8;
    }
    function lab2xyz$4(t) {
        return t > t1$8 ? t * t * t : t2$4 * (t - t0$8);
    }
    function lrgb2rgb$3(x) {
        return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }
    function rgb2lrgb$3(x) {
        return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }
    function hclConvert$4(o) {
        if (o instanceof Hcl$4)
            return new Hcl$4(o.h, o.c, o.l, o.opacity);
        if (!(o instanceof Lab$4))
            o = labConvert$4(o);
        if (o.a === 0 && o.b === 0)
            return new Hcl$4(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
        var h = Math.atan2(o.b, o.a) * rad2deg$4;
        return new Hcl$4(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }
    function hcl$6(h, c, l, opacity) {
        return arguments.length === 1 ? hclConvert$4(h) : new Hcl$4(h, c, l, opacity == null ? 1 : opacity);
    }
    function Hcl$4(h, c, l, opacity) {
        this.h = +h;
        this.c = +c;
        this.l = +l;
        this.opacity = +opacity;
    }
    function hcl2lab$3(o) {
        if (isNaN(o.h))
            return new Lab$4(o.l, 0, 0, o.opacity);
        var h = o.h * deg2rad$4;
        return new Lab$4(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }
    define$4(Hcl$4, hcl$6, extend$4(Color$4, {
        brighter: function (k) {
            return new Hcl$4(this.h, this.c, this.l + K$3 * (k == null ? 1 : k), this.opacity);
        },
        darker: function (k) {
            return new Hcl$4(this.h, this.c, this.l - K$3 * (k == null ? 1 : k), this.opacity);
        },
        rgb: function () {
            return hcl2lab$3(this).rgb();
        }
    }));

    var A$4 = -0.14861, B$4 = +1.78277, C$4 = -0.29227, D$4 = -0.90649, E$4 = +1.97294, ED$4 = E$4 * D$4, EB$4 = E$4 * B$4, BC_DA$4 = B$4 * C$4 - D$4 * A$4;
    function cubehelixConvert$4(o) {
        if (o instanceof Cubehelix$4)
            return new Cubehelix$4(o.h, o.s, o.l, o.opacity);
        if (!(o instanceof Rgb$4))
            o = rgbConvert$4(o);
        var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA$4 * b + ED$4 * r - EB$4 * g) / (BC_DA$4 + ED$4 - EB$4), bl = b - l, k = (E$4 * (g - l) - C$4 * bl) / D$4, s = Math.sqrt(k * k + bl * bl) / (E$4 * l * (1 - l)), // NaN if l=0 or l=1
        h = s ? Math.atan2(k, bl) * rad2deg$4 - 120 : NaN;
        return new Cubehelix$4(h < 0 ? h + 360 : h, s, l, o.opacity);
    }
    function cubehelix$8(h, s, l, opacity) {
        return arguments.length === 1 ? cubehelixConvert$4(h) : new Cubehelix$4(h, s, l, opacity == null ? 1 : opacity);
    }
    function Cubehelix$4(h, s, l, opacity) {
        this.h = +h;
        this.s = +s;
        this.l = +l;
        this.opacity = +opacity;
    }
    define$4(Cubehelix$4, cubehelix$8, extend$4(Color$4, {
        brighter: function (k) {
            k = k == null ? brighter$4 : Math.pow(brighter$4, k);
            return new Cubehelix$4(this.h, this.s, this.l * k, this.opacity);
        },
        darker: function (k) {
            k = k == null ? darker$4 : Math.pow(darker$4, k);
            return new Cubehelix$4(this.h, this.s, this.l * k, this.opacity);
        },
        rgb: function () {
            var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad$4, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh = Math.cos(h), sinh = Math.sin(h);
            return new Rgb$4(255 * (l + a * (A$4 * cosh + B$4 * sinh)), 255 * (l + a * (C$4 * cosh + D$4 * sinh)), 255 * (l + a * (E$4 * cosh)), this.opacity);
        }
    }));

    function constant$i (x) {
        return function () {
            return x;
        };
    }

    function linear$6(a, d) {
        return function (t) {
            return a + t * d;
        };
    }
    function exponential$4(a, b, y) {
        return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
            return Math.pow(a + t * b, y);
        };
    }
    function gamma$3(y) {
        return (y = +y) === 1 ? nogamma$3 : function (a, b) {
            return b - a ? exponential$4(a, b, y) : constant$i(isNaN(a) ? b : a);
        };
    }
    function nogamma$3(a, b) {
        var d = b - a;
        return d ? linear$6(a, d) : constant$i(isNaN(a) ? b : a);
    }

    var interpolateRgb$1 = (function rgbGamma(y) {
        var color = gamma$3(y);
        function rgb(start, end) {
            var r = color((start = rgb$6(start)).r, (end = rgb$6(end)).r), g = color(start.g, end.g), b = color(start.b, end.b), opacity = nogamma$3(start.opacity, end.opacity);
            return function (t) {
                start.r = r(t);
                start.g = g(t);
                start.b = b(t);
                start.opacity = opacity(t);
                return start + "";
            };
        }
        rgb.gamma = rgbGamma;
        return rgb;
    })(1);

    function interpolateNumber$1 (a, b) {
        return a = +a, b = +b, function (t) {
            return a * (1 - t) + b * t;
        };
    }

    var reA$3 = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB$3 = new RegExp(reA$3.source, "g");
    function zero$3(b) {
        return function () {
            return b;
        };
    }
    function one$3(b) {
        return function (t) {
            return b(t) + "";
        };
    }
    function interpolateString$1 (a, b) {
        var bi = reA$3.lastIndex = reB$3.lastIndex = 0, // scan index for next number in b
        am, // current match in a
        bm, // current match in b
        bs, // string preceding current number in b, if any
        i = -1, // index in s
        s = [], // string constants and placeholders
        q = []; // number interpolators
        // Coerce inputs to strings.
        a = a + "", b = b + "";
        // Interpolate pairs of numbers in a & b.
        while ((am = reA$3.exec(a))
            && (bm = reB$3.exec(b))) {
            if ((bs = bm.index) > bi) { // a string precedes the next number in b
                bs = b.slice(bi, bs);
                if (s[i])
                    s[i] += bs; // coalesce with previous string
                else
                    s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
                if (s[i])
                    s[i] += bm; // coalesce with previous string
                else
                    s[++i] = bm;
            }
            else { // interpolate non-matching numbers
                s[++i] = null;
                q.push({ i: i, x: interpolateNumber$1(am, bm) });
            }
            bi = reB$3.lastIndex;
        }
        // Add remains of b.
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
                s[i] += bs; // coalesce with previous string
            else
                s[++i] = bs;
        }
        // Special optimization for only a single match.
        // Otherwise, interpolate each of the numbers and rejoin the string.
        return s.length < 2 ? (q[0]
            ? one$3(q[0].x)
            : zero$3(b))
            : (b = q.length, function (t) {
                for (var i = 0, o; i < b; ++i)
                    s[(o = q[i]).i] = o.x(t);
                return s.join("");
            });
    }

    var degrees$3 = 180 / Math.PI;
    var identity$e = {
        translateX: 0,
        translateY: 0,
        rotate: 0,
        skewX: 0,
        scaleX: 1,
        scaleY: 1
    };
    function decompose$2 (a, b, c, d, e, f) {
        var scaleX, scaleY, skewX;
        if (scaleX = Math.sqrt(a * a + b * b))
            a /= scaleX, b /= scaleX;
        if (skewX = a * c + b * d)
            c -= a * skewX, d -= b * skewX;
        if (scaleY = Math.sqrt(c * c + d * d))
            c /= scaleY, d /= scaleY, skewX /= scaleY;
        if (a * d < b * c)
            a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
        return {
            translateX: e,
            translateY: f,
            rotate: Math.atan2(b, a) * degrees$3,
            skewX: Math.atan(skewX) * degrees$3,
            scaleX: scaleX,
            scaleY: scaleY
        };
    }

    var cssNode$2, cssRoot$2, cssView$2, svgNode$2;
    function parseCss$2(value) {
        if (value === "none")
            return identity$e;
        if (!cssNode$2)
            cssNode$2 = document.createElement("DIV"), cssRoot$2 = document.documentElement, cssView$2 = document.defaultView;
        cssNode$2.style.transform = value;
        value = cssView$2.getComputedStyle(cssRoot$2.appendChild(cssNode$2), null).getPropertyValue("transform");
        cssRoot$2.removeChild(cssNode$2);
        value = value.slice(7, -1).split(",");
        return decompose$2(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
    }
    function parseSvg$2(value) {
        if (value == null)
            return identity$e;
        if (!svgNode$2)
            svgNode$2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
        svgNode$2.setAttribute("transform", value);
        if (!(value = svgNode$2.transform.baseVal.consolidate()))
            return identity$e;
        value = value.matrix;
        return decompose$2(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform$2(parse, pxComma, pxParen, degParen) {
        function pop(s) {
            return s.length ? s.pop() + " " : "";
        }
        function translate(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push("translate(", null, pxComma, null, pxParen);
                q.push({ i: i - 4, x: interpolateNumber$1(xa, xb) }, { i: i - 2, x: interpolateNumber$1(ya, yb) });
            }
            else if (xb || yb) {
                s.push("translate(" + xb + pxComma + yb + pxParen);
            }
        }
        function rotate(a, b, s, q) {
            if (a !== b) {
                if (a - b > 180)
                    b += 360;
                else if (b - a > 180)
                    a += 360; // shortest path
                q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber$1(a, b) });
            }
            else if (b) {
                s.push(pop(s) + "rotate(" + b + degParen);
            }
        }
        function skewX(a, b, s, q) {
            if (a !== b) {
                q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber$1(a, b) });
            }
            else if (b) {
                s.push(pop(s) + "skewX(" + b + degParen);
            }
        }
        function scale(xa, ya, xb, yb, s, q) {
            if (xa !== xb || ya !== yb) {
                var i = s.push(pop(s) + "scale(", null, ",", null, ")");
                q.push({ i: i - 4, x: interpolateNumber$1(xa, xb) }, { i: i - 2, x: interpolateNumber$1(ya, yb) });
            }
            else if (xb !== 1 || yb !== 1) {
                s.push(pop(s) + "scale(" + xb + "," + yb + ")");
            }
        }
        return function (a, b) {
            var s = [], // string constants and placeholders
            q = []; // number interpolators
            a = parse(a), b = parse(b);
            translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
            rotate(a.rotate, b.rotate, s, q);
            skewX(a.skewX, b.skewX, s, q);
            scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
            a = b = null; // gc
            return function (t) {
                var i = -1, n = q.length, o;
                while (++i < n)
                    s[(o = q[i]).i] = o.x(t);
                return s.join("");
            };
        };
    }
    var interpolateTransformCss$2 = interpolateTransform$2(parseCss$2, "px, ", "px)", "deg)");
    var interpolateTransformSvg$2 = interpolateTransform$2(parseSvg$2, ", ", ")", ")");

    function tweenRemove$2(id, name) {
        var tween0, tween1;
        return function () {
            var schedule = set$9(this, id), tween = schedule.tween;
            // If this node shared tween with the previous node,
            // just assign the updated shared tween and we’re done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = tween0 = tween;
                for (var i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1 = tween1.slice();
                        tween1.splice(i, 1);
                        break;
                    }
                }
            }
            schedule.tween = tween1;
        };
    }
    function tweenFunction$2(id, name, value) {
        var tween0, tween1;
        if (typeof value !== "function")
            throw new Error;
        return function () {
            var schedule = set$9(this, id), tween = schedule.tween;
            // If this node shared tween with the previous node,
            // just assign the updated shared tween and we’re done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = (tween0 = tween).slice();
                for (var t = { name: name, value: value }, i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1[i] = t;
                        break;
                    }
                }
                if (i === n)
                    tween1.push(t);
            }
            schedule.tween = tween1;
        };
    }
    function transition_tween$2 (name, value) {
        var id = this._id;
        name += "";
        if (arguments.length < 2) {
            var tween = get$6(this.node(), id).tween;
            for (var i = 0, n = tween.length, t; i < n; ++i) {
                if ((t = tween[i]).name === name) {
                    return t.value;
                }
            }
            return null;
        }
        return this.each((value == null ? tweenRemove$2 : tweenFunction$2)(id, name, value));
    }
    function tweenValue$2(transition, name, value) {
        var id = transition._id;
        transition.each(function () {
            var schedule = set$9(this, id);
            (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
        });
        return function (node) {
            return get$6(node, id).value[name];
        };
    }

    function interpolate$4 (a, b) {
        var c;
        return (typeof b === "number" ? interpolateNumber$1
            : b instanceof color$4 ? interpolateRgb$1
                : (c = color$4(b)) ? (b = c, interpolateRgb$1)
                    : interpolateString$1)(a, b);
    }

    function attrRemove$6(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS$6(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant$6(name, interpolate, value1) {
        var value00, interpolate0;
        return function () {
            var value0 = this.getAttribute(name);
            return value0 === value1 ? null
                : value0 === value00 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value1);
        };
    }
    function attrConstantNS$6(fullname, interpolate, value1) {
        var value00, interpolate0;
        return function () {
            var value0 = this.getAttributeNS(fullname.space, fullname.local);
            return value0 === value1 ? null
                : value0 === value00 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value1);
        };
    }
    function attrFunction$6(name, interpolate, value) {
        var value00, value10, interpolate0;
        return function () {
            var value0, value1 = value(this);
            if (value1 == null)
                return void this.removeAttribute(name);
            value0 = this.getAttribute(name);
            return value0 === value1 ? null
                : value0 === value00 && value1 === value10 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value10 = value1);
        };
    }
    function attrFunctionNS$6(fullname, interpolate, value) {
        var value00, value10, interpolate0;
        return function () {
            var value0, value1 = value(this);
            if (value1 == null)
                return void this.removeAttributeNS(fullname.space, fullname.local);
            value0 = this.getAttributeNS(fullname.space, fullname.local);
            return value0 === value1 ? null
                : value0 === value00 && value1 === value10 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value10 = value1);
        };
    }
    function transition_attr$2 (name, value) {
        var fullname = namespace$3(name), i = fullname === "transform" ? interpolateTransformSvg$2 : interpolate$4;
        return this.attrTween(name, typeof value === "function"
            ? (fullname.local ? attrFunctionNS$6 : attrFunction$6)(fullname, i, tweenValue$2(this, "attr." + name, value))
            : value == null ? (fullname.local ? attrRemoveNS$6 : attrRemove$6)(fullname)
                : (fullname.local ? attrConstantNS$6 : attrConstant$6)(fullname, i, value + ""));
    }

    function attrTweenNS$2(fullname, value) {
        function tween() {
            var node = this, i = value.apply(node, arguments);
            return i && function (t) {
                node.setAttributeNS(fullname.space, fullname.local, i(t));
            };
        }
        tween._value = value;
        return tween;
    }
    function attrTween$2(name, value) {
        function tween() {
            var node = this, i = value.apply(node, arguments);
            return i && function (t) {
                node.setAttribute(name, i(t));
            };
        }
        tween._value = value;
        return tween;
    }
    function transition_attrTween$2 (name, value) {
        var key = "attr." + name;
        if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        var fullname = namespace$3(name);
        return this.tween(key, (fullname.local ? attrTweenNS$2 : attrTween$2)(fullname, value));
    }

    function delayFunction$2(id, value) {
        return function () {
            init$2(this, id).delay = +value.apply(this, arguments);
        };
    }
    function delayConstant$2(id, value) {
        return value = +value, function () {
            init$2(this, id).delay = value;
        };
    }
    function transition_delay$2 (value) {
        var id = this._id;
        return arguments.length
            ? this.each((typeof value === "function"
                ? delayFunction$2
                : delayConstant$2)(id, value))
            : get$6(this.node(), id).delay;
    }

    function durationFunction$2(id, value) {
        return function () {
            set$9(this, id).duration = +value.apply(this, arguments);
        };
    }
    function durationConstant$2(id, value) {
        return value = +value, function () {
            set$9(this, id).duration = value;
        };
    }
    function transition_duration$2 (value) {
        var id = this._id;
        return arguments.length
            ? this.each((typeof value === "function"
                ? durationFunction$2
                : durationConstant$2)(id, value))
            : get$6(this.node(), id).duration;
    }

    function easeConstant$2(id, value) {
        if (typeof value !== "function")
            throw new Error;
        return function () {
            set$9(this, id).ease = value;
        };
    }
    function transition_ease$2 (value) {
        var id = this._id;
        return arguments.length
            ? this.each(easeConstant$2(id, value))
            : get$6(this.node(), id).ease;
    }

    function transition_filter$2 (match) {
        if (typeof match !== "function")
            match = matcher$4(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Transition$2(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge$2 (transition) {
        if (transition._id !== this._id)
            throw new Error;
        for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Transition$2(merges, this._parents, this._name, this._id);
    }

    function start$3(name) {
        return (name + "").trim().split(/^|\s+/).every(function (t) {
            var i = t.indexOf(".");
            if (i >= 0)
                t = t.slice(0, i);
            return !t || t === "start";
        });
    }
    function onFunction$2(id, name, listener) {
        var on0, on1, sit = start$3(name) ? init$2 : set$9;
        return function () {
            var schedule = sit(this, id), on = schedule.on;
            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and we’re done!
            // Otherwise, copy-on-write.
            if (on !== on0)
                (on1 = (on0 = on).copy()).on(name, listener);
            schedule.on = on1;
        };
    }
    function transition_on$2 (name, listener) {
        var id = this._id;
        return arguments.length < 2
            ? get$6(this.node(), id).on.on(name)
            : this.each(onFunction$2(id, name, listener));
    }

    function removeFunction$2(id) {
        return function () {
            var parent = this.parentNode;
            for (var i in this.__transition)
                if (+i !== id)
                    return;
            if (parent)
                parent.removeChild(this);
        };
    }
    function transition_remove$2 () {
        return this.on("end.remove", removeFunction$2(this._id));
    }

    function transition_select$2 (select) {
        var name = this._name, id = this._id;
        if (typeof select !== "function")
            select = selector$3(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                    schedule$2(subgroup[i], name, id, i, subgroup, get$6(node, id));
                }
            }
        }
        return new Transition$2(subgroups, this._parents, name, id);
    }

    function transition_selectAll$2 (select) {
        var name = this._name, id = this._id;
        if (typeof select !== "function")
            select = selectorAll$3(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    for (var children = select.call(node, node.__data__, i, group), child, inherit = get$6(node, id), k = 0, l = children.length; k < l; ++k) {
                        if (child = children[k]) {
                            schedule$2(child, name, id, k, children, inherit);
                        }
                    }
                    subgroups.push(children);
                    parents.push(node);
                }
            }
        }
        return new Transition$2(subgroups, parents, name, id);
    }

    var Selection$6 = selection$3.prototype.constructor;
    function transition_selection$2 () {
        return new Selection$6(this._groups, this._parents);
    }

    function styleRemove$6(name, interpolate) {
        var value00, value10, interpolate0;
        return function () {
            var value0 = styleValue$3(this, name), value1 = (this.style.removeProperty(name), styleValue$3(this, name));
            return value0 === value1 ? null
                : value0 === value00 && value1 === value10 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value10 = value1);
        };
    }
    function styleRemoveEnd$1(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant$6(name, interpolate, value1) {
        var value00, interpolate0;
        return function () {
            var value0 = styleValue$3(this, name);
            return value0 === value1 ? null
                : value0 === value00 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value1);
        };
    }
    function styleFunction$6(name, interpolate, value) {
        var value00, value10, interpolate0;
        return function () {
            var value0 = styleValue$3(this, name), value1 = value(this);
            if (value1 == null)
                value1 = (this.style.removeProperty(name), styleValue$3(this, name));
            return value0 === value1 ? null
                : value0 === value00 && value1 === value10 ? interpolate0
                    : interpolate0 = interpolate(value00 = value0, value10 = value1);
        };
    }
    function transition_style$2 (name, value, priority) {
        var i = (name += "") === "transform" ? interpolateTransformCss$2 : interpolate$4;
        return value == null ? this
            .styleTween(name, styleRemove$6(name, i))
            .on("end.style." + name, styleRemoveEnd$1(name))
            : this.styleTween(name, typeof value === "function"
                ? styleFunction$6(name, i, tweenValue$2(this, "style." + name, value))
                : styleConstant$6(name, i, value + ""), priority);
    }

    function styleTween$2(name, value, priority) {
        function tween() {
            var node = this, i = value.apply(node, arguments);
            return i && function (t) {
                node.style.setProperty(name, i(t), priority);
            };
        }
        tween._value = value;
        return tween;
    }
    function transition_styleTween$2 (name, value, priority) {
        var key = "style." + (name += "");
        if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        return this.tween(key, styleTween$2(name, value, priority == null ? "" : priority));
    }

    function textConstant$6(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction$6(value) {
        return function () {
            var value1 = value(this);
            this.textContent = value1 == null ? "" : value1;
        };
    }
    function transition_text$2 (value) {
        return this.tween("text", typeof value === "function"
            ? textFunction$6(tweenValue$2(this, "text", value))
            : textConstant$6(value == null ? "" : value + ""));
    }

    function transition_transition$2 () {
        var name = this._name, id0 = this._id, id1 = newId$2();
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    var inherit = get$6(node, id0);
                    schedule$2(node, name, id1, i, group, {
                        time: inherit.time + inherit.delay + inherit.duration,
                        delay: 0,
                        duration: inherit.duration,
                        ease: inherit.ease
                    });
                }
            }
        }
        return new Transition$2(groups, this._parents, name, id1);
    }

    var id$2 = 0;
    function Transition$2(groups, parents, name, id) {
        this._groups = groups;
        this._parents = parents;
        this._name = name;
        this._id = id;
    }
    function transition$2(name) {
        return selection$3().transition(name);
    }
    function newId$2() {
        return ++id$2;
    }
    var selection_prototype$2 = selection$3.prototype;
    Transition$2.prototype = transition$2.prototype = {
        constructor: Transition$2,
        select: transition_select$2,
        selectAll: transition_selectAll$2,
        filter: transition_filter$2,
        merge: transition_merge$2,
        selection: transition_selection$2,
        transition: transition_transition$2,
        call: selection_prototype$2.call,
        nodes: selection_prototype$2.nodes,
        node: selection_prototype$2.node,
        size: selection_prototype$2.size,
        empty: selection_prototype$2.empty,
        each: selection_prototype$2.each,
        on: transition_on$2,
        attr: transition_attr$2,
        attrTween: transition_attrTween$2,
        style: transition_style$2,
        styleTween: transition_styleTween$2,
        text: transition_text$2,
        remove: transition_remove$2,
        tween: transition_tween$2,
        delay: transition_delay$2,
        duration: transition_duration$2,
        ease: transition_ease$2
    };

    function cubicInOut$2(t) {
        return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var defaultTiming$2 = {
        time: null,
        delay: 0,
        duration: 250,
        ease: cubicInOut$2
    };
    function inherit$2(node, id) {
        var timing;
        while (!(timing = node.__transition) || !(timing = timing[id])) {
            if (!(node = node.parentNode)) {
                return defaultTiming$2.time = now$2(), defaultTiming$2;
            }
        }
        return timing;
    }
    function selection_transition$2 (name) {
        var id, timing;
        if (name instanceof Transition$2) {
            id = name._id, name = name._name;
        }
        else {
            id = newId$2(), (timing = defaultTiming$2).time = now$2(), name = name == null ? null : name + "";
        }
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    schedule$2(node, name, id, i, group, timing || inherit$2(node, id));
                }
            }
        }
        return new Transition$2(groups, this._parents, name, id);
    }

    selection$3.prototype.interrupt = selection_interrupt$2;
    selection$3.prototype.transition = selection_transition$2;

    var root$4 = [null];
    function active (node, name) {
        var schedules = node.__transition, schedule, i;
        if (schedules) {
            name = name == null ? null : name + "";
            for (i in schedules) {
                if ((schedule = schedules[i]).state > SCHEDULED$2 && schedule.name === name) {
                    return new Transition$2([[node]], root$4, name, +i);
                }
            }
        }
        return null;
    }

    function constant$j (x) {
        return function () {
            return x;
        };
    }

    function x$6(d) {
        return d[0];
    }
    function y$5(d) {
        return d[1];
    }

    function RedBlackTree() {
        this._ = null; // root node
    }
    function RedBlackNode(node) {
        node.U = // parent node
            node.C = // color - true for red, false for black
                node.L = // left node
                    node.R = // right node
                        node.P = // previous node
                            node.N = null; // next node
    }
    RedBlackTree.prototype = {
        constructor: RedBlackTree,
        insert: function (after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N)
                    after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while (after.L)
                        after = after.L;
                    after.L = node;
                }
                else {
                    after.R = node;
                }
                parent = after;
            }
            else if (this._) {
                after = RedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            }
            else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    }
                    else {
                        if (after === parent.R) {
                            RedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        RedBlackRotateRight(this, grandpa);
                    }
                }
                else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    }
                    else {
                        if (after === parent.L) {
                            RedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        RedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function (node) {
            if (node.N)
                node.N.P = node.P;
            if (node.P)
                node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left)
                next = right;
            else if (!right)
                next = left;
            else
                next = RedBlackFirst(right);
            if (parent) {
                if (parent.L === node)
                    parent.L = next;
                else
                    parent.R = next;
            }
            else {
                this._ = next;
            }
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                }
                else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            }
            else {
                red = node.C;
                node = next;
            }
            if (node)
                node.U = parent;
            if (red)
                return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._)
                    break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        RedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if ((sibling.L && sibling.L.C)
                        || (sibling.R && sibling.R.C)) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            RedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        RedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                }
                else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        RedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if ((sibling.L && sibling.L.C)
                        || (sibling.R && sibling.R.C)) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            RedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        RedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            } while (!node.C);
            if (node)
                node.C = false;
        }
    };
    function RedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        }
        else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
            p.R.U = p;
        q.L = p;
    }
    function RedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        }
        else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
            p.L.U = p;
        q.R = p;
    }
    function RedBlackFirst(node) {
        while (node.L)
            node = node.L;
        return node;
    }

    function createEdge(left, right, v0, v1) {
        var edge = [null, null], index = edges.push(edge) - 1;
        edge.left = left;
        edge.right = right;
        if (v0)
            setEdgeEnd(edge, left, right, v0);
        if (v1)
            setEdgeEnd(edge, right, left, v1);
        cells[left.index].halfedges.push(index);
        cells[right.index].halfedges.push(index);
        return edge;
    }
    function createBorderEdge(left, v0, v1) {
        var edge = [v0, v1];
        edge.left = left;
        return edge;
    }
    function setEdgeEnd(edge, left, right, vertex) {
        if (!edge[0] && !edge[1]) {
            edge[0] = vertex;
            edge.left = left;
            edge.right = right;
        }
        else if (edge.left === right) {
            edge[1] = vertex;
        }
        else {
            edge[0] = vertex;
        }
    }
    // Liang–Barsky line clipping.
    function clipEdge(edge, x0, y0, x1, y1) {
        var a = edge[0], b = edge[1], ax = a[0], ay = a[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
        r = x0 - ax;
        if (!dx && r > 0)
            return;
        r /= dx;
        if (dx < 0) {
            if (r < t0)
                return;
            if (r < t1)
                t1 = r;
        }
        else if (dx > 0) {
            if (r > t1)
                return;
            if (r > t0)
                t0 = r;
        }
        r = x1 - ax;
        if (!dx && r < 0)
            return;
        r /= dx;
        if (dx < 0) {
            if (r > t1)
                return;
            if (r > t0)
                t0 = r;
        }
        else if (dx > 0) {
            if (r < t0)
                return;
            if (r < t1)
                t1 = r;
        }
        r = y0 - ay;
        if (!dy && r > 0)
            return;
        r /= dy;
        if (dy < 0) {
            if (r < t0)
                return;
            if (r < t1)
                t1 = r;
        }
        else if (dy > 0) {
            if (r > t1)
                return;
            if (r > t0)
                t0 = r;
        }
        r = y1 - ay;
        if (!dy && r < 0)
            return;
        r /= dy;
        if (dy < 0) {
            if (r > t1)
                return;
            if (r > t0)
                t0 = r;
        }
        else if (dy > 0) {
            if (r < t0)
                return;
            if (r < t1)
                t1 = r;
        }
        if (!(t0 > 0) && !(t1 < 1))
            return true; // TODO Better check?
        if (t0 > 0)
            edge[0] = [ax + t0 * dx, ay + t0 * dy];
        if (t1 < 1)
            edge[1] = [ax + t1 * dx, ay + t1 * dy];
        return true;
    }
    function connectEdge(edge, x0, y0, x1, y1) {
        var v1 = edge[1];
        if (v1)
            return true;
        var v0 = edge[0], left = edge.left, right = edge.right, lx = left[0], ly = left[1], rx = right[0], ry = right[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1)
                return;
            if (lx > rx) {
                if (!v0)
                    v0 = [fx, y0];
                else if (v0[1] >= y1)
                    return;
                v1 = [fx, y1];
            }
            else {
                if (!v0)
                    v0 = [fx, y1];
                else if (v0[1] < y0)
                    return;
                v1 = [fx, y0];
            }
        }
        else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!v0)
                        v0 = [(y0 - fb) / fm, y0];
                    else if (v0[1] >= y1)
                        return;
                    v1 = [(y1 - fb) / fm, y1];
                }
                else {
                    if (!v0)
                        v0 = [(y1 - fb) / fm, y1];
                    else if (v0[1] < y0)
                        return;
                    v1 = [(y0 - fb) / fm, y0];
                }
            }
            else {
                if (ly < ry) {
                    if (!v0)
                        v0 = [x0, fm * x0 + fb];
                    else if (v0[0] >= x1)
                        return;
                    v1 = [x1, fm * x1 + fb];
                }
                else {
                    if (!v0)
                        v0 = [x1, fm * x1 + fb];
                    else if (v0[0] < x0)
                        return;
                    v1 = [x0, fm * x0 + fb];
                }
            }
        }
        edge[0] = v0;
        edge[1] = v1;
        return true;
    }
    function clipEdges(x0, y0, x1, y1) {
        var i = edges.length, edge;
        while (i--) {
            if (!connectEdge(edge = edges[i], x0, y0, x1, y1)
                || !clipEdge(edge, x0, y0, x1, y1)
                || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon$8
                    || Math.abs(edge[0][1] - edge[1][1]) > epsilon$8)) {
                delete edges[i];
            }
        }
    }

    function createCell(site) {
        return cells[site.index] = {
            site: site,
            halfedges: []
        };
    }
    function cellHalfedgeAngle(cell, edge) {
        var site = cell.site, va = edge.left, vb = edge.right;
        if (site === vb)
            vb = va, va = site;
        if (vb)
            return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
        if (site === va)
            va = edge[1], vb = edge[0];
        else
            va = edge[0], vb = edge[1];
        return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
    }
    function cellHalfedgeStart(cell, edge) {
        return edge[+(edge.left !== cell.site)];
    }
    function cellHalfedgeEnd(cell, edge) {
        return edge[+(edge.left === cell.site)];
    }
    function sortCellHalfedges() {
        for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
            if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
                var index = new Array(m), array = new Array(m);
                for (j = 0; j < m; ++j)
                    index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);
                index.sort(function (i, j) { return array[j] - array[i]; });
                for (j = 0; j < m; ++j)
                    array[j] = halfedges[index[j]];
                for (j = 0; j < m; ++j)
                    halfedges[j] = array[j];
            }
        }
    }
    function clipCells(x0, y0, x1, y1) {
        var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start, startX, startY, end, endX, endY, cover = true;
        for (iCell = 0; iCell < nCells; ++iCell) {
            if (cell = cells[iCell]) {
                site = cell.site;
                halfedges = cell.halfedges;
                iHalfedge = halfedges.length;
                // Remove any dangling clipped edges.
                while (iHalfedge--) {
                    if (!edges[halfedges[iHalfedge]]) {
                        halfedges.splice(iHalfedge, 1);
                    }
                }
                // Insert any border edges as necessary.
                iHalfedge = 0, nHalfedges = halfedges.length;
                while (iHalfedge < nHalfedges) {
                    end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
                    start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];
                    if (Math.abs(endX - startX) > epsilon$8 || Math.abs(endY - startY) > epsilon$8) {
                        halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end, Math.abs(endX - x0) < epsilon$8 && y1 - endY > epsilon$8 ? [x0, Math.abs(startX - x0) < epsilon$8 ? startY : y1]
                            : Math.abs(endY - y1) < epsilon$8 && x1 - endX > epsilon$8 ? [Math.abs(startY - y1) < epsilon$8 ? startX : x1, y1]
                                : Math.abs(endX - x1) < epsilon$8 && endY - y0 > epsilon$8 ? [x1, Math.abs(startX - x1) < epsilon$8 ? startY : y0]
                                    : Math.abs(endY - y0) < epsilon$8 && endX - x0 > epsilon$8 ? [Math.abs(startY - y0) < epsilon$8 ? startX : x0, y0]
                                        : null)) - 1);
                        ++nHalfedges;
                    }
                }
                if (nHalfedges)
                    cover = false;
            }
        }
        // If there weren’t any edges, have the closest site cover the extent.
        // It doesn’t matter which corner of the extent we measure!
        if (cover) {
            var dx, dy, d2, dc = Infinity;
            for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
                if (cell = cells[iCell]) {
                    site = cell.site;
                    dx = site[0] - x0;
                    dy = site[1] - y0;
                    d2 = dx * dx + dy * dy;
                    if (d2 < dc)
                        dc = d2, cover = cell;
                }
            }
            if (cover) {
                var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];
                cover.halfedges.push(edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1, edges.push(createBorderEdge(site, v01, v11)) - 1, edges.push(createBorderEdge(site, v11, v10)) - 1, edges.push(createBorderEdge(site, v10, v00)) - 1);
            }
        }
        // Lastly delete any cells with no edges; these were entirely clipped.
        for (iCell = 0; iCell < nCells; ++iCell) {
            if (cell = cells[iCell]) {
                if (!cell.halfedges.length) {
                    delete cells[iCell];
                }
            }
        }
    }

    var circlePool = [];
    var firstCircle;
    function Circle() {
        RedBlackNode(this);
        this.x =
            this.y =
                this.arc =
                    this.site =
                        this.cy = null;
    }
    function attachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc)
            return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite)
            return;
        var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -epsilon2$3)
            return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d;
        var circle = circlePool.pop() || new Circle;
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom
        arc.circle = circle;
        var before = null, node = circles._;
        while (node) {
            if (circle.y < node.y || (circle.y === node.y && circle.x <= node.x)) {
                if (node.L)
                    node = node.L;
                else {
                    before = node.P;
                    break;
                }
            }
            else {
                if (node.R)
                    node = node.R;
                else {
                    before = node;
                    break;
                }
            }
        }
        circles.insert(before, circle);
        if (!before)
            firstCircle = circle;
    }
    function detachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P)
                firstCircle = circle.N;
            circles.remove(circle);
            circlePool.push(circle);
            RedBlackNode(circle);
            arc.circle = null;
        }
    }

    var beachPool = [];
    function Beach() {
        RedBlackNode(this);
        this.edge =
            this.site =
                this.circle = null;
    }
    function createBeach(site) {
        var beach = beachPool.pop() || new Beach;
        beach.site = site;
        return beach;
    }
    function detachBeach(beach) {
        detachCircle(beach);
        beaches.remove(beach);
        beachPool.push(beach);
        RedBlackNode(beach);
    }
    function removeBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = [x, y], previous = beach.P, next = beach.N, disappearing = [beach];
        detachBeach(beach);
        var lArc = previous;
        while (lArc.circle
            && Math.abs(x - lArc.circle.x) < epsilon$8
            && Math.abs(y - lArc.circle.cy) < epsilon$8) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            detachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        detachCircle(lArc);
        var rArc = next;
        while (rArc.circle
            && Math.abs(x - rArc.circle.x) < epsilon$8
            && Math.abs(y - rArc.circle.cy) < epsilon$8) {
            next = rArc.N;
            disappearing.push(rArc);
            detachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        detachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
        attachCircle(lArc);
        attachCircle(rArc);
    }
    function addBeach(site) {
        var x = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node = beaches._;
        while (node) {
            dxl = leftBreakPoint(node, directrix) - x;
            if (dxl > epsilon$8)
                node = node.L;
            else {
                dxr = x - rightBreakPoint(node, directrix);
                if (dxr > epsilon$8) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                }
                else {
                    if (dxl > -epsilon$8) {
                        lArc = node.P;
                        rArc = node;
                    }
                    else if (dxr > -epsilon$8) {
                        lArc = node;
                        rArc = node.N;
                    }
                    else {
                        lArc = rArc = node;
                    }
                    break;
                }
            }
        }
        createCell(site);
        var newArc = createBeach(site);
        beaches.insert(lArc, newArc);
        if (!lArc && !rArc)
            return;
        if (lArc === rArc) {
            detachCircle(lArc);
            rArc = createBeach(lArc.site);
            beaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
            attachCircle(lArc);
            attachCircle(rArc);
            return;
        }
        if (!rArc) { // && lArc
            newArc.edge = createEdge(lArc.site, newArc.site);
            return;
        }
        // else lArc !== rArc
        detachCircle(lArc);
        detachCircle(rArc);
        var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
        setEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = createEdge(lSite, site, null, vertex);
        rArc.edge = createEdge(site, rSite, null, vertex);
        attachCircle(lArc);
        attachCircle(rArc);
    }
    function leftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
        if (!pby2)
            return rfocx;
        var lArc = arc.P;
        if (!lArc)
            return -Infinity;
        site = lArc.site;
        var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
        if (!plby2)
            return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2)
            return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function rightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
            return leftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site[1] === directrix ? site[0] : Infinity;
    }

    var epsilon$8 = 1e-6;
    var epsilon2$3 = 1e-12;
    var beaches;
    var cells;
    var circles;
    var edges;
    function triangleArea(a, b, c) {
        return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
    }
    function lexicographic(a, b) {
        return b[1] - a[1]
            || b[0] - a[0];
    }
    function Diagram(sites, extent) {
        var site = sites.sort(lexicographic).pop(), x, y, circle;
        edges = [];
        cells = new Array(sites.length);
        beaches = new RedBlackTree;
        circles = new RedBlackTree;
        while (true) {
            circle = firstCircle;
            if (site && (!circle || site[1] < circle.y || (site[1] === circle.y && site[0] < circle.x))) {
                if (site[0] !== x || site[1] !== y) {
                    addBeach(site);
                    x = site[0], y = site[1];
                }
                site = sites.pop();
            }
            else if (circle) {
                removeBeach(circle.arc);
            }
            else {
                break;
            }
        }
        sortCellHalfedges();
        if (extent) {
            var x0 = +extent[0][0], y0 = +extent[0][1], x1 = +extent[1][0], y1 = +extent[1][1];
            clipEdges(x0, y0, x1, y1);
            clipCells(x0, y0, x1, y1);
        }
        this.edges = edges;
        this.cells = cells;
        beaches =
            circles =
                edges =
                    cells = null;
    }
    Diagram.prototype = {
        constructor: Diagram,
        polygons: function () {
            var edges = this.edges;
            return this.cells.map(function (cell) {
                var polygon = cell.halfedges.map(function (i) { return cellHalfedgeStart(cell, edges[i]); });
                polygon.data = cell.site.data;
                return polygon;
            });
        },
        triangles: function () {
            var triangles = [], edges = this.edges;
            this.cells.forEach(function (cell, i) {
                if (!(m = (halfedges = cell.halfedges).length))
                    return;
                var site = cell.site, halfedges, j = -1, m, s0, e1 = edges[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
                while (++j < m) {
                    s0 = s1;
                    e1 = edges[halfedges[j]];
                    s1 = e1.left === site ? e1.right : e1.left;
                    if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
                        triangles.push([site.data, s0.data, s1.data]);
                    }
                }
            });
            return triangles;
        },
        links: function () {
            return this.edges.filter(function (edge) {
                return edge.right;
            }).map(function (edge) {
                return {
                    source: edge.left.data,
                    target: edge.right.data
                };
            });
        },
        find: function (x, y, radius) {
            var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
            // Use the previously-found cell, or start with an arbitrary one.
            while (!(cell = that.cells[i1]))
                if (++i1 >= n)
                    return null;
            var dx = x - cell.site[0], dy = y - cell.site[1], d2 = dx * dx + dy * dy;
            // Traverse the half-edges to find a closer cell, if any.
            do {
                cell = that.cells[i0 = i1], i1 = null;
                cell.halfedges.forEach(function (e) {
                    var edge = that.edges[e], v = edge.left;
                    if ((v === cell.site || !v) && !(v = edge.right))
                        return;
                    var vx = x - v[0], vy = y - v[1], v2 = vx * vx + vy * vy;
                    if (v2 < d2)
                        d2 = v2, i1 = v.index;
                });
            } while (i1 !== null);
            that._found = i0;
            return radius == null || d2 <= radius * radius ? cell.site : null;
        }
    };

    function voronoi () {
        var x = x$6, y = y$5, extent = null;
        function voronoi(data) {
            return new Diagram(data.map(function (d, i) {
                var s = [Math.round(x(d, i, data) / epsilon$8) * epsilon$8, Math.round(y(d, i, data) / epsilon$8) * epsilon$8];
                s.index = i;
                s.data = d;
                return s;
            }), extent);
        }
        voronoi.polygons = function (data) {
            return voronoi(data).polygons();
        };
        voronoi.links = function (data) {
            return voronoi(data).links();
        };
        voronoi.triangles = function (data) {
            return voronoi(data).triangles();
        };
        voronoi.x = function (_) {
            return arguments.length ? (x = typeof _ === "function" ? _ : constant$j(+_), voronoi) : x;
        };
        voronoi.y = function (_) {
            return arguments.length ? (y = typeof _ === "function" ? _ : constant$j(+_), voronoi) : y;
        };
        voronoi.extent = function (_) {
            return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
        };
        voronoi.size = function (_) {
            return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
        };
        return voronoi;
    }

    var emptyOn$3 = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween$3 = [];
    var CREATED$3 = 0;
    var SCHEDULED$3 = 1;
    var STARTING$3 = 2;
    var STARTED$3 = 3;
    var RUNNING$3 = 4;
    var ENDING$3 = 5;
    var ENDED$3 = 6;
    function schedule$3 (node, name, id, index, group, timing) {
        var schedules = node.__transition;
        if (!schedules)
            node.__transition = {};
        else if (id in schedules)
            return;
        create$4(node, id, {
            name: name,
            index: index,
            group: group,
            on: emptyOn$3,
            tween: emptyTween$3,
            time: timing.time,
            delay: timing.delay,
            duration: timing.duration,
            ease: timing.ease,
            timer: null,
            state: CREATED$3
        });
    }
    function init$3(node, id) {
        var schedule = get$7(node, id);
        if (schedule.state > CREATED$3)
            throw new Error("too late; already scheduled");
        return schedule;
    }
    function set$a(node, id) {
        var schedule = get$7(node, id);
        if (schedule.state > STARTED$3)
            throw new Error("too late; already running");
        return schedule;
    }
    function get$7(node, id) {
        var schedule = node.__transition;
        if (!schedule || !(schedule = schedule[id]))
            throw new Error("transition not found");
        return schedule;
    }
    function create$4(node, id, self) {
        var schedules = node.__transition, tween;
        // Initialize the self timer when the transition is created.
        // Note the actual delay is not known until the first callback!
        schedules[id] = self;
        self.timer = timer(schedule, 0, self.time);
        function schedule(elapsed) {
            self.state = SCHEDULED$3;
            self.timer.restart(start, self.delay, self.time);
            // If the elapsed delay is less than our first sleep, start immediately.
            if (self.delay <= elapsed)
                start(elapsed - self.delay);
        }
        function start(elapsed) {
            var i, j, n, o;
            // If the state is not SCHEDULED, then we previously errored on start.
            if (self.state !== SCHEDULED$3)
                return stop();
            for (i in schedules) {
                o = schedules[i];
                if (o.name !== self.name)
                    continue;
                // While this element already has a starting transition during this frame,
                // defer starting an interrupting transition until that transition has a
                // chance to tick (and possibly end); see d3/d3-transition#54!
                if (o.state === STARTED$3)
                    return timeout$1(start);
                // Interrupt the active transition, if any.
                if (o.state === RUNNING$3) {
                    o.state = ENDED$3;
                    o.timer.stop();
                    o.on.call("interrupt", node, node.__data__, o.index, o.group);
                    delete schedules[i];
                }
                // Cancel any pre-empted transitions.
                else if (+i < id) {
                    o.state = ENDED$3;
                    o.timer.stop();
                    o.on.call("cancel", node, node.__data__, o.index, o.group);
                    delete schedules[i];
                }
            }
            // Defer the first tick to end of the current frame; see d3/d3#1576.
            // Note the transition may be canceled after start and before the first tick!
            // Note this must be scheduled before the start event; see d3/d3-transition#16!
            // Assuming this is successful, subsequent callbacks go straight to tick.
            timeout$1(function () {
                if (self.state === STARTED$3) {
                    self.state = RUNNING$3;
                    self.timer.restart(tick, self.delay, self.time);
                    tick(elapsed);
                }
            });
            // Dispatch the start event.
            // Note this must be done before the tween are initialized.
            self.state = STARTING$3;
            self.on.call("start", node, node.__data__, self.index, self.group);
            if (self.state !== STARTING$3)
                return; // interrupted
            self.state = STARTED$3;
            // Initialize the tween, deleting null tween.
            tween = new Array(n = self.tween.length);
            for (i = 0, j = -1; i < n; ++i) {
                if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
                    tween[++j] = o;
                }
            }
            tween.length = j + 1;
        }
        function tick(elapsed) {
            var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING$3, 1), i = -1, n = tween.length;
            while (++i < n) {
                tween[i].call(node, t);
            }
            // Dispatch the end event.
            if (self.state === ENDING$3) {
                self.on.call("end", node, node.__data__, self.index, self.group);
                stop();
            }
        }
        function stop() {
            self.state = ENDED$3;
            self.timer.stop();
            delete schedules[id];
            for (var i in schedules)
                return; // eslint-disable-line no-unused-vars
            delete node.__transition;
        }
    }

    function interrupt$3 (node, name) {
        var schedules = node.__transition, schedule, active, empty = true, i;
        if (!schedules)
            return;
        name = name == null ? null : name + "";
        for (i in schedules) {
            if ((schedule = schedules[i]).name !== name) {
                empty = false;
                continue;
            }
            active = schedule.state > STARTING$3 && schedule.state < ENDING$3;
            schedule.state = ENDED$3;
            schedule.timer.stop();
            schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
            delete schedules[i];
        }
        if (empty)
            delete node.__transition;
    }

    function selection_interrupt$3 (name) {
        return this.each(function () {
            interrupt$3(this, name);
        });
    }

    function tweenRemove$3(id, name) {
        var tween0, tween1;
        return function () {
            var schedule = set$a(this, id), tween = schedule.tween;
            // If this node shared tween with the previous node,
            // just assign the updated shared tween and we’re done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = tween0 = tween;
                for (var i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1 = tween1.slice();
                        tween1.splice(i, 1);
                        break;
                    }
                }
            }
            schedule.tween = tween1;
        };
    }
    function tweenFunction$3(id, name, value) {
        var tween0, tween1;
        if (typeof value !== "function")
            throw new Error;
        return function () {
            var schedule = set$a(this, id), tween = schedule.tween;
            // If this node shared tween with the previous node,
            // just assign the updated shared tween and we’re done!
            // Otherwise, copy-on-write.
            if (tween !== tween0) {
                tween1 = (tween0 = tween).slice();
                for (var t = { name: name, value: value }, i = 0, n = tween1.length; i < n; ++i) {
                    if (tween1[i].name === name) {
                        tween1[i] = t;
                        break;
                    }
                }
                if (i === n)
                    tween1.push(t);
            }
            schedule.tween = tween1;
        };
    }
    function transition_tween$3 (name, value) {
        var id = this._id;
        name += "";
        if (arguments.length < 2) {
            var tween = get$7(this.node(), id).tween;
            for (var i = 0, n = tween.length, t; i < n; ++i) {
                if ((t = tween[i]).name === name) {
                    return t.value;
                }
            }
            return null;
        }
        return this.each((value == null ? tweenRemove$3 : tweenFunction$3)(id, name, value));
    }
    function tweenValue$3(transition, name, value) {
        var id = transition._id;
        transition.each(function () {
            var schedule = set$a(this, id);
            (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
        });
        return function (node) {
            return get$7(node, id).value[name];
        };
    }

    function interpolate$5 (a, b) {
        var c;
        return (typeof b === "number" ? interpolateNumber
            : b instanceof color ? interpolateRgb
                : (c = color(b)) ? (b = c, interpolateRgb)
                    : interpolateString)(a, b);
    }

    function attrRemove$7(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS$7(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant$7(name, interpolate, value1) {
        var string00, string1 = value1 + "", interpolate0;
        return function () {
            var string0 = this.getAttribute(name);
            return string0 === string1 ? null
                : string0 === string00 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, value1);
        };
    }
    function attrConstantNS$7(fullname, interpolate, value1) {
        var string00, string1 = value1 + "", interpolate0;
        return function () {
            var string0 = this.getAttributeNS(fullname.space, fullname.local);
            return string0 === string1 ? null
                : string0 === string00 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, value1);
        };
    }
    function attrFunction$7(name, interpolate, value) {
        var string00, string10, interpolate0;
        return function () {
            var string0, value1 = value(this), string1;
            if (value1 == null)
                return void this.removeAttribute(name);
            string0 = this.getAttribute(name);
            string1 = value1 + "";
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
    }
    function attrFunctionNS$7(fullname, interpolate, value) {
        var string00, string10, interpolate0;
        return function () {
            var string0, value1 = value(this), string1;
            if (value1 == null)
                return void this.removeAttributeNS(fullname.space, fullname.local);
            string0 = this.getAttributeNS(fullname.space, fullname.local);
            string1 = value1 + "";
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
    }
    function transition_attr$3 (name, value) {
        var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$5;
        return this.attrTween(name, typeof value === "function"
            ? (fullname.local ? attrFunctionNS$7 : attrFunction$7)(fullname, i, tweenValue$3(this, "attr." + name, value))
            : value == null ? (fullname.local ? attrRemoveNS$7 : attrRemove$7)(fullname)
                : (fullname.local ? attrConstantNS$7 : attrConstant$7)(fullname, i, value));
    }

    function attrInterpolate$1(name, i) {
        return function (t) {
            this.setAttribute(name, i.call(this, t));
        };
    }
    function attrInterpolateNS$1(fullname, i) {
        return function (t) {
            this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
        };
    }
    function attrTweenNS$3(fullname, value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
                t0 = (i0 = i) && attrInterpolateNS$1(fullname, i);
            return t0;
        }
        tween._value = value;
        return tween;
    }
    function attrTween$3(name, value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
                t0 = (i0 = i) && attrInterpolate$1(name, i);
            return t0;
        }
        tween._value = value;
        return tween;
    }
    function transition_attrTween$3 (name, value) {
        var key = "attr." + name;
        if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        var fullname = namespace(name);
        return this.tween(key, (fullname.local ? attrTweenNS$3 : attrTween$3)(fullname, value));
    }

    function delayFunction$3(id, value) {
        return function () {
            init$3(this, id).delay = +value.apply(this, arguments);
        };
    }
    function delayConstant$3(id, value) {
        return value = +value, function () {
            init$3(this, id).delay = value;
        };
    }
    function transition_delay$3 (value) {
        var id = this._id;
        return arguments.length
            ? this.each((typeof value === "function"
                ? delayFunction$3
                : delayConstant$3)(id, value))
            : get$7(this.node(), id).delay;
    }

    function durationFunction$3(id, value) {
        return function () {
            set$a(this, id).duration = +value.apply(this, arguments);
        };
    }
    function durationConstant$3(id, value) {
        return value = +value, function () {
            set$a(this, id).duration = value;
        };
    }
    function transition_duration$3 (value) {
        var id = this._id;
        return arguments.length
            ? this.each((typeof value === "function"
                ? durationFunction$3
                : durationConstant$3)(id, value))
            : get$7(this.node(), id).duration;
    }

    function easeConstant$3(id, value) {
        if (typeof value !== "function")
            throw new Error;
        return function () {
            set$a(this, id).ease = value;
        };
    }
    function transition_ease$3 (value) {
        var id = this._id;
        return arguments.length
            ? this.each(easeConstant$3(id, value))
            : get$7(this.node(), id).ease;
    }

    function transition_filter$3 (match) {
        if (typeof match !== "function")
            match = matcher(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Transition$3(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge$3 (transition) {
        if (transition._id !== this._id)
            throw new Error;
        for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Transition$3(merges, this._parents, this._name, this._id);
    }

    function start$4(name) {
        return (name + "").trim().split(/^|\s+/).every(function (t) {
            var i = t.indexOf(".");
            if (i >= 0)
                t = t.slice(0, i);
            return !t || t === "start";
        });
    }
    function onFunction$3(id, name, listener) {
        var on0, on1, sit = start$4(name) ? init$3 : set$a;
        return function () {
            var schedule = sit(this, id), on = schedule.on;
            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and we’re done!
            // Otherwise, copy-on-write.
            if (on !== on0)
                (on1 = (on0 = on).copy()).on(name, listener);
            schedule.on = on1;
        };
    }
    function transition_on$3 (name, listener) {
        var id = this._id;
        return arguments.length < 2
            ? get$7(this.node(), id).on.on(name)
            : this.each(onFunction$3(id, name, listener));
    }

    function removeFunction$3(id) {
        return function () {
            var parent = this.parentNode;
            for (var i in this.__transition)
                if (+i !== id)
                    return;
            if (parent)
                parent.removeChild(this);
        };
    }
    function transition_remove$3 () {
        return this.on("end.remove", removeFunction$3(this._id));
    }

    function transition_select$3 (select) {
        var name = this._name, id = this._id;
        if (typeof select !== "function")
            select = selector(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                    schedule$3(subgroup[i], name, id, i, subgroup, get$7(node, id));
                }
            }
        }
        return new Transition$3(subgroups, this._parents, name, id);
    }

    function transition_selectAll$3 (select) {
        var name = this._name, id = this._id;
        if (typeof select !== "function")
            select = selectorAll(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    for (var children = select.call(node, node.__data__, i, group), child, inherit = get$7(node, id), k = 0, l = children.length; k < l; ++k) {
                        if (child = children[k]) {
                            schedule$3(child, name, id, k, children, inherit);
                        }
                    }
                    subgroups.push(children);
                    parents.push(node);
                }
            }
        }
        return new Transition$3(subgroups, parents, name, id);
    }

    var Selection$7 = selection.prototype.constructor;
    function transition_selection$3 () {
        return new Selection$7(this._groups, this._parents);
    }

    function styleNull$1(name, interpolate) {
        var string00, string10, interpolate0;
        return function () {
            var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, string10 = string1);
        };
    }
    function styleRemove$7(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant$7(name, interpolate, value1) {
        var string00, string1 = value1 + "", interpolate0;
        return function () {
            var string0 = styleValue(this, name);
            return string0 === string1 ? null
                : string0 === string00 ? interpolate0
                    : interpolate0 = interpolate(string00 = string0, value1);
        };
    }
    function styleFunction$7(name, interpolate, value) {
        var string00, string10, interpolate0;
        return function () {
            var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
            if (value1 == null)
                string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
            return string0 === string1 ? null
                : string0 === string00 && string1 === string10 ? interpolate0
                    : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
        };
    }
    function styleMaybeRemove$1(id, name) {
        var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
        return function () {
            var schedule = set$a(this, id), on = schedule.on, listener = schedule.value[key] == null ? remove || (remove = styleRemove$7(name)) : undefined;
            // If this node shared a dispatch with the previous node,
            // just assign the updated shared dispatch and we’re done!
            // Otherwise, copy-on-write.
            if (on !== on0 || listener0 !== listener)
                (on1 = (on0 = on).copy()).on(event, listener0 = listener);
            schedule.on = on1;
        };
    }
    function transition_style$3 (name, value, priority) {
        var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$5;
        return value == null ? this
            .styleTween(name, styleNull$1(name, i))
            .on("end.style." + name, styleRemove$7(name))
            : typeof value === "function" ? this
                .styleTween(name, styleFunction$7(name, i, tweenValue$3(this, "style." + name, value)))
                .each(styleMaybeRemove$1(this._id, name))
                : this
                    .styleTween(name, styleConstant$7(name, i, value), priority)
                    .on("end.style." + name, null);
    }

    function styleInterpolate$1(name, i, priority) {
        return function (t) {
            this.style.setProperty(name, i.call(this, t), priority);
        };
    }
    function styleTween$3(name, value, priority) {
        var t, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
                t = (i0 = i) && styleInterpolate$1(name, i, priority);
            return t;
        }
        tween._value = value;
        return tween;
    }
    function transition_styleTween$3 (name, value, priority) {
        var key = "style." + (name += "");
        if (arguments.length < 2)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        return this.tween(key, styleTween$3(name, value, priority == null ? "" : priority));
    }

    function textConstant$7(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction$7(value) {
        return function () {
            var value1 = value(this);
            this.textContent = value1 == null ? "" : value1;
        };
    }
    function transition_text$3 (value) {
        return this.tween("text", typeof value === "function"
            ? textFunction$7(tweenValue$3(this, "text", value))
            : textConstant$7(value == null ? "" : value + ""));
    }

    function textInterpolate$1(i) {
        return function (t) {
            this.textContent = i.call(this, t);
        };
    }
    function textTween$1(value) {
        var t0, i0;
        function tween() {
            var i = value.apply(this, arguments);
            if (i !== i0)
                t0 = (i0 = i) && textInterpolate$1(i);
            return t0;
        }
        tween._value = value;
        return tween;
    }
    function transition_textTween$1 (value) {
        var key = "text";
        if (arguments.length < 1)
            return (key = this.tween(key)) && key._value;
        if (value == null)
            return this.tween(key, null);
        if (typeof value !== "function")
            throw new Error;
        return this.tween(key, textTween$1(value));
    }

    function transition_transition$3 () {
        var name = this._name, id0 = this._id, id1 = newId$3();
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    var inherit = get$7(node, id0);
                    schedule$3(node, name, id1, i, group, {
                        time: inherit.time + inherit.delay + inherit.duration,
                        delay: 0,
                        duration: inherit.duration,
                        ease: inherit.ease
                    });
                }
            }
        }
        return new Transition$3(groups, this._parents, name, id1);
    }

    function transition_end$1 () {
        var on0, on1, that = this, id = that._id, size = that.size();
        return new Promise(function (resolve, reject) {
            var cancel = { value: reject }, end = { value: function () { if (--size === 0)
                    resolve(); } };
            that.each(function () {
                var schedule = set$a(this, id), on = schedule.on;
                // If this node shared a dispatch with the previous node,
                // just assign the updated shared dispatch and we’re done!
                // Otherwise, copy-on-write.
                if (on !== on0) {
                    on1 = (on0 = on).copy();
                    on1._.cancel.push(cancel);
                    on1._.interrupt.push(cancel);
                    on1._.end.push(end);
                }
                schedule.on = on1;
            });
        });
    }

    var id$3 = 0;
    function Transition$3(groups, parents, name, id) {
        this._groups = groups;
        this._parents = parents;
        this._name = name;
        this._id = id;
    }
    function newId$3() {
        return ++id$3;
    }
    var selection_prototype$3 = selection.prototype;
    Transition$3.prototype = {
        constructor: Transition$3,
        select: transition_select$3,
        selectAll: transition_selectAll$3,
        filter: transition_filter$3,
        merge: transition_merge$3,
        selection: transition_selection$3,
        transition: transition_transition$3,
        call: selection_prototype$3.call,
        nodes: selection_prototype$3.nodes,
        node: selection_prototype$3.node,
        size: selection_prototype$3.size,
        empty: selection_prototype$3.empty,
        each: selection_prototype$3.each,
        on: transition_on$3,
        attr: transition_attr$3,
        attrTween: transition_attrTween$3,
        style: transition_style$3,
        styleTween: transition_styleTween$3,
        text: transition_text$3,
        textTween: transition_textTween$1,
        remove: transition_remove$3,
        tween: transition_tween$3,
        delay: transition_delay$3,
        duration: transition_duration$3,
        ease: transition_ease$3,
        end: transition_end$1
    };

    var defaultTiming$3 = {
        time: null,
        delay: 0,
        duration: 250,
        ease: cubicInOut
    };
    function inherit$3(node, id) {
        var timing;
        while (!(timing = node.__transition) || !(timing = timing[id])) {
            if (!(node = node.parentNode)) {
                return defaultTiming$3.time = now(), defaultTiming$3;
            }
        }
        return timing;
    }
    function selection_transition$3 (name) {
        var id, timing;
        if (name instanceof Transition$3) {
            id = name._id, name = name._name;
        }
        else {
            id = newId$3(), (timing = defaultTiming$3).time = now(), name = name == null ? null : name + "";
        }
        for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    schedule$3(node, name, id, i, group, timing || inherit$3(node, id));
                }
            }
        }
        return new Transition$3(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt$3;
    selection.prototype.transition = selection_transition$3;

    function constant$k (x) {
        return function () {
            return x;
        };
    }

    function ZoomEvent(target, type, transform) {
        this.target = target;
        this.type = type;
        this.transform = transform;
    }

    function Transform(k, x, y) {
        this.k = k;
        this.x = x;
        this.y = y;
    }
    Transform.prototype = {
        constructor: Transform,
        scale: function (k) {
            return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
        },
        translate: function (x, y) {
            return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
        },
        apply: function (point) {
            return [point[0] * this.k + this.x, point[1] * this.k + this.y];
        },
        applyX: function (x) {
            return x * this.k + this.x;
        },
        applyY: function (y) {
            return y * this.k + this.y;
        },
        invert: function (location) {
            return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
        },
        invertX: function (x) {
            return (x - this.x) / this.k;
        },
        invertY: function (y) {
            return (y - this.y) / this.k;
        },
        rescaleX: function (x) {
            return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
        },
        rescaleY: function (y) {
            return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
        },
        toString: function () {
            return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
        }
    };
    var identity$f = new Transform(1, 0, 0);
    transform$2.prototype = Transform.prototype;
    function transform$2(node) {
        return node.__zoom || identity$f;
    }

    function nopropagation$2() {
        event.stopImmediatePropagation();
    }
    function noevent$3 () {
        event.preventDefault();
        event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2() {
        return !event.button;
    }
    function defaultExtent$1() {
        var e = this, w, h;
        if (e instanceof SVGElement) {
            e = e.ownerSVGElement || e;
            w = e.width.baseVal.value;
            h = e.height.baseVal.value;
        }
        else {
            w = e.clientWidth;
            h = e.clientHeight;
        }
        return [[0, 0], [w, h]];
    }
    function defaultTransform() {
        return this.__zoom || identity$f;
    }
    function defaultWheelDelta() {
        return -event.deltaY * (event.deltaMode ? 120 : 1) / 500;
    }
    function defaultTouchable$1() {
        return "ontouchstart" in this;
    }
    function defaultConstrain(transform, extent, translateExtent) {
        var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
        return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
    }
    function zoom$1 () {
        var filter = defaultFilter$2, extent = defaultExtent$1, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable$1, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate = interpolateZoom, gestures = [], listeners = dispatch("start", "zoom", "end"), touchstarting, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0;
        function zoom(selection) {
            selection
                .property("__zoom", defaultTransform)
                .on("wheel.zoom", wheeled)
                .on("mousedown.zoom", mousedowned)
                .on("dblclick.zoom", dblclicked)
                .filter(touchable)
                .on("touchstart.zoom", touchstarted)
                .on("touchmove.zoom", touchmoved)
                .on("touchend.zoom touchcancel.zoom", touchended)
                .style("touch-action", "none")
                .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
        }
        zoom.transform = function (collection, transform) {
            var selection = collection.selection ? collection.selection() : collection;
            selection.property("__zoom", defaultTransform);
            if (collection !== selection) {
                schedule(collection, transform);
            }
            else {
                selection.interrupt().each(function () {
                    gesture(this, arguments)
                        .start()
                        .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
                        .end();
                });
            }
        };
        zoom.scaleBy = function (selection, k) {
            zoom.scaleTo(selection, function () {
                var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
                return k0 * k1;
            });
        };
        zoom.scaleTo = function (selection, k) {
            zoom.transform(selection, function () {
                var e = extent.apply(this, arguments), t0 = this.__zoom, p0 = centroid(e), p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
                return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
            });
        };
        zoom.translateBy = function (selection, x, y) {
            zoom.transform(selection, function () {
                return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
            });
        };
        zoom.translateTo = function (selection, x, y) {
            zoom.transform(selection, function () {
                var e = extent.apply(this, arguments), t = this.__zoom, p = centroid(e);
                return constrain(identity$f.translate(p[0], p[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
            });
        };
        function scale(transform, k) {
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
            return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
        }
        function translate(transform, p0, p1) {
            var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
            return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
        }
        function centroid(extent) {
            return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
        }
        function schedule(transition, transform, center) {
            transition
                .on("start.zoom", function () { gesture(this, arguments).start(); })
                .on("interrupt.zoom end.zoom", function () { gesture(this, arguments).end(); })
                .tween("zoom", function () {
                var that = this, args = arguments, g = gesture(that, args), e = extent.apply(that, args), p = center || centroid(e), w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a = that.__zoom, b = typeof transform === "function" ? transform.apply(that, args) : transform, i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
                return function (t) {
                    if (t === 1)
                        t = b; // Avoid rounding error on end.
                    else {
                        var l = i(t), k = w / l[2];
                        t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
                    }
                    g.zoom(null, t);
                };
            });
        }
        function gesture(that, args) {
            for (var i = 0, n = gestures.length, g; i < n; ++i) {
                if ((g = gestures[i]).that === that) {
                    return g;
                }
            }
            return new Gesture(that, args);
        }
        function Gesture(that, args) {
            this.that = that;
            this.args = args;
            this.index = -1;
            this.active = 0;
            this.extent = extent.apply(that, args);
        }
        Gesture.prototype = {
            start: function () {
                if (++this.active === 1) {
                    this.index = gestures.push(this) - 1;
                    this.emit("start");
                }
                return this;
            },
            zoom: function (key, transform) {
                if (this.mouse && key !== "mouse")
                    this.mouse[1] = transform.invert(this.mouse[0]);
                if (this.touch0 && key !== "touch")
                    this.touch0[1] = transform.invert(this.touch0[0]);
                if (this.touch1 && key !== "touch")
                    this.touch1[1] = transform.invert(this.touch1[0]);
                this.that.__zoom = transform;
                this.emit("zoom");
                return this;
            },
            end: function () {
                if (--this.active === 0) {
                    gestures.splice(this.index, 1);
                    this.index = -1;
                    this.emit("end");
                }
                return this;
            },
            emit: function (type) {
                customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
            }
        };
        function wheeled() {
            if (!filter.apply(this, arguments))
                return;
            var g = gesture(this, arguments), t = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = mouse(this);
            // If the mouse is in the same location as before, reuse it.
            // If there were recent wheel events, reset the wheel idle timeout.
            if (g.wheel) {
                if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
                    g.mouse[1] = t.invert(g.mouse[0] = p);
                }
                clearTimeout(g.wheel);
            }
            // If this wheel event won’t trigger a transform change, ignore it.
            else if (t.k === k)
                return;
            // Otherwise, capture the mouse point and location at the start.
            else {
                g.mouse = [p, t.invert(p)];
                interrupt$3(this);
                g.start();
            }
            noevent$3();
            g.wheel = setTimeout(wheelidled, wheelDelay);
            g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
            function wheelidled() {
                g.wheel = null;
                g.end();
            }
        }
        function mousedowned() {
            if (touchending || !filter.apply(this, arguments))
                return;
            var g = gesture(this, arguments), v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = mouse(this), x0 = event.clientX, y0 = event.clientY;
            dragDisable(event.view);
            nopropagation$2();
            g.mouse = [p, this.__zoom.invert(p)];
            interrupt$3(this);
            g.start();
            function mousemoved() {
                noevent$3();
                if (!g.moved) {
                    var dx = event.clientX - x0, dy = event.clientY - y0;
                    g.moved = dx * dx + dy * dy > clickDistance2;
                }
                g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));
            }
            function mouseupped() {
                v.on("mousemove.zoom mouseup.zoom", null);
                yesdrag(event.view, g.moved);
                noevent$3();
                g.end();
            }
        }
        function dblclicked() {
            if (!filter.apply(this, arguments))
                return;
            var t0 = this.__zoom, p0 = mouse(this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);
            noevent$3();
            if (duration > 0)
                select(this).transition().duration(duration).call(schedule, t1, p0);
            else
                select(this).call(zoom.transform, t1);
        }
        function touchstarted() {
            if (!filter.apply(this, arguments))
                return;
            var g = gesture(this, arguments), touches = event.changedTouches, started, n = touches.length, i, t, p;
            nopropagation$2();
            for (i = 0; i < n; ++i) {
                t = touches[i], p = touch(this, touches, t.identifier);
                p = [p, this.__zoom.invert(p), t.identifier];
                if (!g.touch0)
                    g.touch0 = p, started = true;
                else if (!g.touch1)
                    g.touch1 = p;
            }
            // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.
            if (touchstarting) {
                touchstarting = clearTimeout(touchstarting);
                if (!g.touch1) {
                    g.end();
                    p = select(this).on("dblclick.zoom");
                    if (p)
                        p.apply(this, arguments);
                    return;
                }
            }
            if (started) {
                touchstarting = setTimeout(function () { touchstarting = null; }, touchDelay);
                interrupt$3(this);
                g.start();
            }
        }
        function touchmoved() {
            var g = gesture(this, arguments), touches = event.changedTouches, n = touches.length, i, t, p, l;
            noevent$3();
            if (touchstarting)
                touchstarting = clearTimeout(touchstarting);
            for (i = 0; i < n; ++i) {
                t = touches[i], p = touch(this, touches, t.identifier);
                if (g.touch0 && g.touch0[2] === t.identifier)
                    g.touch0[0] = p;
                else if (g.touch1 && g.touch1[2] === t.identifier)
                    g.touch1[0] = p;
            }
            t = g.that.__zoom;
            if (g.touch1) {
                var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
                t = scale(t, Math.sqrt(dp / dl));
                p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
                l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
            }
            else if (g.touch0)
                p = g.touch0[0], l = g.touch0[1];
            else
                return;
            g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
        }
        function touchended() {
            var g = gesture(this, arguments), touches = event.changedTouches, n = touches.length, i, t;
            nopropagation$2();
            if (touchending)
                clearTimeout(touchending);
            touchending = setTimeout(function () { touchending = null; }, touchDelay);
            for (i = 0; i < n; ++i) {
                t = touches[i];
                if (g.touch0 && g.touch0[2] === t.identifier)
                    delete g.touch0;
                else if (g.touch1 && g.touch1[2] === t.identifier)
                    delete g.touch1;
            }
            if (g.touch1 && !g.touch0)
                g.touch0 = g.touch1, delete g.touch1;
            if (g.touch0)
                g.touch0[1] = this.__zoom.invert(g.touch0[0]);
            else
                g.end();
        }
        zoom.wheelDelta = function (_) {
            return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant$k(+_), zoom) : wheelDelta;
        };
        zoom.filter = function (_) {
            return arguments.length ? (filter = typeof _ === "function" ? _ : constant$k(!!_), zoom) : filter;
        };
        zoom.touchable = function (_) {
            return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$k(!!_), zoom) : touchable;
        };
        zoom.extent = function (_) {
            return arguments.length ? (extent = typeof _ === "function" ? _ : constant$k([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
        };
        zoom.scaleExtent = function (_) {
            return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
        };
        zoom.translateExtent = function (_) {
            return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
        };
        zoom.constrain = function (_) {
            return arguments.length ? (constrain = _, zoom) : constrain;
        };
        zoom.duration = function (_) {
            return arguments.length ? (duration = +_, zoom) : duration;
        };
        zoom.interpolate = function (_) {
            return arguments.length ? (interpolate = _, zoom) : interpolate;
        };
        zoom.on = function () {
            var value = listeners.on.apply(listeners, arguments);
            return value === listeners ? zoom : value;
        };
        zoom.clickDistance = function (_) {
            return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
        };
        return zoom;
    }



    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        version: version,
        bisect: bisectRight$1,
        bisectRight: bisectRight$1,
        bisectLeft: bisectLeft,
        ascending: ascending$2,
        bisector: bisector$1,
        cross: cross,
        descending: descending,
        deviation: deviation,
        extent: extent,
        histogram: histogram,
        thresholdFreedmanDiaconis: freedmanDiaconis,
        thresholdScott: scott,
        thresholdSturges: sturges,
        max: max$1,
        mean: mean,
        median: median,
        merge: merge$1,
        min: min$1,
        pairs: pairs,
        permute: permute,
        quantile: quantile,
        range: range$1,
        scan: scan,
        shuffle: shuffle,
        sum: sum$1,
        ticks: ticks$1,
        tickIncrement: tickIncrement$1,
        tickStep: tickStep$1,
        transpose: transpose,
        variance: variance,
        zip: zip,
        axisTop: axisTop,
        axisRight: axisRight,
        axisBottom: axisBottom$1,
        axisLeft: axisLeft$1,
        brush: brush,
        brushX: brushX,
        brushY: brushY,
        brushSelection: brushSelection,
        chord: chord,
        ribbon: ribbon,
        nest: nest,
        set: set$4,
        map: map$4,
        keys: keys,
        values: values,
        entries: entries,
        color: color$1,
        rgb: rgb$1,
        hsl: hsl$1,
        lab: lab$1,
        hcl: hcl$1,
        cubehelix: cubehelix$1,
        dispatch: dispatch$1,
        drag: drag,
        dragDisable: nodrag,
        dragEnable: yesdrag$1,
        dsvFormat: dsv,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        csvFormat: csvFormat,
        csvFormatRows: csvFormatRows,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        tsvFormat: tsvFormat,
        tsvFormatRows: tsvFormatRows,
        easeLinear: linear$2,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadOut: quadOut,
        easeQuadInOut: quadInOut,
        easeCubic: cubicInOut$1,
        easeCubicIn: cubicIn,
        easeCubicOut: cubicOut,
        easeCubicInOut: cubicInOut$1,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyOut: polyOut,
        easePolyInOut: polyInOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinOut: sinOut,
        easeSinInOut: sinInOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpOut: expOut,
        easeExpInOut: expInOut,
        easeCircle: circleInOut,
        easeCircleIn: circleIn$1,
        easeCircleOut: circleOut,
        easeCircleInOut: circleInOut,
        easeBounce: bounceOut,
        easeBounceIn: bounceIn,
        easeBounceOut: bounceOut,
        easeBounceInOut: bounceInOut,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackOut: backOut,
        easeBackInOut: backInOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticOut: elasticOut,
        easeElasticInOut: elasticInOut,
        forceCenter: center$3,
        forceCollide: collide,
        forceLink: link$1,
        forceManyBody: manyBody,
        forceRadial: radial,
        forceSimulation: simulation,
        forceX: x$4,
        forceY: y$3,
        formatDefaultLocale: defaultLocale$2,
        get format () { return format$1; },
        get formatPrefix () { return formatPrefix$1; },
        formatLocale: formatLocale$2,
        formatSpecifier: formatSpecifier$1,
        precisionFixed: precisionFixed$1,
        precisionPrefix: precisionPrefix$1,
        precisionRound: precisionRound$1,
        geoArea: area,
        geoBounds: bounds,
        geoCentroid: centroid,
        geoCircle: circle,
        geoClipAntimeridian: clipAntimeridian,
        geoClipCircle: clipCircle,
        geoClipExtent: extent$1,
        geoClipRectangle: clipRectangle,
        geoContains: contains,
        geoDistance: distance,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoInterpolate: interpolate$3,
        geoLength: length$1,
        geoPath: index$1,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoIdentity: identity$9,
        geoProjection: projection,
        geoProjectionMutator: projectionMutator,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        geoRotation: rotation,
        geoStream: geoStream,
        geoTransform: transform$1,
        cluster: cluster,
        hierarchy: hierarchy,
        pack: index$2,
        packSiblings: siblings,
        packEnclose: enclose,
        partition: partition,
        stratify: stratify,
        tree: tree,
        treemap: index$3,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        treemapResquarify: resquarify,
        interpolate: value,
        interpolateArray: array$2,
        interpolateBasis: basis$1,
        interpolateBasisClosed: basisClosed,
        interpolateDate: date$1,
        interpolateNumber: number$5,
        interpolateObject: object$2,
        interpolateRound: round,
        interpolateString: string,
        interpolateTransformCss: interpolateTransformCss$1,
        interpolateTransformSvg: interpolateTransformSvg$1,
        interpolateZoom: zoom,
        interpolateRgb: rgb$3,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateHsl: hsl$4,
        interpolateHslLong: hslLong,
        interpolateLab: lab$3,
        interpolateHcl: hcl$4,
        interpolateHclLong: hclLong,
        interpolateCubehelix: cubehelix$4,
        interpolateCubehelixLong: cubehelixLong,
        quantize: quantize$1,
        path: path$1,
        polygonArea: area$1,
        polygonCentroid: centroid$1,
        polygonHull: hull,
        polygonContains: contains$1,
        polygonLength: length$2,
        quadtree: quadtree$1,
        queue: queue,
        randomUniform: uniform,
        randomNormal: normal,
        randomLogNormal: logNormal,
        randomBates: bates,
        randomIrwinHall: irwinHall,
        randomExponential: exponential$2,
        request: request,
        html: html,
        json: json,
        text: text,
        xml: xml,
        csv: csv$2,
        tsv: tsv$2,
        scaleBand: band,
        scalePoint: point$3,
        scaleIdentity: identity$c,
        scaleLinear: linear$5,
        scaleLog: log$1,
        scaleOrdinal: ordinal$1,
        scaleImplicit: implicit$1,
        scalePow: pow$2,
        scaleSqrt: sqrt$2,
        scaleQuantile: quantile$1,
        scaleQuantize: quantize$2,
        scaleThreshold: threshold$1,
        scaleTime: time,
        scaleUtc: utcTime,
        schemeCategory10: category10,
        schemeCategory20b: category20b,
        schemeCategory20c: category20c,
        schemeCategory20: category20,
        interpolateCubehelixDefault: cubehelix$7,
        interpolateRainbow: rainbow$1,
        interpolateWarm: warm,
        interpolateCool: cool,
        interpolateViridis: viridis,
        interpolateMagma: magma,
        interpolateInferno: inferno,
        interpolatePlasma: plasma,
        scaleSequential: sequential,
        create: create$2,
        creator: creator$2,
        local: local$1,
        matcher: matcher$3,
        mouse: mouse$2,
        namespace: namespace$2,
        namespaces: namespaces$2,
        clientPoint: point$4,
        select: select$2,
        selectAll: selectAll$1,
        selection: selection$2,
        selector: selector$2,
        selectorAll: selectorAll$2,
        style: styleValue$2,
        touch: touch$2,
        touches: touches,
        window: defaultView$2,
        get event () { return event$2; },
        customEvent: customEvent$2,
        arc: arc,
        area: area$2,
        line: line,
        pie: pie,
        areaRadial: areaRadial,
        radialArea: areaRadial,
        lineRadial: lineRadial$1,
        radialLine: lineRadial$1,
        pointRadial: pointRadial,
        linkHorizontal: linkHorizontal$1,
        linkVertical: linkVertical,
        linkRadial: linkRadial,
        symbol: symbol,
        symbols: symbols$1,
        symbolCircle: circle$2,
        symbolCross: cross$2,
        symbolDiamond: diamond,
        symbolSquare: square,
        symbolStar: star,
        symbolTriangle: triangle,
        symbolWye: wye,
        curveBasisClosed: basisClosed$1,
        curveBasisOpen: basisOpen,
        curveBasis: basis$2,
        curveBundle: bundle,
        curveCardinalClosed: cardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCardinal: cardinal,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveCatmullRom: catmullRom,
        curveLinearClosed: linearClosed,
        curveLinear: curveLinear,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        stack: stack,
        stackOffsetExpand: expand,
        stackOffsetDiverging: diverging,
        stackOffsetNone: none$3,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAscending: ascending$6,
        stackOrderDescending: descending$2,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none$4,
        stackOrderReverse: reverse,
        timeInterval: newInterval$2,
        timeMillisecond: millisecond$2,
        timeMilliseconds: milliseconds,
        utcMillisecond: millisecond$2,
        utcMilliseconds: milliseconds,
        timeSecond: second$2,
        timeSeconds: seconds,
        utcSecond: second$2,
        utcSeconds: seconds,
        timeMinute: minute$2,
        timeMinutes: minutes,
        timeHour: hour$2,
        timeHours: hours,
        timeDay: day$2,
        timeDays: days,
        timeWeek: sunday$2,
        timeWeeks: sundays,
        timeSunday: sunday$2,
        timeSundays: sundays,
        timeMonday: monday$2,
        timeMondays: mondays,
        timeTuesday: tuesday$2,
        timeTuesdays: tuesdays,
        timeWednesday: wednesday$2,
        timeWednesdays: wednesdays,
        timeThursday: thursday$2,
        timeThursdays: thursdays,
        timeFriday: friday$2,
        timeFridays: fridays,
        timeSaturday: saturday$2,
        timeSaturdays: saturdays,
        timeMonth: month$2,
        timeMonths: months,
        timeYear: year$2,
        timeYears: years,
        utcMinute: utcMinute$2,
        utcMinutes: utcMinutes,
        utcHour: utcHour$2,
        utcHours: utcHours,
        utcDay: utcDay$2,
        utcDays: utcDays,
        utcWeek: utcSunday$2,
        utcWeeks: utcSundays,
        utcSunday: utcSunday$2,
        utcSundays: utcSundays,
        utcMonday: utcMonday$2,
        utcMondays: utcMondays,
        utcTuesday: utcTuesday$2,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday$2,
        utcWednesdays: utcWednesdays,
        utcThursday: utcThursday$2,
        utcThursdays: utcThursdays,
        utcFriday: utcFriday$2,
        utcFridays: utcFridays,
        utcSaturday: utcSaturday$2,
        utcSaturdays: utcSaturdays,
        utcMonth: utcMonth$2,
        utcMonths: utcMonths,
        utcYear: utcYear$2,
        utcYears: utcYears,
        timeFormatDefaultLocale: defaultLocale$5,
        get timeFormat () { return timeFormat$2; },
        get timeParse () { return timeParse$2; },
        get utcFormat () { return utcFormat$2; },
        get utcParse () { return utcParse$2; },
        timeFormatLocale: formatLocale$5,
        isoFormat: formatIso$2,
        isoParse: parseIso$2,
        now: now$1,
        timer: timer$1,
        timerFlush: timerFlush$1,
        timeout: timeout$3,
        interval: interval$2,
        transition: transition$2,
        active: active,
        interrupt: interrupt$2,
        voronoi: voronoi,
        zoom: zoom$1,
        zoomTransform: transform$2,
        zoomIdentity: identity$f
    });

    var xhtml$4 = "http://www.w3.org/1999/xhtml";
    var namespaces$4 = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml$4,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace$4 (name) {
        var prefix = name += "", i = prefix.indexOf(":");
        if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
            name = name.slice(i + 1);
        return namespaces$4.hasOwnProperty(prefix) ? { space: namespaces$4[prefix], local: name } : name;
    }

    function creatorInherit$4(name) {
        return function () {
            var document = this.ownerDocument, uri = this.namespaceURI;
            return uri === xhtml$4 && document.documentElement.namespaceURI === xhtml$4
                ? document.createElement(name)
                : document.createElementNS(uri, name);
        };
    }
    function creatorFixed$4(fullname) {
        return function () {
            return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
    }
    function creator$4 (name) {
        var fullname = namespace$4(name);
        return (fullname.local
            ? creatorFixed$4
            : creatorInherit$4)(fullname);
    }

    function none$6() { }
    function selector$4 (selector) {
        return selector == null ? none$6 : function () {
            return this.querySelector(selector);
        };
    }

    function selection_select$4 (select) {
        if (typeof select !== "function")
            select = selector$4(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                }
            }
        }
        return new Selection$8(subgroups, this._parents);
    }

    function empty$5() {
        return [];
    }
    function selectorAll$4 (selector) {
        return selector == null ? empty$5 : function () {
            return this.querySelectorAll(selector);
        };
    }

    function selection_selectAll$4 (select) {
        if (typeof select !== "function")
            select = selectorAll$4(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    subgroups.push(select.call(node, node.__data__, i, group));
                    parents.push(node);
                }
            }
        }
        return new Selection$8(subgroups, parents);
    }

    function matcher$5 (selector) {
        return function () {
            return this.matches(selector);
        };
    }

    function selection_filter$4 (match) {
        if (typeof match !== "function")
            match = matcher$5(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Selection$8(subgroups, this._parents);
    }

    function sparse$4 (update) {
        return new Array(update.length);
    }

    function selection_enter$4 () {
        return new Selection$8(this._enter || this._groups.map(sparse$4), this._parents);
    }
    function EnterNode$4(parent, datum) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum;
    }
    EnterNode$4.prototype = {
        constructor: EnterNode$4,
        appendChild: function (child) { return this._parent.insertBefore(child, this._next); },
        insertBefore: function (child, next) { return this._parent.insertBefore(child, next); },
        querySelector: function (selector) { return this._parent.querySelector(selector); },
        querySelectorAll: function (selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$l (x) {
        return function () {
            return x;
        };
    }

    var keyPrefix$5 = "$"; // Protect against keys like “__proto__”.
    function bindIndex$4(parent, group, enter, update, exit, data) {
        var i = 0, node, groupLength = group.length, dataLength = data.length;
        // Put any non-null nodes that fit into update.
        // Put any null nodes into enter.
        // Put any remaining data into enter.
        for (; i < dataLength; ++i) {
            if (node = group[i]) {
                node.__data__ = data[i];
                update[i] = node;
            }
            else {
                enter[i] = new EnterNode$4(parent, data[i]);
            }
        }
        // Put any non-null nodes that don’t fit into exit.
        for (; i < groupLength; ++i) {
            if (node = group[i]) {
                exit[i] = node;
            }
        }
    }
    function bindKey$4(parent, group, enter, update, exit, data, key) {
        var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
        // Compute the key for each node.
        // If multiple nodes have the same key, the duplicates are added to exit.
        for (i = 0; i < groupLength; ++i) {
            if (node = group[i]) {
                keyValues[i] = keyValue = keyPrefix$5 + key.call(node, node.__data__, i, group);
                if (keyValue in nodeByKeyValue) {
                    exit[i] = node;
                }
                else {
                    nodeByKeyValue[keyValue] = node;
                }
            }
        }
        // Compute the key for each datum.
        // If there a node associated with this key, join and add it to update.
        // If there is not (or the key is a duplicate), add it to enter.
        for (i = 0; i < dataLength; ++i) {
            keyValue = keyPrefix$5 + key.call(parent, data[i], i, data);
            if (node = nodeByKeyValue[keyValue]) {
                update[i] = node;
                node.__data__ = data[i];
                nodeByKeyValue[keyValue] = null;
            }
            else {
                enter[i] = new EnterNode$4(parent, data[i]);
            }
        }
        // Add any remaining nodes that were not bound to data to exit.
        for (i = 0; i < groupLength; ++i) {
            if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
                exit[i] = node;
            }
        }
    }
    function selection_data$4 (value, key) {
        if (!value) {
            data = new Array(this.size()), j = -1;
            this.each(function (d) { data[++j] = d; });
            return data;
        }
        var bind = key ? bindKey$4 : bindIndex$4, parents = this._parents, groups = this._groups;
        if (typeof value !== "function")
            value = constant$l(value);
        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
            var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
            bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
            // Now connect the enter nodes to their following update node, such that
            // appendChild can insert the materialized enter node before this node,
            // rather than at the end of the parent node.
            for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
                if (previous = enterGroup[i0]) {
                    if (i0 >= i1)
                        i1 = i0 + 1;
                    while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                        ;
                    previous._next = next || null;
                }
            }
        }
        update = new Selection$8(update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
    }

    function selection_exit$4 () {
        return new Selection$8(this._exit || this._groups.map(sparse$4), this._parents);
    }

    function selection_join$3 (onenter, onupdate, onexit) {
        var enter = this.enter(), update = this, exit = this.exit();
        enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
        if (onupdate != null)
            update = onupdate(update);
        if (onexit == null)
            exit.remove();
        else
            onexit(exit);
        return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge$4 (selection) {
        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Selection$8(merges, this._parents);
    }

    function selection_order$4 () {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
            for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && node.compareDocumentPosition(next) ^ 4)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    }

    function selection_sort$4 (compare) {
        if (!compare)
            compare = ascending$8;
        function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    sortgroup[i] = node;
                }
            }
            sortgroup.sort(compareNode);
        }
        return new Selection$8(sortgroups, this._parents).order();
    }
    function ascending$8(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call$4 () {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
    }

    function selection_nodes$4 () {
        var nodes = new Array(this.size()), i = -1;
        this.each(function () { nodes[++i] = this; });
        return nodes;
    }

    function selection_node$4 () {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    }

    function selection_size$4 () {
        var size = 0;
        this.each(function () { ++size; });
        return size;
    }

    function selection_empty$4 () {
        return !this.node();
    }

    function selection_each$4 (callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
                if (node = group[i])
                    callback.call(node, node.__data__, i, group);
            }
        }
        return this;
    }

    function attrRemove$8(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS$8(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant$8(name, value) {
        return function () {
            this.setAttribute(name, value);
        };
    }
    function attrConstantNS$8(fullname, value) {
        return function () {
            this.setAttributeNS(fullname.space, fullname.local, value);
        };
    }
    function attrFunction$8(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, v);
        };
    }
    function attrFunctionNS$8(fullname, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttributeNS(fullname.space, fullname.local);
            else
                this.setAttributeNS(fullname.space, fullname.local, v);
        };
    }
    function selection_attr$4 (name, value) {
        var fullname = namespace$4(name);
        if (arguments.length < 2) {
            var node = this.node();
            return fullname.local
                ? node.getAttributeNS(fullname.space, fullname.local)
                : node.getAttribute(fullname);
        }
        return this.each((value == null
            ? (fullname.local ? attrRemoveNS$8 : attrRemove$8) : (typeof value === "function"
            ? (fullname.local ? attrFunctionNS$8 : attrFunction$8)
            : (fullname.local ? attrConstantNS$8 : attrConstant$8)))(fullname, value));
    }

    function defaultView$4 (node) {
        return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
            || (node.document && node) // node is a Window
            || node.defaultView; // node is a Document
    }

    function styleRemove$8(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant$8(name, value, priority) {
        return function () {
            this.style.setProperty(name, value, priority);
        };
    }
    function styleFunction$8(name, value, priority) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, v, priority);
        };
    }
    function selection_style$4 (name, value, priority) {
        return arguments.length > 1
            ? this.each((value == null
                ? styleRemove$8 : typeof value === "function"
                ? styleFunction$8
                : styleConstant$8)(name, value, priority == null ? "" : priority))
            : styleValue$4(this.node(), name);
    }
    function styleValue$4(node, name) {
        return node.style.getPropertyValue(name)
            || defaultView$4(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove$4(name) {
        return function () {
            delete this[name];
        };
    }
    function propertyConstant$4(name, value) {
        return function () {
            this[name] = value;
        };
    }
    function propertyFunction$4(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                delete this[name];
            else
                this[name] = v;
        };
    }
    function selection_property$4 (name, value) {
        return arguments.length > 1
            ? this.each((value == null
                ? propertyRemove$4 : typeof value === "function"
                ? propertyFunction$4
                : propertyConstant$4)(name, value))
            : this.node()[name];
    }

    function classArray$4(string) {
        return string.trim().split(/^|\s+/);
    }
    function classList$4(node) {
        return node.classList || new ClassList$4(node);
    }
    function ClassList$4(node) {
        this._node = node;
        this._names = classArray$4(node.getAttribute("class") || "");
    }
    ClassList$4.prototype = {
        add: function (name) {
            var i = this._names.indexOf(name);
            if (i < 0) {
                this._names.push(name);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        remove: function (name) {
            var i = this._names.indexOf(name);
            if (i >= 0) {
                this._names.splice(i, 1);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        contains: function (name) {
            return this._names.indexOf(name) >= 0;
        }
    };
    function classedAdd$4(node, names) {
        var list = classList$4(node), i = -1, n = names.length;
        while (++i < n)
            list.add(names[i]);
    }
    function classedRemove$4(node, names) {
        var list = classList$4(node), i = -1, n = names.length;
        while (++i < n)
            list.remove(names[i]);
    }
    function classedTrue$4(names) {
        return function () {
            classedAdd$4(this, names);
        };
    }
    function classedFalse$4(names) {
        return function () {
            classedRemove$4(this, names);
        };
    }
    function classedFunction$4(names, value) {
        return function () {
            (value.apply(this, arguments) ? classedAdd$4 : classedRemove$4)(this, names);
        };
    }
    function selection_classed$4 (name, value) {
        var names = classArray$4(name + "");
        if (arguments.length < 2) {
            var list = classList$4(this.node()), i = -1, n = names.length;
            while (++i < n)
                if (!list.contains(names[i]))
                    return false;
            return true;
        }
        return this.each((typeof value === "function"
            ? classedFunction$4 : value
            ? classedTrue$4
            : classedFalse$4)(names, value));
    }

    function textRemove$4() {
        this.textContent = "";
    }
    function textConstant$8(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction$8(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        };
    }
    function selection_text$4 (value) {
        return arguments.length
            ? this.each(value == null
                ? textRemove$4 : (typeof value === "function"
                ? textFunction$8
                : textConstant$8)(value))
            : this.node().textContent;
    }

    function htmlRemove$4() {
        this.innerHTML = "";
    }
    function htmlConstant$4(value) {
        return function () {
            this.innerHTML = value;
        };
    }
    function htmlFunction$4(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        };
    }
    function selection_html$4 (value) {
        return arguments.length
            ? this.each(value == null
                ? htmlRemove$4 : (typeof value === "function"
                ? htmlFunction$4
                : htmlConstant$4)(value))
            : this.node().innerHTML;
    }

    function raise$5() {
        if (this.nextSibling)
            this.parentNode.appendChild(this);
    }
    function selection_raise$4 () {
        return this.each(raise$5);
    }

    function lower$4() {
        if (this.previousSibling)
            this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower$4 () {
        return this.each(lower$4);
    }

    function selection_append$4 (name) {
        var create = typeof name === "function" ? name : creator$4(name);
        return this.select(function () {
            return this.appendChild(create.apply(this, arguments));
        });
    }

    function constantNull$4() {
        return null;
    }
    function selection_insert$4 (name, before) {
        var create = typeof name === "function" ? name : creator$4(name), select = before == null ? constantNull$4 : typeof before === "function" ? before : selector$4(before);
        return this.select(function () {
            return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        });
    }

    function remove$4() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    function selection_remove$4 () {
        return this.each(remove$4);
    }

    function selection_cloneShallow$4() {
        return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
    }
    function selection_cloneDeep$4() {
        return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
    }
    function selection_clone$4 (deep) {
        return this.select(deep ? selection_cloneDeep$4 : selection_cloneShallow$4);
    }

    function selection_datum$4 (value) {
        return arguments.length
            ? this.property("__data__", value)
            : this.node().__data__;
    }

    var filterEvents$4 = {};
    var event$3 = null;
    if (typeof document !== "undefined") {
        var element$5 = document.documentElement;
        if (!("onmouseenter" in element$5)) {
            filterEvents$4 = { mouseenter: "mouseover", mouseleave: "mouseout" };
        }
    }
    function filterContextListener$4(listener, index, group) {
        listener = contextListener$4(listener, index, group);
        return function (event) {
            var related = event.relatedTarget;
            if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
                listener.call(this, event);
            }
        };
    }
    function contextListener$4(listener, index, group) {
        return function (event1) {
            var event0 = event$3; // Events can be reentrant (e.g., focus).
            event$3 = event1;
            try {
                listener.call(this, this.__data__, index, group);
            }
            finally {
                event$3 = event0;
            }
        };
    }
    function parseTypenames$8(typenames) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            return { type: t, name: name };
        });
    }
    function onRemove$4(typename) {
        return function () {
            var on = this.__on;
            if (!on)
                return;
            for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
                if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                    this.removeEventListener(o.type, o.listener, o.capture);
                }
                else {
                    on[++i] = o;
                }
            }
            if (++i)
                on.length = i;
            else
                delete this.__on;
        };
    }
    function onAdd$4(typename, value, capture) {
        var wrap = filterEvents$4.hasOwnProperty(typename.type) ? filterContextListener$4 : contextListener$4;
        return function (d, i, group) {
            var on = this.__on, o, listener = wrap(value, i, group);
            if (on)
                for (var j = 0, m = on.length; j < m; ++j) {
                    if ((o = on[j]).type === typename.type && o.name === typename.name) {
                        this.removeEventListener(o.type, o.listener, o.capture);
                        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                        o.value = value;
                        return;
                    }
                }
            this.addEventListener(typename.type, listener, capture);
            o = { type: typename.type, name: typename.name, value: value, listener: listener, capture: capture };
            if (!on)
                this.__on = [o];
            else
                on.push(o);
        };
    }
    function selection_on$4 (typename, value, capture) {
        var typenames = parseTypenames$8(typename + ""), i, n = typenames.length, t;
        if (arguments.length < 2) {
            var on = this.node().__on;
            if (on)
                for (var j = 0, m = on.length, o; j < m; ++j) {
                    for (i = 0, o = on[j]; i < n; ++i) {
                        if ((t = typenames[i]).type === o.type && t.name === o.name) {
                            return o.value;
                        }
                    }
                }
            return;
        }
        on = value ? onAdd$4 : onRemove$4;
        if (capture == null)
            capture = false;
        for (i = 0; i < n; ++i)
            this.each(on(typenames[i], value, capture));
        return this;
    }

    function dispatchEvent$4(node, type, params) {
        var window = defaultView$4(node), event = window.CustomEvent;
        if (typeof event === "function") {
            event = new event(type, params);
        }
        else {
            event = window.document.createEvent("Event");
            if (params)
                event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
            else
                event.initEvent(type, false, false);
        }
        node.dispatchEvent(event);
    }
    function dispatchConstant$4(type, params) {
        return function () {
            return dispatchEvent$4(this, type, params);
        };
    }
    function dispatchFunction$4(type, params) {
        return function () {
            return dispatchEvent$4(this, type, params.apply(this, arguments));
        };
    }
    function selection_dispatch$4 (type, params) {
        return this.each((typeof params === "function"
            ? dispatchFunction$4
            : dispatchConstant$4)(type, params));
    }

    var root$5 = [null];
    function Selection$8(groups, parents) {
        this._groups = groups;
        this._parents = parents;
    }
    Selection$8.prototype = {
        constructor: Selection$8,
        select: selection_select$4,
        selectAll: selection_selectAll$4,
        filter: selection_filter$4,
        data: selection_data$4,
        enter: selection_enter$4,
        exit: selection_exit$4,
        join: selection_join$3,
        merge: selection_merge$4,
        order: selection_order$4,
        sort: selection_sort$4,
        call: selection_call$4,
        nodes: selection_nodes$4,
        node: selection_node$4,
        size: selection_size$4,
        empty: selection_empty$4,
        each: selection_each$4,
        attr: selection_attr$4,
        style: selection_style$4,
        property: selection_property$4,
        classed: selection_classed$4,
        text: selection_text$4,
        html: selection_html$4,
        raise: selection_raise$4,
        lower: selection_lower$4,
        append: selection_append$4,
        insert: selection_insert$4,
        remove: selection_remove$4,
        clone: selection_clone$4,
        datum: selection_datum$4,
        on: selection_on$4,
        dispatch: selection_dispatch$4
    };

    function select$3 (selector) {
        return typeof selector === "string"
            ? new Selection$8([[document.querySelector(selector)]], [document.documentElement])
            : new Selection$8([[selector]], root$5);
    }

    var noop$6 = { value: function () { } };
    function dispatch$4() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
            if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t))
                throw new Error("illegal type: " + t);
            _[t] = [];
        }
        return new Dispatch$4(_);
    }
    function Dispatch$4(_) {
        this._ = _;
    }
    function parseTypenames$9(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            if (t && !types.hasOwnProperty(t))
                throw new Error("unknown type: " + t);
            return { type: t, name: name };
        });
    }
    Dispatch$4.prototype = dispatch$4.prototype = {
        constructor: Dispatch$4,
        on: function (typename, callback) {
            var _ = this._, T = parseTypenames$9(typename + "", _), t, i = -1, n = T.length;
            // If no callback was specified, return the callback of the given type and name.
            if (arguments.length < 2) {
                while (++i < n)
                    if ((t = (typename = T[i]).type) && (t = get$8(_[t], typename.name)))
                        return t;
                return;
            }
            // If a type was specified, set the callback for the given type and name.
            // Otherwise, if a null callback was specified, remove callbacks of the given name.
            if (callback != null && typeof callback !== "function")
                throw new Error("invalid callback: " + callback);
            while (++i < n) {
                if (t = (typename = T[i]).type)
                    _[t] = set$b(_[t], typename.name, callback);
                else if (callback == null)
                    for (t in _)
                        _[t] = set$b(_[t], typename.name, null);
            }
            return this;
        },
        copy: function () {
            var copy = {}, _ = this._;
            for (var t in _)
                copy[t] = _[t].slice();
            return new Dispatch$4(copy);
        },
        call: function (type, that) {
            if ((n = arguments.length - 2) > 0)
                for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                    args[i] = arguments[i + 2];
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        },
        apply: function (type, that, args) {
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        }
    };
    function get$8(type, name) {
        for (var i = 0, n = type.length, c; i < n; ++i) {
            if ((c = type[i]).name === name) {
                return c.value;
            }
        }
    }
    function set$b(type, name, callback) {
        for (var i = 0, n = type.length; i < n; ++i) {
            if (type[i].name === name) {
                type[i] = noop$6, type = type.slice(0, i).concat(type.slice(i + 1));
                break;
            }
        }
        if (callback != null)
            type.push({ name: name, value: callback });
        return type;
    }

    var xhtml$5 = "http://www.w3.org/1999/xhtml";
    var namespaces$5 = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: xhtml$5,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace$5 (name) {
        var prefix = name += "", i = prefix.indexOf(":");
        if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
            name = name.slice(i + 1);
        return namespaces$5.hasOwnProperty(prefix) ? { space: namespaces$5[prefix], local: name } : name;
    }

    function creatorInherit$5(name) {
        return function () {
            var document = this.ownerDocument, uri = this.namespaceURI;
            return uri === xhtml$5 && document.documentElement.namespaceURI === xhtml$5
                ? document.createElement(name)
                : document.createElementNS(uri, name);
        };
    }
    function creatorFixed$5(fullname) {
        return function () {
            return this.ownerDocument.createElementNS(fullname.space, fullname.local);
        };
    }
    function creator$5 (name) {
        var fullname = namespace$5(name);
        return (fullname.local
            ? creatorFixed$5
            : creatorInherit$5)(fullname);
    }

    function none$7() { }
    function selector$5 (selector) {
        return selector == null ? none$7 : function () {
            return this.querySelector(selector);
        };
    }

    function selection_select$5 (select) {
        if (typeof select !== "function")
            select = selector$5(select);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
                if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    subgroup[i] = subnode;
                }
            }
        }
        return new Selection$9(subgroups, this._parents);
    }

    function empty$6() {
        return [];
    }
    function selectorAll$5 (selector) {
        return selector == null ? empty$6 : function () {
            return this.querySelectorAll(selector);
        };
    }

    function selection_selectAll$5 (select) {
        if (typeof select !== "function")
            select = selectorAll$5(select);
        for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    subgroups.push(select.call(node, node.__data__, i, group));
                    parents.push(node);
                }
            }
        }
        return new Selection$9(subgroups, parents);
    }

    function matcher$6 (selector) {
        return function () {
            return this.matches(selector);
        };
    }

    function selection_filter$5 (match) {
        if (typeof match !== "function")
            match = matcher$6(match);
        for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
                if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
                    subgroup.push(node);
                }
            }
        }
        return new Selection$9(subgroups, this._parents);
    }

    function sparse$5 (update) {
        return new Array(update.length);
    }

    function selection_enter$5 () {
        return new Selection$9(this._enter || this._groups.map(sparse$5), this._parents);
    }
    function EnterNode$5(parent, datum) {
        this.ownerDocument = parent.ownerDocument;
        this.namespaceURI = parent.namespaceURI;
        this._next = null;
        this._parent = parent;
        this.__data__ = datum;
    }
    EnterNode$5.prototype = {
        constructor: EnterNode$5,
        appendChild: function (child) { return this._parent.insertBefore(child, this._next); },
        insertBefore: function (child, next) { return this._parent.insertBefore(child, next); },
        querySelector: function (selector) { return this._parent.querySelector(selector); },
        querySelectorAll: function (selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$m (x) {
        return function () {
            return x;
        };
    }

    var keyPrefix$6 = "$"; // Protect against keys like “__proto__”.
    function bindIndex$5(parent, group, enter, update, exit, data) {
        var i = 0, node, groupLength = group.length, dataLength = data.length;
        // Put any non-null nodes that fit into update.
        // Put any null nodes into enter.
        // Put any remaining data into enter.
        for (; i < dataLength; ++i) {
            if (node = group[i]) {
                node.__data__ = data[i];
                update[i] = node;
            }
            else {
                enter[i] = new EnterNode$5(parent, data[i]);
            }
        }
        // Put any non-null nodes that don’t fit into exit.
        for (; i < groupLength; ++i) {
            if (node = group[i]) {
                exit[i] = node;
            }
        }
    }
    function bindKey$5(parent, group, enter, update, exit, data, key) {
        var i, node, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
        // Compute the key for each node.
        // If multiple nodes have the same key, the duplicates are added to exit.
        for (i = 0; i < groupLength; ++i) {
            if (node = group[i]) {
                keyValues[i] = keyValue = keyPrefix$6 + key.call(node, node.__data__, i, group);
                if (keyValue in nodeByKeyValue) {
                    exit[i] = node;
                }
                else {
                    nodeByKeyValue[keyValue] = node;
                }
            }
        }
        // Compute the key for each datum.
        // If there a node associated with this key, join and add it to update.
        // If there is not (or the key is a duplicate), add it to enter.
        for (i = 0; i < dataLength; ++i) {
            keyValue = keyPrefix$6 + key.call(parent, data[i], i, data);
            if (node = nodeByKeyValue[keyValue]) {
                update[i] = node;
                node.__data__ = data[i];
                nodeByKeyValue[keyValue] = null;
            }
            else {
                enter[i] = new EnterNode$5(parent, data[i]);
            }
        }
        // Add any remaining nodes that were not bound to data to exit.
        for (i = 0; i < groupLength; ++i) {
            if ((node = group[i]) && (nodeByKeyValue[keyValues[i]] === node)) {
                exit[i] = node;
            }
        }
    }
    function selection_data$5 (value, key) {
        if (!value) {
            data = new Array(this.size()), j = -1;
            this.each(function (d) { data[++j] = d; });
            return data;
        }
        var bind = key ? bindKey$5 : bindIndex$5, parents = this._parents, groups = this._groups;
        if (typeof value !== "function")
            value = constant$m(value);
        for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
            var parent = parents[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
            bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
            // Now connect the enter nodes to their following update node, such that
            // appendChild can insert the materialized enter node before this node,
            // rather than at the end of the parent node.
            for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
                if (previous = enterGroup[i0]) {
                    if (i0 >= i1)
                        i1 = i0 + 1;
                    while (!(next = updateGroup[i1]) && ++i1 < dataLength)
                        ;
                    previous._next = next || null;
                }
            }
        }
        update = new Selection$9(update, parents);
        update._enter = enter;
        update._exit = exit;
        return update;
    }

    function selection_exit$5 () {
        return new Selection$9(this._exit || this._groups.map(sparse$5), this._parents);
    }

    function selection_join$4 (onenter, onupdate, onexit) {
        var enter = this.enter(), update = this, exit = this.exit();
        enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
        if (onupdate != null)
            update = onupdate(update);
        if (onexit == null)
            exit.remove();
        else
            onexit(exit);
        return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge$5 (selection) {
        for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
            for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group0[i] || group1[i]) {
                    merge[i] = node;
                }
            }
        }
        for (; j < m0; ++j) {
            merges[j] = groups0[j];
        }
        return new Selection$9(merges, this._parents);
    }

    function selection_order$5 () {
        for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
            for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && node.compareDocumentPosition(next) ^ 4)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    }

    function selection_sort$5 (compare) {
        if (!compare)
            compare = ascending$9;
        function compareNode(a, b) {
            return a && b ? compare(a.__data__, b.__data__) : !a - !b;
        }
        for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
            for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
                if (node = group[i]) {
                    sortgroup[i] = node;
                }
            }
            sortgroup.sort(compareNode);
        }
        return new Selection$9(sortgroups, this._parents).order();
    }
    function ascending$9(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call$5 () {
        var callback = arguments[0];
        arguments[0] = this;
        callback.apply(null, arguments);
        return this;
    }

    function selection_nodes$5 () {
        var nodes = new Array(this.size()), i = -1;
        this.each(function () { nodes[++i] = this; });
        return nodes;
    }

    function selection_node$5 () {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    }

    function selection_size$5 () {
        var size = 0;
        this.each(function () { ++size; });
        return size;
    }

    function selection_empty$5 () {
        return !this.node();
    }

    function selection_each$5 (callback) {
        for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
                if (node = group[i])
                    callback.call(node, node.__data__, i, group);
            }
        }
        return this;
    }

    function attrRemove$9(name) {
        return function () {
            this.removeAttribute(name);
        };
    }
    function attrRemoveNS$9(fullname) {
        return function () {
            this.removeAttributeNS(fullname.space, fullname.local);
        };
    }
    function attrConstant$9(name, value) {
        return function () {
            this.setAttribute(name, value);
        };
    }
    function attrConstantNS$9(fullname, value) {
        return function () {
            this.setAttributeNS(fullname.space, fullname.local, value);
        };
    }
    function attrFunction$9(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, v);
        };
    }
    function attrFunctionNS$9(fullname, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.removeAttributeNS(fullname.space, fullname.local);
            else
                this.setAttributeNS(fullname.space, fullname.local, v);
        };
    }
    function selection_attr$5 (name, value) {
        var fullname = namespace$5(name);
        if (arguments.length < 2) {
            var node = this.node();
            return fullname.local
                ? node.getAttributeNS(fullname.space, fullname.local)
                : node.getAttribute(fullname);
        }
        return this.each((value == null
            ? (fullname.local ? attrRemoveNS$9 : attrRemove$9) : (typeof value === "function"
            ? (fullname.local ? attrFunctionNS$9 : attrFunction$9)
            : (fullname.local ? attrConstantNS$9 : attrConstant$9)))(fullname, value));
    }

    function defaultView$5 (node) {
        return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
            || (node.document && node) // node is a Window
            || node.defaultView; // node is a Document
    }

    function styleRemove$9(name) {
        return function () {
            this.style.removeProperty(name);
        };
    }
    function styleConstant$9(name, value, priority) {
        return function () {
            this.style.setProperty(name, value, priority);
        };
    }
    function styleFunction$9(name, value, priority) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, v, priority);
        };
    }
    function selection_style$5 (name, value, priority) {
        return arguments.length > 1
            ? this.each((value == null
                ? styleRemove$9 : typeof value === "function"
                ? styleFunction$9
                : styleConstant$9)(name, value, priority == null ? "" : priority))
            : styleValue$5(this.node(), name);
    }
    function styleValue$5(node, name) {
        return node.style.getPropertyValue(name)
            || defaultView$5(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove$5(name) {
        return function () {
            delete this[name];
        };
    }
    function propertyConstant$5(name, value) {
        return function () {
            this[name] = value;
        };
    }
    function propertyFunction$5(name, value) {
        return function () {
            var v = value.apply(this, arguments);
            if (v == null)
                delete this[name];
            else
                this[name] = v;
        };
    }
    function selection_property$5 (name, value) {
        return arguments.length > 1
            ? this.each((value == null
                ? propertyRemove$5 : typeof value === "function"
                ? propertyFunction$5
                : propertyConstant$5)(name, value))
            : this.node()[name];
    }

    function classArray$5(string) {
        return string.trim().split(/^|\s+/);
    }
    function classList$5(node) {
        return node.classList || new ClassList$5(node);
    }
    function ClassList$5(node) {
        this._node = node;
        this._names = classArray$5(node.getAttribute("class") || "");
    }
    ClassList$5.prototype = {
        add: function (name) {
            var i = this._names.indexOf(name);
            if (i < 0) {
                this._names.push(name);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        remove: function (name) {
            var i = this._names.indexOf(name);
            if (i >= 0) {
                this._names.splice(i, 1);
                this._node.setAttribute("class", this._names.join(" "));
            }
        },
        contains: function (name) {
            return this._names.indexOf(name) >= 0;
        }
    };
    function classedAdd$5(node, names) {
        var list = classList$5(node), i = -1, n = names.length;
        while (++i < n)
            list.add(names[i]);
    }
    function classedRemove$5(node, names) {
        var list = classList$5(node), i = -1, n = names.length;
        while (++i < n)
            list.remove(names[i]);
    }
    function classedTrue$5(names) {
        return function () {
            classedAdd$5(this, names);
        };
    }
    function classedFalse$5(names) {
        return function () {
            classedRemove$5(this, names);
        };
    }
    function classedFunction$5(names, value) {
        return function () {
            (value.apply(this, arguments) ? classedAdd$5 : classedRemove$5)(this, names);
        };
    }
    function selection_classed$5 (name, value) {
        var names = classArray$5(name + "");
        if (arguments.length < 2) {
            var list = classList$5(this.node()), i = -1, n = names.length;
            while (++i < n)
                if (!list.contains(names[i]))
                    return false;
            return true;
        }
        return this.each((typeof value === "function"
            ? classedFunction$5 : value
            ? classedTrue$5
            : classedFalse$5)(names, value));
    }

    function textRemove$5() {
        this.textContent = "";
    }
    function textConstant$9(value) {
        return function () {
            this.textContent = value;
        };
    }
    function textFunction$9(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        };
    }
    function selection_text$5 (value) {
        return arguments.length
            ? this.each(value == null
                ? textRemove$5 : (typeof value === "function"
                ? textFunction$9
                : textConstant$9)(value))
            : this.node().textContent;
    }

    function htmlRemove$5() {
        this.innerHTML = "";
    }
    function htmlConstant$5(value) {
        return function () {
            this.innerHTML = value;
        };
    }
    function htmlFunction$5(value) {
        return function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        };
    }
    function selection_html$5 (value) {
        return arguments.length
            ? this.each(value == null
                ? htmlRemove$5 : (typeof value === "function"
                ? htmlFunction$5
                : htmlConstant$5)(value))
            : this.node().innerHTML;
    }

    function raise$6() {
        if (this.nextSibling)
            this.parentNode.appendChild(this);
    }
    function selection_raise$5 () {
        return this.each(raise$6);
    }

    function lower$5() {
        if (this.previousSibling)
            this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }
    function selection_lower$5 () {
        return this.each(lower$5);
    }

    function selection_append$5 (name) {
        var create = typeof name === "function" ? name : creator$5(name);
        return this.select(function () {
            return this.appendChild(create.apply(this, arguments));
        });
    }

    function constantNull$5() {
        return null;
    }
    function selection_insert$5 (name, before) {
        var create = typeof name === "function" ? name : creator$5(name), select = before == null ? constantNull$5 : typeof before === "function" ? before : selector$5(before);
        return this.select(function () {
            return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
        });
    }

    function remove$5() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    function selection_remove$5 () {
        return this.each(remove$5);
    }

    function selection_cloneShallow$5() {
        var clone = this.cloneNode(false), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_cloneDeep$5() {
        var clone = this.cloneNode(true), parent = this.parentNode;
        return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }
    function selection_clone$5 (deep) {
        return this.select(deep ? selection_cloneDeep$5 : selection_cloneShallow$5);
    }

    function selection_datum$5 (value) {
        return arguments.length
            ? this.property("__data__", value)
            : this.node().__data__;
    }

    var filterEvents$5 = {};
    var event$4 = null;
    if (typeof document !== "undefined") {
        var element$6 = document.documentElement;
        if (!("onmouseenter" in element$6)) {
            filterEvents$5 = { mouseenter: "mouseover", mouseleave: "mouseout" };
        }
    }
    function filterContextListener$5(listener, index, group) {
        listener = contextListener$5(listener, index, group);
        return function (event) {
            var related = event.relatedTarget;
            if (!related || (related !== this && !(related.compareDocumentPosition(this) & 8))) {
                listener.call(this, event);
            }
        };
    }
    function contextListener$5(listener, index, group) {
        return function (event1) {
            var event0 = event$4; // Events can be reentrant (e.g., focus).
            event$4 = event1;
            try {
                listener.call(this, this.__data__, index, group);
            }
            finally {
                event$4 = event0;
            }
        };
    }
    function parseTypenames$a(typenames) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            return { type: t, name: name };
        });
    }
    function onRemove$5(typename) {
        return function () {
            var on = this.__on;
            if (!on)
                return;
            for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
                if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
                    this.removeEventListener(o.type, o.listener, o.capture);
                }
                else {
                    on[++i] = o;
                }
            }
            if (++i)
                on.length = i;
            else
                delete this.__on;
        };
    }
    function onAdd$5(typename, value, capture) {
        var wrap = filterEvents$5.hasOwnProperty(typename.type) ? filterContextListener$5 : contextListener$5;
        return function (d, i, group) {
            var on = this.__on, o, listener = wrap(value, i, group);
            if (on)
                for (var j = 0, m = on.length; j < m; ++j) {
                    if ((o = on[j]).type === typename.type && o.name === typename.name) {
                        this.removeEventListener(o.type, o.listener, o.capture);
                        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
                        o.value = value;
                        return;
                    }
                }
            this.addEventListener(typename.type, listener, capture);
            o = { type: typename.type, name: typename.name, value: value, listener: listener, capture: capture };
            if (!on)
                this.__on = [o];
            else
                on.push(o);
        };
    }
    function selection_on$5 (typename, value, capture) {
        var typenames = parseTypenames$a(typename + ""), i, n = typenames.length, t;
        if (arguments.length < 2) {
            var on = this.node().__on;
            if (on)
                for (var j = 0, m = on.length, o; j < m; ++j) {
                    for (i = 0, o = on[j]; i < n; ++i) {
                        if ((t = typenames[i]).type === o.type && t.name === o.name) {
                            return o.value;
                        }
                    }
                }
            return;
        }
        on = value ? onAdd$5 : onRemove$5;
        if (capture == null)
            capture = false;
        for (i = 0; i < n; ++i)
            this.each(on(typenames[i], value, capture));
        return this;
    }
    function customEvent$3(event1, listener, that, args) {
        var event0 = event$4;
        event1.sourceEvent = event$4;
        event$4 = event1;
        try {
            return listener.apply(that, args);
        }
        finally {
            event$4 = event0;
        }
    }

    function dispatchEvent$5(node, type, params) {
        var window = defaultView$5(node), event = window.CustomEvent;
        if (typeof event === "function") {
            event = new event(type, params);
        }
        else {
            event = window.document.createEvent("Event");
            if (params)
                event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
            else
                event.initEvent(type, false, false);
        }
        node.dispatchEvent(event);
    }
    function dispatchConstant$5(type, params) {
        return function () {
            return dispatchEvent$5(this, type, params);
        };
    }
    function dispatchFunction$5(type, params) {
        return function () {
            return dispatchEvent$5(this, type, params.apply(this, arguments));
        };
    }
    function selection_dispatch$5 (type, params) {
        return this.each((typeof params === "function"
            ? dispatchFunction$5
            : dispatchConstant$5)(type, params));
    }

    var root$6 = [null];
    function Selection$9(groups, parents) {
        this._groups = groups;
        this._parents = parents;
    }
    Selection$9.prototype = {
        constructor: Selection$9,
        select: selection_select$5,
        selectAll: selection_selectAll$5,
        filter: selection_filter$5,
        data: selection_data$5,
        enter: selection_enter$5,
        exit: selection_exit$5,
        join: selection_join$4,
        merge: selection_merge$5,
        order: selection_order$5,
        sort: selection_sort$5,
        call: selection_call$5,
        nodes: selection_nodes$5,
        node: selection_node$5,
        size: selection_size$5,
        empty: selection_empty$5,
        each: selection_each$5,
        attr: selection_attr$5,
        style: selection_style$5,
        property: selection_property$5,
        classed: selection_classed$5,
        text: selection_text$5,
        html: selection_html$5,
        raise: selection_raise$5,
        lower: selection_lower$5,
        append: selection_append$5,
        insert: selection_insert$5,
        remove: selection_remove$5,
        clone: selection_clone$5,
        datum: selection_datum$5,
        on: selection_on$5,
        dispatch: selection_dispatch$5
    };

    function select$4 (selector) {
        return typeof selector === "string"
            ? new Selection$9([[document.querySelector(selector)]], [document.documentElement])
            : new Selection$9([[selector]], root$6);
    }

    function sourceEvent$3 () {
        var current = event$4, source;
        while (source = current.sourceEvent)
            current = source;
        return current;
    }

    function point$9 (node, event) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            point.x = event.clientX, point.y = event.clientY;
            point = point.matrixTransform(node.getScreenCTM().inverse());
            return [point.x, point.y];
        }
        var rect = node.getBoundingClientRect();
        return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }

    function mouse$3 (node) {
        var event = sourceEvent$3();
        if (event.changedTouches)
            event = event.changedTouches[0];
        return point$9(node, event);
    }

    function touch$3 (node, touches, identifier) {
        if (arguments.length < 3)
            identifier = touches, touches = sourceEvent$3().changedTouches;
        for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
            if ((touch = touches[i]).identifier === identifier) {
                return point$9(node, touch);
            }
        }
        return null;
    }

    function nopropagation$3() {
        event$4.stopImmediatePropagation();
    }
    function noevent$4 () {
        event$4.preventDefault();
        event$4.stopImmediatePropagation();
    }

    function nodrag$1 (view) {
        var root = view.document.documentElement, selection = select$4(view).on("dragstart.drag", noevent$4, true);
        if ("onselectstart" in root) {
            selection.on("selectstart.drag", noevent$4, true);
        }
        else {
            root.__noselect = root.style.MozUserSelect;
            root.style.MozUserSelect = "none";
        }
    }
    function yesdrag$2(view, noclick) {
        var root = view.document.documentElement, selection = select$4(view).on("dragstart.drag", null);
        if (noclick) {
            selection.on("click.drag", noevent$4, true);
            setTimeout(function () { selection.on("click.drag", null); }, 0);
        }
        if ("onselectstart" in root) {
            selection.on("selectstart.drag", null);
        }
        else {
            root.style.MozUserSelect = root.__noselect;
            delete root.__noselect;
        }
    }

    function constant$n (x) {
        return function () {
            return x;
        };
    }

    function DragEvent$1(target, type, subject, id, active, x, y, dx, dy, dispatch) {
        this.target = target;
        this.type = type;
        this.subject = subject;
        this.identifier = id;
        this.active = active;
        this.x = x;
        this.y = y;
        this.dx = dx;
        this.dy = dy;
        this._ = dispatch;
    }
    DragEvent$1.prototype.on = function () {
        var value = this._.on.apply(this._, arguments);
        return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$3() {
        return !event$4.button;
    }
    function defaultContainer$1() {
        return this.parentNode;
    }
    function defaultSubject$1(d) {
        return d == null ? { x: event$4.x, y: event$4.y } : d;
    }
    function defaultTouchable$2() {
        return "ontouchstart" in this;
    }
    function drag$1 () {
        var filter = defaultFilter$3, container = defaultContainer$1, subject = defaultSubject$1, touchable = defaultTouchable$2, gestures = {}, listeners = dispatch$4("start", "drag", "end"), active = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
        function drag(selection) {
            selection
                .on("mousedown.drag", mousedowned)
                .filter(touchable)
                .on("touchstart.drag", touchstarted)
                .on("touchmove.drag", touchmoved)
                .on("touchend.drag touchcancel.drag", touchended)
                .style("touch-action", "none")
                .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
        }
        function mousedowned() {
            if (touchending || !filter.apply(this, arguments))
                return;
            var gesture = beforestart("mouse", container.apply(this, arguments), mouse$3, this, arguments);
            if (!gesture)
                return;
            select$4(event$4.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
            nodrag$1(event$4.view);
            nopropagation$3();
            mousemoving = false;
            mousedownx = event$4.clientX;
            mousedowny = event$4.clientY;
            gesture("start");
        }
        function mousemoved() {
            noevent$4();
            if (!mousemoving) {
                var dx = event$4.clientX - mousedownx, dy = event$4.clientY - mousedowny;
                mousemoving = dx * dx + dy * dy > clickDistance2;
            }
            gestures.mouse("drag");
        }
        function mouseupped() {
            select$4(event$4.view).on("mousemove.drag mouseup.drag", null);
            yesdrag$2(event$4.view, mousemoving);
            noevent$4();
            gestures.mouse("end");
        }
        function touchstarted() {
            if (!filter.apply(this, arguments))
                return;
            var touches = event$4.changedTouches, c = container.apply(this, arguments), n = touches.length, i, gesture;
            for (i = 0; i < n; ++i) {
                if (gesture = beforestart(touches[i].identifier, c, touch$3, this, arguments)) {
                    nopropagation$3();
                    gesture("start");
                }
            }
        }
        function touchmoved() {
            var touches = event$4.changedTouches, n = touches.length, i, gesture;
            for (i = 0; i < n; ++i) {
                if (gesture = gestures[touches[i].identifier]) {
                    noevent$4();
                    gesture("drag");
                }
            }
        }
        function touchended() {
            var touches = event$4.changedTouches, n = touches.length, i, gesture;
            if (touchending)
                clearTimeout(touchending);
            touchending = setTimeout(function () { touchending = null; }, 500); // Ghost clicks are delayed!
            for (i = 0; i < n; ++i) {
                if (gesture = gestures[touches[i].identifier]) {
                    nopropagation$3();
                    gesture("end");
                }
            }
        }
        function beforestart(id, container, point, that, args) {
            var p = point(container, id), s, dx, dy, sublisteners = listeners.copy();
            if (!customEvent$3(new DragEvent$1(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
                if ((event$4.subject = s = subject.apply(that, args)) == null)
                    return false;
                dx = s.x - p[0] || 0;
                dy = s.y - p[1] || 0;
                return true;
            }))
                return;
            return function gesture(type) {
                var p0 = p, n;
                switch (type) {
                    case "start":
                        gestures[id] = gesture, n = active++;
                        break;
                    case "end": delete gestures[id], --active; // nobreak
                    case "drag":
                        p = point(container, id), n = active;
                        break;
                }
                customEvent$3(new DragEvent$1(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
            };
        }
        drag.filter = function (_) {
            return arguments.length ? (filter = typeof _ === "function" ? _ : constant$n(!!_), drag) : filter;
        };
        drag.container = function (_) {
            return arguments.length ? (container = typeof _ === "function" ? _ : constant$n(_), drag) : container;
        };
        drag.subject = function (_) {
            return arguments.length ? (subject = typeof _ === "function" ? _ : constant$n(_), drag) : subject;
        };
        drag.touchable = function (_) {
            return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$n(!!_), drag) : touchable;
        };
        drag.on = function () {
            var value = listeners.on.apply(listeners, arguments);
            return value === listeners ? drag : value;
        };
        drag.clickDistance = function (_) {
            return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
        };
        return drag;
    }

    function constant$o (x) {
        return function constant() {
            return x;
        };
    }

    var epsilon$9 = 1e-12;
    var pi$8 = Math.PI;
    var halfPi$4 = pi$8 / 2;
    var tau$8 = 2 * pi$8;

    function arcInnerRadius$1(d) {
        return d.innerRadius;
    }
    function arcOuterRadius$1(d) {
        return d.outerRadius;
    }
    function arcStartAngle$1(d) {
        return d.startAngle;
    }
    function arcEndAngle$1(d) {
        return d.endAngle;
    }
    function arcPadAngle$1(d) {
        return d && d.padAngle; // Note: optional!
    }
    function asin$2(x) {
        return x >= 1 ? halfPi$4 : x <= -1 ? -halfPi$4 : Math.asin(x);
    }
    function intersect$1(x0, y0, x1, y1, x2, y2, x3, y3) {
        var x10 = x1 - x0, y10 = y1 - y0, x32 = x3 - x2, y32 = y3 - y2, t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
        return [x0 + t * x10, y0 + t * y10];
    }
    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents$1(x0, y0, x1, y1, r1, rc, cw) {
        var x01 = x0 - x1, y01 = y0 - y1, lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x0 + ox, y11 = y0 + oy, x10 = x1 + ox, y10 = y1 + oy, x00 = (x11 + x10) / 2, y00 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x00, dy0 = cy0 - y00, dx1 = cx1 - x00, dy1 = cy1 - y00;
        // Pick the closer of the two intersection points.
        // TODO Is there a faster way to determine which intersection to use?
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
            cx0 = cx1, cy0 = cy1;
        return {
            cx: cx0,
            cy: cy0,
            x01: -ox,
            y01: -oy,
            x11: cx0 * (r1 / r - 1),
            y11: cy0 * (r1 / r - 1)
        };
    }
    function arc$1 () {
        var innerRadius = arcInnerRadius$1, outerRadius = arcOuterRadius$1, cornerRadius = constant$o(0), padRadius = null, startAngle = arcStartAngle$1, endAngle = arcEndAngle$1, padAngle = arcPadAngle$1, context = null;
        function arc() {
            var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi$4, a1 = endAngle.apply(this, arguments) - halfPi$4, da = Math.abs(a1 - a0), cw = a1 > a0;
            if (!context)
                context = buffer = path();
            // Ensure that the outer radius is always larger than the inner radius.
            if (r1 < r0)
                r = r1, r1 = r0, r0 = r;
            // Is it a point?
            if (!(r1 > epsilon$9))
                context.moveTo(0, 0);
            // Or is it a circle or annulus?
            else if (da > tau$8 - epsilon$9) {
                context.moveTo(r1 * Math.cos(a0), r1 * Math.sin(a0));
                context.arc(0, 0, r1, a0, a1, !cw);
                if (r0 > epsilon$9) {
                    context.moveTo(r0 * Math.cos(a1), r0 * Math.sin(a1));
                    context.arc(0, 0, r0, a1, a0, cw);
                }
            }
            // Or is it a circular or annular sector?
            else {
                var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = (ap > epsilon$9) && (padRadius ? +padRadius.apply(this, arguments) : Math.sqrt(r0 * r0 + r1 * r1)), rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
                // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.
                if (rp > epsilon$9) {
                    var p0 = asin$2(rp / r0 * Math.sin(ap)), p1 = asin$2(rp / r1 * Math.sin(ap));
                    if ((da0 -= p0 * 2) > epsilon$9)
                        p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
                    else
                        da0 = 0, a00 = a10 = (a0 + a1) / 2;
                    if ((da1 -= p1 * 2) > epsilon$9)
                        p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
                    else
                        da1 = 0, a01 = a11 = (a0 + a1) / 2;
                }
                var x01 = r1 * Math.cos(a01), y01 = r1 * Math.sin(a01), x10 = r0 * Math.cos(a10), y10 = r0 * Math.sin(a10);
                // Apply rounded corners?
                if (rc > epsilon$9) {
                    var x11 = r1 * Math.cos(a11), y11 = r1 * Math.sin(a11), x00 = r0 * Math.cos(a00), y00 = r0 * Math.sin(a00);
                    // Restrict the corner radius according to the sector angle.
                    if (da < pi$8) {
                        var oc = da0 > epsilon$9 ? intersect$1(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10], ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                        rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                        rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
                    }
                }
                // Is the sector collapsed to a line?
                if (!(da1 > epsilon$9))
                    context.moveTo(x01, y01);
                // Does the sector’s outer ring have rounded corners?
                else if (rc1 > epsilon$9) {
                    t0 = cornerTangents$1(x00, y00, x01, y01, r1, rc1, cw);
                    t1 = cornerTangents$1(x11, y11, x10, y10, r1, rc1, cw);
                    context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
                    // Have the corners merged?
                    if (rc1 < rc)
                        context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);
                    // Otherwise, draw the two corners and the ring.
                    else {
                        context.arc(t0.cx, t0.cy, rc1, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
                        context.arc(0, 0, r1, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                        context.arc(t1.cx, t1.cy, rc1, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
                    }
                }
                // Or is the outer ring just a circular arc?
                else
                    context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
                // Is there no inner ring, and it’s a circular sector?
                // Or perhaps it’s an annular sector collapsed due to padding?
                if (!(r0 > epsilon$9) || !(da0 > epsilon$9))
                    context.lineTo(x10, y10);
                // Does the sector’s inner ring (or point) have rounded corners?
                else if (rc0 > epsilon$9) {
                    t0 = cornerTangents$1(x10, y10, x11, y11, r0, -rc0, cw);
                    t1 = cornerTangents$1(x01, y01, x00, y00, r0, -rc0, cw);
                    context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
                    // Have the corners merged?
                    if (rc0 < rc)
                        context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t1.y01, t1.x01), !cw);
                    // Otherwise, draw the two corners and the ring.
                    else {
                        context.arc(t0.cx, t0.cy, rc0, Math.atan2(t0.y01, t0.x01), Math.atan2(t0.y11, t0.x11), !cw);
                        context.arc(0, 0, r0, Math.atan2(t0.cy + t0.y11, t0.cx + t0.x11), Math.atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                        context.arc(t1.cx, t1.cy, rc0, Math.atan2(t1.y11, t1.x11), Math.atan2(t1.y01, t1.x01), !cw);
                    }
                }
                // Or is the inner ring just a circular arc?
                else
                    context.arc(0, 0, r0, a10, a00, cw);
            }
            context.closePath();
            if (buffer)
                return context = null, buffer + "" || null;
        }
        arc.centroid = function () {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$8 / 2;
            return [Math.cos(a) * r, Math.sin(a) * r];
        };
        arc.innerRadius = function (_) {
            return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$o(+_), arc) : innerRadius;
        };
        arc.outerRadius = function (_) {
            return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$o(+_), arc) : outerRadius;
        };
        arc.cornerRadius = function (_) {
            return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$o(+_), arc) : cornerRadius;
        };
        arc.padRadius = function (_) {
            return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$o(+_), arc) : padRadius;
        };
        arc.startAngle = function (_) {
            return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$o(+_), arc) : startAngle;
        };
        arc.endAngle = function (_) {
            return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$o(+_), arc) : endAngle;
        };
        arc.padAngle = function (_) {
            return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$o(+_), arc) : padAngle;
        };
        arc.context = function (_) {
            return arguments.length ? ((context = _ == null ? null : _), arc) : context;
        };
        return arc;
    }

    function Linear$1(context) {
        this._context = context;
    }
    Linear$1.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._point = 0;
        },
        lineEnd: function () {
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1: this._point = 2; // proceed
                default:
                    this._context.lineTo(x, y);
                    break;
            }
        }
    };
    function curveLinear$1 (context) {
        return new Linear$1(context);
    }

    function x$7(p) {
        return p[0];
    }
    function y$6(p) {
        return p[1];
    }

    function line$1 () {
        var x = x$7, y = y$6, defined = constant$o(true), context = null, curve = curveLinear$1, output = null;
        function line(data) {
            var i, n = data.length, d, defined0 = false, buffer;
            if (context == null)
                output = curve(buffer = path());
            for (i = 0; i <= n; ++i) {
                if (!(i < n && defined(d = data[i], i, data)) === defined0) {
                    if (defined0 = !defined0)
                        output.lineStart();
                    else
                        output.lineEnd();
                }
                if (defined0)
                    output.point(+x(d, i, data), +y(d, i, data));
            }
            if (buffer)
                return output = null, buffer + "" || null;
        }
        line.x = function (_) {
            return arguments.length ? (x = typeof _ === "function" ? _ : constant$o(+_), line) : x;
        };
        line.y = function (_) {
            return arguments.length ? (y = typeof _ === "function" ? _ : constant$o(+_), line) : y;
        };
        line.defined = function (_) {
            return arguments.length ? (defined = typeof _ === "function" ? _ : constant$o(!!_), line) : defined;
        };
        line.curve = function (_) {
            return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
        };
        line.context = function (_) {
            return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
        };
        return line;
    }

    function point$a(that, x, y) {
        that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
    }
    function Cardinal$1(context, tension) {
        this._context = context;
        this._k = (1 - tension) / 6;
    }
    Cardinal$1.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 = this._x2 =
                this._y0 = this._y1 = this._y2 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 2:
                    this._context.lineTo(this._x2, this._y2);
                    break;
                case 3:
                    point$a(this, this._x1, this._y1);
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1:
                    this._point = 2;
                    this._x1 = x, this._y1 = y;
                    break;
                case 2: this._point = 3; // proceed
                default:
                    point$a(this, x, y);
                    break;
            }
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
    };

    function point$b(that, x, y) {
        var x1 = that._x1, y1 = that._y1, x2 = that._x2, y2 = that._y2;
        if (that._l01_a > epsilon$9) {
            var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
            x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
            y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
        }
        if (that._l23_a > epsilon$9) {
            var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
            x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
            y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
        }
        that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }
    function CatmullRom$1(context, alpha) {
        this._context = context;
        this._alpha = alpha;
    }
    CatmullRom$1.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 = this._x2 =
                this._y0 = this._y1 = this._y2 = NaN;
            this._l01_a = this._l12_a = this._l23_a =
                this._l01_2a = this._l12_2a = this._l23_2a =
                    this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 2:
                    this._context.lineTo(this._x2, this._y2);
                    break;
                case 3:
                    this.point(this._x2, this._y2);
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            x = +x, y = +y;
            if (this._point) {
                var x23 = this._x2 - x, y23 = this._y2 - y;
                this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
            }
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2: this._point = 3; // proceed
                default:
                    point$b(this, x, y);
                    break;
            }
            this._l01_a = this._l12_a, this._l12_a = this._l23_a;
            this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
            this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
            this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
        }
    };
    var curveCatmullRom = (function custom(alpha) {
        function catmullRom(context) {
            return alpha ? new CatmullRom$1(context, alpha) : new Cardinal$1(context, 0);
        }
        catmullRom.alpha = function (alpha) {
            return custom(+alpha);
        };
        return catmullRom;
    })(0.5);

    function sign$3(x) {
        return x < 0 ? -1 : 1;
    }
    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3$2(that, x2, y2) {
        var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
        return (sign$3(s0) + sign$3(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }
    // Calculate a one-sided slope.
    function slope2$2(that, t) {
        var h = that._x1 - that._x0;
        return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }
    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bézier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point$c(that, t0, t1) {
        var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
        that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }
    function MonotoneX$2(context) {
        this._context = context;
    }
    MonotoneX$2.prototype = {
        areaStart: function () {
            this._line = 0;
        },
        areaEnd: function () {
            this._line = NaN;
        },
        lineStart: function () {
            this._x0 = this._x1 =
                this._y0 = this._y1 =
                    this._t0 = NaN;
            this._point = 0;
        },
        lineEnd: function () {
            switch (this._point) {
                case 2:
                    this._context.lineTo(this._x1, this._y1);
                    break;
                case 3:
                    point$c(this, this._t0, slope2$2(this, this._t0));
                    break;
            }
            if (this._line || (this._line !== 0 && this._point === 1))
                this._context.closePath();
            this._line = 1 - this._line;
        },
        point: function (x, y) {
            var t1 = NaN;
            x = +x, y = +y;
            if (x === this._x1 && y === this._y1)
                return; // Ignore coincident points.
            switch (this._point) {
                case 0:
                    this._point = 1;
                    this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
                    break;
                case 1:
                    this._point = 2;
                    break;
                case 2:
                    this._point = 3;
                    point$c(this, slope2$2(this, t1 = slope3$2(this, x, y)), t1);
                    break;
                default:
                    point$c(this, this._t0, t1 = slope3$2(this, x, y));
                    break;
            }
            this._x0 = this._x1, this._x1 = x;
            this._y0 = this._y1, this._y1 = y;
            this._t0 = t1;
        }
    };
    (Object.create(MonotoneX$2.prototype)).point = function (x, y) {
        MonotoneX$2.prototype.point.call(this, y, x);
    };

    var noop$7 = { value: function () { } };
    function dispatch$5() {
        for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
            if (!(t = arguments[i] + "") || (t in _))
                throw new Error("illegal type: " + t);
            _[t] = [];
        }
        return new Dispatch$5(_);
    }
    function Dispatch$5(_) {
        this._ = _;
    }
    function parseTypenames$b(typenames, types) {
        return typenames.trim().split(/^|\s+/).map(function (t) {
            var name = "", i = t.indexOf(".");
            if (i >= 0)
                name = t.slice(i + 1), t = t.slice(0, i);
            if (t && !types.hasOwnProperty(t))
                throw new Error("unknown type: " + t);
            return { type: t, name: name };
        });
    }
    Dispatch$5.prototype = dispatch$5.prototype = {
        constructor: Dispatch$5,
        on: function (typename, callback) {
            var _ = this._, T = parseTypenames$b(typename + "", _), t, i = -1, n = T.length;
            // If no callback was specified, return the callback of the given type and name.
            if (arguments.length < 2) {
                while (++i < n)
                    if ((t = (typename = T[i]).type) && (t = get$9(_[t], typename.name)))
                        return t;
                return;
            }
            // If a type was specified, set the callback for the given type and name.
            // Otherwise, if a null callback was specified, remove callbacks of the given name.
            if (callback != null && typeof callback !== "function")
                throw new Error("invalid callback: " + callback);
            while (++i < n) {
                if (t = (typename = T[i]).type)
                    _[t] = set$c(_[t], typename.name, callback);
                else if (callback == null)
                    for (t in _)
                        _[t] = set$c(_[t], typename.name, null);
            }
            return this;
        },
        copy: function () {
            var copy = {}, _ = this._;
            for (var t in _)
                copy[t] = _[t].slice();
            return new Dispatch$5(copy);
        },
        call: function (type, that) {
            if ((n = arguments.length - 2) > 0)
                for (var args = new Array(n), i = 0, n, t; i < n; ++i)
                    args[i] = arguments[i + 2];
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        },
        apply: function (type, that, args) {
            if (!this._.hasOwnProperty(type))
                throw new Error("unknown type: " + type);
            for (var t = this._[type], i = 0, n = t.length; i < n; ++i)
                t[i].value.apply(that, args);
        }
    };
    function get$9(type, name) {
        for (var i = 0, n = type.length, c; i < n; ++i) {
            if ((c = type[i]).name === name) {
                return c.value;
            }
        }
    }
    function set$c(type, name, callback) {
        for (var i = 0, n = type.length; i < n; ++i) {
            if (type[i].name === name) {
                type[i] = noop$7, type = type.slice(0, i).concat(type.slice(i + 1));
                break;
            }
        }
        if (callback != null)
            type.push({ name: name, value: callback });
        return type;
    }

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
        return typeof obj;
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var classCallCheck = function (instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    };
    var createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor)
                    descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }
        return function (Constructor, protoProps, staticProps) {
            if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
                defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();
    var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    var get$a = function get(object, property, receiver) {
        if (object === null)
            object = Function.prototype;
        var desc = Object.getOwnPropertyDescriptor(object, property);
        if (desc === undefined) {
            var parent = Object.getPrototypeOf(object);
            if (parent === null) {
                return undefined;
            }
            else {
                return get(parent, property, receiver);
            }
        }
        else if ("value" in desc) {
            return desc.value;
        }
        else {
            var getter = desc.get;
            if (getter === undefined) {
                return undefined;
            }
            return getter.call(receiver);
        }
    };
    var inherits = function (subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass)
            Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    };
    var possibleConstructorReturn = function (self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return call && (typeof call === "object" || typeof call === "function") ? call : self;
    };
    var toConsumableArray = function (arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
                arr2[i] = arr[i];
            return arr2;
        }
        else {
            return Array.from(arr);
        }
    };
    var Annotation = function () {
        function Annotation(_ref) {
            var _ref$x = _ref.x, x = _ref$x === undefined ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === undefined ? 0 : _ref$y, nx = _ref.nx, ny = _ref.ny, _ref$dy = _ref.dy, dy = _ref$dy === undefined ? 0 : _ref$dy, _ref$dx = _ref.dx, dx = _ref$dx === undefined ? 0 : _ref$dx, _ref$color = _ref.color, color = _ref$color === undefined ? "grey" : _ref$color, data = _ref.data, type = _ref.type, subject = _ref.subject, connector = _ref.connector, note = _ref.note, disable = _ref.disable, id = _ref.id, className = _ref.className;
            classCallCheck(this, Annotation);
            this._dx = nx !== undefined ? nx - x : dx;
            this._dy = ny !== undefined ? ny - y : dy;
            this._x = x;
            this._y = y;
            this._color = color;
            this.id = id;
            this._className = className || "";
            this._type = type || "";
            this.data = data;
            this.note = note || {};
            this.connector = connector || {};
            this.subject = subject || {};
            this.disable = disable || [];
        }
        createClass(Annotation, [{
                key: "updatePosition",
                value: function updatePosition() {
                    if (this.type.setPosition) {
                        this.type.setPosition();
                        if (this.type.subject && this.type.subject.selectAll(":not(.handle)").nodes().length !== 0) {
                            this.type.redrawSubject();
                        }
                    }
                }
            }, {
                key: "clearComponents",
                value: function clearComponents() {
                    this.type.clearComponents && this.type.clearComponents();
                }
            }, {
                key: "updateOffset",
                value: function updateOffset() {
                    if (this.type.setOffset) {
                        this.type.setOffset();
                        if (this.type.connector.selectAll(":not(.handle)").nodes().length !== 0) {
                            this.type.redrawConnector();
                        }
                        this.type.redrawNote();
                    }
                }
            }, {
                key: "className",
                get: function get$$1() {
                    return this._className;
                },
                set: function set$$1(className) {
                    this._className = className;
                    if (this.type.setClassName)
                        this.type.setClassName();
                }
            }, {
                key: "type",
                get: function get$$1() {
                    return this._type;
                },
                set: function set$$1(type) {
                    this._type = type;
                    this.clearComponents();
                }
            }, {
                key: "x",
                get: function get$$1() {
                    return this._x;
                },
                set: function set$$1(x) {
                    this._x = x;
                    this.updatePosition();
                }
            }, {
                key: "y",
                get: function get$$1() {
                    return this._y;
                },
                set: function set$$1(y) {
                    this._y = y;
                    this.updatePosition();
                }
            }, {
                key: "color",
                get: function get$$1() {
                    return this._color;
                },
                set: function set$$1(color) {
                    this._color = color;
                    this.updatePosition();
                }
            }, {
                key: "dx",
                get: function get$$1() {
                    return this._dx;
                },
                set: function set$$1(dx) {
                    this._dx = dx;
                    this.updateOffset();
                }
            }, {
                key: "dy",
                get: function get$$1() {
                    return this._dy;
                },
                set: function set$$1(dy) {
                    this._dy = dy;
                    this.updateOffset();
                }
            }, {
                key: "nx",
                set: function set$$1(nx) {
                    this._dx = nx - this._x;
                    this.updateOffset();
                }
            }, {
                key: "ny",
                set: function set$$1(ny) {
                    this._dy = ny - this._y;
                    this.updateOffset();
                }
            }, {
                key: "offset",
                get: function get$$1() {
                    return { x: this._dx, y: this._dy };
                },
                set: function set$$1(_ref2) {
                    var x = _ref2.x, y = _ref2.y;
                    this._dx = x;
                    this._dy = y;
                    this.updateOffset();
                }
            }, {
                key: "position",
                get: function get$$1() {
                    return { x: this._x, y: this._y };
                },
                set: function set$$1(_ref3) {
                    var x = _ref3.x, y = _ref3.y;
                    this._x = x;
                    this._y = y;
                    this.updatePosition();
                }
            }, {
                key: "translation",
                get: function get$$1() {
                    return {
                        x: this._x + this._dx,
                        y: this._y + this._dy
                    };
                }
            }, {
                key: "json",
                get: function get$$1() {
                    var json = {
                        x: this._x,
                        y: this._y,
                        dx: this._dx,
                        dy: this._dy
                    };
                    if (this.data && Object.keys(this.data).length > 0)
                        json.data = this.data;
                    if (this.type)
                        json.type = this.type;
                    if (this._className)
                        json.className = this._className;
                    if (Object.keys(this.connector).length > 0)
                        json.connector = this.connector;
                    if (Object.keys(this.subject).length > 0)
                        json.subject = this.subject;
                    if (Object.keys(this.note).length > 0)
                        json.note = this.note;
                    return json;
                }
            }]);
        return Annotation;
    }();
    var AnnotationCollection = function () {
        function AnnotationCollection(_ref) {
            var annotations = _ref.annotations, accessors = _ref.accessors, accessorsInverse = _ref.accessorsInverse;
            classCallCheck(this, AnnotationCollection);
            this.accessors = accessors;
            this.accessorsInverse = accessorsInverse;
            this.annotations = annotations;
        }
        createClass(AnnotationCollection, [{
                key: "clearTypes",
                value: function clearTypes(newSettings) {
                    this.annotations.forEach(function (d) {
                        d.type = undefined;
                        d.subject = newSettings && newSettings.subject || d.subject;
                        d.connector = newSettings && newSettings.connector || d.connector;
                        d.note = newSettings && newSettings.note || d.note;
                    });
                }
            }, {
                key: "setPositionWithAccessors",
                value: function setPositionWithAccessors() {
                    var _this = this;
                    this.annotations.forEach(function (d) {
                        d.type.setPositionWithAccessors(_this.accessors);
                    });
                }
            }, {
                key: "editMode",
                value: function editMode(_editMode) {
                    this.annotations.forEach(function (a) {
                        if (a.type) {
                            a.type.editMode = _editMode;
                            a.type.updateEditMode();
                        }
                    });
                }
            }, {
                key: "updateDisable",
                value: function updateDisable(disable) {
                    this.annotations.forEach(function (a) {
                        a.disable = disable;
                        if (a.type) {
                            disable.forEach(function (d) {
                                if (a.type[d]) {
                                    a.type[d].remove && a.type[d].remove();
                                    a.type[d] = undefined;
                                }
                            });
                        }
                    });
                }
            }, {
                key: "updateTextWrap",
                value: function updateTextWrap(textWrap) {
                    this.annotations.forEach(function (a) {
                        if (a.type && a.type.updateTextWrap) {
                            a.type.updateTextWrap(textWrap);
                        }
                    });
                }
            }, {
                key: "updateText",
                value: function updateText() {
                    this.annotations.forEach(function (a) {
                        if (a.type && a.type.drawText) {
                            a.type.drawText();
                        }
                    });
                }
            }, {
                key: "updateNotePadding",
                value: function updateNotePadding(notePadding) {
                    this.annotations.forEach(function (a) {
                        if (a.type) {
                            a.type.notePadding = notePadding;
                        }
                    });
                }
            }, {
                key: "json",
                get: function get$$1() {
                    var _this2 = this;
                    return this.annotations.map(function (a) {
                        var json = a.json;
                        if (_this2.accessorsInverse && a.data) {
                            json.data = {};
                            Object.keys(_this2.accessorsInverse).forEach(function (k) {
                                json.data[k] = _this2.accessorsInverse[k]({ x: a.x, y: a.y });
                                //TODO make this feasible to map back to data for other types of subjects
                            });
                        }
                        return json;
                    });
                }
            }, {
                key: "noteNodes",
                get: function get$$1() {
                    return this.annotations.map(function (a) {
                        return _extends({}, a.type.getNoteBBoxOffset(), { positionX: a.x, positionY: a.y });
                    });
                }
                //TODO: come back and rethink if a.x and a.y are applicable in all situations
                // get connectorNodes() {
                //   return this.annotations.map(a => ({ ...a.type.getConnectorBBox(), startX: a.x, startY: a.y}))
                // }
                // get subjectNodes() {
                //   return this.annotations.map(a => ({ ...a.type.getSubjectBBox(), startX: a.x, startY: a.y}))
                // }
                // get annotationNodes() {
                //   return this.annotations.map(a => ({ ...a.type.getAnnotationBBox(), startX: a.x, startY: a.y}))
                // }
            }]);
        return AnnotationCollection;
    }();
    var pointHandle = function pointHandle(_ref) {
        var _ref$cx = _ref.cx, cx = _ref$cx === undefined ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === undefined ? 0 : _ref$cy;
        return { move: { x: cx, y: cy } };
    };
    var circleHandles = function circleHandles(_ref2) {
        var _ref2$cx = _ref2.cx, cx = _ref2$cx === undefined ? 0 : _ref2$cx, _ref2$cy = _ref2.cy, cy = _ref2$cy === undefined ? 0 : _ref2$cy, r1 = _ref2.r1, r2 = _ref2.r2, padding = _ref2.padding;
        var h = { move: { x: cx, y: cy } };
        if (r1 !== undefined) {
            h.r1 = { x: cx + r1 / Math.sqrt(2), y: cy + r1 / Math.sqrt(2) };
        }
        if (r2 !== undefined) {
            h.r2 = { x: cx + r2 / Math.sqrt(2), y: cy + r2 / Math.sqrt(2) };
        }
        if (padding !== undefined) {
            h.padding = { x: cx + r1 + padding, y: cy };
        }
        return h;
    };
    //arc handles
    var addHandles = function addHandles(_ref5) {
        var group = _ref5.group, handles = _ref5.handles, _ref5$r = _ref5.r, r = _ref5$r === undefined ? 10 : _ref5$r;
        //give it a group and x,y to draw handles
        //then give it instructions on what the handles change
        var h = group.selectAll("circle.handle").data(handles);
        h.enter().append("circle").attr("class", "handle").attr("fill", "grey").attr("fill-opacity", 0.1).attr("cursor", "move").attr("stroke-dasharray", 5).attr("stroke", "grey").call(drag$1().container(select$3("g.annotations").node()).on("start", function (d) {
            return d.start && d.start(d);
        }).on("drag", function (d) {
            return d.drag && d.drag(d);
        }).on("end", function (d) {
            return d.end && d.end(d);
        }));
        group.selectAll("circle.handle").attr("cx", function (d) {
            return d.x;
        }).attr("cy", function (d) {
            return d.y;
        }).attr("r", function (d) {
            return d.r || r;
        }).attr("class", function (d) {
            return "handle " + (d.className || "");
        });
        h.exit().remove();
    };
    var leftRightDynamic = function leftRightDynamic(align, y) {
        if (align === "dynamic" || align === "left" || align === "right") {
            if (y < 0) {
                align = "top";
            }
            else {
                align = "bottom";
            }
        }
        return align;
    };
    var topBottomDynamic = function topBottomDynamic(align, x) {
        if (align === "dynamic" || align === "top" || align === "bottom") {
            if (x < 0) {
                align = "right";
            }
            else {
                align = "left";
            }
        }
        return align;
    };
    var orientationTopBottom = ["topBottom", "top", "bottom"];
    var orientationLeftRight = ["leftRight", "left", "right"];
    var noteAlignment = (function (_ref) {
        var _ref$padding = _ref.padding, padding = _ref$padding === undefined ? 0 : _ref$padding, _ref$bbox = _ref.bbox, bbox = _ref$bbox === undefined ? { x: 0, y: 0, width: 0, height: 0 } : _ref$bbox, align = _ref.align, orientation = _ref.orientation, _ref$offset = _ref.offset, offset = _ref$offset === undefined ? { x: 0, y: 0 } : _ref$offset;
        var x = -bbox.x;
        var y = 0; //-bbox.y
        if (orientationTopBottom.indexOf(orientation) !== -1) {
            align = topBottomDynamic(align, offset.x);
            if (offset.y < 0 && orientation === "topBottom" || orientation === "top") {
                y -= bbox.height + padding;
            }
            else {
                y += padding;
            }
            if (align === "middle") {
                x -= bbox.width / 2;
            }
            else if (align === "right") {
                x -= bbox.width;
            }
        }
        else if (orientationLeftRight.indexOf(orientation) !== -1) {
            align = leftRightDynamic(align, offset.y);
            if (offset.x < 0 && orientation === "leftRight" || orientation === "left") {
                x -= bbox.width + padding;
            }
            else {
                x += padding;
            }
            if (align === "middle") {
                y -= bbox.height / 2;
            }
            else if (align === "top") {
                y -= bbox.height;
            }
        }
        return { x: x, y: y };
    });
    var lineBuilder = function lineBuilder(_ref) {
        var data = _ref.data, _ref$curve = _ref.curve, curve = _ref$curve === undefined ? curveLinear$1 : _ref$curve, canvasContext = _ref.canvasContext, className = _ref.className, classID = _ref.classID;
        var lineGen = line$1().curve(curve);
        var builder = {
            type: 'path',
            className: className,
            classID: classID,
            data: data
        };
        if (canvasContext) {
            lineGen.context(canvasContext);
            builder.pathMethods = lineGen;
        }
        else {
            builder.attrs = {
                d: lineGen(data)
            };
        }
        return builder;
    };
    var arcBuilder = function arcBuilder(_ref2) {
        var data = _ref2.data, canvasContext = _ref2.canvasContext, className = _ref2.className, classID = _ref2.classID;
        var builder = {
            type: 'path',
            className: className,
            classID: classID,
            data: data
        };
        var arcShape = arc$1().innerRadius(data.innerRadius || 0).outerRadius(data.outerRadius || data.radius || 2).startAngle(data.startAngle || 0).endAngle(data.endAngle || 2 * Math.PI);
        if (canvasContext) {
            arcShape.context(canvasContext);
            builder.pathMethods = lineGen;
        }
        else {
            builder.attrs = {
                d: arcShape()
            };
        }
        return builder;
    };
    var noteVertical = (function (_ref) {
        var align = _ref.align, _ref$x = _ref.x, x = _ref$x === undefined ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === undefined ? 0 : _ref$y, bbox = _ref.bbox, offset = _ref.offset;
        align = leftRightDynamic(align, offset.y);
        if (align === "top") {
            y -= bbox.height;
        }
        else if (align === "middle") {
            y -= bbox.height / 2;
        }
        var data = [[x, y], [x, y + bbox.height]];
        return { components: [lineBuilder({ data: data, className: "note-line" })] };
    });
    var noteHorizontal = (function (_ref) {
        var align = _ref.align, _ref$x = _ref.x, x = _ref$x === undefined ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === undefined ? 0 : _ref$y, offset = _ref.offset, bbox = _ref.bbox;
        align = topBottomDynamic(align, offset.x);
        if (align === "right") {
            x -= bbox.width;
        }
        else if (align === "middle") {
            x -= bbox.width / 2;
        }
        var data = [[x, y], [x + bbox.width, y]];
        return { components: [lineBuilder({ data: data, className: "note-line" })] };
    });
    var lineSetup = function lineSetup(_ref) {
        var type = _ref.type, subjectType = _ref.subjectType;
        var annotation = type.annotation;
        var offset = annotation.position;
        var x1 = annotation.x - offset.x, x2 = x1 + annotation.dx, y1 = annotation.y - offset.y, y2 = y1 + annotation.dy;
        var subjectData = annotation.subject;
        if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
            var h = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            var angle = Math.asin(-y2 / h);
            var r = subjectData.outerRadius || subjectData.radius + (subjectData.radiusPadding || 0);
            x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
            y1 = Math.abs(Math.sin(angle) * r) * (y2 < 0 ? -1 : 1);
        }
        if (subjectType === "rect") {
            var width = subjectData.width, height = subjectData.height;
            if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
                if (Math.abs(width) > Math.abs(annotation.dx))
                    x1 = width / 2;
                else
                    x1 = width;
            }
            if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
                if (Math.abs(height) > Math.abs(annotation.dy))
                    y1 = height / 2;
                else
                    y1 = height;
            }
            if (x1 === width / 2 && y1 === height / 2) {
                x1 = x2;
                y1 = y2;
            }
        }
        return [[x1, y1], [x2, y2]];
    };
    var connectorLine = (function (connectorData) {
        var data = lineSetup(connectorData);
        return { components: [lineBuilder({ data: data, className: "connector" })] };
    });
    var connectorElbow = (function (_ref) {
        var type = _ref.type, subjectType = _ref.subjectType;
        var annotation = type.annotation;
        var offset = annotation.position;
        var x1 = annotation.x - offset.x, x2 = x1 + annotation.dx, y1 = annotation.y - offset.y, y2 = y1 + annotation.dy;
        var subjectData = annotation.subject;
        if (subjectType === "rect") {
            var width = subjectData.width, height = subjectData.height;
            if (width > 0 && annotation.dx > 0 || width < 0 && annotation.dx < 0) {
                if (Math.abs(width) > Math.abs(annotation.dx))
                    x1 = width / 2;
                else
                    x1 = width;
            }
            if (height > 0 && annotation.dy > 0 || height < 0 && annotation.dy < 0) {
                if (Math.abs(height) > Math.abs(annotation.dy))
                    y1 = height / 2;
                else
                    y1 = height;
            }
            if (x1 === width / 2 && y1 === height / 2) {
                x1 = x2;
                y1 = y2;
            }
        }
        var data = [[x1, y1], [x2, y2]];
        var diffY = y2 - y1;
        var diffX = x2 - x1;
        var xe = x2;
        var ye = y2;
        var opposite = y2 < y1 && x2 > x1 || x2 < x1 && y2 > y1 ? -1 : 1;
        if (Math.abs(diffX) < Math.abs(diffY)) {
            xe = x2;
            ye = y1 + diffX * opposite;
        }
        else {
            ye = y2;
            xe = x1 + diffY * opposite;
        }
        if (subjectType === "circle" && (subjectData.outerRadius || subjectData.radius)) {
            var r = (subjectData.outerRadius || subjectData.radius) + (subjectData.radiusPadding || 0);
            var length = r / Math.sqrt(2);
            if (Math.abs(diffX) > length && Math.abs(diffY) > length) {
                x1 = length * (x2 < 0 ? -1 : 1);
                y1 = length * (y2 < 0 ? -1 : 1);
                data = [[x1, y1], [xe, ye], [x2, y2]];
            }
            else if (Math.abs(diffX) > Math.abs(diffY)) {
                var angle = Math.asin(-y2 / r);
                x1 = Math.abs(Math.cos(angle) * r) * (x2 < 0 ? -1 : 1);
                data = [[x1, y2], [x2, y2]];
            }
            else {
                var _angle = Math.acos(x2 / r);
                y1 = Math.abs(Math.sin(_angle) * r) * (y2 < 0 ? -1 : 1);
                data = [[x2, y1], [x2, y2]];
            }
        }
        else {
            data = [[x1, y1], [xe, ye], [x2, y2]];
        }
        return { components: [lineBuilder({ data: data, className: "connector" })] };
    });
    var connectorCurve = (function (_ref) {
        var type = _ref.type, connectorData = _ref.connectorData, subjectType = _ref.subjectType;
        if (!connectorData) {
            connectorData = {};
        }
        if (!connectorData.points || typeof connectorData.points === "number") {
            connectorData.points = createPoints(type.annotation.offset, connectorData.points);
        }
        if (!connectorData.curve) {
            connectorData.curve = curveCatmullRom;
        }
        var handles = [];
        if (type.editMode) {
            var cHandles = connectorData.points.map(function (c, i) {
                return _extends({}, pointHandle({ cx: c[0], cy: c[1] }), { index: i });
            });
            var updatePoint = function updatePoint(index) {
                connectorData.points[index][0] += event$3.dx;
                connectorData.points[index][1] += event$3.dy;
                type.redrawConnector();
            };
            handles = type.mapHandles(cHandles.map(function (h) {
                return _extends({}, h.move, { drag: updatePoint.bind(type, h.index) });
            }));
        }
        var data = lineSetup({ type: type, subjectType: subjectType });
        data = [data[0]].concat(toConsumableArray(connectorData.points), [data[1]]);
        var components = [lineBuilder({ data: data, curve: connectorData.curve, className: "connector" })];
        return { components: components, handles: handles };
    });
    var createPoints = function createPoints(offset) {
        var anchors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        var diff = { x: offset.x / (anchors + 1), y: offset.y / (anchors + 1) };
        var p = [];
        var i = 1;
        for (; i <= anchors; i++) {
            p.push([diff.x * i + i % 2 * 20, diff.y * i - i % 2 * 20]);
        }
        return p;
    };
    var connectorArrow = (function (_ref) {
        var annotation = _ref.annotation, start = _ref.start, end = _ref.end, _ref$scale = _ref.scale, scale = _ref$scale === undefined ? 1 : _ref$scale;
        var offset = annotation.position;
        if (!start) {
            start = [annotation.dx, annotation.dy];
        }
        else {
            start = [-end[0] + start[0], -end[1] + start[1]];
        }
        if (!end) {
            end = [annotation.x - offset.x, annotation.y - offset.y];
        }
        var x1 = end[0], y1 = end[1];
        var dx = start[0];
        var dy = start[1];
        var size = 10 * scale;
        var angleOffset = 16 / 180 * Math.PI;
        var angle = Math.atan(dy / dx);
        if (dx < 0) {
            angle += Math.PI;
        }
        var data = [[x1, y1], [Math.cos(angle + angleOffset) * size + x1, Math.sin(angle + angleOffset) * size + y1], [Math.cos(angle - angleOffset) * size + x1, Math.sin(angle - angleOffset) * size + y1], [x1, y1]];
        //TODO add in reverse
        // if (canvasContext.arrowReverse){
        //   data = [[x1, y1],
        //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
        //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
        //   [x1, y1]
        //   ]
        // } else {
        //   data = [[x1, y1],
        //   [Math.cos(angle + angleOffset)*size, Math.sin(angle + angleOffset)*size],
        //   [Math.cos(angle - angleOffset)*size, Math.sin(angle - angleOffset)*size],
        //   [x1, y1]
        //   ]
        // }
        return {
            components: [lineBuilder({
                    data: data,
                    className: "connector-end connector-arrow",
                    classID: "connector-end"
                })]
        };
    });
    var connectorDot = (function (_ref) {
        var line$$1 = _ref.line, _ref$scale = _ref.scale, scale = _ref$scale === undefined ? 1 : _ref$scale;
        var dot = arcBuilder({
            className: "connector-end connector-dot",
            classID: "connector-end",
            data: { radius: 3 * Math.sqrt(scale) }
        });
        dot.attrs.transform = "translate(" + line$$1.data[0][0] + ", " + line$$1.data[0][1] + ")";
        return { components: [dot] };
    });
    var subjectCircle = (function (_ref) {
        var subjectData = _ref.subjectData, type = _ref.type;
        if (!subjectData.radius && !subjectData.outerRadius) {
            subjectData.radius = 20;
        }
        var handles = [];
        var c = arcBuilder({ data: subjectData, className: "subject" });
        if (type.editMode) {
            var h = circleHandles({
                r1: c.data.outerRadius || c.data.radius,
                r2: c.data.innerRadius,
                padding: subjectData.radiusPadding
            });
            var updateRadius = function updateRadius(attr) {
                var r = subjectData[attr] + event$3.dx * Math.sqrt(2);
                subjectData[attr] = r;
                type.redrawSubject();
                type.redrawConnector();
            };
            var cHandles = [_extends({}, h.r1, {
                    drag: updateRadius.bind(type, subjectData.outerRadius !== undefined ? "outerRadius" : "radius")
                })];
            if (subjectData.innerRadius) {
                cHandles.push(_extends({}, h.r2, { drag: updateRadius.bind(type, "innerRadius") }));
            }
            handles = type.mapHandles(cHandles);
        }
        c.attrs["fill-opacity"] = 0;
        return { components: [c], handles: handles };
    });
    var subjectRect = (function (_ref) {
        var subjectData = _ref.subjectData, type = _ref.type;
        if (!subjectData.width) {
            subjectData.width = 100;
        }
        if (!subjectData.height) {
            subjectData.height = 100;
        }
        var handles = [];
        var width = subjectData.width, height = subjectData.height;
        var data = [[0, 0], [width, 0], [width, height], [0, height], [0, 0]];
        var rect = lineBuilder({ data: data, className: "subject" });
        if (type.editMode) {
            var updateWidth = function updateWidth() {
                subjectData.width = event$3.x;
                type.redrawSubject();
                type.redrawConnector();
            };
            var updateHeight = function updateHeight() {
                subjectData.height = event$3.y;
                type.redrawSubject();
                type.redrawConnector();
            };
            var rHandles = [{ x: width, y: height / 2, drag: updateWidth.bind(type) }, { x: width / 2, y: height, drag: updateHeight.bind(type) }];
            handles = type.mapHandles(rHandles);
        }
        rect.attrs["fill-opacity"] = 0.1;
        return { components: [rect], handles: handles };
    });
    var subjectThreshold = (function (_ref) {
        var subjectData = _ref.subjectData, type = _ref.type;
        var offset = type.annotation.position;
        var x1 = (subjectData.x1 !== undefined ? subjectData.x1 : offset.x) - offset.x, x2 = (subjectData.x2 !== undefined ? subjectData.x2 : offset.x) - offset.x, y1 = (subjectData.y1 !== undefined ? subjectData.y1 : offset.y) - offset.y, y2 = (subjectData.y2 !== undefined ? subjectData.y2 : offset.y) - offset.y;
        var data = [[x1, y1], [x2, y2]];
        return { components: [lineBuilder({ data: data, className: 'subject' })] };
    });
    var subjectBadge = (function (_ref) {
        var _ref$subjectData = _ref.subjectData, subjectData = _ref$subjectData === undefined ? {} : _ref$subjectData, _ref$type = _ref.type, type = _ref$type === undefined ? {} : _ref$type;
        var annotation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var typeSettings = type.typeSettings && type.typeSettings.subject;
        if (!subjectData.radius) {
            if (typeSettings && typeSettings.radius) {
                subjectData.radius = typeSettings.radius;
            }
            else {
                subjectData.radius = 14;
            }
        }
        if (!subjectData.x) {
            if (typeSettings && typeSettings.x) {
                subjectData.x = typeSettings.x;
            }
        }
        if (!subjectData.y) {
            if (typeSettings && typeSettings.y) {
                subjectData.y = typeSettings.y;
            }
        }
        var handles = [];
        var components = [];
        var radius = subjectData.radius;
        var innerRadius = radius * 0.7;
        var x = 0;
        var y = 0;
        var notCornerOffset = Math.sqrt(2) * radius;
        var placement = {
            xleftcorner: -radius,
            xrightcorner: radius,
            ytopcorner: -radius,
            ybottomcorner: radius,
            xleft: -notCornerOffset,
            xright: notCornerOffset,
            ytop: -notCornerOffset,
            ybottom: notCornerOffset
        };
        if (subjectData.x && !subjectData.y) {
            x = placement["x" + subjectData.x];
        }
        else if (subjectData.y && !subjectData.x) {
            y = placement["y" + subjectData.y];
        }
        else if (subjectData.x && subjectData.y) {
            x = placement["x" + subjectData.x + "corner"];
            y = placement["y" + subjectData.y + "corner"];
        }
        var transform = "translate(" + x + ", " + y + ")";
        var circlebg = arcBuilder({ className: "subject", data: { radius: radius } });
        circlebg.attrs.transform = transform;
        circlebg.attrs.fill = annotation.color;
        circlebg.attrs["stroke-linecap"] = "round";
        circlebg.attrs["stroke-width"] = "3px";
        var circle = arcBuilder({
            className: "subject-ring",
            data: { outerRadius: radius, innerRadius: innerRadius }
        });
        circle.attrs.transform = transform;
        // circle.attrs.fill = annotation.color
        circle.attrs["stroke-width"] = "3px";
        circle.attrs.fill = "white";
        var pointer = void 0;
        if (x && y || !x && !y) {
            pointer = lineBuilder({
                className: "subject-pointer",
                data: [[0, 0], [x || 0, 0], [0, y || 0], [0, 0]]
            });
        }
        else if (x || y) {
            var notCornerPointerXY = function notCornerPointerXY(v) {
                var sign = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                return v && v / Math.sqrt(2) / Math.sqrt(2) || sign * radius / Math.sqrt(2);
            };
            pointer = lineBuilder({
                className: "subject-pointer",
                data: [[0, 0], [notCornerPointerXY(x), notCornerPointerXY(y)], [notCornerPointerXY(x, -1), notCornerPointerXY(y, -1)], [0, 0]]
            });
        }
        if (pointer) {
            pointer.attrs.fill = annotation.color;
            pointer.attrs["stroke-linecap"] = "round";
            pointer.attrs["stroke-width"] = "3px";
            components.push(pointer);
        }
        if (type.editMode) {
            var dragBadge = function dragBadge() {
                subjectData.x = event$3.x < -radius * 2 ? "left" : event$3.x > radius * 2 ? "right" : undefined;
                subjectData.y = event$3.y < -radius * 2 ? "top" : event$3.y > radius * 2 ? "bottom" : undefined;
                type.redrawSubject();
            };
            var bHandles = { x: x * 2, y: y * 2, drag: dragBadge.bind(type) };
            if (!bHandles.x && !bHandles.y) {
                bHandles.y = -radius;
            }
            handles = type.mapHandles([bHandles]);
        }
        var text = void 0;
        if (subjectData.text) {
            text = {
                type: "text",
                className: "badge-text",
                attrs: {
                    fill: "white",
                    stroke: "none",
                    "font-size": ".7em",
                    text: subjectData.text,
                    "text-anchor": "middle",
                    dy: ".25em",
                    x: x,
                    y: y
                }
            };
        }
        components.push(circlebg);
        components.push(circle);
        components.push(text);
        return { components: components, handles: handles };
    });
    //Note options
    //Connector options
    //Subject options
    var Type = function () {
        function Type(_ref) {
            var a = _ref.a, annotation = _ref.annotation, editMode = _ref.editMode, dispatcher = _ref.dispatcher, notePadding = _ref.notePadding, accessors = _ref.accessors;
            classCallCheck(this, Type);
            this.a = a;
            this.note = annotation.disable.indexOf("note") === -1 && a.select("g.annotation-note");
            this.noteContent = this.note && a.select("g.annotation-note-content");
            this.connector = annotation.disable.indexOf("connector") === -1 && a.select("g.annotation-connector");
            this.subject = annotation.disable.indexOf("subject") === -1 && a.select("g.annotation-subject");
            this.dispatcher = dispatcher;
            if (dispatcher) {
                var handler = addHandlers.bind(null, dispatcher, annotation);
                handler({ component: this.note, name: "note" });
                handler({ component: this.connector, name: "connector" });
                handler({ component: this.subject, name: "subject" });
            }
            this.annotation = annotation;
            this.editMode = annotation.editMode || editMode;
            this.notePadding = notePadding !== undefined ? notePadding : 3;
            this.offsetCornerX = 0;
            this.offsetCornerY = 0;
            if (accessors && annotation.data) {
                this.init(accessors);
            }
        }
        createClass(Type, [{
                key: "init",
                value: function init(accessors) {
                    if (!this.annotation.x) {
                        this.mapX(accessors);
                    }
                    if (!this.annotation.y) {
                        this.mapY(accessors);
                    }
                }
            }, {
                key: "mapY",
                value: function mapY(accessors) {
                    if (accessors.y) {
                        this.annotation.y = accessors.y(this.annotation.data);
                    }
                }
            }, {
                key: "mapX",
                value: function mapX(accessors) {
                    if (accessors.x) {
                        this.annotation.x = accessors.x(this.annotation.data);
                    }
                }
            }, {
                key: "updateEditMode",
                value: function updateEditMode() {
                    this.a.selectAll("circle.handle").remove();
                }
            }, {
                key: "drawOnSVG",
                value: function drawOnSVG(component, builders) {
                    var _this = this;
                    if (!Array.isArray(builders)) {
                        builders = [builders];
                    }
                    builders.filter(function (b) {
                        return b;
                    }).forEach(function (_ref2) {
                        var type = _ref2.type, className = _ref2.className, attrs = _ref2.attrs, handles = _ref2.handles, classID = _ref2.classID;
                        if (type === "handle") {
                            addHandles({ group: component, r: attrs && attrs.r, handles: handles });
                        }
                        else {
                            newWithClass(component, [_this.annotation], type, className, classID);
                            var el = component.select(type + "." + (classID || className));
                            var addAttrs = Object.keys(attrs);
                            var removeAttrs = [];
                            var currentAttrs = el.node().attributes;
                            for (var i = currentAttrs.length - 1; i >= 0; i--) {
                                var name = currentAttrs[i].name;
                                if (addAttrs.indexOf(name) === -1 && name !== "class")
                                    removeAttrs.push(name);
                            }
                            addAttrs.forEach(function (attr) {
                                if (attr === "text") {
                                    el.text(attrs[attr]);
                                }
                                else {
                                    el.attr(attr, attrs[attr]);
                                }
                            });
                            removeAttrs.forEach(function (attr) {
                                return el.attr(attr, null);
                            });
                        }
                    });
                }
                //TODO: how to extend this to a drawOnCanvas mode?
            }, {
                key: "getNoteBBox",
                value: function getNoteBBox() {
                    return bboxWithoutHandles(this.note, ".annotation-note-content text");
                }
            }, {
                key: "getNoteBBoxOffset",
                value: function getNoteBBoxOffset() {
                    var bbox = bboxWithoutHandles(this.note, ".annotation-note-content");
                    var transform = this.noteContent.attr("transform").split(/\(|\,|\)/g);
                    bbox.offsetCornerX = parseFloat(transform[1]) + this.annotation.dx;
                    bbox.offsetCornerY = parseFloat(transform[2]) + this.annotation.dy;
                    bbox.offsetX = this.annotation.dx;
                    bbox.offsetY = this.annotation.dy;
                    return bbox;
                }
            }, {
                key: "drawSubject",
                value: function drawSubject() {
                    var _this2 = this;
                    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    var subjectData = this.annotation.subject;
                    var type = context.type;
                    var subjectParams = { type: this, subjectData: subjectData };
                    var subject = {};
                    if (type === "circle")
                        subject = subjectCircle(subjectParams);
                    else if (type === "rect")
                        subject = subjectRect(subjectParams);
                    else if (type === "threshold")
                        subject = subjectThreshold(subjectParams);
                    else if (type === "badge")
                        subject = subjectBadge(subjectParams, this.annotation);
                    var _subject = subject, _subject$components = _subject.components, components = _subject$components === undefined ? [] : _subject$components, _subject$handles = _subject.handles, handles = _subject$handles === undefined ? [] : _subject$handles;
                    components.forEach(function (c) {
                        if (c && c.attrs && !c.attrs.stroke) {
                            c.attrs.stroke = _this2.annotation.color;
                        }
                    });
                    if (this.editMode) {
                        handles = handles.concat(this.mapHandles([{ drag: this.dragSubject.bind(this) }]));
                        components.push({ type: "handle", handles: handles });
                    }
                    return components;
                }
            }, {
                key: "drawConnector",
                value: function drawConnector() {
                    var _this3 = this;
                    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    var connectorData = this.annotation.connector;
                    var type = connectorData.type || context.type;
                    var connectorParams = { type: this, connectorData: connectorData };
                    connectorParams.subjectType = this.typeSettings && this.typeSettings.subject && this.typeSettings.subject.type;
                    var connector = {};
                    if (type === "curve")
                        connector = connectorCurve(connectorParams);
                    else if (type === "elbow")
                        connector = connectorElbow(connectorParams);
                    else
                        connector = connectorLine(connectorParams);
                    var _connector = connector, _connector$components = _connector.components, components = _connector$components === undefined ? [] : _connector$components, _connector$handles = _connector.handles, handles = _connector$handles === undefined ? [] : _connector$handles;
                    var line$$1 = components[0];
                    //TODO: genericize this into fill t/f stroke t/f
                    if (line$$1) {
                        line$$1.attrs.stroke = this.annotation.color;
                        line$$1.attrs.fill = "none";
                    }
                    var endType = connectorData.end || context.end;
                    var end = {};
                    if (endType === "arrow") {
                        var s = line$$1.data[1];
                        var e = line$$1.data[0];
                        var distance = Math.sqrt(Math.pow(s[0] - e[0], 2) + Math.pow(s[1] - e[1], 2));
                        if (distance < 5 && line$$1.data[2]) {
                            s = line$$1.data[2];
                        }
                        end = connectorArrow({
                            annotation: this.annotation,
                            start: s,
                            end: e,
                            scale: connectorData.endScale
                        });
                    }
                    else if (endType === "dot") {
                        end = connectorDot({ line: line$$1, scale: connectorData.endScale });
                    }
                    else if (!endType || endType === "none") {
                        this.connector && this.connector.select(".connector-end").remove();
                    }
                    if (end.components) {
                        end.components.forEach(function (c) {
                            c.attrs.fill = _this3.annotation.color;
                            c.attrs.stroke = _this3.annotation.color;
                        });
                        components = components.concat(end.components);
                    }
                    if (this.editMode) {
                        if (handles.length !== 0)
                            components.push({ type: "handle", handles: handles });
                    }
                    return components;
                }
            }, {
                key: "drawNote",
                value: function drawNote() {
                    var _this4 = this;
                    var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
                    var noteData = this.annotation.note;
                    var align = noteData.align || context.align || "dynamic";
                    var noteParams = {
                        bbox: context.bbox,
                        align: align,
                        offset: this.annotation.offset
                    };
                    var lineType = noteData.lineType || context.lineType;
                    var note = {};
                    if (lineType === "vertical")
                        note = noteVertical(noteParams);
                    else if (lineType === "horizontal")
                        note = noteHorizontal(noteParams);
                    var _note = note, _note$components = _note.components, components = _note$components === undefined ? [] : _note$components, _note$handles = _note.handles, handles = _note$handles === undefined ? [] : _note$handles;
                    components.forEach(function (c) {
                        c.attrs.stroke = _this4.annotation.color;
                    });
                    if (this.editMode) {
                        handles = this.mapHandles([{ x: 0, y: 0, drag: this.dragNote.bind(this) }]);
                        components.push({ type: "handle", handles: handles });
                        var dragging = this.dragNote.bind(this), start = this.dragstarted.bind(this), end = this.dragended.bind(this);
                        this.note.call(drag$1().container(select$3("g.annotations").node()).on("start", function (d) {
                            return start(d);
                        }).on("drag", function (d) {
                            return dragging(d);
                        }).on("end", function (d) {
                            return end(d);
                        }));
                    }
                    else {
                        this.note.on("mousedown.drag", null);
                    }
                    return components;
                }
            }, {
                key: "drawNoteContent",
                value: function drawNoteContent(context) {
                    var noteData = this.annotation.note;
                    var padding = noteData.padding !== undefined ? noteData.padding : this.notePadding;
                    var orientation = noteData.orientation || context.orientation || "topBottom";
                    var lineType = noteData.lineType || context.lineType;
                    var align = noteData.align || context.align || "dynamic";
                    if (lineType === "vertical")
                        orientation = "leftRight";
                    else if (lineType === "horizontal")
                        orientation = "topBottom";
                    var noteParams = {
                        padding: padding,
                        bbox: context.bbox,
                        offset: this.annotation.offset,
                        orientation: orientation,
                        align: align
                    };
                    var _noteAlignment = noteAlignment(noteParams), x = _noteAlignment.x, y = _noteAlignment.y;
                    this.offsetCornerX = x + this.annotation.dx;
                    this.offsetCornerY = y + this.annotation.dy;
                    this.note && this.noteContent.attr("transform", "translate(" + x + ", " + y + ")");
                    return [];
                }
            }, {
                key: "drawOnScreen",
                value: function drawOnScreen(component, drawFunction) {
                    return this.drawOnSVG(component, drawFunction);
                }
            }, {
                key: "redrawSubject",
                value: function redrawSubject() {
                    this.subject && this.drawOnScreen(this.subject, this.drawSubject());
                }
            }, {
                key: "redrawConnector",
                value: function redrawConnector() {
                    this.connector && this.drawOnScreen(this.connector, this.drawConnector());
                }
            }, {
                key: "redrawNote",
                value: function redrawNote() {
                    var bbox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getNoteBBox();
                    this.noteContent && this.drawOnScreen(this.noteContent, this.drawNoteContent({ bbox: bbox }));
                    this.note && this.drawOnScreen(this.note, this.drawNote({ bbox: bbox }));
                }
            }, {
                key: "setPosition",
                value: function setPosition() {
                    var position = this.annotation.position;
                    this.a.attr("transform", "translate(" + position.x + ", " + position.y + ")");
                }
            }, {
                key: "clearComponents",
                value: function clearComponents() {
                    this.subject && this.subject.select("*").remove();
                    this.connector && this.connector.select("*").remove();
                    // this.note && this.note.select("*").remove()
                }
            }, {
                key: "setOffset",
                value: function setOffset() {
                    if (this.note) {
                        var offset = this.annotation.offset;
                        this.note.attr("transform", "translate(" + offset.x + ", " + offset.y + ")");
                    }
                }
            }, {
                key: "setPositionWithAccessors",
                value: function setPositionWithAccessors(accessors) {
                    if (accessors && this.annotation.data) {
                        this.mapX(accessors);
                        this.mapY(accessors);
                    }
                    this.setPosition();
                }
            }, {
                key: "setClassName",
                value: function setClassName() {
                    this.a.attr("class", "annotation " + (this.className && this.className()) + " " + (this.editMode ? "editable" : "") + " " + (this.annotation.className || ""));
                }
            }, {
                key: "draw",
                value: function draw() {
                    this.setClassName();
                    this.setPosition();
                    this.setOffset();
                    this.redrawSubject();
                    this.redrawConnector();
                    this.redrawNote();
                }
            }, {
                key: "dragstarted",
                value: function dragstarted() {
                    event$3.sourceEvent.stopPropagation();
                    this.dispatcher && this.dispatcher.call("dragstart", this.a, this.annotation);
                    this.a.classed("dragging", true);
                    this.a.selectAll("circle.handle").style("pointer-events", "none");
                }
            }, {
                key: "dragended",
                value: function dragended() {
                    this.dispatcher && this.dispatcher.call("dragend", this.a, this.annotation);
                    this.a.classed("dragging", false);
                    this.a.selectAll("circle.handle").style("pointer-events", "all");
                }
            }, {
                key: "dragSubject",
                value: function dragSubject() {
                    var position = this.annotation.position;
                    position.x += event$3.dx;
                    position.y += event$3.dy;
                    this.annotation.position = position;
                }
            }, {
                key: "dragNote",
                value: function dragNote() {
                    var offset = this.annotation.offset;
                    offset.x += event$3.dx;
                    offset.y += event$3.dy;
                    this.annotation.offset = offset;
                }
            }, {
                key: "mapHandles",
                value: function mapHandles(handles) {
                    var _this5 = this;
                    return handles.map(function (h) {
                        return _extends({}, h, {
                            start: _this5.dragstarted.bind(_this5),
                            end: _this5.dragended.bind(_this5)
                        });
                    });
                }
            }]);
        return Type;
    }();
    var customType = function customType(initialType, typeSettings, _init) {
        return function (_initialType) {
            inherits(customType, _initialType);
            function customType(settings) {
                classCallCheck(this, customType);
                var _this6 = possibleConstructorReturn(this, (customType.__proto__ || Object.getPrototypeOf(customType)).call(this, settings));
                _this6.typeSettings = typeSettings;
                if (typeSettings.disable) {
                    typeSettings.disable.forEach(function (d) {
                        _this6[d] && _this6[d].remove();
                        _this6[d] = undefined;
                        if (d === "note") {
                            _this6.noteContent = undefined;
                        }
                    });
                }
                return _this6;
            }
            createClass(customType, [{
                    key: "className",
                    value: function className() {
                        return "" + (typeSettings.className || get$a(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this) && get$a(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "className", this).call(this) || "");
                    }
                }, {
                    key: "drawSubject",
                    value: function drawSubject(context) {
                        this.typeSettings.subject = _extends({}, typeSettings.subject, this.typeSettings.subject);
                        return get$a(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawSubject", this).call(this, _extends({}, context, this.typeSettings.subject));
                    }
                }, {
                    key: "drawConnector",
                    value: function drawConnector(context) {
                        this.typeSettings.connector = _extends({}, typeSettings.connector, this.typeSettings.connector);
                        return get$a(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawConnector", this).call(this, _extends({}, context, typeSettings.connector, this.typeSettings.connector));
                    }
                }, {
                    key: "drawNote",
                    value: function drawNote(context) {
                        this.typeSettings.note = _extends({}, typeSettings.note, this.typeSettings.note);
                        return get$a(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNote", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
                    }
                }, {
                    key: "drawNoteContent",
                    value: function drawNoteContent(context) {
                        return get$a(customType.prototype.__proto__ || Object.getPrototypeOf(customType.prototype), "drawNoteContent", this).call(this, _extends({}, context, typeSettings.note, this.typeSettings.note));
                    }
                }], [{
                    key: "init",
                    value: function init(annotation, accessors) {
                        get$a(customType.__proto__ || Object.getPrototypeOf(customType), "init", this).call(this, annotation, accessors);
                        if (_init) {
                            annotation = _init(annotation, accessors);
                        }
                        return annotation;
                    }
                }]);
            return customType;
        }(initialType);
    };
    var d3NoteText = function (_Type) {
        inherits(d3NoteText, _Type);
        function d3NoteText(params) {
            classCallCheck(this, d3NoteText);
            var _this7 = possibleConstructorReturn(this, (d3NoteText.__proto__ || Object.getPrototypeOf(d3NoteText)).call(this, params));
            _this7.textWrap = params.textWrap || 120;
            _this7.drawText();
            return _this7;
        }
        createClass(d3NoteText, [{
                key: "updateTextWrap",
                value: function updateTextWrap(textWrap) {
                    this.textWrap = textWrap;
                    this.drawText();
                }
                //TODO: add update text functionality
            }, {
                key: "drawText",
                value: function drawText() {
                    if (this.note) {
                        newWithClass(this.note, [this.annotation], "g", "annotation-note-content");
                        var noteContent = this.note.select("g.annotation-note-content");
                        newWithClass(noteContent, [this.annotation], "rect", "annotation-note-bg");
                        newWithClass(noteContent, [this.annotation], "text", "annotation-note-label");
                        newWithClass(noteContent, [this.annotation], "text", "annotation-note-title");
                        var titleBBox = { height: 0 };
                        var label = this.a.select("text.annotation-note-label");
                        var wrapLength = this.annotation.note && this.annotation.note.wrap || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrap || this.textWrap;
                        var wrapSplitter = this.annotation.note && this.annotation.note.wrapSplitter || this.typeSettings && this.typeSettings.note && this.typeSettings.note.wrapSplitter;
                        var bgPadding = this.annotation.note && this.annotation.note.bgPadding || this.typeSettings && this.typeSettings.note && this.typeSettings.note.bgPadding;
                        var bgPaddingFinal = { top: 0, bottom: 0, left: 0, right: 0 };
                        if (typeof bgPadding === "number") {
                            bgPaddingFinal = {
                                top: bgPadding,
                                bottom: bgPadding,
                                left: bgPadding,
                                right: bgPadding
                            };
                        }
                        else if (bgPadding && (typeof bgPadding === "undefined" ? "undefined" : _typeof(bgPadding)) === "object") {
                            bgPaddingFinal = _extends(bgPaddingFinal, bgPadding);
                        }
                        if (this.annotation.note.title) {
                            var title = this.a.select("text.annotation-note-title");
                            title.text(this.annotation.note.title);
                            title.attr("fill", this.annotation.color);
                            title.attr("font-weight", "bold");
                            title.call(wrap$1, wrapLength, wrapSplitter);
                            titleBBox = title.node().getBBox();
                        }
                        label.text(this.annotation.note.label).attr("dx", "0");
                        label.call(wrap$1, wrapLength, wrapSplitter);
                        label.attr("y", titleBBox.height * 1.1 || 0);
                        label.attr("fill", this.annotation.color);
                        var bbox = this.getNoteBBox();
                        this.a.select("rect.annotation-note-bg").attr("width", bbox.width + bgPaddingFinal.left + bgPaddingFinal.right).attr("height", bbox.height + bgPaddingFinal.top + bgPaddingFinal.bottom).attr("x", bbox.x - bgPaddingFinal.left).attr("y", -bgPaddingFinal.top).attr("fill", "white").attr("fill-opacity", 0);
                    }
                }
            }]);
        return d3NoteText;
    }(Type);
    var d3Label = customType(d3NoteText, {
        className: "label",
        note: { align: "middle" }
    });
    var d3Callout = customType(d3NoteText, {
        className: "callout",
        note: { lineType: "horizontal" }
    });
    var d3CalloutElbow = customType(d3Callout, {
        className: "callout elbow",
        connector: { type: "elbow" }
    });
    var d3CalloutCurve = customType(d3Callout, {
        className: "callout curve",
        connector: { type: "curve" }
    });
    var d3Badge = customType(Type, {
        className: "badge",
        subject: { type: "badge" },
        disable: ["connector", "note"]
    });
    var d3CalloutCircle = customType(d3NoteText, {
        className: "callout circle",
        subject: { type: "circle" },
        note: { lineType: "horizontal" },
        connector: { type: "elbow" }
    });
    var d3CalloutRect = customType(d3NoteText, {
        className: "callout rect",
        subject: { type: "rect" },
        note: { lineType: "horizontal" },
        connector: { type: "elbow" }
    });
    var ThresholdMap = function (_d3Callout) {
        inherits(ThresholdMap, _d3Callout);
        function ThresholdMap() {
            classCallCheck(this, ThresholdMap);
            return possibleConstructorReturn(this, (ThresholdMap.__proto__ || Object.getPrototypeOf(ThresholdMap)).apply(this, arguments));
        }
        createClass(ThresholdMap, [{
                key: "mapY",
                value: function mapY(accessors) {
                    get$a(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapY", this).call(this, accessors);
                    var a = this.annotation;
                    if ((a.subject.x1 || a.subject.x2) && a.data && accessors.y) {
                        a.y = accessors.y(a.data);
                    }
                    if ((a.subject.x1 || a.subject.x2) && !a.x) {
                        a.x = a.subject.x1 || a.subject.x2;
                    }
                }
            }, {
                key: "mapX",
                value: function mapX(accessors) {
                    get$a(ThresholdMap.prototype.__proto__ || Object.getPrototypeOf(ThresholdMap.prototype), "mapX", this).call(this, accessors);
                    var a = this.annotation;
                    if ((a.subject.y1 || a.subject.y2) && a.data && accessors.x) {
                        a.x = accessors.x(a.data);
                    }
                    if ((a.subject.y1 || a.subject.y2) && !a.y) {
                        a.y = a.subject.y1 || a.subject.y2;
                    }
                }
            }]);
        return ThresholdMap;
    }(d3Callout);
    var d3XYThreshold = customType(ThresholdMap, {
        className: "callout xythreshold",
        subject: { type: "threshold" }
    });
    var newWithClass = function newWithClass(a, d, type, className, classID) {
        var group = a.selectAll(type + "." + (classID || className)).data(d);
        group.enter().append(type).merge(group).attr("class", className);
        group.exit().remove();
        return a;
    };
    var addHandlers = function addHandlers(dispatcher, annotation, _ref3) {
        var component = _ref3.component, name = _ref3.name;
        if (component) {
            component.on("mouseover.annotations", function () {
                dispatcher.call(name + "over", component, annotation);
            }).on("mouseout.annotations", function () {
                return dispatcher.call(name + "out", component, annotation);
            }).on("click.annotations", function () {
                return dispatcher.call(name + "click", component, annotation);
            });
        }
    };
    //Text wrapping code adapted from Mike Bostock
    var wrap$1 = function wrap(text, width, wrapSplitter) {
        var lineHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.2;
        text.each(function () {
            var text = select$3(this), words = text.text().split(wrapSplitter || /[ \t\r\n]+/).reverse().filter(function (w) {
                return w !== "";
            });
            var word = void 0, line$$1 = [], tspan = text.text(null).append("tspan").attr("x", 0).attr("dy", 0.8 + "em");
            while (word = words.pop()) {
                line$$1.push(word);
                tspan.text(line$$1.join(" "));
                if (tspan.node().getComputedTextLength() > width && line$$1.length > 1) {
                    line$$1.pop();
                    tspan.text(line$$1.join(" "));
                    line$$1 = [word];
                    tspan = text.append("tspan").attr("x", 0).attr("dy", lineHeight + "em").text(word);
                }
            }
        });
    };
    var bboxWithoutHandles = function bboxWithoutHandles(selection) {
        var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ":not(.handle)";
        if (!selection) {
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        return selection.selectAll(selector).nodes().reduce(function (p, c) {
            var bbox = c.getBBox();
            p.x = Math.min(p.x, bbox.x);
            p.y = Math.min(p.y, bbox.y);
            p.width = Math.max(p.width, bbox.width);
            var yOffset = c && c.attributes && c.attributes.y;
            p.height = Math.max(p.height, (yOffset && parseFloat(yOffset.value) || 0) + bbox.height);
            return p;
        }, { x: 0, y: 0, width: 0, height: 0 });
    };
    function annotation() {
        var annotations = [], collection = void 0, context = void 0, 
        //TODO: add canvas functionality
        disable = [], accessors = {}, accessorsInverse = {}, editMode = false, ids = void 0, type = d3Callout, textWrap = void 0, notePadding = void 0, annotationDispatcher = dispatch$5("subjectover", "subjectout", "subjectclick", "connectorover", "connectorout", "connectorclick", "noteover", "noteout", "noteclick", "dragend", "dragstart"), sel = void 0;
        var annotation = function annotation(selection) {
            sel = selection;
            //TODO: check to see if this is still needed
            if (!editMode) {
                selection.selectAll("circle.handle").remove();
            }
            var translatedAnnotations = annotations.map(function (a) {
                if (!a.type) {
                    a.type = type;
                }
                if (!a.disable) {
                    a.disable = disable;
                }
                return new Annotation(a);
            });
            collection = collection || new AnnotationCollection({
                annotations: translatedAnnotations,
                accessors: accessors,
                accessorsInverse: accessorsInverse,
                ids: ids
            });
            var annotationG = selection.selectAll("g").data([collection]);
            annotationG.enter().append("g").attr("class", "annotations");
            var group = selection.select("g.annotations");
            newWithClass(group, collection.annotations, "g", "annotation");
            var annotation = group.selectAll("g.annotation");
            annotation.each(function (d) {
                var a = select$3(this);
                a.attr("class", "annotation");
                newWithClass(a, [d], "g", "annotation-connector");
                newWithClass(a, [d], "g", "annotation-subject");
                newWithClass(a, [d], "g", "annotation-note");
                newWithClass(a.select("g.annotation-note"), [d], "g", "annotation-note-content");
                d.type = d.type.toString() === "[object Object]" ? d.type : new d.type({
                    a: a,
                    annotation: d,
                    textWrap: textWrap,
                    notePadding: notePadding,
                    editMode: editMode,
                    dispatcher: annotationDispatcher,
                    accessors: accessors
                });
                d.type.draw();
                d.type.drawText && d.type.drawText();
            });
        };
        annotation.json = function () {
            /* eslint-disable no-console */
            console.log("Annotations JSON was copied to your clipboard. Please note the annotation type is not JSON compatible. It appears in the objects array in the console, but not in the copied JSON.", collection.json);
            /* eslint-enable no-console */
            window.copy(JSON.stringify(collection.json.map(function (a) {
                delete a.type;
                return a;
            })));
            return annotation;
        };
        annotation.update = function () {
            if (annotations && collection) {
                annotations = collection.annotations.map(function (a) {
                    a.type.draw();
                    return a;
                });
            }
            return annotation;
        };
        annotation.updateText = function () {
            if (collection) {
                collection.updateText(textWrap);
                annotations = collection.annotations;
            }
            return annotation;
        };
        annotation.updatedAccessors = function () {
            collection.setPositionWithAccessors();
            annotations = collection.annotations;
            return annotation;
        };
        annotation.disable = function (_) {
            if (!arguments.length)
                return disable;
            disable = _;
            if (collection) {
                collection.updateDisable(disable);
                annotations = collection.annotations;
            }
            return annotation;
        };
        annotation.textWrap = function (_) {
            if (!arguments.length)
                return textWrap;
            textWrap = _;
            if (collection) {
                collection.updateTextWrap(textWrap);
                annotations = collection.annotations;
            }
            return annotation;
        };
        annotation.notePadding = function (_) {
            if (!arguments.length)
                return notePadding;
            notePadding = _;
            if (collection) {
                collection.updateNotePadding(notePadding);
                annotations = collection.annotations;
            }
            return annotation;
        };
        //todo think of how to handle when undefined is sent
        annotation.type = function (_, settings) {
            if (!arguments.length)
                return type;
            type = _;
            if (collection) {
                collection.annotations.map(function (a) {
                    a.type.note && a.type.note.selectAll("*:not(.annotation-note-content)").remove();
                    a.type.noteContent && a.type.noteContent.selectAll("*").remove();
                    a.type.subject && a.type.subject.selectAll("*").remove();
                    a.type.connector && a.type.connector.selectAll("*").remove();
                    a.type.typeSettings = {};
                    a.type = type;
                    a.subject = settings && settings.subject || a.subject;
                    a.connector = settings && settings.connector || a.connector;
                    a.note = settings && settings.note || a.note;
                });
                annotations = collection.annotations;
            }
            return annotation;
        };
        annotation.annotations = function (_) {
            if (!arguments.length)
                return collection && collection.annotations || annotations;
            annotations = _;
            if (collection && collection.annotations) {
                var rerun = annotations.some(function (d) {
                    return !d.type || d.type.toString() !== "[object Object]";
                });
                if (rerun) {
                    collection = null;
                    annotation(sel);
                }
                else {
                    collection.annotations = annotations;
                }
            }
            return annotation;
        };
        annotation.context = function (_) {
            if (!arguments.length)
                return context;
            context = _;
            return annotation;
        };
        annotation.accessors = function (_) {
            if (!arguments.length)
                return accessors;
            accessors = _;
            return annotation;
        };
        annotation.accessorsInverse = function (_) {
            if (!arguments.length)
                return accessorsInverse;
            accessorsInverse = _;
            return annotation;
        };
        annotation.ids = function (_) {
            if (!arguments.length)
                return ids;
            ids = _;
            return annotation;
        };
        annotation.editMode = function (_) {
            if (!arguments.length)
                return editMode;
            editMode = _;
            if (sel) {
                sel.selectAll("g.annotation").classed("editable", editMode);
            }
            if (collection) {
                collection.editMode(editMode);
                annotations = collection.annotations;
            }
            return annotation;
        };
        annotation.collection = function (_) {
            if (!arguments.length)
                return collection;
            collection = _;
            return annotation;
        };
        annotation.on = function () {
            var value = annotationDispatcher.on.apply(annotationDispatcher, arguments);
            return value === annotationDispatcher ? annotation : value;
        };
        return annotation;
    }

    var types = {
        annotationLabel: d3Label,
        annotationCallout: d3Callout,
        annotationCalloutElbow: d3CalloutElbow,
        annotationCalloutCurve: d3CalloutCurve,
        annotationCalloutCircle: d3CalloutCircle,
        annotationCalloutRect: d3CalloutRect,
        annotationXYThreshold: d3XYThreshold,
        annotationBadge: d3Badge
    };
    function annotate(_a) {
        var source = _a.source, data = _a.data, xScale = _a.xScale, xAccessor = _a.xAccessor, yScale = _a.yScale, yAccessor = _a.yAccessor, ignoreScales = _a.ignoreScales, width = _a.width, height = _a.height, padding = _a.padding, margin = _a.margin, bitmaps = _a.bitmaps;
        select$2(source)
            .selectAll('.vcl-annotation-group')
            .remove();
        var annotations = select$2(source)
            .append('g')
            .attr('class', 'vcl-annotation-group')
            .attr('data-testid', 'annotation-group');
        hideNode(annotations.node());
        var editable = select$2(source)
            .append('g')
            .attr('class', 'editable vcl-annotation-group')
            .attr('data-testid', 'editable-annotation-group');
        hideNode(editable.node());
        if (data && data.length) {
            var percentX_1 = linear$5()
                .range(xScale ? xScale.range() : [0, 100])
                .domain([0, 100]);
            var yRange_1 = yScale ? yScale.range() : [0, 100];
            var y0 = yRange_1[0] >= yRange_1[1] ? 100 : 0;
            var y1 = 100 - y0;
            var percentY_1 = linear$5()
                .range(yRange_1)
                .domain([y0, y1]);
            var invertedY_1 = function (d) {
                var height = yRange_1[0] >= yRange_1[1] ? yRange_1[0] : yRange_1[1];
                return yScale(d) - height;
            };
            var annotationData_1 = [];
            var annotationEditableData_1 = [];
            data.forEach(function (datum, i) {
                var d = {};
                var dKeys = Object.keys(datum);
                dKeys.forEach(function (key) {
                    if (key !== 'data' && key !== 'subject' && key !== 'connector' && key !== 'note') {
                        if (datum[key] instanceof Array) {
                            d[key] = __spreadArrays(datum[key]);
                        }
                        else {
                            d[key] = datum[key];
                        }
                    }
                    else {
                        d[key] = {};
                        var innerKeys = Object.keys(datum[key]);
                        innerKeys.forEach(function (innerKey) {
                            if (datum[key][innerKey] instanceof Array) {
                                if (innerKey === 'points') {
                                    // [ // datum[key][innerKey]
                                    //   [ // point
                                    //     40,
                                    //     50
                                    //   ],
                                    //   [
                                    //     200,
                                    //     100
                                    //   ]
                                    // ]
                                    // or
                                    // [ // datum[key][innerKey]
                                    //   [ // point
                                    //     [val,val],
                                    //     [val]
                                    //   ],
                                    //   [
                                    //     [val],
                                    //     [val]
                                    //   ]
                                    // ]
                                    d[key][innerKey] = [];
                                    datum[key][innerKey].forEach(function (point) {
                                        var clonedPoint = [];
                                        if (point[0] instanceof Array && point[1] instanceof Array) {
                                            clonedPoint.push(__spreadArrays(point[0]));
                                            clonedPoint.push(__spreadArrays(point[1]));
                                        }
                                        else {
                                            clonedPoint.push(point[0]);
                                            clonedPoint.push(point[1]);
                                        }
                                        d[key][innerKey].push(clonedPoint);
                                    });
                                }
                                else {
                                    d[key][innerKey] = __spreadArrays(datum[key][innerKey]);
                                }
                            }
                            else {
                                d[key][innerKey] = datum[key][innerKey];
                            }
                        });
                    }
                });
                var yToDate = d.parseAsDates && (d.parseAsDates.includes('y') || d.parseAsDates.includes(yAccessor));
                var xToDate = d.parseAsDates && (d.parseAsDates.includes('x') || d.parseAsDates.includes(xAccessor));
                var diff = 0;
                if (d.data) {
                    var keys = Object.keys(d.data);
                    var i_1 = 0;
                    if (yToDate || xToDate) {
                        for (i_1 = 0; i_1 < keys.length; i_1++) {
                            if (keys[i_1] === 'x' || keys[i_1] === xAccessor) {
                                d.data[keys[i_1]] = checkDate(d.data[keys[i_1]], xToDate);
                            }
                            else if (keys[i_1] === yAccessor || keys[i_1] === 'y') {
                                d.data[keys[i_1]] = checkDate(d.data[keys[i_1]], yToDate);
                            }
                        }
                    }
                }
                if (d.x) {
                    d.x = resolveValue(d.x, xScale, percentX_1, xToDate);
                }
                if (d.y) {
                    d.y = resolveValue(d.y, yScale, percentY_1, yToDate);
                }
                if (d.dx) {
                    if (d.dx instanceof Array) {
                        diff = d.data && d.data[xAccessor] !== undefined ? xScale(d.data[xAccessor]) : d.x ? d.x : 0;
                    }
                    d.dx = resolveValue(d.dx, xScale, percentX_1, xToDate) - diff;
                }
                if (d.dy) {
                    diff = 0;
                    if (d.dy instanceof Array) {
                        diff = d.data && d.data[yAccessor] !== undefined ? yScale(d.data[yAccessor]) : d.y ? d.y : 0;
                    }
                    d.dy = resolveValue(d.dy, yScale, percentY_1, yToDate) - diff;
                }
                if (d.subject) {
                    if (d.subject.x1) {
                        d.subject.x1 = resolveValue(d.subject.x1, xScale, percentX_1, xToDate);
                    }
                    if (d.subject.y1) {
                        d.subject.y1 = resolveValue(d.subject.y1, yScale, percentY_1, yToDate);
                    }
                    if (d.subject.x2) {
                        d.subject.x2 = resolveValue(d.subject.x2, xScale, percentX_1, xToDate);
                    }
                    if (d.subject.y2) {
                        d.subject.y2 = resolveValue(d.subject.y2, yScale, percentY_1, yToDate);
                    }
                    if (d.subject.width) {
                        d.subject.width = resolveValue(d.subject.width, xScale, percentX_1, xToDate);
                    }
                    if (d.subject.height) {
                        d.subject.height = resolveValue(d.subject.height, invertedY_1, percentY_1, yToDate);
                    }
                }
                if (d.connector) {
                    if (typeof d.connector.curve === 'string') {
                        d.connector.curve = d3[d.connector.curve];
                    }
                    if (d.connector.points instanceof Array) {
                        d.connector.points.forEach(function (point) {
                            point[0] = resolveValue(point[0], xScale, percentX_1, xToDate);
                            point[1] = resolveValue(point[1], yScale, percentY_1, yToDate);
                        });
                    }
                }
                if (d.type && typeof d.type === 'string') {
                    d.type = types[d.type];
                }
                if (!d.editMode) {
                    annotationData_1.push(d);
                }
                else {
                    annotationEditableData_1.push(d);
                }
                if (d.color) {
                    d.color = visaColorToHex(d.color) || d.color;
                }
                if (d.collisionHideOnly) {
                    if (d.className) {
                        d.className = d.className + ' annotation-detect-collision';
                    }
                    else {
                        d.className = 'annotation-detect-collision';
                    }
                }
            });
            var makeAnnotations = annotation().annotations(annotationData_1);
            var makeEditableAnnotations = annotation()
                .editMode(true)
                .annotations(annotationEditableData_1);
            if (!ignoreScales) {
                makeAnnotations = annotation()
                    .accessors({
                    x: function (d) {
                        return xScale(d[xAccessor]);
                    },
                    y: function (d) {
                        return yScale(d[yAccessor]);
                    }
                })
                    .annotations(annotationData_1);
                makeEditableAnnotations = annotation()
                    .editMode(true)
                    .accessors({
                    x: function (d) {
                        return xScale(d[xAccessor]);
                    },
                    y: function (d) {
                        return yScale(d[yAccessor]);
                    }
                })
                    .annotations(annotationEditableData_1);
            }
            annotations.call(makeAnnotations);
            editable.call(makeEditableAnnotations);
            // checking if avoidCollision is set in any annotation object that user passed
            if (annotationData_1 && annotationData_1.some(function (e) { return e.collisionHideOnly === true; })) {
                hideOverlappingAnnotations(source, width, height, padding, margin, bitmaps);
            }
            if (annotationEditableData_1 && annotationEditableData_1.some(function (e) { return e.collisionHideOnly === true; })) {
                hideOverlappingAnnotations(source, width, height, padding, margin, bitmaps);
            }
        }
        // addStrokeUnder(
        //   d3
        //     .select(source)
        //     .selectAll('.vcl-annotation-group')
        //     .selectAll('text'),
        //   'white'
        // );
    }
    function resolveValue(d, scale, percentScale, shouldBeDate) {
        if (d) {
            if (d instanceof Array) {
                if (d.length === 1) {
                    return checkZero(scale(checkDate(d[0], shouldBeDate)));
                }
                else if (d.length === 2) {
                    return checkZero(scale(checkDate(d[0], shouldBeDate)) - scale(checkDate(d[1], shouldBeDate)));
                }
            }
            else if (typeof d === 'string' && d.substring(d.length - 1, d.length) === '%') {
                return checkZero(percentScale(+d.substring(0, d.length - 1)));
            }
        }
        return checkZero(d);
    }
    function checkZero(v) {
        if (v === 0) {
            return 0.000000001;
        }
        return v;
    }
    function checkDate(d, shouldCheck) {
        if (shouldCheck) {
            if (typeof d === 'object' && typeof d.getMonth === 'function') {
                return d;
            }
            return new Date(d);
        }
        return d;
    }
    function hideOverlappingAnnotations(source, width, height, padding, margin, bitmaps) {
        // now that we have annotated we can use existing bitmap to check for collisions
        // all annotation shapes are drawn as paths
        // circle.handle is used for edit mode, which we currently don't support
        // annotation-connector
        // path.connector
        // annotation-subject
        // path.subject
        // annotation-note
        // path.note-line
        // annotation-note-content
        // text.annotation-note-label
        // text.annotation-note-title
        // rect.annotation-note-bg
        var annotationsG = select(source)
            .select('.vcl-annotation-group')
            .select('.annotations');
        annotationsG.selectAll('.annotation').style('visibility', null);
        annotationsG.selectAll('.annotation-detect-collision').each(function (_, i, n) {
            // annotationsG.selectAll('.annotation').each((_, i, n) => {
            var me = n[i];
            var annotationTransform = parseTransformSimple(select(me).attr('transform'));
            var annotationTranslate = (annotationTransform && annotationTransform['translate']) || [0, 0];
            // we will need to address transforms on:
            // 1. g.annotation
            // 2. g.annotation-note
            // 3. g.annotation-note-content
            // 4. g.connector path.connector-end.connector-dot
            var annotationNoteTransform = select(me)
                .select('.annotation-note')
                .attr('transform') &&
                parseTransformSimple(select(me)
                    .select('.annotation-note')
                    .attr('transform'));
            var annotationNoteTranslate = (annotationNoteTransform && annotationNoteTransform['translate']) || [0, 0];
            var annotationNoteContentTransform = select(me)
                .select('.annotation-note')
                .select('.annotation-note-content')
                .attr('transform') &&
                parseTransformSimple(select(me)
                    .select('.annotation-note')
                    .select('.annotation-note-content')
                    .attr('transform'));
            var annotationNoteContentTranslate = (annotationNoteContentTransform &&
                annotationNoteContentTransform['translate']) || [0, 0];
            // first thing we can do is add data-d paths to draw all the annotation stuff to bitmap
            // paths will also need to handle the various transforms
            select(me)
                .selectAll('path')
                .each(function (_, i, n) {
                var pathMe = select(n[i]);
                var translateX = annotationTranslate[0] + padding.left + margin.left;
                var translateY = annotationTranslate[1] + padding.top + margin.top;
                if (pathMe.classed('note-line')) {
                    translateX += annotationNoteTranslate[0];
                    translateY += annotationNoteTranslate[1];
                }
                pathMe
                    .attr('data-d', pathMe.attr('d'))
                    .attr('data-translate-x', translateX)
                    .attr('data-translate-y', translateY);
            });
            // next we need to try and handle our texts for the annotations
            // this assumes all text is in the note arena
            var maxDataWidth = 0;
            select(me)
                .selectAll('text')
                .each(function (_, i, n) {
                var textElement = n[i];
                var style = getComputedStyle(textElement);
                var fontSize = parseFloat(style.fontSize);
                var textHeight = Math.max(fontSize - 1, 1); // clone.getBBox().height;
                var textWidth = getTextWidth(textElement.textContent, fontSize, true, style.fontFamily);
                var textMe = select(textElement);
                var translateX = annotationTranslate[0] +
                    annotationNoteTranslate[0] +
                    annotationNoteContentTranslate[0] +
                    padding.left +
                    margin.left;
                var translateY = annotationTranslate[1] +
                    annotationNoteTranslate[1] +
                    annotationNoteContentTranslate[1] +
                    padding.top +
                    margin.top;
                maxDataWidth = Math.max(textWidth, maxDataWidth);
                textMe
                    .attr('data-x', +textMe.attr('x') || 0)
                    .attr('data-y', textHeight / 2 + +textMe.attr('y') || 0)
                    .attr('data-ignore', textWidth === 0)
                    .attr('data-width', textWidth)
                    .attr('data-height', textHeight)
                    .attr('data-translate-x', translateX)
                    .attr('data-translate-y', translateY)
                    .attr('data-no-text-anchor', true);
            });
            // if we have no text we set this flag for visibility check later
            if (maxDataWidth === 0) {
                select(me).attr('data-no-text', true);
            }
        });
        bitmaps = resolveLabelCollision({
            bitmaps: bitmaps,
            labelSelection: select('.nothing-exists-here'),
            avoidMarks: [annotationsG.selectAll('.annotation-detect-collision').selectAll('path')],
            validPositions: ['middle'],
            offsets: [1],
            // offsets: [2, 2, 4, 2, 1, 1, 1, 1],
            accessors: ['cidx'],
            size: [roundTo(width, 0), roundTo(height, 0)] // we need the whole width for series labels
        });
        bitmaps = resolveLabelCollision({
            bitmaps: bitmaps,
            labelSelection: annotationsG.selectAll('.annotation-detect-collision text'),
            avoidMarks: [],
            validPositions: ['middle'],
            offsets: [1],
            accessors: ['cidx'],
            size: [roundTo(width, 0), roundTo(height, 0)] // we need the whole width for series labels
        });
        // now that we have hidden text, we need to  hide the rest of the annotation
        annotationsG.selectAll('.annotation-detect-collision').each(function (_, i, n) {
            var me = n[i];
            var textShownIndicator = false;
            select(me)
                .selectAll('text')
                .each(function (_, i, n) {
                var textElement = n[i];
                var elementIndicator = select(textElement).attr('data-label-hidden') === 'false' &&
                    select(textElement).attr('data-ignore') === 'false';
                textShownIndicator = textShownIndicator || elementIndicator; // if we already have a true, we need to keep it
            });
            // this will flip visibility on the full element if we don't find any visible text
            if (textShownIndicator || select(me).attr('data-no-text') === 'true') {
                select(me).style('visibility', null);
            }
            else {
                select(me).style('visibility', 'hidden');
            }
        });
    }
    function parseTransformSimple(transform) {
        var result = {};
        transform
            .trim()
            .replace(', ', ',')
            .split(' ')
            .forEach(function (transformation) {
            var step1 = transformation.split(')')[0].split(',');
            var step2 = step1[0].split('(');
            result[step2[0]] = [];
            result[step2[0]].push(+step2[1], +step1[1]);
        });
        return result;
    }

    function _extends$1() {
        _extends$1 = Object.assign || function (target) {
            for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                    if (Object.prototype.hasOwnProperty.call(source, key)) {
                        target[key] = source[key];
                    }
                }
            }
            return target;
        };
        return _extends$1.apply(this, arguments);
    }

    /** Used for built-in method references. */
    var objectProto = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;
    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */
    var root$7 = freeGlobal || freeSelf || Function('return this')();

    /** Built-in value references. */
    var Symbol$1 = root$7.Symbol;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$1.toString;
    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
        var isOwn = hasOwnProperty$1.call(value, symToStringTag), tag = value[symToStringTag];
        try {
            value[symToStringTag] = undefined;
            var unmasked = true;
        }
        catch (e) { }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
            if (isOwn) {
                value[symToStringTag] = tag;
            }
            else {
                delete value[symToStringTag];
            }
        }
        return result;
    }

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$2.toString;
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
        return nativeObjectToString$1.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]', undefinedTag = '[object Undefined]';
    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
        if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
        }
        return (symToStringTag$1 && symToStringTag$1 in Object(value))
            ? getRawTag(value)
            : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
        return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';
    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
        return typeof value == 'symbol' ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
        if (isArray(value)) {
            return false;
        }
        var type = typeof value;
        if (type == 'number' || type == 'symbol' || type == 'boolean' ||
            value == null || isSymbol(value)) {
            return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
            (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
        var type = typeof value;
        return value != null && (type == 'object' || type == 'function');
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', proxyTag = '[object Proxy]';
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
        if (!isObject(value)) {
            return false;
        }
        // The use of `Object#toString` avoids issues with the `typeof` operator
        // in Safari 9 which returns 'object' for typed arrays and other constructors.
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /** Used to detect overreaching core-js shims. */
    var coreJsData = root$7['__core-js_shared__'];

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function () {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
        return uid ? ('Symbol(src)_1.' + uid) : '';
    }());
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
        return !!maskSrcKey && (maskSrcKey in func);
    }

    /** Used for built-in method references. */
    var funcProto = Function.prototype;
    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
        if (func != null) {
            try {
                return funcToString.call(func);
            }
            catch (e) { }
            try {
                return (func + '');
            }
            catch (e) { }
        }
        return '';
    }

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype, objectProto$3 = Object.prototype;
    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;
    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
        funcToString$1.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&')
            .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
            return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
    }

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
        return object == null ? undefined : object[key];
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined;
    }

    /* Built-in method references that are verified to be native. */
    var nativeCreate = getNative(Object, 'create');

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
        }
        return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
    }

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
        return this;
    }

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
        return value === other || (value !== value && other !== other);
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
            if (eq(array[length][0], key)) {
                return length;
            }
        }
        return -1;
    }

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;
    /** Built-in value references. */
    var splice = arrayProto.splice;
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
            data.pop();
        }
        else {
            splice.call(data, index, 1);
        }
        --this.size;
        return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
            ++this.size;
            data.push([key, value]);
        }
        else {
            data[index][1] = value;
        }
        return this;
    }

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /* Built-in method references that are verified to be native. */
    var Map$4 = getNative(root$7, 'Map');

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
            'hash': new Hash,
            'map': new (Map$4 || ListCache),
            'string': new Hash
        };
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
        var type = typeof value;
        return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
            ? (value !== '__proto__')
            : (value === null);
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key)
            ? data[typeof key == 'string' ? 'string' : 'hash']
            : data.map;
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
        var result = getMapData(this, key)['delete'](key);
        this.size -= result ? 1 : 0;
        return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
        return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
        return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
    }

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
        }
    }
    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';
    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
        if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function () {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
                return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
    }
    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;
    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
        var result = memoize(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
            }
            return key;
        });
        var cache = result.cache;
        return result;
    }

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;
    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function (string) {
        var result = [];
        if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
        }
        string.replace(rePropName, function (match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
        });
        return result;
    });

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
            result[index] = iteratee(array[index], index, array);
        }
        return result;
    }

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;
    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
        // Exit early for strings to avoid a performance hit in some environments.
        if (typeof value == 'string') {
            return value;
        }
        if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
        }
        if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
        }
        var result = (value + '');
        return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
        return value == null ? '' : baseToString(value);
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
        if (isArray(value)) {
            return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]';
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function () { return arguments; }()) ? baseIsArguments : function (value) {
        return isObjectLike(value) && hasOwnProperty$5.call(value, 'callee') &&
            !propertyIsEnumerable.call(value, 'callee');
    };

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length &&
            (type == 'number' ||
                (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
        return typeof value == 'number' &&
            value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
    }

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;
    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
        if (typeof value == 'string' || isSymbol(value)) {
            return value;
        }
        var result = (value + '');
        return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
                break;
            }
            object = object[key];
        }
        if (result || ++index != length) {
            return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) &&
            (isArray(object) || isArguments(object));
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
        var data = this.__data__, result = data['delete'](key);
        this.size = data.size;
        return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
        return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
        return this.__data__.has(key);
    }

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map$4 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
            }
            data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
    }

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
    }
    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */
    function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
                break;
            }
        }
        return array;
    }

    var defineProperty = (function () {
        try {
            var func = getNative(Object, 'defineProperty');
            func({}, '', {});
            return func;
        }
        catch (e) { }
    }());

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
        if (key == '__proto__' && defineProperty) {
            defineProperty(object, key, {
                'configurable': true,
                'enumerable': true,
                'value': value,
                'writable': true
            });
        }
        else {
            object[key] = value;
        }
    }

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty$6.call(object, key) && eq(objValue, value)) ||
            (value === undefined && !(key in object))) {
            baseAssignValue(object, key, value);
        }
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
            var key = props[index];
            var newValue = customizer
                ? customizer(object[key], source[key], key, object, source)
                : undefined;
            if (newValue === undefined) {
                newValue = source[key];
            }
            if (isNew) {
                baseAssignValue(object, key, newValue);
            }
            else {
                assignValue(object, key, newValue);
            }
        }
        return object;
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
            result[index] = iteratee(index);
        }
        return result;
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
        return false;
    }

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Built-in value references. */
    var Buffer = moduleExports ? root$7.Buffer : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]', arrayTag = '[object Array]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag$1 = '[object Function]', mapTag = '[object Map]', numberTag = '[object Number]', objectTag = '[object Object]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
        typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
            typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
                typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
                    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
        typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
            typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
                typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
                    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
                        typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
                            typedArrayTags[setTag] = typedArrayTags[stringTag] =
                                typedArrayTags[weakMapTag] = false;
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
        return isObjectLike(value) &&
            isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
        return function (value) {
            return func(value);
        };
    }

    /** Detect free variable `exports`. */
    var freeExports$1 = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */
    var freeModule$1 = freeExports$1 && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports$1 && freeGlobal.process;
    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function () {
        try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;
            if (types) {
                return types;
            }
            // Legacy `process.binding('util')` for Node.js < 10.
            return freeProcess && freeProcess.binding && freeProcess.binding('util');
        }
        catch (e) { }
    }());

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
            if ((inherited || hasOwnProperty$7.call(value, key)) &&
                !(skipIndexes && (
                // Safari 9 has enumerable `arguments.length` in strict mode.
                key == 'length' ||
                    // Node.js 0.10 has enumerable non-index properties on buffers.
                    (isBuff && (key == 'offset' || key == 'parent')) ||
                    // PhantomJS 2 has enumerable non-index properties on typed arrays.
                    (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                    // Skip index properties.
                    isIndex(key, length)))) {
                result.push(key);
            }
        }
        return result;
    }

    /** Used for built-in method references. */
    var objectProto$9 = Object.prototype;
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
        var Ctor = value && value.constructor, proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$9;
        return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
        return function (arg) {
            return func(transform(arg));
        };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */
    var objectProto$a = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
        if (!isPrototype(object)) {
            return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
            if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
                result.push(key);
            }
        }
        return result;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys$1(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
        return object && copyObject(source, keys$1(source), object);
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
            for (var key in Object(object)) {
                result.push(key);
            }
        }
        return result;
    }

    /** Used for built-in method references. */
    var objectProto$b = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
        if (!isObject(object)) {
            return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {
                result.push(key);
            }
        }
        return result;
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
    }

    /** Detect free variable `exports`. */
    var freeExports$2 = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */
    var freeModule$2 = freeExports$2 && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
    /** Built-in value references. */
    var Buffer$1 = moduleExports$2 ? root$7.Buffer : undefined, allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;
    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
            return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
            array[index] = source[index];
        }
        return array;
    }

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
                result[resIndex++] = value;
            }
        }
        return result;
    }

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
        return [];
    }

    /** Used for built-in method references. */
    var objectProto$c = Object.prototype;
    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$c.propertyIsEnumerable;
    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
        if (object == null) {
            return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function (symbol) {
            return propertyIsEnumerable$1.call(object, symbol);
        });
    };

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
    }

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
            array[offset + index] = values[index];
        }
        return array;
    }

    /** Built-in value references. */
    var getPrototype = overArg(Object.getPrototypeOf, Object);

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols$1 ? stubArray : function (object) {
        var result = [];
        while (object) {
            arrayPush(result, getSymbols(object));
            object = getPrototype(object);
        }
        return result;
    };

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
        return baseGetAllKeys(object, keys$1, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /* Built-in method references that are verified to be native. */
    var DataView$1 = getNative(root$7, 'DataView');

    /* Built-in method references that are verified to be native. */
    var Promise$1 = getNative(root$7, 'Promise');

    /* Built-in method references that are verified to be native. */
    var Set$4 = getNative(root$7, 'Set');

    /* Built-in method references that are verified to be native. */
    var WeakMap = getNative(root$7, 'WeakMap');

    /** `Object#toString` result references. */
    var mapTag$1 = '[object Map]', objectTag$1 = '[object Object]', promiseTag = '[object Promise]', setTag$1 = '[object Set]', weakMapTag$1 = '[object WeakMap]';
    var dataViewTag$1 = '[object DataView]';
    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$4), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$4), weakMapCtorString = toSource(WeakMap);
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;
    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1) ||
        (Map$4 && getTag(new Map$4) != mapTag$1) ||
        (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
        (Set$4 && getTag(new Set$4) != setTag$1) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag$1)) {
        getTag = function (value) {
            var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
            if (ctorString) {
                switch (ctorString) {
                    case dataViewCtorString: return dataViewTag$1;
                    case mapCtorString: return mapTag$1;
                    case promiseCtorString: return promiseTag;
                    case setCtorString: return setTag$1;
                    case weakMapCtorString: return weakMapTag$1;
                }
            }
            return result;
        };
    }
    var getTag$1 = getTag;

    /** Used for built-in method references. */
    var objectProto$d = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$a = objectProto$d.hasOwnProperty;
    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        // Add properties assigned by `RegExp#exec`.
        if (length && typeof array[0] == 'string' && hasOwnProperty$a.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
        }
        return result;
    }

    /** Built-in value references. */
    var Uint8Array = root$7.Uint8Array;

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
        return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /** Used to match `RegExp` flags from their coerced string values. */
    var reFlags = /\w*$/;
    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
    }

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;
    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /** `Object#toString` result references. */
    var boolTag$1 = '[object Boolean]', dateTag$1 = '[object Date]', mapTag$2 = '[object Map]', numberTag$1 = '[object Number]', regexpTag$1 = '[object RegExp]', setTag$2 = '[object Set]', stringTag$1 = '[object String]', symbolTag$1 = '[object Symbol]';
    var arrayBufferTag$1 = '[object ArrayBuffer]', dataViewTag$2 = '[object DataView]', float32Tag$1 = '[object Float32Array]', float64Tag$1 = '[object Float64Array]', int8Tag$1 = '[object Int8Array]', int16Tag$1 = '[object Int16Array]', int32Tag$1 = '[object Int32Array]', uint8Tag$1 = '[object Uint8Array]', uint8ClampedTag$1 = '[object Uint8ClampedArray]', uint16Tag$1 = '[object Uint16Array]', uint32Tag$1 = '[object Uint32Array]';
    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
            case arrayBufferTag$1:
                return cloneArrayBuffer(object);
            case boolTag$1:
            case dateTag$1:
                return new Ctor(+object);
            case dataViewTag$2:
                return cloneDataView(object, isDeep);
            case float32Tag$1:
            case float64Tag$1:
            case int8Tag$1:
            case int16Tag$1:
            case int32Tag$1:
            case uint8Tag$1:
            case uint8ClampedTag$1:
            case uint16Tag$1:
            case uint32Tag$1:
                return cloneTypedArray(object, isDeep);
            case mapTag$2:
                return new Ctor;
            case numberTag$1:
            case stringTag$1:
                return new Ctor(object);
            case regexpTag$1:
                return cloneRegExp(object);
            case setTag$2:
                return new Ctor;
            case symbolTag$1:
                return cloneSymbol(object);
        }
    }

    /** Built-in value references. */
    var objectCreate = Object.create;
    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function () {
        function object() { }
        return function (proto) {
            if (!isObject(proto)) {
                return {};
            }
            if (objectCreate) {
                return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object;
            object.prototype = undefined;
            return result;
        };
    }());

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
        return (typeof object.constructor == 'function' && !isPrototype(object))
            ? baseCreate(getPrototype(object))
            : {};
    }

    /** `Object#toString` result references. */
    var mapTag$3 = '[object Map]';
    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
        return isObjectLike(value) && getTag$1(value) == mapTag$3;
    }

    /* Node.js helper references. */
    var nodeIsMap = nodeUtil && nodeUtil.isMap;
    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /** `Object#toString` result references. */
    var setTag$3 = '[object Set]';
    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
        return isObjectLike(value) && getTag$1(value) == setTag$3;
    }

    /* Node.js helper references. */
    var nodeIsSet = nodeUtil && nodeUtil.isSet;
    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]', arrayTag$1 = '[object Array]', boolTag$2 = '[object Boolean]', dateTag$2 = '[object Date]', errorTag$1 = '[object Error]', funcTag$2 = '[object Function]', genTag$1 = '[object GeneratorFunction]', mapTag$4 = '[object Map]', numberTag$2 = '[object Number]', objectTag$2 = '[object Object]', regexpTag$2 = '[object RegExp]', setTag$4 = '[object Set]', stringTag$2 = '[object String]', symbolTag$2 = '[object Symbol]', weakMapTag$2 = '[object WeakMap]';
    var arrayBufferTag$2 = '[object ArrayBuffer]', dataViewTag$3 = '[object DataView]', float32Tag$2 = '[object Float32Array]', float64Tag$2 = '[object Float64Array]', int8Tag$2 = '[object Int8Array]', int16Tag$2 = '[object Int16Array]', int32Tag$2 = '[object Int32Array]', uint8Tag$2 = '[object Uint8Array]', uint8ClampedTag$2 = '[object Uint8ClampedArray]', uint16Tag$2 = '[object Uint16Array]', uint32Tag$2 = '[object Uint32Array]';
    /** Used to identify `toStringTag` values supported by `_.clone`. */
    var cloneableTags = {};
    cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] =
        cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
            cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
                cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
                    cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
                        cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] =
                            cloneableTags[numberTag$2] = cloneableTags[objectTag$2] =
                                cloneableTags[regexpTag$2] = cloneableTags[setTag$4] =
                                    cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] =
                                        cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
                                            cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
    cloneableTags[errorTag$1] = cloneableTags[funcTag$2] =
        cloneableTags[weakMapTag$2] = false;
    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== undefined) {
            return result;
        }
        if (!isObject(value)) {
            return value;
        }
        var isArr = isArray(value);
        if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
                return copyArray(value, result);
            }
        }
        else {
            var tag = getTag$1(value), isFunc = tag == funcTag$2 || tag == genTag$1;
            if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag$2 || tag == argsTag$2 || (isFunc && !object)) {
                result = (isFlat || isFunc) ? {} : initCloneObject(value);
                if (!isDeep) {
                    return isFlat
                        ? copySymbolsIn(value, baseAssignIn(result, value))
                        : copySymbols(value, baseAssign(result, value));
                }
            }
            else {
                if (!cloneableTags[tag]) {
                    return object ? value : {};
                }
                result = initCloneByTag(value, tag, isDeep);
            }
        }
        // Check for circular references and return its corresponding clone.
        stack || (stack = new Stack);
        var stacked = stack.get(value);
        if (stacked) {
            return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
            value.forEach(function (subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
        }
        else if (isMap(value)) {
            value.forEach(function (subValue, key) {
                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
        }
        var keysFunc = isFull
            ? (isFlat ? getAllKeysIn : getAllKeys)
            : (isFlat ? keysIn : keys$1);
        var props = isArr ? undefined : keysFunc(value);
        arrayEach(props || value, function (subValue, key) {
            if (props) {
                key = subValue;
                subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
        return result;
    }

    /** Used to compose bitmasks for cloning. */
    var CLONE_DEEP_FLAG$1 = 1, CLONE_SYMBOLS_FLAG$1 = 4;
    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == 'function' ? customizer : undefined;
        return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1, customizer);
    }

    /** `Object#toString` result references. */
    var stringTag$3 = '[object String]';
    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
        return typeof value == 'string' ||
            (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag$3);
    }

    /**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */
    function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
            result.push(data.value);
        }
        return result;
    }

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function (value, key) {
            result[++index] = [key, value];
        });
        return result;
    }

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function (value) {
            result[++index] = value;
        });
        return result;
    }

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function asciiToArray(string) {
        return string.split('');
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff', rsComboMarksRange = '\\u0300-\\u036f', reComboHalfMarksRange = '\\ufe20-\\ufe2f', rsComboSymbolsRange = '\\u20d0-\\u20ff', rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = '\\ufe0e\\ufe0f';
    /** Used to compose unicode capture groups. */
    var rsZWJ = '\\u200d';
    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');
    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode(string) {
        return reHasUnicode.test(string);
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange$1 = '\\ud800-\\udfff', rsComboMarksRange$1 = '\\u0300-\\u036f', reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f', rsComboSymbolsRange$1 = '\\u20d0-\\u20ff', rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = '\\ufe0e\\ufe0f';
    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange$1 + ']', rsCombo = '[' + rsComboRange$1 + ']', rsFitz = '\\ud83c[\\udffb-\\udfff]', rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')', rsNonAstral = '[^' + rsAstralRange$1 + ']', rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsZWJ$1 = '\\u200d';
    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?', rsOptVar = '[' + rsVarRange$1 + ']?', rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*', rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray(string) {
        return string.match(reUnicode) || [];
    }

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
        return hasUnicode(string)
            ? unicodeToArray(string)
            : asciiToArray(string);
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
        return arrayMap(props, function (key) {
            return object[key];
        });
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values$1(object) {
        return object == null ? [] : baseValues(object, keys$1(object));
    }

    /** `Object#toString` result references. */
    var mapTag$5 = '[object Map]', setTag$5 = '[object Set]';
    /** Built-in value references. */
    var symIterator = Symbol$1 ? Symbol$1.iterator : undefined;
    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
        if (!value) {
            return [];
        }
        if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
        }
        var tag = getTag$1(value), func = tag == mapTag$5 ? mapToArray : (tag == setTag$5 ? setToArray : values$1);
        return func(value);
    }

    var toString$1 = Object.prototype.toString;
    var errorToString = Error.prototype.toString;
    var regExpToString = RegExp.prototype.toString;
    var symbolToString$1 = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : function () {
        return '';
    };
    var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
    function printNumber(val) {
        if (val != +val)
            return 'NaN';
        var isNegativeZero = val === 0 && 1 / val < 0;
        return isNegativeZero ? '-0' : '' + val;
    }
    function printSimpleValue(val, quoteStrings) {
        if (quoteStrings === void 0) {
            quoteStrings = false;
        }
        if (val == null || val === true || val === false)
            return '' + val;
        var typeOf = typeof val;
        if (typeOf === 'number')
            return printNumber(val);
        if (typeOf === 'string')
            return quoteStrings ? "\"" + val + "\"" : val;
        if (typeOf === 'function')
            return '[Function ' + (val.name || 'anonymous') + ']';
        if (typeOf === 'symbol')
            return symbolToString$1.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
        var tag = toString$1.call(val).slice(8, -1);
        if (tag === 'Date')
            return isNaN(val.getTime()) ? '' + val : val.toISOString(val);
        if (tag === 'Error' || val instanceof Error)
            return '[' + errorToString.call(val) + ']';
        if (tag === 'RegExp')
            return regExpToString.call(val);
        return null;
    }
    function printValue(value, quoteStrings) {
        var result = printSimpleValue(value, quoteStrings);
        if (result !== null)
            return result;
        return JSON.stringify(value, function (key, value) {
            var result = printSimpleValue(this[key], quoteStrings);
            if (result !== null)
                return result;
            return value;
        }, 2);
    }

    var mixed = {
        default: '${path} is invalid',
        required: '${path} is a required field',
        oneOf: '${path} must be one of the following values: ${values}',
        notOneOf: '${path} must not be one of the following values: ${values}',
        notType: function notType(_ref) {
            var path = _ref.path, type = _ref.type, value = _ref.value, originalValue = _ref.originalValue;
            var isCast = originalValue != null && originalValue !== value;
            var msg = path + " must be a `" + type + "` type, " + ("but the final value was: `" + printValue(value, true) + "`") + (isCast ? " (cast from the value `" + printValue(originalValue, true) + "`)." : '.');
            if (value === null) {
                msg += "\n If \"null\" is intended as an empty value be sure to mark the schema as `.nullable()`";
            }
            return msg;
        },
        defined: '${path} must be defined'
    };
    var string$2 = {
        length: '${path} must be exactly ${length} characters',
        min: '${path} must be at least ${min} characters',
        max: '${path} must be at most ${max} characters',
        matches: '${path} must match the following: "${regex}"',
        email: '${path} must be a valid email',
        url: '${path} must be a valid URL',
        trim: '${path} must be a trimmed string',
        lowercase: '${path} must be a lowercase string',
        uppercase: '${path} must be a upper case string'
    };
    var number$9 = {
        min: '${path} must be greater than or equal to ${min}',
        max: '${path} must be less than or equal to ${max}',
        lessThan: '${path} must be less than ${less}',
        moreThan: '${path} must be greater than ${more}',
        notEqual: '${path} must be not equal to ${notEqual}',
        positive: '${path} must be a positive number',
        negative: '${path} must be a negative number',
        integer: '${path} must be an integer'
    };
    var date$4 = {
        min: '${path} field must be later than ${min}',
        max: '${path} field must be at earlier than ${max}'
    };
    var object$4 = {
        noUnknown: '${path} field has unspecified keys: ${unknown}'
    };
    var array$4 = {
        min: '${path} field must have at least ${min} items',
        max: '${path} field must have less than or equal to ${max} items'
    };

    var isSchema = (function (obj) {
        return obj && obj.__isYupSchema__;
    });

    var Condition = /*#__PURE__*/ function () {
        function Condition(refs, options) {
            this.refs = refs;
            if (typeof options === 'function') {
                this.fn = options;
                return;
            }
            if (!has(options, 'is'))
                throw new TypeError('`is:` is required for `when()` conditions');
            if (!options.then && !options.otherwise)
                throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');
            var is = options.is, then = options.then, otherwise = options.otherwise;
            var check = typeof is === 'function' ? is : function () {
                for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
                    values[_key] = arguments[_key];
                }
                return values.every(function (value) {
                    return value === is;
                });
            };
            this.fn = function () {
                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                }
                var options = args.pop();
                var schema = args.pop();
                var branch = check.apply(void 0, args) ? then : otherwise;
                if (!branch)
                    return undefined;
                if (typeof branch === 'function')
                    return branch(schema);
                return schema.concat(branch.resolve(options));
            };
        }
        var _proto = Condition.prototype;
        _proto.resolve = function resolve(base, options) {
            var values = this.refs.map(function (ref) {
                return ref.getValue(options);
            });
            var schema = this.fn.apply(base, values.concat(base, options));
            if (schema === undefined || schema === base)
                return base;
            if (!isSchema(schema))
                throw new TypeError('conditions must return a schema object');
            return schema.resolve(options);
        };
        return Condition;
    }();

    function _objectWithoutPropertiesLoose(source, excluded) {
        if (source == null)
            return {};
        var target = {};
        var sourceKeys = Object.keys(source);
        var key, i;
        for (i = 0; i < sourceKeys.length; i++) {
            key = sourceKeys[i];
            if (excluded.indexOf(key) >= 0)
                continue;
            target[key] = source[key];
        }
        return target;
    }

    /* jshint node: true */
    function makeArrayFrom(obj) {
        return Array.prototype.slice.apply(obj);
    }
    var PENDING = "pending", RESOLVED = "resolved", REJECTED = "rejected";
    function SynchronousPromise(handler) {
        this.status = PENDING;
        this._continuations = [];
        this._parent = null;
        this._paused = false;
        if (handler) {
            handler.call(this, this._continueWith.bind(this), this._failWith.bind(this));
        }
    }
    function looksLikeAPromise(obj) {
        return obj && typeof (obj.then) === "function";
    }
    function passThrough(value) {
        return value;
    }
    SynchronousPromise.prototype = {
        then: function (nextFn, catchFn) {
            var next = SynchronousPromise.unresolved()._setParent(this);
            if (this._isRejected()) {
                if (this._paused) {
                    this._continuations.push({
                        promise: next,
                        nextFn: nextFn,
                        catchFn: catchFn
                    });
                    return next;
                }
                if (catchFn) {
                    try {
                        var catchResult = catchFn(this._error);
                        if (looksLikeAPromise(catchResult)) {
                            this._chainPromiseData(catchResult, next);
                            return next;
                        }
                        else {
                            return SynchronousPromise.resolve(catchResult)._setParent(this);
                        }
                    }
                    catch (e) {
                        return SynchronousPromise.reject(e)._setParent(this);
                    }
                }
                return SynchronousPromise.reject(this._error)._setParent(this);
            }
            this._continuations.push({
                promise: next,
                nextFn: nextFn,
                catchFn: catchFn
            });
            this._runResolutions();
            return next;
        },
        catch: function (handler) {
            if (this._isResolved()) {
                return SynchronousPromise.resolve(this._data)._setParent(this);
            }
            var next = SynchronousPromise.unresolved()._setParent(this);
            this._continuations.push({
                promise: next,
                catchFn: handler
            });
            this._runRejections();
            return next;
        },
        finally: function (callback) {
            var ran = false;
            function runFinally(result, err) {
                if (!ran) {
                    ran = true;
                    if (!callback) {
                        callback = passThrough;
                    }
                    var callbackResult = callback(result);
                    if (looksLikeAPromise(callbackResult)) {
                        return callbackResult.then(function () {
                            if (err) {
                                throw err;
                            }
                            return result;
                        });
                    }
                    else {
                        return result;
                    }
                }
            }
            return this
                .then(function (result) {
                return runFinally(result);
            })
                .catch(function (err) {
                return runFinally(null, err);
            });
        },
        pause: function () {
            this._paused = true;
            return this;
        },
        resume: function () {
            var firstPaused = this._findFirstPaused();
            if (firstPaused) {
                firstPaused._paused = false;
                firstPaused._runResolutions();
                firstPaused._runRejections();
            }
            return this;
        },
        _findAncestry: function () {
            return this._continuations.reduce(function (acc, cur) {
                if (cur.promise) {
                    var node = {
                        promise: cur.promise,
                        children: cur.promise._findAncestry()
                    };
                    acc.push(node);
                }
                return acc;
            }, []);
        },
        _setParent: function (parent) {
            if (this._parent) {
                throw new Error("parent already set");
            }
            this._parent = parent;
            return this;
        },
        _continueWith: function (data) {
            var firstPending = this._findFirstPending();
            if (firstPending) {
                firstPending._data = data;
                firstPending._setResolved();
            }
        },
        _findFirstPending: function () {
            return this._findFirstAncestor(function (test) {
                return test._isPending && test._isPending();
            });
        },
        _findFirstPaused: function () {
            return this._findFirstAncestor(function (test) {
                return test._paused;
            });
        },
        _findFirstAncestor: function (matching) {
            var test = this;
            var result;
            while (test) {
                if (matching(test)) {
                    result = test;
                }
                test = test._parent;
            }
            return result;
        },
        _failWith: function (error) {
            var firstRejected = this._findFirstPending();
            if (firstRejected) {
                firstRejected._error = error;
                firstRejected._setRejected();
            }
        },
        _takeContinuations: function () {
            return this._continuations.splice(0, this._continuations.length);
        },
        _runRejections: function () {
            if (this._paused || !this._isRejected()) {
                return;
            }
            var error = this._error, continuations = this._takeContinuations(), self = this;
            continuations.forEach(function (cont) {
                if (cont.catchFn) {
                    try {
                        var catchResult = cont.catchFn(error);
                        self._handleUserFunctionResult(catchResult, cont.promise);
                    }
                    catch (e) {
                        cont.promise.reject(e);
                    }
                }
                else {
                    cont.promise.reject(error);
                }
            });
        },
        _runResolutions: function () {
            if (this._paused || !this._isResolved() || this._isPending()) {
                return;
            }
            var continuations = this._takeContinuations();
            if (looksLikeAPromise(this._data)) {
                return this._handleWhenResolvedDataIsPromise(this._data);
            }
            var data = this._data;
            var self = this;
            continuations.forEach(function (cont) {
                if (cont.nextFn) {
                    try {
                        var result = cont.nextFn(data);
                        self._handleUserFunctionResult(result, cont.promise);
                    }
                    catch (e) {
                        self._handleResolutionError(e, cont);
                    }
                }
                else if (cont.promise) {
                    cont.promise.resolve(data);
                }
            });
        },
        _handleResolutionError: function (e, continuation) {
            this._setRejected();
            if (continuation.catchFn) {
                try {
                    continuation.catchFn(e);
                    return;
                }
                catch (e2) {
                    e = e2;
                }
            }
            if (continuation.promise) {
                continuation.promise.reject(e);
            }
        },
        _handleWhenResolvedDataIsPromise: function (data) {
            var self = this;
            return data.then(function (result) {
                self._data = result;
                self._runResolutions();
            }).catch(function (error) {
                self._error = error;
                self._setRejected();
                self._runRejections();
            });
        },
        _handleUserFunctionResult: function (data, nextSynchronousPromise) {
            if (looksLikeAPromise(data)) {
                this._chainPromiseData(data, nextSynchronousPromise);
            }
            else {
                nextSynchronousPromise.resolve(data);
            }
        },
        _chainPromiseData: function (promiseData, nextSynchronousPromise) {
            promiseData.then(function (newData) {
                nextSynchronousPromise.resolve(newData);
            }).catch(function (newError) {
                nextSynchronousPromise.reject(newError);
            });
        },
        _setResolved: function () {
            this.status = RESOLVED;
            if (!this._paused) {
                this._runResolutions();
            }
        },
        _setRejected: function () {
            this.status = REJECTED;
            if (!this._paused) {
                this._runRejections();
            }
        },
        _isPending: function () {
            return this.status === PENDING;
        },
        _isResolved: function () {
            return this.status === RESOLVED;
        },
        _isRejected: function () {
            return this.status === REJECTED;
        }
    };
    SynchronousPromise.resolve = function (result) {
        return new SynchronousPromise(function (resolve, reject) {
            if (looksLikeAPromise(result)) {
                result.then(function (newResult) {
                    resolve(newResult);
                }).catch(function (error) {
                    reject(error);
                });
            }
            else {
                resolve(result);
            }
        });
    };
    SynchronousPromise.reject = function (result) {
        return new SynchronousPromise(function (resolve, reject) {
            reject(result);
        });
    };
    SynchronousPromise.unresolved = function () {
        return new SynchronousPromise(function (resolve, reject) {
            this.resolve = resolve;
            this.reject = reject;
        });
    };
    SynchronousPromise.all = function () {
        var args = makeArrayFrom(arguments);
        if (Array.isArray(args[0])) {
            args = args[0];
        }
        if (!args.length) {
            return SynchronousPromise.resolve([]);
        }
        return new SynchronousPromise(function (resolve, reject) {
            var allData = [], numResolved = 0, doResolve = function () {
                if (numResolved === args.length) {
                    resolve(allData);
                }
            }, rejected = false, doReject = function (err) {
                if (rejected) {
                    return;
                }
                rejected = true;
                reject(err);
            };
            args.forEach(function (arg, idx) {
                SynchronousPromise.resolve(arg).then(function (thisResult) {
                    allData[idx] = thisResult;
                    numResolved += 1;
                    doResolve();
                }).catch(function (err) {
                    doReject(err);
                });
            });
        });
    };
    function createAggregateErrorFrom(errors) {
        /* jshint ignore:start */
        if (typeof window !== "undefined" && "AggregateError" in window) {
            return new window.AggregateError(errors);
        }
        /* jshint ignore:end */
        return { errors: errors };
    }
    SynchronousPromise.any = function () {
        var args = makeArrayFrom(arguments);
        if (Array.isArray(args[0])) {
            args = args[0];
        }
        if (!args.length) {
            return SynchronousPromise.reject(createAggregateErrorFrom([]));
        }
        return new SynchronousPromise(function (resolve, reject) {
            var allErrors = [], numRejected = 0, doReject = function () {
                if (numRejected === args.length) {
                    reject(createAggregateErrorFrom(allErrors));
                }
            }, resolved = false, doResolve = function (result) {
                if (resolved) {
                    return;
                }
                resolved = true;
                resolve(result);
            };
            args.forEach(function (arg, idx) {
                SynchronousPromise.resolve(arg).then(function (thisResult) {
                    doResolve(thisResult);
                }).catch(function (err) {
                    allErrors[idx] = err;
                    numRejected += 1;
                    doReject();
                });
            });
        });
    };
    SynchronousPromise.allSettled = function () {
        var args = makeArrayFrom(arguments);
        if (Array.isArray(args[0])) {
            args = args[0];
        }
        if (!args.length) {
            return SynchronousPromise.resolve([]);
        }
        return new SynchronousPromise(function (resolve) {
            var allData = [], numSettled = 0, doSettled = function () {
                numSettled += 1;
                if (numSettled === args.length) {
                    resolve(allData);
                }
            };
            args.forEach(function (arg, idx) {
                SynchronousPromise.resolve(arg).then(function (thisResult) {
                    allData[idx] = {
                        status: "fulfilled",
                        value: thisResult
                    };
                    doSettled();
                }).catch(function (err) {
                    allData[idx] = {
                        status: "rejected",
                        reason: err
                    };
                    doSettled();
                });
            });
        });
    };
    /* jshint ignore:start */
    if (Promise === SynchronousPromise) {
        throw new Error("Please use SynchronousPromise.installGlobally() to install globally");
    }
    var RealPromise = Promise;
    SynchronousPromise.installGlobally = function (__awaiter) {
        if (Promise === SynchronousPromise) {
            return __awaiter;
        }
        var result = patchAwaiterIfRequired(__awaiter);
        Promise = SynchronousPromise;
        return result;
    };
    SynchronousPromise.uninstallGlobally = function () {
        if (Promise === SynchronousPromise) {
            Promise = RealPromise;
        }
    };
    function patchAwaiterIfRequired(__awaiter) {
        if (typeof (__awaiter) === "undefined" || __awaiter.__patched) {
            return __awaiter;
        }
        var originalAwaiter = __awaiter;
        __awaiter = function () {
            originalAwaiter.apply(this, makeArrayFrom(arguments));
        };
        __awaiter.__patched = true;
        return __awaiter;
    }
    /* jshint ignore:end */
    var synchronousPromise = {
        SynchronousPromise: SynchronousPromise
    };
    var synchronousPromise_1 = synchronousPromise.SynchronousPromise;

    var strReg = /\$\{\s*(\w+)\s*\}/g;
    var replace = function replace(str) {
        return function (params) {
            return str.replace(strReg, function (_, key) {
                return printValue(params[key]);
            });
        };
    };
    function ValidationError(errors, value, field, type) {
        var _this = this;
        this.name = 'ValidationError';
        this.value = value;
        this.path = field;
        this.type = type;
        this.errors = [];
        this.inner = [];
        if (errors)
            [].concat(errors).forEach(function (err) {
                _this.errors = _this.errors.concat(err.errors || err);
                if (err.inner)
                    _this.inner = _this.inner.concat(err.inner.length ? err.inner : err);
            });
        this.message = this.errors.length > 1 ? this.errors.length + " errors occurred" : this.errors[0];
        if (Error.captureStackTrace)
            Error.captureStackTrace(this, ValidationError);
    }
    ValidationError.prototype = Object.create(Error.prototype);
    ValidationError.prototype.constructor = ValidationError;
    ValidationError.isError = function (err) {
        return err && err.name === 'ValidationError';
    };
    ValidationError.formatError = function (message, params) {
        if (typeof message === 'string')
            message = replace(message);
        var fn = function fn(params) {
            params.path = params.label || params.path || 'this';
            return typeof message === 'function' ? message(params) : message;
        };
        return arguments.length === 1 ? fn : fn(params);
    };

    var promise = function promise(sync) {
        return sync ? synchronousPromise_1 : Promise;
    };
    var unwrapError = function unwrapError(errors) {
        if (errors === void 0) {
            errors = [];
        }
        return errors.inner && errors.inner.length ? errors.inner : [].concat(errors);
    };
    function scopeToValue(promises, value, sync) {
        //console.log('scopeToValue', promises, value)
        var p = promise(sync).all(promises); //console.log('scopeToValue B', p)
        var b = p.catch(function (err) {
            if (err.name === 'ValidationError')
                err.value = value;
            throw err;
        }); //console.log('scopeToValue c', b)
        var c = b.then(function () {
            return value;
        }); //console.log('scopeToValue d', c)
        return c;
    }
    /**
     * If not failing on the first error, catch the errors
     * and collect them in an array
     */
    function propagateErrors(endEarly, errors) {
        return endEarly ? null : function (err) {
            errors.push(err);
            return err.value;
        };
    }
    function settled(promises, sync) {
        var Promise = promise(sync);
        return Promise.all(promises.map(function (p) {
            return Promise.resolve(p).then(function (value) {
                return {
                    fulfilled: true,
                    value: value
                };
            }, function (value) {
                return {
                    fulfilled: false,
                    value: value
                };
            });
        }));
    }
    function collectErrors(_ref) {
        var validations = _ref.validations, value = _ref.value, path = _ref.path, sync = _ref.sync, errors = _ref.errors, sort = _ref.sort;
        errors = unwrapError(errors);
        return settled(validations, sync).then(function (results) {
            var nestedErrors = results.filter(function (r) {
                return !r.fulfilled;
            }).reduce(function (arr, _ref2) {
                var error = _ref2.value;
                // we are only collecting validation errors
                if (!ValidationError.isError(error)) {
                    throw error;
                }
                return arr.concat(error);
            }, []);
            if (sort)
                nestedErrors.sort(sort); //show parent errors after the nested ones: name.first, name
            errors = nestedErrors.concat(errors);
            if (errors.length)
                throw new ValidationError(errors, value, path);
            return value;
        });
    }
    function runValidations(_ref3) {
        var endEarly = _ref3.endEarly, options = _objectWithoutPropertiesLoose(_ref3, ["endEarly"]);
        if (endEarly)
            return scopeToValue(options.validations, options.value, options.sync);
        return collectErrors(options);
    }

    var isObject$1 = function isObject(obj) {
        return Object.prototype.toString.call(obj) === '[object Object]';
    };
    function prependDeep(target, source) {
        for (var key in source) {
            if (has(source, key)) {
                var sourceVal = source[key], targetVal = target[key];
                if (targetVal === undefined) {
                    target[key] = sourceVal;
                }
                else if (targetVal === sourceVal) {
                    continue;
                }
                else if (isSchema(targetVal)) {
                    if (isSchema(sourceVal))
                        target[key] = sourceVal.concat(targetVal);
                }
                else if (isObject$1(targetVal)) {
                    if (isObject$1(sourceVal))
                        target[key] = prependDeep(targetVal, sourceVal);
                }
                else if (Array.isArray(targetVal)) {
                    if (Array.isArray(sourceVal))
                        target[key] = sourceVal.concat(targetVal);
                }
            }
        }
        return target;
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
        return function (object, iteratee, keysFunc) {
            var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
            while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee(iterable[key], key, iterable) === false) {
                    break;
                }
            }
            return object;
        };
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys$1);
    }

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';
    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED$2);
        return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
        return this.__data__.has(value);
    }

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache;
        while (++index < length) {
            this.add(values[index]);
        }
    }
    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
            if (predicate(array[index], index, array)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
        return cache.has(key);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
        }
        // Check that cyclic values are equal.
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;
        stack.set(array, other);
        stack.set(other, array);
        // Ignore non-index properties.
        while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
                var compared = isPartial
                    ? customizer(othValue, arrValue, index, other, array, stack)
                    : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
                if (compared) {
                    continue;
                }
                result = false;
                break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
                if (!arraySome(other, function (othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) &&
                        (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                        return seen.push(othIndex);
                    }
                })) {
                    result = false;
                    break;
                }
            }
            else if (!(arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
            }
        }
        stack['delete'](array);
        stack['delete'](other);
        return result;
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
    /** `Object#toString` result references. */
    var boolTag$3 = '[object Boolean]', dateTag$3 = '[object Date]', errorTag$2 = '[object Error]', mapTag$6 = '[object Map]', numberTag$3 = '[object Number]', regexpTag$3 = '[object RegExp]', setTag$6 = '[object Set]', stringTag$4 = '[object String]', symbolTag$3 = '[object Symbol]';
    var arrayBufferTag$3 = '[object ArrayBuffer]', dataViewTag$4 = '[object DataView]';
    /** Used to convert symbols to primitives and strings. */
    var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined, symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
            case dataViewTag$4:
                if ((object.byteLength != other.byteLength) ||
                    (object.byteOffset != other.byteOffset)) {
                    return false;
                }
                object = object.buffer;
                other = other.buffer;
            case arrayBufferTag$3:
                if ((object.byteLength != other.byteLength) ||
                    !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                    return false;
                }
                return true;
            case boolTag$3:
            case dateTag$3:
            case numberTag$3:
                // Coerce booleans to `1` or `0` and dates to milliseconds.
                // Invalid dates are coerced to `NaN`.
                return eq(+object, +other);
            case errorTag$2:
                return object.name == other.name && object.message == other.message;
            case regexpTag$3:
            case stringTag$4:
                // Coerce regexes to strings and treat strings, primitives and objects,
                // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                // for more details.
                return object == (other + '');
            case mapTag$6:
                var convert = mapToArray;
            case setTag$6:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                    return false;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked) {
                    return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG$1;
                // Recursively compare objects (susceptible to call stack limits).
                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack['delete'](object);
                return result;
            case symbolTag$3:
                if (symbolValueOf$1) {
                    return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
                }
        }
        return false;
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1;
    /** Used for built-in method references. */
    var objectProto$e = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$b = objectProto$e.hasOwnProperty;
    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
            return false;
        }
        var index = objLength;
        while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty$b.call(other, key))) {
                return false;
            }
        }
        // Check that cyclic values are equal.
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
                var compared = isPartial
                    ? customizer(othValue, objValue, key, other, object, stack)
                    : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined
                ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                : compared)) {
                result = false;
                break;
            }
            skipCtor || (skipCtor = key == 'constructor');
        }
        if (result && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                    typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                result = false;
            }
        }
        stack['delete'](object);
        stack['delete'](other);
        return result;
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1;
    /** `Object#toString` result references. */
    var argsTag$3 = '[object Arguments]', arrayTag$2 = '[object Array]', objectTag$3 = '[object Object]';
    /** Used for built-in method references. */
    var objectProto$f = Object.prototype;
    /** Used to check objects for own properties. */
    var hasOwnProperty$c = objectProto$f.hasOwnProperty;
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag$2 : getTag$1(object), othTag = othIsArr ? arrayTag$2 : getTag$1(other);
        objTag = objTag == argsTag$3 ? objectTag$3 : objTag;
        othTag = othTag == argsTag$3 ? objectTag$3 : othTag;
        var objIsObj = objTag == objectTag$3, othIsObj = othTag == objectTag$3, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
                return false;
            }
            objIsArr = true;
            objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
            stack || (stack = new Stack);
            return (objIsArr || isTypedArray(object))
                ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
                : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
            var objIsWrapped = objIsObj && hasOwnProperty$c.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty$c.call(other, '__wrapped__');
            if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack);
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
        }
        if (!isSameTag) {
            return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
            return true;
        }
        if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
            return !length;
        }
        object = Object(object);
        while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                ? data[1] !== object[data[0]]
                : !(data[0] in object)) {
                return false;
            }
        }
        while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                    return false;
                }
            }
            else {
                var stack = new Stack;
                if (customizer) {
                    var result = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result === undefined
                    ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
                    : result)) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
        return value === value && !isObject(value);
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
        var result = keys$1(object), length = result.length;
        while (length--) {
            var key = result[length], value = object[key];
            result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
        return function (object) {
            if (object == null) {
                return false;
            }
            return object[key] === srcValue &&
                (srcValue !== undefined || (key in Object(object)));
        };
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function (object) {
            return object === source || baseIsMatch(object, source, matchData);
        };
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
            object = object[toKey(path[index++])];
        }
        return (index && index == length) ? object : undefined;
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get$b(object, path, defaultValue) {
        var result = object == null ? undefined : baseGet(object, path);
        return result === undefined ? defaultValue : result;
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
        return object != null && key in Object(object);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
    }

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
        }
        return function (object) {
            var objValue = get$b(object, path);
            return (objValue === undefined && objValue === srcValue)
                ? hasIn(object, path)
                : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
        };
    }

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity$g(value) {
        return value;
    }

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
        return function (object) {
            return object == null ? undefined : object[key];
        };
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
        return function (object) {
            return baseGet(object, path);
        };
    }

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
        // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
        // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
        if (typeof value == 'function') {
            return value;
        }
        if (value == null) {
            return identity$g;
        }
        if (typeof value == 'object') {
            return isArray(value)
                ? baseMatchesProperty(value[0], value[1])
                : baseMatches(value);
        }
        return property(value);
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee);
        baseForOwn(object, function (value, key, object) {
            baseAssignValue(result, key, iteratee(value, key, object));
        });
        return result;
    }

    /**
     * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>
     */
    function Cache(maxSize) {
        this._maxSize = maxSize;
        this.clear();
    }
    Cache.prototype.clear = function () {
        this._size = 0;
        this._values = Object.create(null);
    };
    Cache.prototype.get = function (key) {
        return this._values[key];
    };
    Cache.prototype.set = function (key, value) {
        this._size >= this._maxSize && this.clear();
        if (!(key in this._values))
            this._size++;
        return (this._values[key] = value);
    };
    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g, DIGIT_REGEX = /^\d+$/, LEAD_DIGIT_REGEX = /^\d/, SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g, CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/, MAX_CACHE_SIZE = 512;
    var pathCache = new Cache(MAX_CACHE_SIZE), setCache = new Cache(MAX_CACHE_SIZE), getCache = new Cache(MAX_CACHE_SIZE);
    var propertyExpr = {
        Cache: Cache,
        split: split,
        normalizePath: normalizePath,
        setter: function (path) {
            var parts = normalizePath(path);
            return (setCache.get(path) ||
                setCache.set(path, function setter(obj, value) {
                    var index = 0;
                    var len = parts.length;
                    var data = obj;
                    while (index < len - 1) {
                        var part = parts[index];
                        if (part === '__proto__' ||
                            part === 'constructor' ||
                            part === 'prototype') {
                            return obj;
                        }
                        data = data[parts[index++]];
                    }
                    data[parts[index]] = value;
                }));
        },
        getter: function (path, safe) {
            var parts = normalizePath(path);
            return (getCache.get(path) ||
                getCache.set(path, function getter(data) {
                    var index = 0, len = parts.length;
                    while (index < len) {
                        if (data != null || !safe)
                            data = data[parts[index++]];
                        else
                            return;
                    }
                    return data;
                }));
        },
        join: function (segments) {
            return segments.reduce(function (path, part) {
                return (path +
                    (isQuoted(part) || DIGIT_REGEX.test(part)
                        ? '[' + part + ']'
                        : (path ? '.' : '') + part));
            }, '');
        },
        forEach: function (path, cb, thisArg) {
            forEach(Array.isArray(path) ? path : split(path), cb, thisArg);
        },
    };
    function normalizePath(path) {
        return (pathCache.get(path) ||
            pathCache.set(path, split(path).map(function (part) {
                return part.replace(CLEAN_QUOTES_REGEX, '$2');
            })));
    }
    function split(path) {
        return path.match(SPLIT_REGEX) || [''];
    }
    function forEach(parts, iter, thisArg) {
        var len = parts.length, part, idx, isArray, isBracket;
        for (idx = 0; idx < len; idx++) {
            part = parts[idx];
            if (part) {
                if (shouldBeQuoted(part)) {
                    part = '"' + part + '"';
                }
                isBracket = isQuoted(part);
                isArray = !isBracket && /^\d+$/.test(part);
                iter.call(thisArg, part, isBracket, isArray, idx, parts);
            }
        }
    }
    function isQuoted(str) {
        return (typeof str === 'string' && str && ["'", '"'].indexOf(str.charAt(0)) !== -1);
    }
    function hasLeadingNumber(part) {
        return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
    }
    function hasSpecialChars(part) {
        return SPEC_CHAR_REGEX.test(part);
    }
    function shouldBeQuoted(part) {
        return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
    }
    var propertyExpr_2 = propertyExpr.split;
    var propertyExpr_5 = propertyExpr.getter;
    var propertyExpr_7 = propertyExpr.forEach;

    var prefixes$3 = {
        context: '$',
        value: '.'
    };
    var Reference = /*#__PURE__*/ function () {
        function Reference(key, options) {
            if (options === void 0) {
                options = {};
            }
            if (typeof key !== 'string')
                throw new TypeError('ref must be a string, got: ' + key);
            this.key = key.trim();
            if (key === '')
                throw new TypeError('ref must be a non-empty string');
            this.isContext = this.key[0] === prefixes$3.context;
            this.isValue = this.key[0] === prefixes$3.value;
            this.isSibling = !this.isContext && !this.isValue;
            var prefix = this.isContext ? prefixes$3.context : this.isValue ? prefixes$3.value : '';
            this.path = this.key.slice(prefix.length);
            this.getter = this.path && propertyExpr_5(this.path, true);
            this.map = options.map;
        }
        var _proto = Reference.prototype;
        _proto.getValue = function getValue(options) {
            var result = this.isContext ? options.context : this.isValue ? options.value : options.parent;
            if (this.getter)
                result = this.getter(result || {});
            if (this.map)
                result = this.map(result);
            return result;
        };
        _proto.cast = function cast(value, options) {
            return this.getValue(_extends$1({}, options, {
                value: value
            }));
        };
        _proto.resolve = function resolve() {
            return this;
        };
        _proto.describe = function describe() {
            return {
                type: 'ref',
                key: this.key
            };
        };
        _proto.toString = function toString() {
            return "Ref(" + this.key + ")";
        };
        Reference.isRef = function isRef(value) {
            return value && value.__isYupRef;
        };
        return Reference;
    }();
    Reference.prototype.__isYupRef = true;

    var formatError = ValidationError.formatError;
    var thenable = function thenable(p) {
        return p && typeof p.then === 'function' && typeof p.catch === 'function';
    };
    function runTest(testFn, ctx, value, sync) {
        var result = testFn.call(ctx, value);
        if (!sync)
            return Promise.resolve(result);
        if (thenable(result)) {
            throw new Error("Validation test of type: \"" + ctx.type + "\" returned a Promise during a synchronous validate. " + "This test will finish after the validate call has returned");
        }
        return synchronousPromise_1.resolve(result);
    }
    function resolveParams(oldParams, newParams, resolve) {
        return mapValues(_extends$1({}, oldParams, {}, newParams), resolve);
    }
    function createErrorFactory(_ref) {
        var value = _ref.value, label = _ref.label, resolve = _ref.resolve, originalValue = _ref.originalValue, opts = _objectWithoutPropertiesLoose(_ref, ["value", "label", "resolve", "originalValue"]);
        return function createError(_temp) {
            var _ref2 = _temp === void 0 ? {} : _temp, _ref2$path = _ref2.path, path = _ref2$path === void 0 ? opts.path : _ref2$path, _ref2$message = _ref2.message, message = _ref2$message === void 0 ? opts.message : _ref2$message, _ref2$type = _ref2.type, type = _ref2$type === void 0 ? opts.name : _ref2$type, params = _ref2.params;
            params = _extends$1({
                path: path,
                value: value,
                originalValue: originalValue,
                label: label
            }, resolveParams(opts.params, params, resolve));
            return _extends$1(new ValidationError(formatError(message, params), value, path, type), {
                params: params
            });
        };
    }
    function createValidation(options) {
        var name = options.name, message = options.message, test = options.test, params = options.params;
        function validate(_ref3) {
            var value = _ref3.value, path = _ref3.path, label = _ref3.label, options = _ref3.options, originalValue = _ref3.originalValue, sync = _ref3.sync, rest = _objectWithoutPropertiesLoose(_ref3, ["value", "path", "label", "options", "originalValue", "sync"]);
            var parent = options.parent;
            var resolve = function resolve(item) {
                return Reference.isRef(item) ? item.getValue({
                    value: value,
                    parent: parent,
                    context: options.context
                }) : item;
            };
            var createError = createErrorFactory({
                message: message,
                path: path,
                value: value,
                originalValue: originalValue,
                params: params,
                label: label,
                resolve: resolve,
                name: name
            });
            var ctx = _extends$1({
                path: path,
                parent: parent,
                type: name,
                createError: createError,
                resolve: resolve,
                options: options
            }, rest);
            return runTest(test, ctx, value, sync).then(function (validOrError) {
                if (ValidationError.isError(validOrError))
                    throw validOrError;
                else if (!validOrError)
                    throw createError();
            });
        }
        validate.OPTIONS = options;
        return validate;
    }

    var trim = function trim(part) {
        return part.substr(0, part.length - 1).substr(1);
    };
    function getIn(schema, path, value, context) {
        if (context === void 0) {
            context = value;
        }
        var parent, lastPart, lastPartDebug; // root path: ''
        if (!path)
            return {
                parent: parent,
                parentPath: path,
                schema: schema
            };
        propertyExpr_7(path, function (_part, isBracket, isArray) {
            var part = isBracket ? trim(_part) : _part;
            schema = schema.resolve({
                context: context,
                parent: parent,
                value: value
            });
            if (schema.innerType) {
                var idx = isArray ? parseInt(part, 10) : 0;
                if (value && idx >= value.length) {
                    throw new Error("Yup.reach cannot resolve an array item at index: " + _part + ", in the path: " + path + ". " + "because there is no value at that index. ");
                }
                parent = value;
                value = value && value[idx];
                schema = schema.innerType;
            } // sometimes the array index part of a path doesn't exist: "nested.arr.child"
            // in these cases the current part is the next schema and should be processed
            // in this iteration. For cases where the index signature is included this
            // check will fail and we'll handle the `child` part on the next iteration like normal
            if (!isArray) {
                if (!schema.fields || !schema.fields[part])
                    throw new Error("The schema does not contain the path: " + path + ". " + ("(failed at: " + lastPartDebug + " which is a type: \"" + schema._type + "\")"));
                parent = value;
                value = value && value[part];
                schema = schema.fields[part];
            }
            lastPart = part;
            lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
        });
        return {
            schema: schema,
            parent: parent,
            parentPath: lastPart
        };
    }

    var RefSet = /*#__PURE__*/ function () {
        function RefSet() {
            this.list = new Set();
            this.refs = new Map();
        }
        var _proto = RefSet.prototype;
        _proto.toArray = function toArray$1() {
            return toArray(this.list).concat(toArray(this.refs.values()));
        };
        _proto.add = function add(value) {
            Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
        };
        _proto.delete = function _delete(value) {
            Reference.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
        };
        _proto.has = function has(value, resolve) {
            if (this.list.has(value))
                return true;
            var item, values = this.refs.values();
            while (item = values.next(), !item.done) {
                if (resolve(item.value) === value)
                    return true;
            }
            return false;
        };
        _proto.clone = function clone() {
            var next = new RefSet();
            next.list = new Set(this.list);
            next.refs = new Map(this.refs);
            return next;
        };
        _proto.merge = function merge(newItems, removeItems) {
            var next = this.clone();
            newItems.list.forEach(function (value) {
                return next.add(value);
            });
            newItems.refs.forEach(function (value) {
                return next.add(value);
            });
            removeItems.list.forEach(function (value) {
                return next.delete(value);
            });
            removeItems.refs.forEach(function (value) {
                return next.delete(value);
            });
            return next;
        };
        return RefSet;
    }();
    function SchemaType(options) {
        var _this = this;
        if (options === void 0) {
            options = {};
        }
        if (!(this instanceof SchemaType))
            return new SchemaType();
        this._deps = [];
        this._conditions = [];
        this._options = {
            abortEarly: true,
            recursive: true
        };
        this._exclusive = Object.create(null);
        this._whitelist = new RefSet();
        this._blacklist = new RefSet();
        this.tests = [];
        this.transforms = [];
        this.withMutation(function () {
            _this.typeError(mixed.notType);
        });
        if (has(options, 'default'))
            this._defaultDefault = options.default;
        this.type = options.type || 'mixed'; // TODO: remove
        this._type = options.type || 'mixed';
    }
    var proto$3 = SchemaType.prototype = {
        __isYupSchema__: true,
        constructor: SchemaType,
        clone: function clone() {
            var _this2 = this;
            if (this._mutate)
                return this; // if the nested value is a schema we can skip cloning, since
            // they are already immutable
            return cloneDeepWith(this, function (value) {
                if (isSchema(value) && value !== _this2)
                    return value;
            });
        },
        label: function label(_label) {
            var next = this.clone();
            next._label = _label;
            return next;
        },
        meta: function meta(obj) {
            if (arguments.length === 0)
                return this._meta;
            var next = this.clone();
            next._meta = _extends$1(next._meta || {}, obj);
            return next;
        },
        withMutation: function withMutation(fn) {
            var before = this._mutate;
            this._mutate = true;
            var result = fn(this);
            this._mutate = before;
            return result;
        },
        concat: function concat(schema) {
            if (!schema || schema === this)
                return this;
            if (schema._type !== this._type && this._type !== 'mixed')
                throw new TypeError("You cannot `concat()` schema's of different types: " + this._type + " and " + schema._type);
            var next = prependDeep(schema.clone(), this); // new undefined default is overridden by old non-undefined one, revert
            if (has(schema, '_default'))
                next._default = schema._default;
            next.tests = this.tests;
            next._exclusive = this._exclusive; // manually merge the blacklist/whitelist (the other `schema` takes
            // precedence in case of conflicts)
            next._whitelist = this._whitelist.merge(schema._whitelist, schema._blacklist);
            next._blacklist = this._blacklist.merge(schema._blacklist, schema._whitelist); // manually add the new tests to ensure
            // the deduping logic is consistent
            next.withMutation(function (next) {
                schema.tests.forEach(function (fn) {
                    next.test(fn.OPTIONS);
                });
            });
            return next;
        },
        isType: function isType(v) {
            if (this._nullable && v === null)
                return true;
            return !this._typeCheck || this._typeCheck(v);
        },
        resolve: function resolve(options) {
            var schema = this;
            if (schema._conditions.length) {
                var conditions = schema._conditions;
                schema = schema.clone();
                schema._conditions = [];
                schema = conditions.reduce(function (schema, condition) {
                    return condition.resolve(schema, options);
                }, schema);
                schema = schema.resolve(options);
            }
            return schema;
        },
        cast: function cast(value, options) {
            if (options === void 0) {
                options = {};
            }
            var resolvedSchema = this.resolve(_extends$1({}, options, {
                value: value
            }));
            var result = resolvedSchema._cast(value, options);
            if (value !== undefined && options.assert !== false && resolvedSchema.isType(result) !== true) {
                var formattedValue = printValue(value);
                var formattedResult = printValue(result);
                throw new TypeError("The value of " + (options.path || 'field') + " could not be cast to a value " + ("that satisfies the schema type: \"" + resolvedSchema._type + "\". \n\n") + ("attempted value: " + formattedValue + " \n") + (formattedResult !== formattedValue ? "result of cast: " + formattedResult : ''));
            }
            return result;
        },
        _cast: function _cast(rawValue) {
            var _this3 = this;
            var value = rawValue === undefined ? rawValue : this.transforms.reduce(function (value, fn) {
                return fn.call(_this3, value, rawValue);
            }, rawValue);
            if (value === undefined && has(this, '_default')) {
                value = this.default();
            }
            return value;
        },
        _validate: function _validate(_value, options) {
            var _this4 = this;
            if (options === void 0) {
                options = {};
            }
            var value = _value;
            var originalValue = options.originalValue != null ? options.originalValue : _value;
            var isStrict = this._option('strict', options);
            var endEarly = this._option('abortEarly', options);
            var sync = options.sync;
            var path = options.path;
            var label = this._label;
            if (!isStrict) {
                value = this._cast(value, _extends$1({
                    assert: false
                }, options));
            } // value is cast, we can check if it meets type requirements
            var validationParams = {
                value: value,
                path: path,
                schema: this,
                options: options,
                label: label,
                originalValue: originalValue,
                sync: sync
            };
            var initialTests = [];
            if (this._typeError)
                initialTests.push(this._typeError(validationParams));
            if (this._whitelistError)
                initialTests.push(this._whitelistError(validationParams));
            if (this._blacklistError)
                initialTests.push(this._blacklistError(validationParams));
            return runValidations({
                validations: initialTests,
                endEarly: endEarly,
                value: value,
                path: path,
                sync: sync
            }).then(function (value) {
                return runValidations({
                    path: path,
                    sync: sync,
                    value: value,
                    endEarly: endEarly,
                    validations: _this4.tests.map(function (fn) {
                        return fn(validationParams);
                    })
                });
            });
        },
        validate: function validate(value, options) {
            if (options === void 0) {
                options = {};
            }
            var schema = this.resolve(_extends$1({}, options, {
                value: value
            }));
            return schema._validate(value, options);
        },
        validateSync: function validateSync(value, options) {
            if (options === void 0) {
                options = {};
            }
            var schema = this.resolve(_extends$1({}, options, {
                value: value
            }));
            var result, err;
            schema._validate(value, _extends$1({}, options, {
                sync: true
            })).then(function (r) {
                return result = r;
            }).catch(function (e) {
                return err = e;
            });
            if (err)
                throw err;
            return result;
        },
        isValid: function isValid(value, options) {
            return this.validate(value, options).then(function () {
                return true;
            }).catch(function (err) {
                if (err.name === 'ValidationError')
                    return false;
                throw err;
            });
        },
        isValidSync: function isValidSync(value, options) {
            try {
                this.validateSync(value, options);
                return true;
            }
            catch (err) {
                if (err.name === 'ValidationError')
                    return false;
                throw err;
            }
        },
        getDefault: function getDefault(options) {
            if (options === void 0) {
                options = {};
            }
            var schema = this.resolve(options);
            return schema.default();
        },
        default: function _default(def) {
            if (arguments.length === 0) {
                var defaultValue = has(this, '_default') ? this._default : this._defaultDefault;
                return typeof defaultValue === 'function' ? defaultValue.call(this) : cloneDeepWith(defaultValue);
            }
            var next = this.clone();
            next._default = def;
            return next;
        },
        strict: function strict(isStrict) {
            if (isStrict === void 0) {
                isStrict = true;
            }
            var next = this.clone();
            next._options.strict = isStrict;
            return next;
        },
        _isPresent: function _isPresent(value) {
            return value != null;
        },
        required: function required(message) {
            if (message === void 0) {
                message = mixed.required;
            }
            return this.test({
                message: message,
                name: 'required',
                exclusive: true,
                test: function test(value) {
                    return this.schema._isPresent(value);
                }
            });
        },
        notRequired: function notRequired() {
            var next = this.clone();
            next.tests = next.tests.filter(function (test) {
                return test.OPTIONS.name !== 'required';
            });
            return next;
        },
        nullable: function nullable(isNullable) {
            if (isNullable === void 0) {
                isNullable = true;
            }
            var next = this.clone();
            next._nullable = isNullable;
            return next;
        },
        transform: function transform(fn) {
            var next = this.clone();
            next.transforms.push(fn);
            return next;
        },
        /**
         * Adds a test function to the schema's queue of tests.
         * tests can be exclusive or non-exclusive.
         *
         * - exclusive tests, will replace any existing tests of the same name.
         * - non-exclusive: can be stacked
         *
         * If a non-exclusive test is added to a schema with an exclusive test of the same name
         * the exclusive test is removed and further tests of the same name will be stacked.
         *
         * If an exclusive test is added to a schema with non-exclusive tests of the same name
         * the previous tests are removed and further tests of the same name will replace each other.
         */
        test: function test() {
            var opts;
            if (arguments.length === 1) {
                if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'function') {
                    opts = {
                        test: arguments.length <= 0 ? undefined : arguments[0]
                    };
                }
                else {
                    opts = arguments.length <= 0 ? undefined : arguments[0];
                }
            }
            else if (arguments.length === 2) {
                opts = {
                    name: arguments.length <= 0 ? undefined : arguments[0],
                    test: arguments.length <= 1 ? undefined : arguments[1]
                };
            }
            else {
                opts = {
                    name: arguments.length <= 0 ? undefined : arguments[0],
                    message: arguments.length <= 1 ? undefined : arguments[1],
                    test: arguments.length <= 2 ? undefined : arguments[2]
                };
            }
            if (opts.message === undefined)
                opts.message = mixed.default;
            if (typeof opts.test !== 'function')
                throw new TypeError('`test` is a required parameters');
            var next = this.clone();
            var validate = createValidation(opts);
            var isExclusive = opts.exclusive || opts.name && next._exclusive[opts.name] === true;
            if (opts.exclusive && !opts.name) {
                throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');
            }
            next._exclusive[opts.name] = !!opts.exclusive;
            next.tests = next.tests.filter(function (fn) {
                if (fn.OPTIONS.name === opts.name) {
                    if (isExclusive)
                        return false;
                    if (fn.OPTIONS.test === validate.OPTIONS.test)
                        return false;
                }
                return true;
            });
            next.tests.push(validate);
            return next;
        },
        when: function when(keys, options) {
            if (arguments.length === 1) {
                options = keys;
                keys = '.';
            }
            var next = this.clone(), deps = [].concat(keys).map(function (key) {
                return new Reference(key);
            });
            deps.forEach(function (dep) {
                if (dep.isSibling)
                    next._deps.push(dep.key);
            });
            next._conditions.push(new Condition(deps, options));
            return next;
        },
        typeError: function typeError(message) {
            var next = this.clone();
            next._typeError = createValidation({
                message: message,
                name: 'typeError',
                test: function test(value) {
                    if (value !== undefined && !this.schema.isType(value))
                        return this.createError({
                            params: {
                                type: this.schema._type
                            }
                        });
                    return true;
                }
            });
            return next;
        },
        oneOf: function oneOf(enums, message) {
            if (message === void 0) {
                message = mixed.oneOf;
            }
            var next = this.clone();
            enums.forEach(function (val) {
                next._whitelist.add(val);
                next._blacklist.delete(val);
            });
            next._whitelistError = createValidation({
                message: message,
                name: 'oneOf',
                test: function test(value) {
                    if (value === undefined)
                        return true;
                    var valids = this.schema._whitelist;
                    return valids.has(value, this.resolve) ? true : this.createError({
                        params: {
                            values: valids.toArray().join(', ')
                        }
                    });
                }
            });
            return next;
        },
        notOneOf: function notOneOf(enums, message) {
            if (message === void 0) {
                message = mixed.notOneOf;
            }
            var next = this.clone();
            enums.forEach(function (val) {
                next._blacklist.add(val);
                next._whitelist.delete(val);
            });
            next._blacklistError = createValidation({
                message: message,
                name: 'notOneOf',
                test: function test(value) {
                    var invalids = this.schema._blacklist;
                    if (invalids.has(value, this.resolve))
                        return this.createError({
                            params: {
                                values: invalids.toArray().join(', ')
                            }
                        });
                    return true;
                }
            });
            return next;
        },
        strip: function strip(_strip) {
            if (_strip === void 0) {
                _strip = true;
            }
            var next = this.clone();
            next._strip = _strip;
            return next;
        },
        _option: function _option(key, overrides) {
            return has(overrides, key) ? overrides[key] : this._options[key];
        },
        describe: function describe() {
            var next = this.clone();
            return {
                type: next._type,
                meta: next._meta,
                label: next._label,
                tests: next.tests.map(function (fn) {
                    return {
                        name: fn.OPTIONS.name,
                        params: fn.OPTIONS.params
                    };
                }).filter(function (n, idx, list) {
                    return list.findIndex(function (c) {
                        return c.name === n.name;
                    }) === idx;
                })
            };
        },
        defined: function defined(message) {
            if (message === void 0) {
                message = mixed.defined;
            }
            return this.nullable().test({
                message: message,
                name: 'defined',
                exclusive: true,
                test: function test(value) {
                    return value !== undefined;
                }
            });
        }
    };
    var _loop = function _loop() {
        var method = _arr[_i];
        proto$3[method + "At"] = function (path, value, options) {
            if (options === void 0) {
                options = {};
            }
            var _getIn = getIn(this, path, value, options.context), parent = _getIn.parent, parentPath = _getIn.parentPath, schema = _getIn.schema;
            return schema[method](parent && parent[parentPath], _extends$1({}, options, {
                parent: parent,
                path: path
            }));
        };
    };
    for (var _i = 0, _arr = ['validate', 'validateSync']; _i < _arr.length; _i++) {
        _loop();
    }
    for (var _i2 = 0, _arr2 = ['equals', 'is']; _i2 < _arr2.length; _i2++) {
        var alias = _arr2[_i2];
        proto$3[alias] = proto$3.oneOf;
    }
    for (var _i3 = 0, _arr3 = ['not', 'nope']; _i3 < _arr3.length; _i3++) {
        var _alias = _arr3[_i3];
        proto$3[_alias] = proto$3.notOneOf;
    }
    proto$3.optional = proto$3.notRequired;

    function inherits$1(ctor, superCtor, spec) {
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        _extends$1(ctor.prototype, spec);
    }

    function BooleanSchema() {
        var _this = this;
        if (!(this instanceof BooleanSchema))
            return new BooleanSchema();
        SchemaType.call(this, {
            type: 'boolean'
        });
        this.withMutation(function () {
            _this.transform(function (value) {
                if (!this.isType(value)) {
                    if (/^(true|1)$/i.test(value))
                        return true;
                    if (/^(false|0)$/i.test(value))
                        return false;
                }
                return value;
            });
        });
    }
    inherits$1(BooleanSchema, SchemaType, {
        _typeCheck: function _typeCheck(v) {
            if (v instanceof Boolean)
                v = v.valueOf();
            return typeof v === 'boolean';
        }
    });

    var isAbsent = (function (value) {
        return value == null;
    });

    var rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i; // eslint-disable-next-line
    var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
    var isTrimmed = function isTrimmed(value) {
        return isAbsent(value) || value === value.trim();
    };
    function StringSchema() {
        var _this = this;
        if (!(this instanceof StringSchema))
            return new StringSchema();
        SchemaType.call(this, {
            type: 'string'
        });
        this.withMutation(function () {
            _this.transform(function (value) {
                if (this.isType(value))
                    return value;
                return value != null && value.toString ? value.toString() : value;
            });
        });
    }
    inherits$1(StringSchema, SchemaType, {
        _typeCheck: function _typeCheck(value) {
            if (value instanceof String)
                value = value.valueOf();
            return typeof value === 'string';
        },
        _isPresent: function _isPresent(value) {
            return SchemaType.prototype._cast.call(this, value) && value.length > 0;
        },
        length: function length(_length, message) {
            if (message === void 0) {
                message = string$2.length;
            }
            return this.test({
                message: message,
                name: 'length',
                exclusive: true,
                params: {
                    length: _length
                },
                test: function test(value) {
                    return isAbsent(value) || value.length === this.resolve(_length);
                }
            });
        },
        min: function min(_min, message) {
            if (message === void 0) {
                message = string$2.min;
            }
            return this.test({
                message: message,
                name: 'min',
                exclusive: true,
                params: {
                    min: _min
                },
                test: function test(value) {
                    return isAbsent(value) || value.length >= this.resolve(_min);
                }
            });
        },
        max: function max(_max, message) {
            if (message === void 0) {
                message = string$2.max;
            }
            return this.test({
                name: 'max',
                exclusive: true,
                message: message,
                params: {
                    max: _max
                },
                test: function test(value) {
                    return isAbsent(value) || value.length <= this.resolve(_max);
                }
            });
        },
        matches: function matches(regex, options) {
            var excludeEmptyString = false;
            var message;
            var name;
            if (options) {
                if (typeof options === 'object') {
                    excludeEmptyString = options.excludeEmptyString;
                    message = options.message;
                    name = options.name;
                }
                else {
                    message = options;
                }
            }
            return this.test({
                name: name || 'matches',
                message: message || string$2.matches,
                params: {
                    regex: regex
                },
                test: function test(value) {
                    return isAbsent(value) || value === '' && excludeEmptyString || value.search(regex) !== -1;
                }
            });
        },
        email: function email(message) {
            if (message === void 0) {
                message = string$2.email;
            }
            return this.matches(rEmail, {
                name: 'email',
                message: message,
                excludeEmptyString: true
            });
        },
        url: function url(message) {
            if (message === void 0) {
                message = string$2.url;
            }
            return this.matches(rUrl, {
                name: 'url',
                message: message,
                excludeEmptyString: true
            });
        },
        //-- transforms --
        ensure: function ensure() {
            return this.default('').transform(function (val) {
                return val === null ? '' : val;
            });
        },
        trim: function trim(message) {
            if (message === void 0) {
                message = string$2.trim;
            }
            return this.transform(function (val) {
                return val != null ? val.trim() : val;
            }).test({
                message: message,
                name: 'trim',
                test: isTrimmed
            });
        },
        lowercase: function lowercase(message) {
            if (message === void 0) {
                message = string$2.lowercase;
            }
            return this.transform(function (value) {
                return !isAbsent(value) ? value.toLowerCase() : value;
            }).test({
                message: message,
                name: 'string_case',
                exclusive: true,
                test: function test(value) {
                    return isAbsent(value) || value === value.toLowerCase();
                }
            });
        },
        uppercase: function uppercase(message) {
            if (message === void 0) {
                message = string$2.uppercase;
            }
            return this.transform(function (value) {
                return !isAbsent(value) ? value.toUpperCase() : value;
            }).test({
                message: message,
                name: 'string_case',
                exclusive: true,
                test: function test(value) {
                    return isAbsent(value) || value === value.toUpperCase();
                }
            });
        }
    });

    var isNaN$1 = function isNaN(value) {
        return value != +value;
    };
    function NumberSchema() {
        var _this = this;
        if (!(this instanceof NumberSchema))
            return new NumberSchema();
        SchemaType.call(this, {
            type: 'number'
        });
        this.withMutation(function () {
            _this.transform(function (value) {
                var parsed = value;
                if (typeof parsed === 'string') {
                    parsed = parsed.replace(/\s/g, '');
                    if (parsed === '')
                        return NaN; // don't use parseFloat to avoid positives on alpha-numeric strings
                    parsed = +parsed;
                }
                if (this.isType(parsed))
                    return parsed;
                return parseFloat(parsed);
            });
        });
    }
    inherits$1(NumberSchema, SchemaType, {
        _typeCheck: function _typeCheck(value) {
            if (value instanceof Number)
                value = value.valueOf();
            return typeof value === 'number' && !isNaN$1(value);
        },
        min: function min(_min, message) {
            if (message === void 0) {
                message = number$9.min;
            }
            return this.test({
                message: message,
                name: 'min',
                exclusive: true,
                params: {
                    min: _min
                },
                test: function test(value) {
                    return isAbsent(value) || value >= this.resolve(_min);
                }
            });
        },
        max: function max(_max, message) {
            if (message === void 0) {
                message = number$9.max;
            }
            return this.test({
                message: message,
                name: 'max',
                exclusive: true,
                params: {
                    max: _max
                },
                test: function test(value) {
                    return isAbsent(value) || value <= this.resolve(_max);
                }
            });
        },
        lessThan: function lessThan(less, message) {
            if (message === void 0) {
                message = number$9.lessThan;
            }
            return this.test({
                message: message,
                name: 'max',
                exclusive: true,
                params: {
                    less: less
                },
                test: function test(value) {
                    return isAbsent(value) || value < this.resolve(less);
                }
            });
        },
        moreThan: function moreThan(more, message) {
            if (message === void 0) {
                message = number$9.moreThan;
            }
            return this.test({
                message: message,
                name: 'min',
                exclusive: true,
                params: {
                    more: more
                },
                test: function test(value) {
                    return isAbsent(value) || value > this.resolve(more);
                }
            });
        },
        positive: function positive(msg) {
            if (msg === void 0) {
                msg = number$9.positive;
            }
            return this.moreThan(0, msg);
        },
        negative: function negative(msg) {
            if (msg === void 0) {
                msg = number$9.negative;
            }
            return this.lessThan(0, msg);
        },
        integer: function integer(message) {
            if (message === void 0) {
                message = number$9.integer;
            }
            return this.test({
                name: 'integer',
                message: message,
                test: function test(val) {
                    return isAbsent(val) || Number.isInteger(val);
                }
            });
        },
        truncate: function truncate() {
            return this.transform(function (value) {
                return !isAbsent(value) ? value | 0 : value;
            });
        },
        round: function round(method) {
            var avail = ['ceil', 'floor', 'round', 'trunc'];
            method = method && method.toLowerCase() || 'round'; // this exists for symemtry with the new Math.trunc
            if (method === 'trunc')
                return this.truncate();
            if (avail.indexOf(method.toLowerCase()) === -1)
                throw new TypeError('Only valid options for round() are: ' + avail.join(', '));
            return this.transform(function (value) {
                return !isAbsent(value) ? Math[method](value) : value;
            });
        }
    });

    /* eslint-disable */
    /**
     *
     * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
     * NON-CONFORMANT EDITION.
     * © 2011 Colin Snover <http://zetafleet.com>
     * Released under MIT license.
     */
    //              1 YYYY                 2 MM        3 DD              4 HH     5 mm        6 ss            7 msec         8 Z 9 ±    10 tzHH    11 tzmm
    var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
    function parseIsoDate(date) {
        var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
        if (struct = isoReg.exec(date)) {
            // avoid NaN timestamps caused by “undefined” values being passed to Date.UTC
            for (var i = 0, k; k = numericKeys[i]; ++i) {
                struct[k] = +struct[k] || 0;
            } // allow undefined days and months
            struct[2] = (+struct[2] || 1) - 1;
            struct[3] = +struct[3] || 1; // allow arbitrary sub-second precision beyond milliseconds
            struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0; // timestamps without timezone identifiers should be considered local time
            if ((struct[8] === undefined || struct[8] === '') && (struct[9] === undefined || struct[9] === ''))
                timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
            else {
                if (struct[8] !== 'Z' && struct[9] !== undefined) {
                    minutesOffset = struct[10] * 60 + struct[11];
                    if (struct[9] === '+')
                        minutesOffset = 0 - minutesOffset;
                }
                timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
            }
        }
        else
            timestamp = Date.parse ? Date.parse(date) : NaN;
        return timestamp;
    }

    var invalidDate = new Date('');
    var isDate = function isDate(obj) {
        return Object.prototype.toString.call(obj) === '[object Date]';
    };
    function DateSchema() {
        var _this = this;
        if (!(this instanceof DateSchema))
            return new DateSchema();
        SchemaType.call(this, {
            type: 'date'
        });
        this.withMutation(function () {
            _this.transform(function (value) {
                if (this.isType(value))
                    return value;
                value = parseIsoDate(value); // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.
                return !isNaN(value) ? new Date(value) : invalidDate;
            });
        });
    }
    inherits$1(DateSchema, SchemaType, {
        _typeCheck: function _typeCheck(v) {
            return isDate(v) && !isNaN(v.getTime());
        },
        min: function min(_min, message) {
            if (message === void 0) {
                message = date$4.min;
            }
            var limit = _min;
            if (!Reference.isRef(limit)) {
                limit = this.cast(_min);
                if (!this._typeCheck(limit))
                    throw new TypeError('`min` must be a Date or a value that can be `cast()` to a Date');
            }
            return this.test({
                message: message,
                name: 'min',
                exclusive: true,
                params: {
                    min: _min
                },
                test: function test(value) {
                    return isAbsent(value) || value >= this.resolve(limit);
                }
            });
        },
        max: function max(_max, message) {
            if (message === void 0) {
                message = date$4.max;
            }
            var limit = _max;
            if (!Reference.isRef(limit)) {
                limit = this.cast(_max);
                if (!this._typeCheck(limit))
                    throw new TypeError('`max` must be a Date or a value that can be `cast()` to a Date');
            }
            return this.test({
                message: message,
                name: 'max',
                exclusive: true,
                params: {
                    max: _max
                },
                test: function test(value) {
                    return isAbsent(value) || value <= this.resolve(limit);
                }
            });
        }
    });

    function _taggedTemplateLiteralLoose(strings, raw) {
        if (!raw) {
            raw = strings.slice(0);
        }
        strings.raw = raw;
        return strings;
    }

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
            accumulator = array[++index];
        }
        while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
    }

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyOf(object) {
        return function (key) {
            return object == null ? undefined : object[key];
        };
    }

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
        // Latin-1 Supplement block.
        '\xc0': 'A', '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a', '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C', '\xe7': 'c',
        '\xd0': 'D', '\xf0': 'd',
        '\xc8': 'E', '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e', '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcc': 'I', '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xec': 'i', '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N', '\xf1': 'n',
        '\xd2': 'O', '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o', '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U', '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u', '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y', '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss',
        // Latin Extended-A block.
        '\u0100': 'A', '\u0102': 'A', '\u0104': 'A',
        '\u0101': 'a', '\u0103': 'a', '\u0105': 'a',
        '\u0106': 'C', '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
        '\u0107': 'c', '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
        '\u010e': 'D', '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
        '\u0112': 'E', '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
        '\u0113': 'e', '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
        '\u011c': 'G', '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
        '\u011d': 'g', '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
        '\u0124': 'H', '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
        '\u0128': 'I', '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
        '\u0129': 'i', '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
        '\u0134': 'J', '\u0135': 'j',
        '\u0136': 'K', '\u0137': 'k', '\u0138': 'k',
        '\u0139': 'L', '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
        '\u013a': 'l', '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
        '\u0143': 'N', '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
        '\u0144': 'n', '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
        '\u014c': 'O', '\u014e': 'O', '\u0150': 'O',
        '\u014d': 'o', '\u014f': 'o', '\u0151': 'o',
        '\u0154': 'R', '\u0156': 'R', '\u0158': 'R',
        '\u0155': 'r', '\u0157': 'r', '\u0159': 'r',
        '\u015a': 'S', '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
        '\u015b': 's', '\u015d': 's', '\u015f': 's', '\u0161': 's',
        '\u0162': 'T', '\u0164': 'T', '\u0166': 'T',
        '\u0163': 't', '\u0165': 't', '\u0167': 't',
        '\u0168': 'U', '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
        '\u0169': 'u', '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
        '\u0174': 'W', '\u0175': 'w',
        '\u0176': 'Y', '\u0177': 'y', '\u0178': 'Y',
        '\u0179': 'Z', '\u017b': 'Z', '\u017d': 'Z',
        '\u017a': 'z', '\u017c': 'z', '\u017e': 'z',
        '\u0132': 'IJ', '\u0133': 'ij',
        '\u0152': 'Oe', '\u0153': 'oe',
        '\u0149': "'n", '\u017f': 's'
    };
    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter = basePropertyOf(deburredLetters);

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    /** Used to compose unicode character classes. */
    var rsComboMarksRange$2 = '\\u0300-\\u036f', reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f', rsComboSymbolsRange$2 = '\\u20d0-\\u20ff', rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;
    /** Used to compose unicode capture groups. */
    var rsCombo$1 = '[' + rsComboRange$2 + ']';
    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo$1, 'g');
    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /** Used to match words composed of alphanumeric characters. */
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords(string) {
        return string.match(reAsciiWord) || [];
    }

    /** Used to detect strings that need a more robust regexp to match words. */
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
    }

    /** Used to compose unicode character classes. */
    var rsAstralRange$2 = '\\ud800-\\udfff', rsComboMarksRange$3 = '\\u0300-\\u036f', reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f', rsComboSymbolsRange$3 = '\\u20d0-\\u20ff', rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3, rsDingbatRange = '\\u2700-\\u27bf', rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff', rsMathOpRange = '\\xac\\xb1\\xd7\\xf7', rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf', rsPunctuationRange = '\\u2000-\\u206f', rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000', rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde', rsVarRange$2 = '\\ufe0e\\ufe0f', rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]", rsBreak = '[' + rsBreakRange + ']', rsCombo$2 = '[' + rsComboRange$3 + ']', rsDigits = '\\d+', rsDingbat = '[' + rsDingbatRange + ']', rsLower = '[' + rsLowerRange + ']', rsMisc = '[^' + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']', rsFitz$1 = '\\ud83c[\\udffb-\\udfff]', rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')', rsNonAstral$1 = '[^' + rsAstralRange$2 + ']', rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}', rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]', rsUpper = '[' + rsUpperRange + ']', rsZWJ$2 = '\\u200d';
    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')', rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')', rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?', rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?', reOptMod$1 = rsModifier$1 + '?', rsOptVar$1 = '[' + rsVarRange$2 + ']?', rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*', rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])', rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])', rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1, rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;
    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
        rsUpper + '+' + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
    ].join('|'), 'g');
    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
    }

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined : pattern;
        if (pattern === undefined) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
    }

    /** Used to compose unicode capture groups. */
    var rsApos$1 = "['\u2019]";
    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos$1, 'g');
    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
        return function (string) {
            return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
        };
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function (result, word, index) {
        return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
            start = -start > length ? 0 : (length + start);
        }
        end = end > length ? length : end;
        if (end < 0) {
            end += length;
        }
        length = start > end ? 0 : ((end - start) >>> 0);
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
            result[index] = array[index + start];
        }
        return result;
    }

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined ? length : end;
        return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
        return function (string) {
            string = toString(string);
            var strSymbols = hasUnicode(string)
                ? stringToArray(string)
                : undefined;
            var chr = strSymbols
                ? strSymbols[0]
                : string.charAt(0);
            var trailing = strSymbols
                ? castSlice(strSymbols, 1).join('')
                : string.slice(1);
            return chr[methodName]() + trailing;
        };
    }

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function (result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
    });

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee);
        baseForOwn(object, function (value, key, object) {
            baseAssignValue(result, iteratee(value, key, object), value);
        });
        return result;
    }

    /**
     * Topological sorting function
     *
     * @param {Array} edges
     * @returns {Array}
     */
    var toposort_1 = function (edges) {
        return toposort(uniqueNodes(edges), edges);
    };
    var array$5 = toposort;
    function toposort(nodes, edges) {
        var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor
        // Better data structures make algorithm much faster.
        , outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
        // check for unknown nodes
        edges.forEach(function (edge) {
            if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
                throw new Error('Unknown node. There is an unknown node in the supplied edges.');
            }
        });
        while (i--) {
            if (!visited[i])
                visit(nodes[i], i, new Set());
        }
        return sorted;
        function visit(node, i, predecessors) {
            if (predecessors.has(node)) {
                var nodeRep;
                try {
                    nodeRep = ", node was:" + JSON.stringify(node);
                }
                catch (e) {
                    nodeRep = "";
                }
                throw new Error('Cyclic dependency' + nodeRep);
            }
            if (!nodesHash.has(node)) {
                throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: ' + JSON.stringify(node));
            }
            if (visited[i])
                return;
            visited[i] = true;
            var outgoing = outgoingEdges.get(node) || new Set();
            outgoing = Array.from(outgoing);
            if (i = outgoing.length) {
                predecessors.add(node);
                do {
                    var child = outgoing[--i];
                    visit(child, nodesHash.get(child), predecessors);
                } while (i);
                predecessors.delete(node);
            }
            sorted[--cursor] = node;
        }
    }
    function uniqueNodes(arr) {
        var res = new Set();
        for (var i = 0, len = arr.length; i < len; i++) {
            var edge = arr[i];
            res.add(edge[0]);
            res.add(edge[1]);
        }
        return Array.from(res);
    }
    function makeOutgoingEdges(arr) {
        var edges = new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
            var edge = arr[i];
            if (!edges.has(edge[0]))
                edges.set(edge[0], new Set());
            if (!edges.has(edge[1]))
                edges.set(edge[1], new Set());
            edges.get(edge[0]).add(edge[1]);
        }
        return edges;
    }
    function makeNodesHash(arr) {
        var res = new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
            res.set(arr[i], i);
        }
        return res;
    }
    toposort_1.array = array$5;

    function sortFields(fields, excludes) {
        if (excludes === void 0) {
            excludes = [];
        }
        var edges = [], nodes = [];
        function addNode(depPath, key) {
            var node = propertyExpr_2(depPath)[0];
            if (!~nodes.indexOf(node))
                nodes.push(node);
            if (!~excludes.indexOf(key + "-" + node))
                edges.push([key, node]);
        }
        for (var key in fields) {
            if (has(fields, key)) {
                var value = fields[key];
                if (!~nodes.indexOf(key))
                    nodes.push(key);
                if (Reference.isRef(value) && value.isSibling)
                    addNode(value.path, key);
                else if (isSchema(value) && value._deps)
                    value._deps.forEach(function (path) {
                        return addNode(path, key);
                    });
            }
        }
        return toposort_1.array(nodes, edges).reverse();
    }

    function findIndex(arr, err) {
        var idx = Infinity;
        arr.some(function (key, ii) {
            if (err.path.indexOf(key) !== -1) {
                idx = ii;
                return true;
            }
        });
        return idx;
    }
    function sortByKeyOrder(fields) {
        var keys = Object.keys(fields);
        return function (a, b) {
            return findIndex(keys, a) - findIndex(keys, b);
        };
    }

    function makePath(strings) {
        for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            values[_key - 1] = arguments[_key];
        }
        var path = strings.reduce(function (str, next) {
            var value = values.shift();
            return str + (value == null ? '' : value) + next;
        });
        return path.replace(/^\./, '');
    }

    function _templateObject3() {
        var data = _taggedTemplateLiteralLoose(["", "[\"", "\"]"]);
        _templateObject3 = function _templateObject3() {
            return data;
        };
        return data;
    }
    function _templateObject2() {
        var data = _taggedTemplateLiteralLoose(["", ".", ""]);
        _templateObject2 = function _templateObject2() {
            return data;
        };
        return data;
    }
    function _templateObject() {
        var data = _taggedTemplateLiteralLoose(["", ".", ""]);
        _templateObject = function _templateObject() {
            return data;
        };
        return data;
    }
    var isObject$2 = function isObject(obj) {
        return Object.prototype.toString.call(obj) === '[object Object]';
    };
    var promise$1 = function promise(sync) {
        return sync ? synchronousPromise_1 : Promise;
    };
    function unknown(ctx, value) {
        var known = Object.keys(ctx.fields);
        return Object.keys(value).filter(function (key) {
            return known.indexOf(key) === -1;
        });
    }
    function ObjectSchema(spec) {
        var _this2 = this;
        if (!(this instanceof ObjectSchema))
            return new ObjectSchema(spec);
        SchemaType.call(this, {
            type: 'object',
            default: function _default() {
                var _this = this;
                if (!this._nodes.length)
                    return undefined;
                var dft = {};
                this._nodes.forEach(function (key) {
                    dft[key] = _this.fields[key].default ? _this.fields[key].default() : undefined;
                });
                return dft;
            }
        });
        this.fields = Object.create(null);
        this._nodes = [];
        this._excludedEdges = [];
        this.withMutation(function () {
            _this2.transform(function coerce(value) {
                if (typeof value === 'string') {
                    try {
                        value = JSON.parse(value);
                    }
                    catch (err) {
                        value = null;
                    }
                }
                if (this.isType(value))
                    return value;
                return null;
            });
            if (spec) {
                _this2.shape(spec);
            }
        });
    }
    inherits$1(ObjectSchema, SchemaType, {
        _typeCheck: function _typeCheck(value) {
            return isObject$2(value) || typeof value === 'function';
        },
        _cast: function _cast(_value, options) {
            var _this3 = this;
            if (options === void 0) {
                options = {};
            }
            var value = SchemaType.prototype._cast.call(this, _value, options); //should ignore nulls here
            if (value === undefined)
                return this.default();
            if (!this._typeCheck(value))
                return value;
            var fields = this.fields;
            var strip = this._option('stripUnknown', options) === true;
            var props = this._nodes.concat(Object.keys(value).filter(function (v) {
                return _this3._nodes.indexOf(v) === -1;
            }));
            var intermediateValue = {}; // is filled during the transform below
            var innerOptions = _extends$1({}, options, {
                parent: intermediateValue,
                __validating: false
            });
            var isChanged = false;
            props.forEach(function (prop) {
                var field = fields[prop];
                var exists = has(value, prop);
                if (field) {
                    var fieldValue;
                    var strict = field._options && field._options.strict; // safe to mutate since this is fired in sequence
                    innerOptions.path = makePath(_templateObject(), options.path, prop);
                    innerOptions.value = value[prop];
                    field = field.resolve(innerOptions);
                    if (field._strip === true) {
                        isChanged = isChanged || prop in value;
                        return;
                    }
                    fieldValue = !options.__validating || !strict ? field.cast(value[prop], innerOptions) : value[prop];
                    if (fieldValue !== undefined)
                        intermediateValue[prop] = fieldValue;
                }
                else if (exists && !strip)
                    intermediateValue[prop] = value[prop];
                if (intermediateValue[prop] !== value[prop])
                    isChanged = true;
            });
            return isChanged ? intermediateValue : value;
        },
        _validate: function _validate(_value, opts) {
            var _this4 = this;
            if (opts === void 0) {
                opts = {};
            }
            var endEarly, recursive;
            var sync = opts.sync;
            var errors = [];
            var originalValue = opts.originalValue != null ? opts.originalValue : _value;
            endEarly = this._option('abortEarly', opts);
            recursive = this._option('recursive', opts);
            opts = _extends$1({}, opts, {
                __validating: true,
                originalValue: originalValue
            });
            return SchemaType.prototype._validate.call(this, _value, opts).catch(propagateErrors(endEarly, errors)).then(function (value) {
                if (!recursive || !isObject$2(value)) {
                    // only iterate though actual objects
                    if (errors.length)
                        throw errors[0];
                    return value;
                }
                originalValue = originalValue || value;
                var validations = _this4._nodes.map(function (key) {
                    var path = key.indexOf('.') === -1 ? makePath(_templateObject2(), opts.path, key) : makePath(_templateObject3(), opts.path, key);
                    var field = _this4.fields[key];
                    var innerOptions = _extends$1({}, opts, {
                        path: path,
                        parent: value,
                        originalValue: originalValue[key]
                    });
                    if (field && field.validate) {
                        // inner fields are always strict:
                        // 1. this isn't strict so the casting will also have cast inner values
                        // 2. this is strict in which case the nested values weren't cast either
                        innerOptions.strict = true;
                        return field.validate(value[key], innerOptions);
                    }
                    return promise$1(sync).resolve(true);
                });
                return runValidations({
                    sync: sync,
                    validations: validations,
                    value: value,
                    errors: errors,
                    endEarly: endEarly,
                    path: opts.path,
                    sort: sortByKeyOrder(_this4.fields)
                });
            });
        },
        concat: function concat(schema) {
            var next = SchemaType.prototype.concat.call(this, schema);
            next._nodes = sortFields(next.fields, next._excludedEdges);
            return next;
        },
        shape: function shape(schema, excludes) {
            if (excludes === void 0) {
                excludes = [];
            }
            var next = this.clone();
            var fields = _extends$1(next.fields, schema);
            next.fields = fields;
            if (excludes.length) {
                if (!Array.isArray(excludes[0]))
                    excludes = [excludes];
                var keys = excludes.map(function (_ref) {
                    var first = _ref[0], second = _ref[1];
                    return first + "-" + second;
                });
                next._excludedEdges = next._excludedEdges.concat(keys);
            }
            next._nodes = sortFields(fields, next._excludedEdges);
            return next;
        },
        from: function from(_from, to, alias) {
            var fromGetter = propertyExpr_5(_from, true);
            return this.transform(function (obj) {
                if (obj == null)
                    return obj;
                var newObj = obj;
                if (has(obj, _from)) {
                    newObj = _extends$1({}, obj);
                    if (!alias)
                        delete newObj[_from];
                    newObj[to] = fromGetter(obj);
                }
                return newObj;
            });
        },
        noUnknown: function noUnknown(noAllow, message) {
            if (noAllow === void 0) {
                noAllow = true;
            }
            if (message === void 0) {
                message = object$4.noUnknown;
            }
            if (typeof noAllow === 'string') {
                message = noAllow;
                noAllow = true;
            }
            var next = this.test({
                name: 'noUnknown',
                exclusive: true,
                message: message,
                test: function test(value) {
                    if (value == null)
                        return true;
                    var unknownKeys = unknown(this.schema, value);
                    return !noAllow || unknownKeys.length === 0 || this.createError({
                        params: {
                            unknown: unknownKeys.join(', ')
                        }
                    });
                }
            });
            next._options.stripUnknown = noAllow;
            return next;
        },
        unknown: function unknown(allow, message) {
            if (allow === void 0) {
                allow = true;
            }
            if (message === void 0) {
                message = object$4.noUnknown;
            }
            return this.noUnknown(!allow, message);
        },
        transformKeys: function transformKeys(fn) {
            return this.transform(function (obj) {
                return obj && mapKeys(obj, function (_, key) {
                    return fn(key);
                });
            });
        },
        camelCase: function camelCase$1() {
            return this.transformKeys(camelCase);
        },
        snakeCase: function snakeCase$1() {
            return this.transformKeys(snakeCase);
        },
        constantCase: function constantCase() {
            return this.transformKeys(function (key) {
                return snakeCase(key).toUpperCase();
            });
        },
        describe: function describe() {
            var base = SchemaType.prototype.describe.call(this);
            base.fields = mapValues(this.fields, function (value) {
                return value.describe();
            });
            return base;
        }
    });

    function _templateObject2$1() {
        var data = _taggedTemplateLiteralLoose(["", "[", "]"]);
        _templateObject2$1 = function _templateObject2() {
            return data;
        };
        return data;
    }
    function _templateObject$1() {
        var data = _taggedTemplateLiteralLoose(["", "[", "]"]);
        _templateObject$1 = function _templateObject() {
            return data;
        };
        return data;
    }
    function ArraySchema(type) {
        var _this = this;
        if (!(this instanceof ArraySchema))
            return new ArraySchema(type);
        SchemaType.call(this, {
            type: 'array'
        }); // `undefined` specifically means uninitialized, as opposed to
        // "no subtype"
        this._subType = undefined;
        this.innerType = undefined;
        this.withMutation(function () {
            _this.transform(function (values) {
                if (typeof values === 'string')
                    try {
                        values = JSON.parse(values);
                    }
                    catch (err) {
                        values = null;
                    }
                return this.isType(values) ? values : null;
            });
            if (type)
                _this.of(type);
        });
    }
    inherits$1(ArraySchema, SchemaType, {
        _typeCheck: function _typeCheck(v) {
            return Array.isArray(v);
        },
        _cast: function _cast(_value, _opts) {
            var _this2 = this;
            var value = SchemaType.prototype._cast.call(this, _value, _opts); //should ignore nulls here
            if (!this._typeCheck(value) || !this.innerType)
                return value;
            var isChanged = false;
            var castArray = value.map(function (v, idx) {
                var castElement = _this2.innerType.cast(v, _extends$1({}, _opts, {
                    path: makePath(_templateObject$1(), _opts.path, idx)
                }));
                if (castElement !== v) {
                    isChanged = true;
                }
                return castElement;
            });
            return isChanged ? castArray : value;
        },
        _validate: function _validate(_value, options) {
            var _this3 = this;
            if (options === void 0) {
                options = {};
            }
            var errors = [];
            var sync = options.sync;
            var path = options.path;
            var innerType = this.innerType;
            var endEarly = this._option('abortEarly', options);
            var recursive = this._option('recursive', options);
            var originalValue = options.originalValue != null ? options.originalValue : _value;
            return SchemaType.prototype._validate.call(this, _value, options).catch(propagateErrors(endEarly, errors)).then(function (value) {
                if (!recursive || !innerType || !_this3._typeCheck(value)) {
                    if (errors.length)
                        throw errors[0];
                    return value;
                }
                originalValue = originalValue || value;
                var validations = value.map(function (item, idx) {
                    var path = makePath(_templateObject2$1(), options.path, idx); // object._validate note for isStrict explanation
                    var innerOptions = _extends$1({}, options, {
                        path: path,
                        strict: true,
                        parent: value,
                        originalValue: originalValue[idx]
                    });
                    if (innerType.validate)
                        return innerType.validate(item, innerOptions);
                    return true;
                });
                return runValidations({
                    sync: sync,
                    path: path,
                    value: value,
                    errors: errors,
                    endEarly: endEarly,
                    validations: validations
                });
            });
        },
        _isPresent: function _isPresent(value) {
            return SchemaType.prototype._cast.call(this, value) && value.length > 0;
        },
        of: function of(schema) {
            var next = this.clone();
            if (schema !== false && !isSchema(schema))
                throw new TypeError('`array.of()` sub-schema must be a valid yup schema, or `false` to negate a current sub-schema. ' + 'not: ' + printValue(schema));
            next._subType = schema;
            next.innerType = schema;
            return next;
        },
        min: function min(_min, message) {
            message = message || array$4.min;
            return this.test({
                message: message,
                name: 'min',
                exclusive: true,
                params: {
                    min: _min
                },
                test: function test(value) {
                    return isAbsent(value) || value.length >= this.resolve(_min);
                }
            });
        },
        max: function max(_max, message) {
            message = message || array$4.max;
            return this.test({
                message: message,
                name: 'max',
                exclusive: true,
                params: {
                    max: _max
                },
                test: function test(value) {
                    return isAbsent(value) || value.length <= this.resolve(_max);
                }
            });
        },
        ensure: function ensure() {
            var _this4 = this;
            return this.default(function () {
                return [];
            }).transform(function (val, original) {
                // We don't want to return `null` for nullable schema
                if (_this4._typeCheck(val))
                    return val;
                return original == null ? [] : [].concat(original);
            });
        },
        compact: function compact(rejector) {
            var reject = !rejector ? function (v) {
                return !!v;
            } : function (v, i, a) {
                return !rejector(v, i, a);
            };
            return this.transform(function (values) {
                return values != null ? values.filter(reject) : values;
            });
        },
        describe: function describe() {
            var base = SchemaType.prototype.describe.call(this);
            if (this.innerType)
                base.innerType = this.innerType.describe();
            return base;
        }
    });

    var ref = function ref(key, options) {
        return new Reference(key, options);
    };
    function addMethod(schemaType, name, fn) {
        if (!schemaType || !isSchema(schemaType.prototype))
            throw new TypeError('You must provide a yup schema constructor function');
        if (typeof name !== 'string')
            throw new TypeError('A Method name must be provided');
        if (typeof fn !== 'function')
            throw new TypeError('Method function must be provided');
        schemaType.prototype[name] = fn;
    }

    var validationStyle = {
        warningStyle: 'color: #C6003F;font-size:medium;',
        recommendationStyle: 'font-size:medium;',
        specialRecommendationStyle: 'color: #0061C1;font-size:medium;'
    };
    var VALIDATIONRULES = {
        TITLE: {
            MIN: 5,
            MAX: 50
        },
        PURPOSE: {
            MIN: 40,
            MAX: 250
        },
        EXECUTIVE: {
            MIN: 40,
            MAX: 250
        },
        EXECUTIVECOMBINED: {
            MIN: 40,
            MAX: 250
        },
        CONTEXTEXPLANATION: {
            MIN: 40,
            MAX: 500
        },
        CONTEXTEXPLANATIONCOMBINED: {
            MIN: 40,
            MAX: 500
        },
        STATISTICALNOTES: {
            MIN: 40,
            MAX: 250
        },
        STRUCTURENOTES: {
            MIN: 40,
            MAX: 250
        },
        DATAELEMENTDESCRIPTIONACCESSOR: {
            MIN: 0,
            MAX: 125
        },
        ELEMENTDESCRIPTIONACCESSOR: {
            MAX: 125
        },
        ANNOTATIONNOTETITLE: {
            MIN: 5,
            MAX: 50
        },
        ANNOTATIONNOTELABEL: {
            MIN: 25,
            MAX: 125
        },
        ANNOTATIONACCESSIBILITYDESCRIPTION: {
            MIN: 25,
            MAX: 125
        },
        UNIQUEID: {
            MIN: 1,
            MAX: 125
        }
    };
    var VALIDATIONMESSAGES = {
        WARNINGS: {
            TITLE: 'Either mainTitle or accessibility.title is required',
            LONGDESCRIPTION: 'Either accessibility.longDescription or accessibility.contextExplanation is required',
            EXECUTIVESUMMARY: 'Either accessibility.purpose or accessibility.executiveSummary is required',
            ONCLICKEVENT: 'accessibility.elementsAreInterface needs a boolean value either true or false',
            ANNOTATIONDESCRIPTION: 'Either annotation.accessibilityDescription or annotation.note.label is required',
            WARNINGLOGGROUP: 'CHARTNAME has accessibility warnings and other messages',
            NORMALIZED: 'Either tooltipLabel or dataLabel should have normalized format'
        },
        RECOMMENDATIONS: {
            EXECUTIVESUMMARY: 'Either accessibility.purpose or accessibility.executiveSummary should have minimum 40 characters and a combined length between 40 and 250 characters',
            LONGDESCRIPTION: 'Either accessibility.longDescription or accessibility.contextExplanation should have minimum 40 characters and a combined length between 40 and 500 characters',
            TITLE: 'Either mainTitle or accessibility.title should have length between 5 and 50 characters',
            STATISTICALNOTES: 'accessibility.statisticalNotes should have length between 40 and 250 characters',
            STRUCTURENOTES: 'accessibility.structureNotes should have length between 40 and 250 characters',
            DATAELEMENTDESCRIPTIONACCESSOR: 'accessibility.elementDescriptionAccessor should have length between 0 and 125 characters',
            ELEMENTDESCRIPTIONACCESSOR: 'Passing accessibility.elementDescriptionAccessor can add description to chart elements',
            ANNOTATIONNOTETITLE: 'Should have length between 5 and 50 characters',
            ANNOTATIONNOTELABEL: 'Should have length between 25 and 125 characters',
            ANNOTATIONACCESSIBILITYDESCRIPTION: 'Should have length between 25 and 125 characters',
            UNIQUEID: 'Should have human readable uniqueID',
            INCLUDEDATAKEYNAMES: "accessibility.includeDataKeyNames: data's key names are recommended as human-readable with includeDataKeyNames set to true",
            RECOMMENDATIONLOGGROUP: 'CHARTNAME has strong accessibility recommendations',
            SPECIALRECOMMENDATION: 'Success! CHARTNAME has met minimum accessibility, we recommend you disable accessibility validation by setting accessibility.disableValidation'
        }
    };
    var ACCESSIBILITYPROPS = {
        MAINTITLE: 'mainTitle',
        LONGDESCRIPTION: 'longDescription',
        CONTEXTEXPLANATION: 'contextExplanation',
        PURPOSE: 'purpose',
        ONCLICKEVENT: 'onClickEvent',
        NOTE: 'note',
        DISABLEVALIDATION: 'disableValidation',
        INCLUDEDATAKEYNAMES: 'includeDataKeyNames',
        CHARTNAME: 'CHARTNAME',
        TOOLTIPLABEL: 'tooltipLabel',
        DATALABEL: 'dataLabel',
        VALUEACCESSOR: 'valueAccessor'
    };
    var options$1 = {
        abortEarly: false
    };
    var accessibilityWarningsSubSchema = {
        requiredSchema: StringSchema()
            .required()
            .trim(),
        requiredSubSchema: ObjectSchema().shape({
            label: StringSchema()
                .required()
                .trim()
        }),
        requiredBooleanSchema: BooleanSchema().required()
    };
    var getCustomSchema = function (min, max) {
        return StringSchema()
            .required()
            .trim()
            .min(min)
            .max(max);
    };
    var getCustomRegexSchema = function (regexWord) {
        return StringSchema()
            .required()
            .trim()
            .matches(regexWord);
    };
    var validateBySchemaRefs = function (validationMessage, tooltipLabelRef, dataLabelRef, valueAccessorRef, schema) {
        return this.test({
            message: validationMessage,
            test: function (value) {
                var tooltipLabelValue = this.resolve(tooltipLabelRef);
                var dataLabelValue = this.resolve(dataLabelRef);
                var valueAccessorValue = this.resolve(valueAccessorRef);
                if (value &&
                    StringSchema()
                        .min(1)
                        .isValidSync(valueAccessorValue, options$1)) {
                    var valueAccessorIndex = Array.prototype.findIndex.call(tooltipLabelValue.labelAccessor, function (el) { return el.trim() === ('' + valueAccessorValue).trim(); });
                    return valueAccessorIndex > -1
                        ? schema.isValidSync(((tooltipLabelValue || {}).format || [''])[valueAccessorIndex], options$1)
                        : schema.isValidSync((dataLabelValue || {}).format, options$1);
                }
                return true;
            }
        });
    };
    var validateBySchemaRef = function (validationMessage, ref, firstSchema, secondSchema) {
        return this.test({
            message: validationMessage,
            test: function (value) {
                secondSchema = secondSchema ? secondSchema : firstSchema;
                var refField = this.resolve(ref);
                var isFieldValid = firstSchema.isValidSync(value, options$1);
                var isRefFieldValid = secondSchema.isValidSync(refField, options$1);
                return isRefFieldValid || isFieldValid ? true : false;
            }
        });
    };
    var validateBySchemaRefBoolean = function (schema, booleanSchema, ref, validationMessage) {
        return this.test({
            message: validationMessage,
            test: function (value) {
                var refField = this.resolve(ref);
                return schema.isValidSync(refField, options$1)
                    ? booleanSchema.isValidSync(value, { abortyEarly: false, strict: true })
                    : true;
            }
        });
    };
    var validateBySchemaRefAndCondition = function (schema, combinedSchema, ref, validationMessage) {
        return this.test({
            message: validationMessage,
            test: function (value) {
                var refField = (this.resolve(ref) || '').toString().trim();
                var field = (value || '').toString().trim();
                var fieldRefFieldCombined = "" + refField + field;
                var isValidRefField = schema.isValidSync(refField, options$1);
                var isValidField = schema.isValidSync(field, options$1);
                var isValid = combinedSchema.isValidSync(fieldRefFieldCombined, options$1);
                var derivedValidStatus = (refField.length && !isValidRefField) || (field.length && !isValidField) ? false : true;
                return derivedValidStatus && (isValidField || isValidRefField) && isValid ? true : false;
            }
        });
    };
    var validateBySchema = function (schema, validationMessage) {
        return this.test({
            message: validationMessage,
            test: function (value) {
                return schema.isValidSync(value, options$1);
            }
        });
    };
    var getAccessibilityWarningsSchema = function () {
        return ObjectSchema().shape({
            title: StringSchema().validateBySchemaRef(VALIDATIONMESSAGES.WARNINGS.TITLE, ref("$" + ACCESSIBILITYPROPS.MAINTITLE), accessibilityWarningsSubSchema.requiredSchema),
            longDescription: StringSchema().validateBySchemaRef(VALIDATIONMESSAGES.WARNINGS.LONGDESCRIPTION, ref("" + ACCESSIBILITYPROPS.CONTEXTEXPLANATION), accessibilityWarningsSubSchema.requiredSchema),
            executiveSummary: StringSchema().validateBySchemaRef(VALIDATIONMESSAGES.WARNINGS.EXECUTIVESUMMARY, ref("" + ACCESSIBILITYPROPS.PURPOSE), accessibilityWarningsSubSchema.requiredSchema),
            elementsAreInterface: BooleanSchema().validateBySchemaRefBoolean(accessibilityWarningsSubSchema.requiredSchema, accessibilityWarningsSubSchema.requiredBooleanSchema, ref("$" + ACCESSIBILITYPROPS.ONCLICKEVENT), VALIDATIONMESSAGES.WARNINGS.ONCLICKEVENT),
            normalized: BooleanSchema().validateBySchemaRefs(VALIDATIONMESSAGES.WARNINGS.NORMALIZED, ref("$" + ACCESSIBILITYPROPS.TOOLTIPLABEL), ref("$" + ACCESSIBILITYPROPS.DATALABEL), ref("$" + ACCESSIBILITYPROPS.VALUEACCESSOR), getCustomRegexSchema(/^normalized$/)),
            annotations: ArraySchema().of(ObjectSchema().shape({
                accessibilityDescription: StringSchema().validateBySchemaRef(VALIDATIONMESSAGES.WARNINGS.ANNOTATIONDESCRIPTION, ref("" + ACCESSIBILITYPROPS.NOTE), accessibilityWarningsSubSchema.requiredSchema, accessibilityWarningsSubSchema.requiredSubSchema)
            }))
        });
    };
    var getAccessibilityRecommendationSchema = function () {
        return ObjectSchema().shape({
            title: StringSchema().validateBySchemaRef(VALIDATIONMESSAGES.RECOMMENDATIONS.TITLE, ref("$" + ACCESSIBILITYPROPS.MAINTITLE), getCustomSchema(VALIDATIONRULES.TITLE.MIN, VALIDATIONRULES.TITLE.MAX)),
            longDescription: StringSchema().validateBySchemaRefAndCondition(getCustomSchema(VALIDATIONRULES.CONTEXTEXPLANATION.MIN, VALIDATIONRULES.CONTEXTEXPLANATION.MAX), getCustomSchema(VALIDATIONRULES.CONTEXTEXPLANATIONCOMBINED.MIN, VALIDATIONRULES.CONTEXTEXPLANATIONCOMBINED.MAX), ref("" + ACCESSIBILITYPROPS.CONTEXTEXPLANATION), VALIDATIONMESSAGES.RECOMMENDATIONS.LONGDESCRIPTION),
            executiveSummary: StringSchema().validateBySchemaRefAndCondition(getCustomSchema(VALIDATIONRULES.PURPOSE.MIN, VALIDATIONRULES.PURPOSE.MAX), getCustomSchema(VALIDATIONRULES.EXECUTIVECOMBINED.MIN, VALIDATIONRULES.EXECUTIVECOMBINED.MAX), ref("" + ACCESSIBILITYPROPS.PURPOSE), VALIDATIONMESSAGES.RECOMMENDATIONS.EXECUTIVESUMMARY),
            statisticalNotes: StringSchema().validateBySchema(getCustomSchema(VALIDATIONRULES.STATISTICALNOTES.MIN, VALIDATIONRULES.STATISTICALNOTES.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.STATISTICALNOTES),
            structureNotes: StringSchema().validateBySchema(getCustomSchema(VALIDATIONRULES.STRUCTURENOTES.MIN, VALIDATIONRULES.STRUCTURENOTES.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.STRUCTURENOTES),
            elementDescriptionAccessor: StringSchema().nullable().validateBySchema(StringSchema()
                .nullable()
                .max(VALIDATIONRULES.ELEMENTDESCRIPTIONACCESSOR.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.ELEMENTDESCRIPTIONACCESSOR),
            annotations: ArraySchema().of(ObjectSchema().shape({
                note: ObjectSchema().shape({
                    title: StringSchema().validateBySchema(getCustomSchema(VALIDATIONRULES.ANNOTATIONNOTETITLE.MIN, VALIDATIONRULES.ANNOTATIONNOTETITLE.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.ANNOTATIONNOTETITLE),
                    label: StringSchema().validateBySchema(getCustomSchema(VALIDATIONRULES.ANNOTATIONNOTELABEL.MIN, VALIDATIONRULES.ANNOTATIONNOTELABEL.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.ANNOTATIONNOTELABEL)
                }),
                accessibilityDescription: StringSchema().validateBySchema(getCustomSchema(VALIDATIONRULES.ANNOTATIONACCESSIBILITYDESCRIPTION.MIN, VALIDATIONRULES.ANNOTATIONACCESSIBILITYDESCRIPTION.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.ANNOTATIONACCESSIBILITYDESCRIPTION)
            })),
            data: ArraySchema()
                .nullable()
                .of(ObjectSchema().shape({
                note: StringSchema().nullable().validateBySchema(StringSchema()
                    .nullable()
                    .max(VALIDATIONRULES.DATAELEMENTDESCRIPTIONACCESSOR.MAX), VALIDATIONMESSAGES.RECOMMENDATIONS.DATAELEMENTDESCRIPTIONACCESSOR)
            })),
            uniqueID: StringSchema().validateBySchema(StringSchema()
                .required()
                .trim()
                .min(VALIDATIONRULES.UNIQUEID.MIN), VALIDATIONMESSAGES.RECOMMENDATIONS.UNIQUEID)
        });
    };
    function validateRecommendations(chartName, accessibilityProps, optionsWithContext, isAnyWarnings) {
        var recommendationSpecialMessage = VALIDATIONMESSAGES.RECOMMENDATIONS.SPECIALRECOMMENDATION.replace(ACCESSIBILITYPROPS.CHARTNAME, chartName);
        var recommendationGroup = VALIDATIONMESSAGES.RECOMMENDATIONS.RECOMMENDATIONLOGGROUP.replace(ACCESSIBILITYPROPS.CHARTNAME, chartName);
        try {
            var accessibilityRecommendationSchema = getAccessibilityRecommendationSchema();
            accessibilityRecommendationSchema.validateSync(accessibilityProps, optionsWithContext);
            if (!isAnyWarnings && accessibilityProps && !accessibilityProps[ACCESSIBILITYPROPS.DISABLEVALIDATION]) {
                console.log("%c " + recommendationSpecialMessage, validationStyle.specialRecommendationStyle);
            }
        }
        catch (errors) {
            if (!isAnyWarnings) {
                console.groupCollapsed("%c " + recommendationGroup, validationStyle.recommendationStyle);
            }
            errors.inner.map(function (error) {
                console.log("%c " + error.path + ": " + error.message, validationStyle.recommendationStyle);
            });
        }
        if (!accessibilityProps && !accessibilityProps[ACCESSIBILITYPROPS.INCLUDEDATAKEYNAMES]) {
            console.log("%c " + VALIDATIONMESSAGES.RECOMMENDATIONS.INCLUDEDATAKEYNAMES, validationStyle.recommendationStyle);
        }
        console.groupEnd();
    }
    function validateWarnings(chartName, accessibilityProps, optionsWithContext) {
        var warningGroup = VALIDATIONMESSAGES.WARNINGS.WARNINGLOGGROUP.replace(ACCESSIBILITYPROPS.CHARTNAME, chartName);
        try {
            var accessibilityWarningSchema = getAccessibilityWarningsSchema();
            accessibilityWarningSchema.validateSync(accessibilityProps, optionsWithContext);
            return false;
        }
        catch (errors) {
            console.groupCollapsed("%c " + warningGroup, validationStyle.warningStyle);
            errors.inner.map(function (error) {
                console.warn("%c " + error.path + ": " + error.message, validationStyle.warningStyle);
            });
            return true;
        }
    }
    var validateAccessibilityProps = function (chartName, accessibilityObject, otherProps) {
        if (accessibilityObject === void 0) { accessibilityObject = {}; }
        if (otherProps === void 0) { otherProps = { context: {}, data: {}, uniqueID: '', annotations: [], misc: {} }; }
        var context = otherProps.context, annotations = otherProps.annotations, data = otherProps.data, uniqueID = otherProps.uniqueID, misc = otherProps.misc;
        var optionsWithContext = {
            context: context,
            abortEarly: false
        };
        var accessibilityProps = __assign(__assign(__assign({}, accessibilityObject), { annotations: annotations, data: data, uniqueID: uniqueID }), misc);
        addMethod(StringSchema, 'validateBySchemaRefAndCondition', validateBySchemaRefAndCondition);
        addMethod(StringSchema, 'validateBySchema', validateBySchema);
        addMethod(BooleanSchema, 'validateBySchemaRefs', validateBySchemaRefs);
        addMethod(StringSchema, 'validateBySchemaRef', validateBySchemaRef);
        addMethod(BooleanSchema, 'validateBySchemaRefBoolean', validateBySchemaRefBoolean);
        var isAnyWarnings = validateWarnings(chartName, accessibilityProps, optionsWithContext);
        validateRecommendations(chartName, accessibilityProps, optionsWithContext, isAnyWarnings);
    };

    /**
     * Copyright (c) 2020, 2021, 2022 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    // import { darkerColor } from './colors';
    var accessibility = {
        longDescription: '',
        executiveSummary: '',
        purpose: '',
        contextExplanation: '',
        title: '',
        elementDescriptionAccessor: '',
        statisticalNotes: '',
        structureNotes: '',
        includeDataKeyNames: false,
        hideDataTableButton: false,
        disableValidation: false,
        elementsAreInterface: null,
        hideTextures: false,
        hideStrokes: false,
        showSmallLabels: false,
        showExperimentalTextures: false,
        keyboardNavConfig: {
            disabled: false
        }
    };
    var animationConfig = {
        disabled: false
    };
    var highestHeadingLevel = 'h2';
    var sortOrder = '';
    var sortOrderAsc = 'asc';
    var sortOrderDesc = 'desc';
    var layout = 'vertical';
    var xAxis = {
        visible: true,
        gridVisible: true,
        label: 'X Axis',
        format: '0[.][0][0]a',
        tickInterval: 1
    };
    var xAxisDate = {
        visible: true,
        gridVisible: false,
        label: 'X Axis',
        unit: 'month',
        format: '%b %y',
        tickInterval: 1
    };
    var yAxis = {
        visible: true,
        gridVisible: true,
        label: 'Y Axis',
        format: '0[.][0][0]a',
        tickInterval: 1
    };
    var wrapLabel = true;
    var colorPaletteSingle = 'single_blue';
    var colorPaletteSequential = 'sequential_suppPurple';
    var colorPaletteSequentialGrey = 'sequential_grey';
    var colorPaletteDiverging = 'diverging_RtoB';
    var colorPaletteCategorical = 'categorical';
    var colorSteps4 = 4;
    var colorSteps5 = 5;
    var hoverStyle = {
        color: '',
        strokeWidth: 2
    };
    var clickStyle = {
        color: '',
        strokeWidth: 2
    };
    var symbolHoverStyle = {
        color: '',
        strokeWidth: 2
    };
    var symbolClickStyle = {
        color: '',
        strokeWidth: 3
    };
    var referenceStyle = {
        color: 'pri_grey',
        strokeWidth: '1px',
        opacity: 1,
        dashed: ''
    };
    var seriesLabel = {
        visible: true,
        placement: 'right',
        label: [],
        collisionHideOnly: false
    };
    var cursor = 'default';
    var hoverOpacity = 1;
    var strokeWidth1 = 1;
    var strokeWidth2 = 2;
    var roundedCorner = 0;
    var barIntervalRatio = 0.2;
    var dotRadius6 = 6;
    var dotRadius5 = 5;
    var dotRadius4 = 4;
    var dotOpacity = 1;
    var dotSymbols = ['circle'];
    var showDots = true;
    var showFitLine = false;
    var showBaselineTrue = true;
    var showBaselineFalse = false;
    var secondaryLines = {
        keys: [],
        showDataLabel: true,
        showSeriesLabel: true,
        opacity: 1
    };
    var hiddenDataLabel = {
        visible: false,
        placement: 'bottom',
        labelAccessor: '',
        format: '',
        collisionHideOnly: false,
        collisionPlacement: 'all'
    };
    var dataLabel = {
        visible: true,
        placement: 'top',
        labelAccessor: '',
        format: '0[.][0][0]a',
        collisionHideOnly: false,
        collisionPlacement: 'top'
    };
    var dataLabelLine = {
        visible: true,
        placement: 'top',
        labelAccessor: '',
        format: '0[.][0][0]a',
        collisionHideOnly: false,
        collisionPlacement: 'all'
    };
    var dataLabelOutside = {
        visible: true,
        placement: 'outside',
        labelAccessor: '',
        format: '0[.][0][0]a',
        collisionHideOnly: false
    };
    var dataLabelMiddle = {
        visible: true,
        placement: 'middle',
        labelAccessor: '',
        format: '0[.][0][0]a',
        collisionHideOnly: false,
        collisionPlacement: 'middle'
    };
    var dataLabelCenter = {
        visible: true,
        placement: 'center',
        labelAccessor: '',
        format: '',
        collisionHideOnly: false,
        collisionPlacement: 'centroid'
    };
    var dataLabelEnds = {
        visible: true,
        placement: 'ends',
        labelAccessor: '',
        format: '0[.][0][0]a',
        collisionHideOnly: false
    };
    var dataLabelBottomRight = {
        visible: true,
        placement: 'bottom-right',
        labelAccessor: '',
        format: '0[.][0][0]a',
        collisionHideOnly: false,
        collisionPlacement: 'right'
    };
    // used on pie, no placement for collision yet on that chart
    var dataLabelNormalizedOut = {
        visible: true,
        placement: 'outside',
        labelAccessor: '',
        format: 'normalized',
        collisionHideOnly: false
    };
    var tooltipLabel = {
        labelAccessor: [],
        labelTitle: [],
        format: ''
    };
    // only leaving empty string in here so it displays in demo app and storybook
    var sizeConfig = {
        sizeAccessor: '',
        minValueOverride: '',
        maxValueOverride: '',
        minSizeOverride: '',
        maxSizeOverride: '',
        dualEncodeColor: false
    };
    var legend = {
        visible: true,
        interactive: false,
        format: '0[.][0][0]a',
        labels: ''
    };
    var categoryLegend = {
        visible: true,
        interactive: false,
        format: '',
        labels: ''
    };
    var keyLegend = {
        visible: true,
        interactive: false,
        type: 'key',
        format: '0[.][0][0]a',
        labels: ''
    };
    var hiddenLegend = {
        visible: false,
        interactive: false,
        labels: ''
    };
    var showTooltip = true;
    var suppressEvents = false;
    var referenceLines = [];
    var annotations = [];
    var clickHighlight = [];

    var propDefaultValues = /*#__PURE__*/Object.freeze({
        __proto__: null,
        accessibility: accessibility,
        animationConfig: animationConfig,
        highestHeadingLevel: highestHeadingLevel,
        sortOrder: sortOrder,
        sortOrderAsc: sortOrderAsc,
        sortOrderDesc: sortOrderDesc,
        layout: layout,
        xAxis: xAxis,
        xAxisDate: xAxisDate,
        yAxis: yAxis,
        wrapLabel: wrapLabel,
        colorPaletteSingle: colorPaletteSingle,
        colorPaletteSequential: colorPaletteSequential,
        colorPaletteSequentialGrey: colorPaletteSequentialGrey,
        colorPaletteDiverging: colorPaletteDiverging,
        colorPaletteCategorical: colorPaletteCategorical,
        colorSteps4: colorSteps4,
        colorSteps5: colorSteps5,
        hoverStyle: hoverStyle,
        clickStyle: clickStyle,
        symbolHoverStyle: symbolHoverStyle,
        symbolClickStyle: symbolClickStyle,
        referenceStyle: referenceStyle,
        seriesLabel: seriesLabel,
        cursor: cursor,
        hoverOpacity: hoverOpacity,
        strokeWidth1: strokeWidth1,
        strokeWidth2: strokeWidth2,
        roundedCorner: roundedCorner,
        barIntervalRatio: barIntervalRatio,
        dotRadius6: dotRadius6,
        dotRadius5: dotRadius5,
        dotRadius4: dotRadius4,
        dotOpacity: dotOpacity,
        dotSymbols: dotSymbols,
        showDots: showDots,
        showFitLine: showFitLine,
        showBaselineTrue: showBaselineTrue,
        showBaselineFalse: showBaselineFalse,
        secondaryLines: secondaryLines,
        hiddenDataLabel: hiddenDataLabel,
        dataLabel: dataLabel,
        dataLabelLine: dataLabelLine,
        dataLabelOutside: dataLabelOutside,
        dataLabelMiddle: dataLabelMiddle,
        dataLabelCenter: dataLabelCenter,
        dataLabelEnds: dataLabelEnds,
        dataLabelBottomRight: dataLabelBottomRight,
        dataLabelNormalizedOut: dataLabelNormalizedOut,
        tooltipLabel: tooltipLabel,
        sizeConfig: sizeConfig,
        legend: legend,
        categoryLegend: categoryLegend,
        keyLegend: keyLegend,
        hiddenLegend: hiddenLegend,
        showTooltip: showTooltip,
        suppressEvents: suppressEvents,
        referenceLines: referenceLines,
        annotations: annotations,
        clickHighlight: clickHighlight
    });

    /**
     * Copyright (c) 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    function targetDepth(d) {
        return d.target.depth;
    }
    function sankeyLeft(node) {
        return node.depth;
    }
    function sankeyRight(node, n) {
        return n - 1 - node.height;
    }
    function sankeyJustify(node, n) {
        return node.sourceLinks.length ? node.depth : n - 1;
    }
    function sankeyCenter(node) {
        return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min(node.sourceLinks, targetDepth) - 1 : 0;
    }
    function constant$p(x) {
        return function () {
            return x;
        };
    }
    function ascendingSourceBreadth(a, b) {
        return ascendingBreadth(a.source, b.source) || a.index - b.index;
    }
    function ascendingTargetBreadth(a, b) {
        return ascendingBreadth(a.target, b.target) || a.index - b.index;
    }
    function ascendingBreadth(a, b) {
        return a.y0 - b.y0;
    }
    function value$1(d) {
        return d.value;
    }
    function defaultId$1(d, _i, _nodes) {
        return d.index;
    }
    function defaultNodes(graph) {
        return graph.nodes;
    }
    function defaultLinks(graph) {
        return graph.links;
    }
    function find$1(nodeById, id) {
        var node = nodeById.get(id);
        if (!node)
            throw new Error('missing: ' + id);
        return node;
    }
    function computeLinkBreadths(_a) {
        var nodes = _a.nodes;
        for (var _b = 0, nodes_1 = nodes; _b < nodes_1.length; _b++) {
            var node = nodes_1[_b];
            var y0 = node.y0;
            var y1 = y0;
            for (var _c = 0, _d = node.sourceLinks; _c < _d.length; _c++) {
                var link = _d[_c];
                link.y0 = y0 + link.width / 2;
                y0 += link.width;
            }
            for (var _e = 0, _f = node.targetLinks; _e < _f.length; _e++) {
                var link = _f[_e];
                link.y1 = y1 + link.width / 2;
                y1 += link.width;
            }
        }
    }
    // The 'compareNodes' argument here was to the original d3-sankey script in order to allow us to bottom align nodes in VCC's alluvial-diagram
    function Sankey(compareNodes, showLinks) {
        var x0 = 0, y0 = 0, x1 = 1, y1 = 1; // extent
        var dx = 24; // nodeWidth
        var dy = 8, py; // nodePadding
        var id = defaultId$1;
        var align = sankeyJustify;
        var sort;
        var linkSort;
        var nodes = defaultNodes;
        var links = defaultLinks;
        var iterations = 6;
        function sankey() {
            var graph = { nodes: nodes.apply(null, arguments), links: links.apply(null, arguments) };
            computeNodeLinks(graph);
            computeNodeValues(graph);
            computeNodeDepths(graph);
            computeNodeHeights(graph);
            computeNodeBreadths(graph);
            computeLinkBreadths(graph);
            return graph;
        }
        sankey.update = function (graph) {
            computeLinkBreadths(graph);
            return graph;
        };
        sankey.nodeId = function (_) {
            return arguments.length ? ((id = typeof _ === 'function' ? _ : constant$p(_)), sankey) : id;
        };
        sankey.nodeAlign = function (_) {
            return arguments.length ? ((align = typeof _ === 'function' ? _ : constant$p(_)), sankey) : align;
        };
        sankey.nodeSort = function (_) {
            return arguments.length ? ((sort = _), sankey) : sort;
        };
        sankey.nodeWidth = function (_) {
            return arguments.length ? ((dx = +_), sankey) : dx;
        };
        sankey.nodePadding = function (_) {
            return arguments.length ? ((dy = py = +_), sankey) : dy;
        };
        sankey.nodes = function (_) {
            return arguments.length ? ((nodes = typeof _ === 'function' ? _ : constant$p(_)), sankey) : nodes;
        };
        sankey.links = function (_) {
            return arguments.length ? ((links = typeof _ === 'function' ? _ : constant$p(_)), sankey) : links;
        };
        sankey.linkSort = function (_) {
            return arguments.length ? ((linkSort = _), sankey) : linkSort;
        };
        sankey.size = function (_) {
            return arguments.length ? ((x0 = y0 = 0), (x1 = +_[0]), (y1 = +_[1]), sankey) : [x1 - x0, y1 - y0];
        };
        sankey.extent = function (_) {
            return arguments.length
                ? ((x0 = +_[0][0]), (x1 = +_[1][0]), (y0 = +_[0][1]), (y1 = +_[1][1]), sankey)
                : [[x0, y0], [x1, y1]];
        };
        sankey.iterations = function (_) {
            return arguments.length ? ((iterations = +_), sankey) : iterations;
        };
        // VCC had to transform for .. of with object.entries to forEach for es5 support
        function computeNodeLinks(_a) {
            var nodes = _a.nodes, links = _a.links;
            nodes.forEach(function (node, i) {
                node.index = i;
                node.sourceLinks = [];
                node.targetLinks = [];
            });
            var nodeById = new Map(nodes.map(function (d, i) { return [id(d, i, nodes), d]; }));
            links.forEach(function (link, i) {
                link.index = i;
                var source = link.source, target = link.target;
                if (typeof source !== 'object')
                    source = link.source = find$1(nodeById, source);
                if (typeof target !== 'object')
                    target = link.target = find$1(nodeById, target);
                source.sourceLinks.push(link);
                target.targetLinks.push(link);
            });
            if (linkSort != null) {
                for (var _b = 0, nodes_2 = nodes; _b < nodes_2.length; _b++) {
                    var _c = nodes_2[_b], sourceLinks = _c.sourceLinks, targetLinks = _c.targetLinks;
                    sourceLinks.sort(linkSort);
                    targetLinks.sort(linkSort);
                }
            }
        }
        function computeNodeValues(_a) {
            var nodes = _a.nodes;
            for (var _b = 0, nodes_3 = nodes; _b < nodes_3.length; _b++) {
                var node = nodes_3[_b];
                node.value =
                    node.fixedValue === undefined
                        ? Math.max(sum(node.sourceLinks, value$1), sum(node.targetLinks, value$1))
                        : node.fixedValue;
            }
        }
        // VCC had to transform for .. of with Set() to forEach for es5 support
        function computeNodeDepths(_a) {
            var nodes = _a.nodes;
            var n = nodes.length;
            var current = new Set(nodes);
            var next = new Set();
            var x = 0;
            while (current.size) {
                current.forEach(function (node) {
                    node.depth = x;
                    for (var _a = 0, _b = node.sourceLinks; _a < _b.length; _a++) {
                        var target = _b[_a].target;
                        next.add(target);
                    }
                });
                if (++x > n)
                    throw new Error('circular link');
                current = next;
                next = new Set();
            }
        }
        // VCC had to transform for .. of with Set() to forEach for es5 support
        function computeNodeHeights(_a) {
            var nodes = _a.nodes;
            var n = nodes.length;
            var current = new Set(nodes);
            var next = new Set();
            var x = 0;
            while (current.size) {
                current.forEach(function (node) {
                    node.height = x;
                    for (var _a = 0, _b = node.targetLinks; _a < _b.length; _a++) {
                        var source = _b[_a].source;
                        next.add(source);
                    }
                });
                if (++x > n)
                    throw new Error('circular link');
                current = next;
                next = new Set();
            }
        }
        // added in order to compute x position when links are hidden
        function computeNodeLayersWhenLinksHidden(_a) {
            var nodes = _a.nodes;
            var x = max(nodes, function (d) { return d.depth; });
            var allNodeWidths = x * (2 * dx);
            var leftPadding = (x1 - allNodeWidths) / 2;
            var columns = new Array(x + 1);
            for (var _b = 0, nodes_4 = nodes; _b < nodes_4.length; _b++) {
                var node = nodes_4[_b];
                var i = Math.max(0, Math.min(x, Math.floor(align.call(null, node, x + 1))));
                node.layer = i;
                node.x0 = leftPadding + node.depth * (2 * dx);
                node.x1 = node.x0 + dx;
                if (columns[i])
                    columns[i].push(node);
                else
                    columns[i] = [node];
            }
            if (sort)
                for (var _c = 0, columns_1 = columns; _c < columns_1.length; _c++) {
                    var column = columns_1[_c];
                    column.sort(sort);
                }
            return columns;
        }
        function computeNodeLayers(_a) {
            var nodes = _a.nodes;
            var x = max(nodes, function (d) { return d.depth; }) + 1;
            var kx = (x1 - x0 - dx) / (x - 1);
            var columns = new Array(x);
            for (var _b = 0, nodes_5 = nodes; _b < nodes_5.length; _b++) {
                var node = nodes_5[_b];
                var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
                node.layer = i;
                node.x0 = x0 + i * kx;
                node.x1 = node.x0 + dx;
                if (columns[i])
                    columns[i].push(node);
                else
                    columns[i] = [node];
            }
            if (sort)
                for (var _c = 0, columns_2 = columns; _c < columns_2.length; _c++) {
                    var column = columns_2[_c];
                    column.sort(sort);
                }
            return columns;
        }
        // This function was added to the original d3-sankey script in order to allow us to bottom align nodes in VCC's alluvial-diagram
        function setBottomAlignedNodes(columns) {
            var nodeCount = max(columns, function (c) { return c.length; });
            var maxValues = [];
            for (var i = 0; i < nodeCount; ++i) {
                var max_1 = 0;
                for (var j = 0; j < columns.length; ++j) {
                    if (columns[j][i] && columns[j][i].value && columns[j][i].value > max_1) {
                        max_1 = columns[j][i].value;
                    }
                }
                maxValues[i] = max_1;
            }
            var ky = (y1 - y0 - (nodeCount - 1) * py) / sum(maxValues);
            for (var _a = 0, columns_3 = columns; _a < columns_3.length; _a++) {
                var nodes_6 = columns_3[_a];
                var y = y0;
                for (var i = 0; i < nodes_6.length; ++i) {
                    nodes_6[i].y1 = y + maxValues[i] * ky;
                    nodes_6[i].y0 = nodes_6[i].y1 - nodes_6[i].value * ky;
                    y = nodes_6[i].y1 + py;
                    for (var _b = 0, _c = nodes_6[i].sourceLinks; _b < _c.length; _b++) {
                        var link = _c[_b];
                        link.width = link.value * ky;
                    }
                }
            }
        }
        function initializeNodeBreadths(columns) {
            var ky = min(columns, function (c) { return (y1 - y0 - (c.length - 1) * py) / sum(c, value$1); });
            for (var _a = 0, columns_4 = columns; _a < columns_4.length; _a++) {
                var nodes_8 = columns_4[_a];
                var y = y0;
                for (var _b = 0, nodes_7 = nodes_8; _b < nodes_7.length; _b++) {
                    var node = nodes_7[_b];
                    node.y0 = y;
                    node.y1 = y + node.value * ky;
                    y = node.y1 + py;
                    for (var _c = 0, _d = node.sourceLinks; _c < _d.length; _c++) {
                        var link = _d[_c];
                        link.width = link.value * ky;
                    }
                }
                y = (y1 - y + py) / (nodes_8.length + 1);
                for (var i = 0; i < nodes_8.length; ++i) {
                    var node = nodes_8[i];
                    node.y0 += y * (i + 1);
                    node.y1 += y * (i + 1);
                }
                reorderLinks(nodes_8);
            }
        }
        function computeNodeBreadths(graph) {
            var columns = !showLinks ? computeNodeLayersWhenLinksHidden(graph) : computeNodeLayers(graph);
            py = Math.min(dy, (y1 - y0) / (max(columns, function (c) { return c.length; }) - 1));
            // This operation was added to the original d3-sankey script to allow us to call a function that bottom aligns nodes in VCC's alluvial-diagram
            compareNodes ? setBottomAlignedNodes(columns) : initializeNodeBreadths(columns);
            for (var i = 0; i < iterations; ++i) {
                var alpha = Math.pow(0.99, i);
                var beta = Math.max(1 - alpha, (i + 1) / iterations);
                // This prop and operation was to the original d3-sankey script to allow us to bottom align nodes in VCC's alluvial-diagram
                if (!compareNodes) {
                    relaxRightToLeft(columns, alpha, beta);
                    relaxLeftToRight(columns, alpha, beta);
                }
            }
        }
        // Reposition each node based on its incoming (target) links.
        function relaxLeftToRight(columns, alpha, beta) {
            for (var i = 1, n = columns.length; i < n; ++i) {
                var column = columns[i];
                for (var _a = 0, column_1 = column; _a < column_1.length; _a++) {
                    var target = column_1[_a];
                    var y = 0;
                    var w = 0;
                    for (var _b = 0, _c = target.targetLinks; _b < _c.length; _b++) {
                        var _d = _c[_b], source = _d.source, value_1 = _d.value;
                        var v = value_1 * (target.layer - source.layer);
                        y += targetTop(source, target) * v;
                        w += v;
                    }
                    if (!(w > 0))
                        continue;
                    var dy_1 = (y / w - target.y0) * alpha;
                    target.y0 += dy_1;
                    target.y1 += dy_1;
                    reorderNodeLinks(target);
                }
                if (sort === undefined)
                    column.sort(ascendingBreadth);
                resolveCollisions(column, beta);
            }
        }
        // Reposition each node based on its outgoing (source) links.
        function relaxRightToLeft(columns, alpha, beta) {
            for (var n = columns.length, i = n - 2; i >= 0; --i) {
                var column = columns[i];
                for (var _a = 0, column_2 = column; _a < column_2.length; _a++) {
                    var source = column_2[_a];
                    var y = 0;
                    var w = 0;
                    for (var _b = 0, _c = source.sourceLinks; _b < _c.length; _b++) {
                        var _d = _c[_b], target = _d.target, value_2 = _d.value;
                        var v = value_2 * (target.layer - source.layer);
                        y += sourceTop(source, target) * v;
                        w += v;
                    }
                    if (!(w > 0))
                        continue;
                    var dy_2 = (y / w - source.y0) * alpha;
                    source.y0 += dy_2;
                    source.y1 += dy_2;
                    reorderNodeLinks(source);
                }
                if (sort === undefined)
                    column.sort(ascendingBreadth);
                resolveCollisions(column, beta);
            }
        }
        function resolveCollisions(nodes, alpha) {
            var i = nodes.length >> 1;
            var subject = nodes[i];
            resolveCollisionsBottomToTop(nodes, subject.y0 - py, i - 1, alpha);
            resolveCollisionsTopToBottom(nodes, subject.y1 + py, i + 1, alpha);
            resolveCollisionsBottomToTop(nodes, y1, nodes.length - 1, alpha);
            resolveCollisionsTopToBottom(nodes, y0, 0, alpha);
        }
        // Push any overlapping nodes down.
        function resolveCollisionsTopToBottom(nodes, y, i, alpha) {
            for (; i < nodes.length; ++i) {
                var node = nodes[i];
                var dy_3 = (y - node.y0) * alpha;
                if (dy_3 > 1e-6)
                    (node.y0 += dy_3), (node.y1 += dy_3);
                y = node.y1 + py;
            }
        }
        // Push any overlapping nodes up.
        function resolveCollisionsBottomToTop(nodes, y, i, alpha) {
            for (; i >= 0; --i) {
                var node = nodes[i];
                var dy_4 = (node.y1 - y) * alpha;
                if (dy_4 > 1e-6)
                    (node.y0 -= dy_4), (node.y1 -= dy_4);
                y = node.y0 - py;
            }
        }
        function reorderNodeLinks(_a) {
            var sourceLinks = _a.sourceLinks, targetLinks = _a.targetLinks;
            if (linkSort === undefined) {
                for (var _b = 0, targetLinks_1 = targetLinks; _b < targetLinks_1.length; _b++) {
                    var sourceLinks_2 = targetLinks_1[_b].source.sourceLinks;
                    sourceLinks_2.sort(ascendingTargetBreadth);
                }
                for (var _c = 0, sourceLinks_1 = sourceLinks; _c < sourceLinks_1.length; _c++) {
                    var targetLinks_2 = sourceLinks_1[_c].target.targetLinks;
                    targetLinks_2.sort(ascendingSourceBreadth);
                }
            }
        }
        function reorderLinks(nodes) {
            if (linkSort === undefined) {
                for (var _a = 0, nodes_9 = nodes; _a < nodes_9.length; _a++) {
                    var _b = nodes_9[_a], sourceLinks = _b.sourceLinks, targetLinks = _b.targetLinks;
                    sourceLinks.sort(ascendingTargetBreadth);
                    targetLinks.sort(ascendingSourceBreadth);
                }
            }
        }
        // Returns the target.y0 that would produce an ideal link from source to target.
        function targetTop(source, target) {
            var y = source.y0 - ((source.sourceLinks.length - 1) * py) / 2;
            for (var _a = 0, _b = source.sourceLinks; _a < _b.length; _a++) {
                var _c = _b[_a], node = _c.target, width = _c.width;
                if (node === target)
                    break;
                y += width + py;
            }
            for (var _d = 0, _e = target.targetLinks; _d < _e.length; _d++) {
                var _f = _e[_d], node = _f.source, width = _f.width;
                if (node === source)
                    break;
                y -= width;
            }
            return y;
        }
        // Returns the source.y0 that would produce an ideal link from source to target.
        function sourceTop(source, target) {
            var y = target.y0 - ((target.targetLinks.length - 1) * py) / 2;
            for (var _a = 0, _b = target.targetLinks; _a < _b.length; _a++) {
                var _c = _b[_a], node = _c.source, width = _c.width;
                if (node === source)
                    break;
                y += width + py;
            }
            for (var _d = 0, _e = source.sourceLinks; _d < _e.length; _d++) {
                var _f = _e[_d], node = _f.target, width = _f.width;
                if (node === target)
                    break;
                y -= width;
            }
            return y;
        }
        return sankey;
    }
    function horizontalSource(d) {
        return [d.source.x1, d.y0];
    }
    function horizontalTarget(d) {
        return [d.target.x0, d.y1];
    }
    function sankeyLinkHorizontal() {
        return linkHorizontal()
            .source(horizontalSource)
            .target(horizontalTarget);
    }

    /**
     * Copyright (c) 2020, 2021 Visa, Inc.
     *
     * This source code is licensed under the MIT license
     * https://github.com/visa/visa-chart-components/blob/master/LICENSE
     *
     **/
    // incorporate OSS licenses into build
    window['VisaChartsLibOSSLicenses'] = getLicenses(); // tslint:disable-line no-string-literal

    var Utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        autoTextColor: autoTextColor,
        buildStrokes: buildStrokes,
        checkAttributeTransitions: checkAttributeTransitions,
        createTextStrokeFilter: createTextStrokeFilter,
        getBrowser: getBrowser,
        getOS: getOS,
        findTagLevel: findTagLevel,
        createUrl: createUrl,
        createMultiStrokeFilter: createMultiStrokeFilter,
        removeFilters: removeFilters,
        drawHoverStrokes: drawHoverStrokes,
        removeHoverStrokes: removeHoverStrokes,
        mirrorStrokeTransition: mirrorStrokeTransition,
        initializeElementAccess: initializeElementAccess,
        initializeDescriptionRoot: initializeDescriptionRoot,
        setElementFocusHandler: setElementFocusHandler,
        setElementAccessID: setElementAccessID,
        setTooltipAccess: setTooltipAccess,
        setLegendAccess: setLegendAccess,
        setHighContrastListener: setHighContrastListener,
        createLabel: createLabel,
        createGroupLabel: createGroupLabel,
        setAccessibilityController: setAccessibilityController,
        hideNonessentialGroups: hideNonessentialGroups,
        hideNode: hideNode,
        setAccessTitle: setAccessTitle,
        setAccessSubtitle: setAccessSubtitle,
        setAccessLongDescription: setAccessLongDescription,
        setAccessExecutiveSummary: setAccessExecutiveSummary,
        setAccessPurpose: setAccessPurpose,
        setAccessContext: setAccessContext,
        setAccessStatistics: setAccessStatistics,
        setAccessChartCounts: setAccessChartCounts,
        setAccessXAxis: setAccessXAxis,
        setAccessYAxis: setAccessYAxis,
        setAccessStructure: setAccessStructure,
        setAccessAnnotation: setAccessAnnotation,
        retainAccessFocus: retainAccessFocus,
        checkAccessFocus: checkAccessFocus,
        setElementInteractionAccessState: setElementInteractionAccessState,
        setAccessibilityDescriptionWidth: setAccessibilityDescriptionWidth,
        annotate: annotate,
        getTexture: getTexture,
        convertColorsToTextures: convertColorsToTextures,
        prepareStrokeColorsFromScheme: prepareStrokeColorsFromScheme,
        calculateLuminance: calculateLuminance,
        calculateRelativeLuminance: calculateRelativeLuminance,
        getAccessibleStrokes: getAccessibleStrokes,
        getRecursiveStroke: getRecursiveStroke,
        getContrastingStroke: getContrastingStroke,
        ensureTextContrast: ensureTextContrast,
        convertVisaColor: convertVisaColor,
        circularFind: circularFind,
        resolveLabelCollision: resolveLabelCollision,
        prepareBitmap: prepareBitmap,
        addToBitmap: addToBitmap,
        findCollision: findCollision,
        capitalized: capitalized,
        chartAccessors: chartAccessors,
        checkInteraction: checkInteraction,
        checkClicked: checkClicked,
        checkHovered: checkHovered,
        drawAxis: drawAxis,
        wrap: wrap,
        drawGrid: drawGrid,
        drawLegend: drawLegend,
        setLegendInteractionState: setLegendInteractionState,
        drawTooltip: drawTooltip,
        darkerColor: darkerColor,
        equalizePath: equalizePath,
        formatDataLabel: formatDataLabel,
        formatStats: formatStats,
        formatDate: formatDate,
        getColors: getColors,
        getLicenses: getLicenses,
        generalizePath: generalizePath,
        getDataSymbol: getDataSymbol,
        getScopedData: getScopedData,
        getTextWidth: getTextWidth,
        verifyTextHasSpace: verifyTextHasSpace,
        manuallyWrapText: manuallyWrapText,
        getPadding: getPadding,
        interactionStyle: interactionStyle,
        initTooltipStyle: initTooltipStyle,
        leastSquares: leastSquares,
        moveToFront: moveToFront,
        mapButtons: mapButtons,
        orderScopedData: orderScopedData,
        outlineColor: outlineColor,
        overrideTitleTooltip: overrideTitleTooltip,
        placeDataLabels: placeDataLabels,
        propDefaultValues: propDefaultValues,
        resolveLines: resolveLines,
        roundTo: roundTo,
        symbols: symbols,
        sankey: Sankey,
        sankeyCenter: sankeyCenter,
        sankeyJustify: sankeyJustify,
        sankeyLeft: sankeyLeft,
        sankeyLinkHorizontal: sankeyLinkHorizontal,
        sankeyRight: sankeyRight,
        transitionEndAll: transitionEndAll,
        transformData: transformData,
        scopeDataKeys: scopeDataKeys,
        visaColors: visaColors,
        validateAccessibilityProps: validateAccessibilityProps,
        fixNestedSparseness: fixNestedSparseness,
        prepareRenderChange: prepareRenderChange
    });

    var index$4 = __assign({}, Utils);

    return index$4;

})));
});

export { selector as a, selectorAll as b, selection as c, styleValue as d, event as e, matcher as m, namespace as n, select as s, visaChartsUtils_umd as v };
