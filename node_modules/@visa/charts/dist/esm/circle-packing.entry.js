import { r as registerInstance, c as createEvent, h, g as getElement } from './index-1c5d8972.js';
import { v as visaChartsUtils_umd, s as select, e as event } from './visa-charts-utils.umd-23a648ee.js';
import { m as max } from './max-d011e4a4.js';
import { v as v4 } from './index-ba4ad12d.js';

/**
 * Copyright (c) 2020, 2021 Visa, Inc.
 *
 * This source code is licensed under the MIT license
 * https://github.com/visa/visa-chart-components/blob/master/LICENSE
 *
 **/
const { propDefaultValues } = visaChartsUtils_umd;
class CirclePackingDefaultValues {
}
CirclePackingDefaultValues.mainTitle = 'Circle Packing Title';
CirclePackingDefaultValues.subTitle = "This is the circle packing chart's subtitle";
CirclePackingDefaultValues.height = 400;
CirclePackingDefaultValues.width = 400;
CirclePackingDefaultValues.circlePadding = 5;
CirclePackingDefaultValues.margin = {
  top: 400 * 0.01,
  bottom: 400 * 0.01,
  right: 400 * 0.01,
  left: 400 * 0.01
};
CirclePackingDefaultValues.padding = {
  top: 400 * 0.01,
  bottom: 400 * 0.01,
  right: 400 * 0.01,
  left: 400 * 0.01
};
CirclePackingDefaultValues.dataDepth = 5;
CirclePackingDefaultValues.displayDepth = 2;
CirclePackingDefaultValues.parentAccessor = 'parentNode';
CirclePackingDefaultValues.nodeAccessor = 'childNode';
CirclePackingDefaultValues.sizeAccessor = 'value';
CirclePackingDefaultValues.colorPalette = propDefaultValues.colorPaletteSequentialGrey;
CirclePackingDefaultValues.dataLabel = propDefaultValues.dataLabelCenter;
CirclePackingDefaultValues.hoverStyle = propDefaultValues.hoverStyle;
CirclePackingDefaultValues.clickStyle = propDefaultValues.clickStyle;
CirclePackingDefaultValues.hoverOpacity = propDefaultValues.hoverOpacity;
CirclePackingDefaultValues.cursor = propDefaultValues.cursor;
CirclePackingDefaultValues.interactionKeys = propDefaultValues.interactionKeys;
CirclePackingDefaultValues.highestHeadingLevel = propDefaultValues.highestHeadingLevel;
CirclePackingDefaultValues.annotations = propDefaultValues.annotations;
CirclePackingDefaultValues.accessibility = propDefaultValues.accessibility;
CirclePackingDefaultValues.animationConfig = propDefaultValues.animationConfig;
CirclePackingDefaultValues.tooltipLabel = propDefaultValues.tooltipLabel;
CirclePackingDefaultValues.showTooltip = propDefaultValues.showTooltip;
CirclePackingDefaultValues.clickHighlight = propDefaultValues.clickHighlight;
CirclePackingDefaultValues.suppressEvents = propDefaultValues.suppressEvents;

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback) {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);
  return this;
}

function node_eachBefore(callback) {
  var node = this, nodes = [node], children, i;
  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }
  return this;
}

function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children, i, n;
  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function hierarchy(data, children) {
  var root = new Node$1(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node$1(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node$1(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node$1.prototype = hierarchy.prototype = {
  constructor: Node$1,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};

var slice = Array.prototype.slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function enclose(circles) {
  var i = 0, n = (circles = shuffle(slice.call(circles))).length, B = [], p, e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;
    else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;

  if (enclosesWeakAll(p, B)) return [p];

  // If we get here then B must have at least one element.
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i])
        && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }

  // If we get here then B must have at least two elements.
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p)
          && enclosesNot(encloseBasis2(B[i], p), B[j])
          && enclosesNot(encloseBasis2(B[j], p), B[i])
          && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }

  // If we get here then something is very wrong.
  throw new Error;
}

function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1: return encloseBasis1(B[0]);
    case 2: return encloseBasis2(B[0], B[1]);
    case 3: return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r,
      x2 = b.x, y2 = b.y, r2 = b.r,
      x3 = c.x, y3 = c.y, r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}

function place(b, a, c) {
  var dx = b.x - a.x, x, a2,
      dy = b.y - a.y, y, b2,
      d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b2 = b.r + c.r, b2 *= b2;
    if (a2 > b2) {
      x = (d2 + b2 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b2) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}

function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;

  var a, b, c, n, aa, ca, i, j, k, sj, sk;

  // Place the first circle.
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r;

  // Place the second circle.
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r;

  // Place the third circle.
  place(b, a, c = circles[2]);

  // Initialize the front-chain using the first three circles a, b and c.
  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;

  // Attempt to place each remaining circle…
  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c);

    // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.
    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }
        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next);

    // Success! Insert the new circle c between a and b.
    c.previous = a, c.next = b, a.next = b.previous = b = c;

    // Compute the new closest circle pair to the centroid.
    aa = score(a);
    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }
    b = a.next;
  }

  // Compute the enclosing circle of the front chain.
  a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = enclose(a);

  // Translate the circles to put the enclosing circle around the origin.
  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

function constant(x) {
  return function() {
    return x;
  };
}

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

function index() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius))
          .eachAfter(packChildren(padding, 0.5))
          .eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius))
          .eachAfter(packChildren(constantZero, 1))
          .eachAfter(packChildren(padding, root.r / Math.min(dx, dy)))
          .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }

  pack.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack) : radius;
  };

  pack.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function(x) {
    return arguments.length ? (padding = typeof x === "function" ? x : constant(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function(node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;

      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = packEnclose(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}

var keyPrefix = "$", // Protect against keys like “__proto__”.
    preroot = {depth: -1},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new Node$1(d);
      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = required(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify) : parentId;
  };

  return stratify;
}

const circlePackingCss = ".o-layout{width:100%;display:-ms-flexbox;display:flex;-ms-flex-wrap:wrap;flex-wrap:wrap}.o-layout--chart{width:100%}.is--vertical .o-layout--chart{width:90%}circle-packing .screen-reader-info{position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden}circle-packing .annotations{pointer-events:none}circle-packing .annotations .handle{pointer-events:all}circle-packing .label{font:12px \"Open Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;text-anchor:middle}circle-packing .label,circle-packing .node--root{pointer-events:none}";

const { getContrastingStroke, createTextStrokeFilter, convertColorsToTextures, initializeElementAccess, initializeDescriptionRoot, setElementFocusHandler, setElementAccessID, setAccessibilityController, hideNonessentialGroups, setAccessTitle, setAccessSubtitle, setAccessLongDescription, setAccessExecutiveSummary, setAccessPurpose, setAccessContext, setAccessStatistics, setAccessChartCounts, setAccessStructure, setAccessAnnotation, retainAccessFocus, checkAccessFocus, setElementInteractionAccessState, drawTooltip, setAccessibilityDescriptionWidth, annotate, getPadding, chartAccessors, checkInteraction, checkClicked, checkHovered, convertVisaColor, getColors, getLicenses, getScopedData, initTooltipStyle, transitionEndAll, overrideTitleTooltip, roundTo, scopeDataKeys, visaColors, validateAccessibilityProps, findTagLevel, prepareRenderChange, resolveLabelCollision } = visaChartsUtils_umd;
const CirclePacking = class {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.clickEvent = createEvent(this, "clickEvent", 7);
    this.hoverEvent = createEvent(this, "hoverEvent", 7);
    this.mouseOutEvent = createEvent(this, "mouseOutEvent", 7);
    this.initialLoadEvent = createEvent(this, "initialLoadEvent", 7);
    this.drawStartEvent = createEvent(this, "drawStartEvent", 7);
    this.drawEndEvent = createEvent(this, "drawEndEvent", 7);
    this.transitionEndEvent = createEvent(this, "transitionEndEvent", 7);
    // Chart Attributes (1/7)
    this.mainTitle = CirclePackingDefaultValues.mainTitle;
    this.subTitle = CirclePackingDefaultValues.subTitle;
    this.height = CirclePackingDefaultValues.height;
    this.width = CirclePackingDefaultValues.width;
    this.margin = CirclePackingDefaultValues.margin;
    this.padding = CirclePackingDefaultValues.padding;
    this.circlePadding = CirclePackingDefaultValues.circlePadding;
    this.highestHeadingLevel = CirclePackingDefaultValues.highestHeadingLevel;
    this.dataDepth = CirclePackingDefaultValues.dataDepth;
    this.displayDepth = CirclePackingDefaultValues.displayDepth;
    this.parentAccessor = CirclePackingDefaultValues.parentAccessor;
    this.nodeAccessor = CirclePackingDefaultValues.nodeAccessor;
    this.sizeAccessor = CirclePackingDefaultValues.sizeAccessor;
    // Color & Shape (4/7)
    this.colorPalette = CirclePackingDefaultValues.colorPalette;
    this.cursor = CirclePackingDefaultValues.cursor;
    this.hoverStyle = CirclePackingDefaultValues.hoverStyle;
    this.clickStyle = CirclePackingDefaultValues.clickStyle;
    this.hoverOpacity = CirclePackingDefaultValues.hoverOpacity;
    this.animationConfig = CirclePackingDefaultValues.animationConfig;
    // Data label (5/7)
    this.showTooltip = CirclePackingDefaultValues.showTooltip;
    this.tooltipLabel = CirclePackingDefaultValues.tooltipLabel;
    this.dataLabel = CirclePackingDefaultValues.dataLabel;
    this.annotations = CirclePackingDefaultValues.annotations;
    this.accessibility = CirclePackingDefaultValues.accessibility;
    // Calculation (6/7)
    // Interactivity (7/7)
    this.suppressEvents = CirclePackingDefaultValues.suppressEvents;
    this.clickHighlight = CirclePackingDefaultValues.clickHighlight;
    this.shouldValidateAccessibility = true;
    this.currentDepth = 0;
    this.zooming = false;
    this.timer = 0;
    this.delay = 200;
    this.prevent = false;
    this.updated = false;
    this.exitSize = 0;
    this.enterSize = 0;
    this.shouldZoom = false;
    this.shouldValidateInteractionKeys = false;
    this.shouldDrawInteractionState = false;
    // shouldUpdateAccessibility: boolean = false;
    this.shouldUpdateAnnotations = false;
    this.shouldResetRoot = false;
    this.shouldSetColors = false;
    this.shouldUpdateDisplayDepth = false;
    this.shouldUpdateLabels = false;
    this.shouldAddStrokeUnder = false;
    this.shouldUpdateCursor = false;
    this.shouldUpdateData = false;
    this.shouldUpdateTableData = false;
    this.shouldValidate = false;
    this.shouldBindInteractivity = false;
    this.shouldUpdateDescriptionWrapper = false;
    this.shouldSetChartAccessibilityTitle = false;
    this.shouldSetChartAccessibilitySubtitle = false;
    this.shouldSetChartAccessibilityLongDescription = false;
    this.shouldSetChartAccessibilityExecutiveSummary = false;
    this.shouldSetChartAccessibilityStatisticalNotes = false;
    this.shouldSetChartAccessibilityStructureNotes = false;
    this.shouldSetParentSVGAccessibility = false;
    this.shouldSetGeometryAccessibilityAttributes = false;
    this.shouldSetGeometryAriaLabels = false;
    this.shouldSetGroupAccessibilityAttributes = false;
    this.shouldSetGroupAccessibilityLabel = false;
    this.shouldSetChartAccessibilityPurpose = false;
    this.shouldSetChartAccessibilityContext = false;
    this.shouldSetChartAccessibilityCount = false;
    this.shouldUpdateLayout = false;
    this.shouldSetTextures = false;
    this.shouldSetStrokes = false;
    this.shouldSetTextStrokes = false;
    this.shouldSetTagLevels = false;
    this.shouldRedrawWrapper = false;
    this.shouldSetIDs = false;
    this.innerInteractionKeys = [];
    this.defaultsLoaded = {};
    this.bottomLevel = 'p';
    this.topLevel = 'h2';
    this.strokes = {};
    this.setCircleFilter = (_, i, n) => {
      return !select(n[i]).classed('moving') && !this.accessibility.hideStrokes ? this.filter : null;
    };
    this.setIDs = () => {
      this.rootG.selectAll('circle:not(.vcl-accessibility-focus-highlight)').attr('id', d => {
        return 'circle-in-pack-' + this.generateValidId(d.data.id);
      });
    };
    this.generateValidId = inputId => {
      const id = inputId instanceof Date ? inputId.getTime() : inputId;
      return (id + '-' + this.chartID).replace(/\W/g, '-');
    };
    this.setCircleStyle = (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      const dataObj = d.data.data;
      const defaultColor = this.colorArr[d.depth] || '#fff';
      // const previousColor = this.preparedColors[d.depth-1] || '#fff';
      const clicked = checkClicked(dataObj, this.clickHighlight, this.innerInteractionKeys);
      const hovered = checkHovered(dataObj, this.hoverHighlight, this.innerInteractionKeys);
      const baseColor = d.depth !== 0
        ? clicked && this.clickStyle.color
          ? visaColors[this.clickStyle.color] || this.clickStyle.color || defaultColor
          : hovered && this.hoverStyle.color
            ? visaColors[this.hoverStyle.color] || this.hoverStyle.color || defaultColor
            : defaultColor
        : defaultColor;
      select(n[i])
        .attr('stroke', clicked
        ? getContrastingStroke(visaColors[this.clickStyle.color] || this.clickStyle.color || this.preparedColors[d.depth])
        : hovered
          ? getContrastingStroke(visaColors[this.hoverStyle.color] || this.hoverStyle.color || this.preparedColors[d.depth])
          : this.strokes[d.depth])
        .attr('stroke-width', clicked
        ? this.clickStyle.strokeWidth || 3
        : hovered
          ? this.hoverStyle.strokeWidth || 2
          : !this.accessibility.hideStrokes
            ? 1
            : 0)
        .attr('stroke-dasharray', hovered && !clicked ? '4 3' : '');
      return baseColor;
    };
  }
  dataWatcher(_new, _old) {
    this.updated = true;
    this.shouldUpdateData = true;
    this.shouldUpdateTableData = true;
    this.shouldValidate = true;
    this.shouldZoom = true;
    this.shouldAddStrokeUnder = true;
    this.shouldSetGeometryAccessibilityAttributes = true;
    this.shouldSetGeometryAriaLabels = true;
    this.shouldDrawInteractionState = true;
    this.shouldSetTextures = true;
    this.shouldSetStrokes = true;
    this.shouldSetColors = true;
  }
  titleWatcher(_new, _old) {
    this.shouldValidate = true;
    this.shouldUpdateDescriptionWrapper = true;
    this.shouldSetChartAccessibilityTitle = true;
    this.shouldSetParentSVGAccessibility = true;
  }
  subtitleWatcher(_new, _old) {
    this.shouldSetChartAccessibilitySubtitle = true;
    this.shouldSetParentSVGAccessibility = true;
  }
  headingWatcher(_newVal, _oldVal) {
    this.shouldRedrawWrapper = true;
    this.shouldSetTagLevels = true;
    this.shouldSetChartAccessibilityCount = true;
    this.shouldUpdateDescriptionWrapper = true;
    this.shouldSetChartAccessibilityTitle = true;
    this.shouldSetChartAccessibilitySubtitle = true;
    this.shouldSetChartAccessibilityLongDescription = true;
    this.shouldSetChartAccessibilityContext = true;
    this.shouldSetChartAccessibilityExecutiveSummary = true;
    this.shouldSetChartAccessibilityPurpose = true;
    this.shouldSetChartAccessibilityStatisticalNotes = true;
    this.shouldSetChartAccessibilityStructureNotes = true;
  }
  clusterWatcher(_new, _old) {
    this.shouldUpdateData = true;
    this.shouldUpdateTableData = true;
    this.shouldZoom = true;
    this.shouldAddStrokeUnder = true;
    this.shouldSetGeometryAriaLabels = true;
    this.shouldDrawInteractionState = true;
  }
  nodeWatcher(_new, _old) {
    this.shouldUpdateData = true;
    this.shouldUpdateTableData = true;
    this.shouldZoom = true;
    this.shouldAddStrokeUnder = true;
    this.shouldSetGeometryAriaLabels = true;
    this.shouldDrawInteractionState = true;
  }
  sizeWatcher(_new, _old) {
    this.shouldUpdateData = true;
    this.shouldUpdateTableData = true;
    this.shouldSetGeometryAriaLabels = true;
    this.shouldZoom = true;
  }
  heightWatcher(_new, _old) {
    this.shouldUpdateLayout = true;
    this.shouldResetRoot = true;
    this.shouldUpdateData = true;
    this.shouldZoom = true;
    this.shouldAddStrokeUnder = true;
  }
  dataDepthWatcher(_new, _old) {
    this.shouldUpdateData = true;
    this.shouldSetColors = true;
    this.shouldZoom = true;
  }
  displayDepthWatcher(_new, _old) {
    this.shouldUpdateDisplayDepth = true;
    this.shouldZoom = true;
  }
  circlePaddingWatcher(_new, _old) {
    this.shouldUpdateData = true;
    this.shouldZoom = true;
  }
  colorsWatcher(_new, _old) {
    this.shouldSetColors = true;
    this.shouldDrawInteractionState = true;
    this.shouldSetTextures = true;
    this.shouldSetStrokes = true;
  }
  showTooltipWatcher(_new, _old) {
    this.shouldDrawInteractionState = true;
  }
  tooltipLabelWatcher(_new, _old) {
    this.shouldUpdateTableData = true;
  }
  hoverOpacityWatcher(_new, _old) {
    this.shouldDrawInteractionState = true;
  }
  interactionStyleWatcher(_new, _old) {
    this.shouldDrawInteractionState = true;
    this.shouldSetTextures = true;
    this.shouldSetStrokes = true;
    this.shouldSetColors = true;
  }
  cursorWatcher(_new, _old) {
    this.shouldUpdateCursor = true;
  }
  clickWatcher(_new, _old) {
    this.shouldDrawInteractionState = true;
  }
  hoverWatcher(_new, _old) {
    this.shouldDrawInteractionState = true;
  }
  zoomWatcher(_new, _old) {
    this.shouldZoom = true;
  }
  interactionWatcher(_new, _old) {
    this.shouldValidateInteractionKeys = true;
    this.shouldUpdateTableData = true;
    this.shouldDrawInteractionState = true;
    this.shouldSetGeometryAriaLabels = true;
  }
  labelWatcher(_new, _old) {
    this.shouldUpdateTableData = true;
    this.shouldUpdateLabels = true;
    this.shouldAddStrokeUnder = true;
  }
  accessibilityWatcher(_newVal, _oldVal) {
    this.shouldValidate = true;
    const newTitle = _newVal && _newVal.title ? _newVal.title : false;
    const oldTitle = _oldVal && _oldVal.title ? _oldVal.title : false;
    if (newTitle !== oldTitle) {
      this.shouldUpdateDescriptionWrapper = true;
      this.shouldSetChartAccessibilityTitle = true;
      this.shouldSetParentSVGAccessibility = true;
    }
    const newExecutiveSummary = _newVal && _newVal.executiveSummary ? _newVal.executiveSummary : false;
    const oldExecutiveSummary = _oldVal && _oldVal.executiveSummary ? _oldVal.executiveSummary : false;
    if (newExecutiveSummary !== oldExecutiveSummary) {
      this.shouldSetChartAccessibilityExecutiveSummary = true;
    }
    const newPurpose = _newVal && _newVal.purpose ? _newVal.purpose : false;
    const oldPurpose = _oldVal && _oldVal.purpose ? _oldVal.purpose : false;
    if (newPurpose !== oldPurpose) {
      this.shouldSetChartAccessibilityPurpose = true;
    }
    const newLongDescription = _newVal && _newVal.longDescription ? _newVal.longDescription : false;
    const oldLongDescription = _oldVal && _oldVal.longDescription ? _oldVal.longDescription : false;
    if (newLongDescription !== oldLongDescription) {
      this.shouldSetChartAccessibilityLongDescription = true;
    }
    const newContext = _newVal && _newVal.contextExplanation ? _newVal.contextExplanation : false;
    const oldContext = _oldVal && _oldVal.contextExplanation ? _oldVal.contextExplanation : false;
    if (newContext !== oldContext) {
      this.shouldSetChartAccessibilityContext = true;
    }
    const newStatisticalNotes = _newVal && _newVal.statisticalNotes ? _newVal.statisticalNotes : false;
    const oldStatisticalNotes = _oldVal && _oldVal.statisticalNotes ? _oldVal.statisticalNotes : false;
    if (newStatisticalNotes !== oldStatisticalNotes) {
      this.shouldSetChartAccessibilityStatisticalNotes = true;
    }
    const newStructureNotes = _newVal && _newVal.structureNotes ? _newVal.structureNotes : false;
    const oldStructureNotes = _oldVal && _oldVal.structureNotes ? _oldVal.structureNotes : false;
    if (newStructureNotes !== oldStructureNotes) {
      this.shouldSetChartAccessibilityStructureNotes = true;
    }
    const newincludeDataKeyNames = _newVal && _newVal.includeDataKeyNames;
    const oldincludeDataKeyNames = _oldVal && _oldVal.includeDataKeyNames;
    const newElementDescriptionAccessor = _newVal && _newVal.elementDescriptionAccessor ? _newVal.elementDescriptionAccessor : false;
    const oldElementDescriptionAccessor = _oldVal && _oldVal.elementDescriptionAccessor ? _oldVal.elementDescriptionAccessor : false;
    if (newincludeDataKeyNames !== oldincludeDataKeyNames ||
      newElementDescriptionAccessor !== oldElementDescriptionAccessor) {
      if (newincludeDataKeyNames !== oldincludeDataKeyNames) {
        // this one is tricky because it needs to run after the lifecycle
        // AND it could run in the off-chance this prop is changed
        this.shouldSetGroupAccessibilityLabel = true;
      }
      this.shouldSetGeometryAriaLabels = true;
      this.shouldSetParentSVGAccessibility = true;
    }
    const newTextures = _newVal && _newVal.hideTextures ? _newVal.hideTextures : false;
    const oldTextures = _oldVal && _oldVal.hideTextures ? _oldVal.hideTextures : false;
    if (newTextures !== oldTextures) {
      this.shouldSetTextures = true;
      this.shouldDrawInteractionState = true;
    }
    const newStrokes = _newVal && _newVal.hideStrokes ? _newVal.hideStrokes : false;
    const oldStrokes = _oldVal && _oldVal.hideStrokes ? _oldVal.hideStrokes : false;
    if (newStrokes !== oldStrokes) {
      this.shouldSetStrokes = true;
      this.shouldDrawInteractionState = true;
    }
    const newKeyNav = _newVal && _newVal.keyboardNavConfig && _newVal.keyboardNavConfig.disabled
      ? _newVal.keyboardNavConfig.disabled
      : false;
    const oldKeyNav = _oldVal && _oldVal.keyboardNavConfig && _oldVal.keyboardNavConfig.disabled
      ? _oldVal.keyboardNavConfig.disabled
      : false;
    const newInterface = _newVal && _newVal.elementsAreInterface ? _newVal.elementsAreInterface : false;
    const oldInterface = _oldVal && _oldVal.elementsAreInterface ? _oldVal.elementsAreInterface : false;
    if (newKeyNav !== oldKeyNav || newInterface !== oldInterface) {
      this.shouldSetGeometryAriaLabels = true;
      this.shouldSetParentSVGAccessibility = true;
      this.shouldUpdateDescriptionWrapper = true;
      this.shouldRedrawWrapper = true;
      this.shouldSetChartAccessibilityTitle = true;
      this.shouldSetChartAccessibilitySubtitle = true;
      this.shouldSetChartAccessibilityLongDescription = true;
      this.shouldSetChartAccessibilityContext = true;
      this.shouldSetChartAccessibilityExecutiveSummary = true;
      this.shouldSetChartAccessibilityPurpose = true;
      this.shouldSetChartAccessibilityStatisticalNotes = true;
      this.shouldSetChartAccessibilityStructureNotes = true;
    }
    if (newInterface !== oldInterface) {
      this.shouldDrawInteractionState = true;
    }
  }
  annotationsWatcher(_new, _old) {
    this.shouldValidate = true;
    this.shouldUpdateAnnotations = true;
  }
  idWatcher(newID, _oldID) {
    console.error('Change detected in prop uniqueID from value ' +
      _oldID +
      ' to value ' +
      newID +
      '. This prop cannot be changed after component has loaded.');
    // this.chartID = newID || 'circle-pack-' + uuid();
    // this.circlePackingEl.id = this.chartID;
    // this.shouldValidate = true;
    // this.shouldUpdateDescriptionWrapper = true;
    // this.shouldSetParentSVGAccessibility = true;
    // this.shouldSetTextures = true;
    // this.shouldDrawInteractionState = true;
    // this.shouldSetStrokes = true;
    // this.shouldSetTextStrokes = true;
    // this.shouldSetIDs = true;
  }
  suppressWatcher(_newVal, _oldVal) {
    this.shouldBindInteractivity = true;
    this.shouldUpdateCursor = true;
    this.shouldSetGeometryAriaLabels = true;
    this.shouldSetParentSVGAccessibility = true;
    this.shouldUpdateDescriptionWrapper = true;
    this.shouldRedrawWrapper = true;
    this.shouldValidate = true;
    this.shouldSetChartAccessibilityTitle = true;
    this.shouldSetChartAccessibilitySubtitle = true;
    this.shouldSetChartAccessibilityLongDescription = true;
    this.shouldSetChartAccessibilityContext = true;
    this.shouldSetChartAccessibilityExecutiveSummary = true;
    this.shouldSetChartAccessibilityPurpose = true;
    this.shouldSetChartAccessibilityStatisticalNotes = true;
    this.shouldSetChartAccessibilityStructureNotes = true;
  }
  componentWillLoad() {
    const chartID = this.uniqueID || 'circle-pack-' + v4();
    this.initialLoadEvent.emit({ chartID: chartID });
    return new Promise(resolve => {
      this.duration = 0;
      this.chartID = chartID;
      this.circlePackingEl.id = this.chartID;
      this.setTagLevels();
      this.validateInteractionKeys();
      this.setTableData();
      this.setLayoutData();
      this.restructureData();
      this.shouldValidateAccessibilityProps();
      this.setColors();
      resolve('component will load');
    });
  }
  componentWillUpdate() {
    // NEVER put items in this method (until stencil bug is resolved)
    // see: https://github.com/ionic-team/stencil/issues/2061#issuecomment-578282178
    return new Promise(resolve => {
      resolve('component will update');
    });
  }
  componentDidLoad() {
    return new Promise(resolve => {
      this.renderRootElements();
      this.setTooltipInitialStyle();
      this.setChartDescriptionWrapper();
      this.setChartAccessibilityTitle();
      this.setChartAccessibilitySubtitle();
      this.setChartAccessibilityLongDescription();
      this.setChartAccessibilityExecutiveSummary();
      this.setChartAccessibilityPurpose();
      this.setChartAccessibilityContext();
      this.setChartAccessibilityStatisticalNotes();
      this.setChartAccessibilityStructureNotes();
      this.setParentSVGAccessibility();
      this.prepareChartForDrawing();
      this.reSetRoot();
      this.setTextures();
      this.setStrokes();
      this.setTextStrokes();
      this.updateDisplayDepth();
      this.enterUpdateExitCircles(this.circleG, this.filterData(this.currentDepth));
      const target = this.getZoomTarget();
      this.drawZoomChildren(target);
      this.setChartCountAccessibility();
      this.setGeometryAccessibilityAttributes();
      this.setGeometryAriaLabels();
      this.addStrokeUnder();
      this.zoom(target);
      this.drawAnnotations();
      this.onChangeHandler();
      // we want to hide all child <g> of this.root BUT we want to make sure not to hide the
      // parent<g> that contains our geometries! In a subGroup chart (like stacked bars),
      // we want to pass the PARENT of all the <g>s that contain bars
      hideNonessentialGroups(this.root.node(), this.circleG.node(), true);
      // this.setGroupAccessibilityAttributes();
      resolve('component did load');
    });
  }
  componentDidUpdate() {
    return new Promise(resolve => {
      this.duration = !this.animationConfig || !this.animationConfig.disabled ? 750 : 0;
      // the following function always runs, no matter what prop changed
      this.prepareChartForDrawing();
      if (this.shouldResetRoot) {
        this.reSetRoot();
        this.shouldResetRoot = false;
      }
      if (this.shouldSetColors) {
        this.setColors();
        this.shouldSetColors = false;
      }
      if (this.shouldSetTextures) {
        this.setTextures();
        this.shouldSetTextures = false;
      }
      if (this.shouldSetStrokes) {
        this.setStrokes();
        this.shouldSetStrokes = false;
      }
      if (this.shouldSetTextStrokes) {
        this.setTextStrokes();
        this.shouldSetTextStrokes = false;
      }
      if (this.shouldSetIDs) {
        this.setIDs();
        this.shouldSetIDs = false;
      }
      if (this.shouldUpdateDescriptionWrapper) {
        this.setChartDescriptionWrapper();
        this.shouldUpdateDescriptionWrapper = false;
      }
      if (this.shouldSetChartAccessibilityCount) {
        this.setChartCountAccessibility();
        this.shouldSetChartAccessibilityCount = false;
      }
      if (this.shouldSetChartAccessibilityTitle) {
        this.setChartAccessibilityTitle();
        this.shouldSetChartAccessibilityTitle = false;
      }
      if (this.shouldSetChartAccessibilitySubtitle) {
        this.setChartAccessibilitySubtitle();
        this.shouldSetChartAccessibilitySubtitle = false;
      }
      if (this.shouldSetChartAccessibilityLongDescription) {
        this.setChartAccessibilityLongDescription();
        this.shouldSetChartAccessibilityLongDescription = false;
      }
      if (this.shouldSetChartAccessibilityExecutiveSummary) {
        this.setChartAccessibilityExecutiveSummary();
        this.shouldSetChartAccessibilityExecutiveSummary = false;
      }
      if (this.shouldSetChartAccessibilityPurpose) {
        this.setChartAccessibilityPurpose();
        this.shouldSetChartAccessibilityPurpose = false;
      }
      if (this.shouldSetChartAccessibilityContext) {
        this.setChartAccessibilityContext();
        this.shouldSetChartAccessibilityContext = false;
      }
      if (this.shouldSetChartAccessibilityStatisticalNotes) {
        this.setChartAccessibilityStatisticalNotes();
        this.shouldSetChartAccessibilityStatisticalNotes = false;
      }
      if (this.shouldSetChartAccessibilityStructureNotes) {
        this.setChartAccessibilityStructureNotes();
        this.shouldSetChartAccessibilityStructureNotes = false;
      }
      if (this.shouldSetParentSVGAccessibility) {
        this.setParentSVGAccessibility();
        this.shouldSetParentSVGAccessibility = false;
      }
      if (this.shouldUpdateDisplayDepth) {
        this.updateDisplayDepth();
        this.shouldUpdateDisplayDepth = false;
      }
      if (this.shouldZoom) {
        const target = this.getZoomTarget();
        this.drawZoomChildren(target);
        this.zoom(target);
        this.shouldZoom = false;
      }
      else if (this.shouldUpdateLabels) {
        const target = this.getZoomTarget();
        if (target.children && target.children.length) {
          this.setLabelSelections(target.children);
        }
        this.shouldUpdateLabels = false;
      }
      if (this.shouldAddStrokeUnder) {
        this.addStrokeUnder();
        this.shouldAddStrokeUnder = false;
      }
      // if (this.shouldUpdateCursor || this.shouldDrawInteractionState) {
      //   this.setGlobalSelections();
      // }
      if (this.shouldSetGeometryAccessibilityAttributes) {
        this.setGeometryAccessibilityAttributes();
        this.shouldSetGeometryAccessibilityAttributes = false;
      }
      if (this.shouldSetGeometryAriaLabels) {
        this.setGeometryAriaLabels();
        this.shouldSetGeometryAriaLabels = false;
      }
      if (this.shouldBindInteractivity) {
        this.bindInteractivity();
        this.shouldBindInteractivity = false;
      }
      if (this.shouldDrawInteractionState) {
        this.updateInteractionState();
        this.shouldDrawInteractionState = false;
      }
      if (this.shouldUpdateCursor) {
        this.updateCursor();
        this.shouldUpdateCursor = false;
      }
      if (this.shouldUpdateAnnotations) {
        this.drawAnnotations();
        this.shouldUpdateAnnotations = false;
      }
      this.onChangeHandler();
      resolve('component did update');
    }).then(() => this.drawEndEvent.emit({ chartID: this.chartID }));
  }
  shouldValidateAccessibilityProps() {
    if (this.shouldValidateAccessibility && !this.accessibility.disableValidation) {
      this.shouldValidateAccessibility = false;
      validateAccessibilityProps(this.chartID, Object.assign({}, this.accessibility), {
        annotations: this.annotations,
        data: this.data,
        uniqueID: this.uniqueID,
        context: {
          mainTitle: this.mainTitle,
          onClickEvent: !this.suppressEvents ? this.clickEvent.emit : undefined
        }
      });
    }
  }
  setTableData() {
    // generate scoped and formatted data for data-table component
    const keys = scopeDataKeys(this, chartAccessors, 'circle-packing');
    this.tableData = getScopedData(this.data, keys);
    this.tableColumns = Object.keys(keys);
  }
  setLayoutData() {
    this.padding = typeof this.padding === 'string' ? getPadding(this.padding) : this.padding;
    // before we render/load we need to set our height and width based on props
    this.innerHeight = this.height - this.margin.top - this.margin.bottom;
    this.innerWidth = this.width - this.margin.left - this.margin.right;
    this.innerPaddedHeight = this.innerHeight - this.padding.top - this.padding.bottom;
    this.innerPaddedWidth = this.innerWidth - this.padding.left - this.padding.right;
  }
  restructureData() {
    this.diameter = Math.min(this.innerPaddedWidth, this.innerPaddedHeight);
    this.holder = stratify()
      .id(d => d[this.nodeAccessor])
      .parentId(d => d[this.parentAccessor])(this.data);
    this.rootCircle = hierarchy(this.holder)
      .sum(d => d.data[this.sizeAccessor] || 1)
      .sort((a, b) => b.data.value - a.data.value);
    // this.focus = this.focus || this.rootCircle;
    this.nodes = index()
      .size([this.diameter - this.circlePadding, this.diameter - this.circlePadding])
      .padding(this.circlePadding)(this.rootCircle)
      .descendants();
    this.innerDataDepth = this.dataDepth
      ? Math.min(max(this.nodes, d => d.depth), this.dataDepth)
      : max(this.nodes, d => d.depth);
    this.nodes = this.nodes.filter(d => !(d.depth > this.innerDataDepth));
  }
  validateInteractionKeys() {
    this.innerInteractionKeys =
      !this.interactionKeys || (this.interactionKeys && this.interactionKeys.length === 0)
        ? [this.nodeAccessor]
        : [...this.interactionKeys];
  }
  prepareChartForDrawing() {
    const validId = this.zoomToNode ? this.generateValidId(this.zoomToNode[this.nodeAccessor]) : '';
    const target = this.zoomToNode ? this.rootG.select('#circle-in-pack-' + validId).data()[0] : this.rootCircle;
    this.view = !this.view ? [target.x, target.y, target.r * 2] : this.view;
    this.zoomRatio = !this.zoomRatio ? this.diameter / this.view[2] : this.zoomRatio;
    this.currentDepth = target.depth;
  }
  renderRootElements() {
    this.svg = select(this.circlePackingEl)
      .select('.visa-viz-circle-packing-container')
      .append('svg')
      .attr('width', this.width)
      .attr('height', this.height)
      .attr('viewBox', '0 0 ' + this.width + ' ' + this.height)
      .attr('data-testid', 'root-svg');
    this.root = this.svg
      .append('g')
      .attr('id', 'visa-viz-margin-container-g-' + this.chartID)
      .attr('data-testid', 'margin-container');
    this.rootG = this.root
      .append('g')
      .attr('id', 'visa-viz-padding-container-g-' + this.chartID)
      .attr('data-testid', 'padding-container');
    this.circleG = this.rootG
      .append('g')
      .attr('class', 'circle-pack-group')
      .attr('data-testid', 'circle-group');
    this.textG = this.rootG
      .append('g')
      .attr('class', 'circle-pack-text-group')
      .attr('data-testid', 'dataLabel-group');
    this.tooltipG = select(this.circlePackingEl).select('.circle-packing-tooltip');
  }
  reSetRoot() {
    const changeSvg = prepareRenderChange({
      selection: this.svg,
      duration: this.duration,
      namespace: 'root_reset'
    });
    changeSvg
      .attr('width', this.width)
      .attr('height', this.height)
      .attr('viewBox', '0 0 ' + this.width + ' ' + this.height);
    const changeRoot = prepareRenderChange({
      selection: this.root,
      duration: this.duration,
      namespace: 'root_reset'
    });
    changeRoot.attr('transform', `translate(${this.diameter / 2 + this.margin.left}, ${this.diameter / 2 + this.margin.top})`);
    const changeRootG = prepareRenderChange({
      selection: this.rootG,
      duration: this.duration,
      namespace: 'root_reset'
    });
    changeRootG.attr('transform', `translate(${this.padding.left}, ${this.padding.top})`);
    if (typeof this.filter !== 'undefined') {
      this.enterUpdateExitCircles(this.circleG, this.filterData(0));
    }
    setAccessibilityDescriptionWidth(this.chartID, this.width);
  }
  setGlobalSelections() {
    this.circle = this.rootG.selectAll('circle:not(.vcl-accessibility-focus-highlight)');
  }
  enterUpdateExitCircles(root, data) {
    const depth = data[0].depth;
    const dataBoundToGeometries = root.selectAll('.g-level-' + depth).data(data, d => d.data.id);
    this.enterCircle = dataBoundToGeometries.enter().append('g');
    this.enterSize += this.enterCircle.size();
    this.exitCircle = dataBoundToGeometries.exit();
    this.enterCircles(depth);
    this.exitCircles(this.exitCircle, true);
    this.updateParentCircle = dataBoundToGeometries.merge(this.enterCircle);
    this.updateParentCircle.order();
    this.checkRecursion(depth);
  }
  enterCircles(depth) {
    this.enterCircle.attr('class', 'g-level-' + depth).attr('id', d => {
      return 'circle-in-pack-' + this.generateValidId(d.data.id);
    });
    this.enterCircle
      .append('circle')
      .attr('filter', this.setCircleFilter)
      .classed('node node-level-' + depth, true)
      .classed('node--root', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      return !d.parent;
    })
      .on('mouseover', !this.suppressEvents
      ? (_, i, n) => {
        const d = select(n[i].parentNode).datum();
        this.onHoverHandler(d, n[i]);
      }
      : null)
      .on('mouseout', !this.suppressEvents
      ? () => {
        this.onMouseOutHandler();
      }
      : null)
      .on('click', !this.suppressEvents
      ? (_, i, n) => {
        const d = select(n[i].parentNode).datum();
        if (!this.zooming) {
          this.clickEvent.emit({ data: d.data.data, target: n[i] });
        }
      }
      : null)
      .attr('fill', this.setCircleStyle)
      .attr('opacity', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      const dataObj = d.data.data;
      return checkInteraction(dataObj, 1, this.hoverOpacity, this.hoverHighlight, this.clickHighlight, this.innerInteractionKeys);
    })
      .each((_d, i, n) => {
      initializeElementAccess(n[i]);
      setElementFocusHandler({
        node: n[i],
        geomType: 'node',
        includeKeyNames: this.accessibility.includeDataKeyNames,
        dataKeys: scopeDataKeys(this, chartAccessors, 'circle-packing'),
        recursive: true,
        groupName: 'node',
        uniqueID: this.chartID
        // groupKeys: ["sum"], // circle-packing doesn't use this, so it can be omitted
        // nested: true, // circle-packing doesn't use this, so it can be omitted
      });
      setElementAccessID({
        node: n[i],
        uniqueID: this.chartID
      });
      const d = select(n[i].parentNode).datum();
      let selected = checkInteraction(d, true, false, '', this.clickHighlight, this.innerInteractionKeys);
      selected = this.clickHighlight && this.clickHighlight.length ? selected : false;
      const selectable = this.accessibility.elementsAreInterface;
      setElementInteractionAccessState(n[i], selected, selectable);
    })
      .attr('data-testid', 'circle')
      .attr('data-id', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      const dataObj = d.data.data;
      return `circle-${dataObj[this.parentAccessor]}-${dataObj[this.nodeAccessor]}`;
    })
      .attr('cursor', !this.suppressEvents ? this.cursor : null)
      .attr('transform', d => 'translate(' +
      roundTo((d.x - this.view[0]) * this.zoomRatio, 4) +
      ',' +
      roundTo((d.y - this.view[1]) * this.zoomRatio, 4) +
      ')')
      .attr('r', 0);
  }
  exitCircles(group, checkRecursive) {
    // const exitSelection = (group, checkRecursive) => {
    if (group.size()) {
      this.exitSize += group.size();
      if (checkRecursive) {
        this.exitSize += group.selectAll('g').size();
      }
      // before we exit geometries, we need to check if a focus exists or not
      const focusDidExist = checkAccessFocus(this.rootG.node());
      // then we must remove the exiting elements
      group.remove();
      // then our util can count geometries
      this.setChartCountAccessibility();
      // since items exited, labels must receive updated values
      this.setGeometryAriaLabels();
      // and also make sure the user's focus isn't lost
      retainAccessFocus({
        parentGNode: this.rootG.node(),
        focusDidExist,
        recursive: true
      });
    }
  }
  checkRecursion(depth) {
    this.updateParentCircle.each((d, i, n) => {
      const updateDepth = this.currentDepth + this.innerDisplayDepth;
      let nextDepth = 0;
      if (d.depth + 1 <= updateDepth) {
        nextDepth = depth + 1;
      }
      if (nextDepth && d.children && d.children.length) {
        this.enterUpdateExitCircles(select(n[i]), d.children);
      }
      else {
        this.exitCircles(select(n[i]).selectAll('g'), false);
      }
    });
  }
  setLabelSelections(data) {
    // drawLabels(data) {
    const dataBoundToLabels = this.textG.selectAll('text').data(data, d => (d.data || {}).id);
    this.enterText = dataBoundToLabels.enter().append('text');
    this.updateText = dataBoundToLabels.merge(this.enterText);
    this.exitText = dataBoundToLabels.exit().remove();
    this.enterLabels();
    this.drawLabels();
    // this.updateText.exit().remove();
  }
  enterLabels() {
    this.enterText
      .attr('filter', this.textFilter)
      .attr('class', 'label circle-packing-dataLabel')
      .attr('cursor', !this.suppressEvents ? this.cursor : null)
      .attr('data-testid', 'dataLabel')
      .attr('data-x', d => roundTo((d.x - this.view[0]) * this.zoomRatio, 4))
      .attr('data-y', d => roundTo((d.y - this.view[1]) * this.zoomRatio, 4))
      .attr('data-translate-x', this.diameter / 2 + this.margin.left)
      .attr('data-translate-y', this.diameter / 2 + this.margin.top)
      .attr('x', d => roundTo((d.x - this.view[0]) * this.zoomRatio, 4))
      .attr('y', d => roundTo((d.y - this.view[1]) * this.zoomRatio, 4))
      .attr('text-anchor', 'middle');
  }
  drawLabels() {
    this.updateText
      .attr('opacity', _ => {
      return this.dataLabel.visible ? 1 : 0;
    })
      .text(d => this.dataLabel.labelAccessor ? d.data.data[this.dataLabel.labelAccessor] : d.data.data[this.nodeAccessor]);
    if (!this.shouldZoom && this.shouldUpdateLabels)
      this.placeLabels(); // only need to call place labels if not already calling zoom
  }
  placeLabels() {
    const hideOnly = this.dataLabel.placement !== 'auto' && this.dataLabel.collisionHideOnly;
    const labelUpdate = this.updateText
      .classed('moving', (d, i, n) => {
      const oldX = +select(n[i]).attr('data-x');
      const oldY = +select(n[i]).attr('data-y');
      const newX = roundTo((d.x - this.view[0]) * this.zoomRatio, 4);
      const newY = roundTo((d.y - this.view[1]) * this.zoomRatio, 4);
      return oldX !== newX || oldY !== newY;
    })
      .attr('data-x', d => roundTo((d.x - this.view[0]) * this.zoomRatio, 4))
      .attr('data-y', d => roundTo((d.y - this.view[1]) * this.zoomRatio, 4))
      .attr('data-translate-x', this.diameter / 2 + this.margin.left)
      .attr('data-translate-y', this.diameter / 2 + this.margin.top)
      .style('visibility', (_, i, n) => this.dataLabel.placement === 'auto' || this.dataLabel.collisionHideOnly
      ? select(n[i]).style('visibility')
      : null)
      // .filter('.moving') // not sure why we filter this on moving
      .attr('filter', null)
      .transition('place')
      .duration(this.duration);
    const collisionSettings = {
      all: {
        validPositions: [
          'middle',
          'top',
          'bottom',
          'left',
          'right',
          'bottom-right',
          'bottom-left',
          'top-left',
          'top-right'
        ],
        offsets: [1, 1, 2, 4, 4, 1, 1, 1, 1]
      },
      centroid: {
        validPositions: ['middle'],
        offsets: [1]
      },
      top: {
        validPositions: ['top', 'top-left', 'top-right'],
        offsets: [1, 1, 1]
      },
      middle: {
        validPositions: ['middle', 'left', 'right'],
        offsets: [1, 4, 4]
      },
      bottom: {
        validPositions: ['bottom', 'bottom-left', 'bottom-right'],
        offsets: [2, 1, 1]
      },
      right: {
        validPositions: ['right', 'top-right', 'bottom-right'],
        offsets: [4, 1, 1]
      },
      left: {
        validPositions: ['left', 'top-left', 'bottom-left'],
        offsets: [4, 1, 1]
      }
    };
    const collisionPlacement = this.dataLabel && this.dataLabel.collisionPlacement;
    const validPositions = hideOnly
      ? ['middle']
      : collisionPlacement && collisionSettings[collisionPlacement] // check whether placement provided maps correctly
        ? collisionSettings[collisionPlacement].validPositions
        : collisionSettings['all'].validPositions;
    const offsets = hideOnly
      ? [1]
      : collisionPlacement && collisionSettings[collisionPlacement] // check whether placement provided maps correctly
        ? collisionSettings[collisionPlacement].offsets
        : collisionSettings['all'].offsets;
    // we are only going to do collision algorithm when requested
    if (this.dataLabel.visible && (this.dataLabel.placement === 'auto' || this.dataLabel.collisionHideOnly)) {
      this.bitmaps = resolveLabelCollision({
        labelSelection: labelUpdate,
        avoidMarks: [],
        validPositions,
        offsets,
        accessors: [this.parentAccessor, this.nodeAccessor],
        size: [roundTo(this.innerPaddedWidth), roundTo(this.innerPaddedHeight)],
        hideOnly: this.dataLabel.visible && hideOnly
      });
      // if hide only we still need to place the labels based on standard logic
      if (hideOnly) {
        labelUpdate
          .attr('x', d => roundTo((d.x - this.view[0]) * this.zoomRatio, 4))
          .attr('y', d => roundTo((d.y - this.view[1]) * this.zoomRatio, 4));
      }
    }
    else {
      labelUpdate
        .attr('x', d => roundTo((d.x - this.view[0]) * this.zoomRatio, 4))
        .attr('y', d => roundTo((d.y - this.view[1]) * this.zoomRatio, 4));
    }
    labelUpdate.call(transitionEndAll, () => {
      this.updateText.classed('moving', false);
      setTimeout(() => {
        this.addStrokeUnder();
      }, 0);
    });
  }
  addStrokeUnder() {
    this.updateText.attr('filter', this.textFilter);
  }
  setTextStrokes() {
    this.textFilter = createTextStrokeFilter({
      root: this.svg.node(),
      id: this.chartID,
      color: '#ffffff'
    });
    this.filter = createTextStrokeFilter({
      root: this.svg.node(),
      id: this.chartID,
      color: '#ffffff',
      strokeSizeOverride: 1
    });
  }
  bindInteractivity() {
    this.circle
      .on('mouseover', !this.suppressEvents
      ? (_, i, n) => {
        const d = select(n[i].parentNode).datum();
        this.onHoverHandler(d, n[i]);
      }
      : null)
      .on('mouseout', !this.suppressEvents
      ? () => {
        this.onMouseOutHandler();
      }
      : null)
      .on('click', !this.suppressEvents
      ? (_, i, n) => {
        const d = select(n[i].parentNode).datum();
        if (!this.zooming) {
          this.clickEvent.emit({ data: d.data.data, target: n[i] });
        }
      }
      : null);
  }
  drawAnnotations() {
    annotate({
      source: this.rootG.node(),
      data: this.annotations,
      // xScale: this.x,
      // xAccessor: this.ordinalAccessor,
      // yScale: this.y,
      // yAccessor: this.valueAccessor
      width: this.width,
      height: this.height,
      padding: this.padding,
      margin: this.margin,
      bitmaps: this.bitmaps
    });
    setAccessAnnotation(this.circlePackingEl, this.annotations);
  }
  setColors() {
    this.preparedColors = this.colors
      ? convertVisaColor(this.colors)
      : getColors(this.colorPalette, this.innerDataDepth + 1);
  }
  setTextures() {
    const colorsArray = this.preparedColors.range ? this.preparedColors.range() : this.preparedColors;
    if (this.accessibility.hideTextures || colorsArray.length > 6) {
      this.colorArr = this.preparedColors;
    }
    else {
      const textures = convertColorsToTextures({
        colors: colorsArray,
        rootSVG: this.svg.node(),
        id: this.chartID,
        scheme: 'categorical',
        disableTransitions: !this.duration
      });
      this.colorArr = this.preparedColors.range ? this.preparedColors.copy().range(textures) : textures;
    }
  }
  setStrokes() {
    // let i = 0
    this.strokes = [];
    this.preparedColors.forEach(color => {
      // const background = i ? this.preparedColors[i-1] : '#ffffff'
      this.strokes.push(getContrastingStroke(color));
      // i++
    });
  }
  updateDisplayDepth() {
    this.innerDisplayDepth = this.displayDepth
      ? Math.min(max(this.nodes, d => d.depth), this.displayDepth)
      : max(this.nodes, d => d.depth);
    if (this.circleG) {
      this.circleG.selectAll('g').each((d, i, n) => {
        if (d.depth > this.innerDisplayDepth) {
          this.exitSize++;
          this.exitSize += select(n[i])
            .selectAll('g')
            .size();
          select(n[i]).remove();
        }
      });
    }
  }
  updateCursor() {
    this.circle.attr('cursor', !this.suppressEvents ? this.cursor : null);
  }
  updateInteractionState() {
    this.circle
      .attr('fill', this.setCircleStyle)
      .attr('filter', this.setCircleFilter)
      .attr('opacity', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      const dataObj = d.data.data;
      return checkInteraction(dataObj, 1, this.hoverOpacity, this.hoverHighlight, this.clickHighlight, this.innerInteractionKeys);
    })
      .each((_d, i, n) => {
      const d = select(n[i].parentNode).datum();
      let selected = checkInteraction(d, true, false, '', this.clickHighlight, this.innerInteractionKeys);
      selected = this.clickHighlight && this.clickHighlight.length ? selected : false;
      const selectable = this.accessibility.elementsAreInterface;
      setElementInteractionAccessState(n[i], selected, selectable);
    });
    if (!this.zooming) {
      retainAccessFocus({
        parentGNode: this.rootG.node(),
        recursive: true
      });
    }
  }
  drawZoomChildren(target) {
    if (target.children && target.children.length) {
      const validId = this.generateValidId(target.data.id);
      this.enterUpdateExitCircles(this.rootG.select('#circle-in-pack-' + validId), target.children);
      this.setGlobalSelections();
      this.setLabelSelections(target.children);
    }
    else if (target) {
      this.setGlobalSelections();
      this.setLabelSelections([target]);
    }
  }
  getZoomTarget() {
    const validId = this.zoomToNode ? this.generateValidId(this.zoomToNode[this.nodeAccessor]) : '';
    return this.zoomToNode ? this.rootG.select('#circle-in-pack-' + validId).datum() : this.rootCircle;
  }
  zoom(target) {
    this.zooming = true;
    this.view = [target.x, target.y, target.r * 2];
    this.zoomRatio = this.diameter / this.view[2];
    // property that only assigned once
    this.circle
      .classed('moving', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      const oldX = +select(n[i]).attr('data-cx');
      const oldY = +select(n[i]).attr('data-cy');
      const oldR = +select(n[i]).attr('r');
      const newX = roundTo((d.x - this.view[0]) * this.zoomRatio, 4);
      const newY = roundTo((d.y - this.view[1]) * this.zoomRatio, 4);
      const newR = d.r * this.zoomRatio;
      return oldR !== newR || oldX !== newX || oldY !== newY;
    })
      .attr('data-cx', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      return roundTo((d.x - this.view[0]) * this.zoomRatio, 4);
    })
      .attr('data-cy', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      return roundTo((d.y - this.view[1]) * this.zoomRatio, 4);
    })
      .attr('data-r', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      return d.r * this.zoomRatio;
    })
      .attr('data-translate-x', this.diameter / 2 + this.margin.left)
      .attr('data-translate-y', this.diameter / 2 + this.margin.top);
    const changeCircle = this.circle
      .filter('.moving')
      .attr('filter', null)
      .transition('zoom')
      .duration(this.duration)
      .attr('transform', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      return ('translate(' +
        roundTo((d.x - this.view[0]) * this.zoomRatio, 4) +
        ',' +
        roundTo((d.y - this.view[1]) * this.zoomRatio, 4) +
        ')');
    })
      .attr('r', (_, i, n) => {
      const d = select(n[i].parentNode).datum();
      return d.r * this.zoomRatio;
    });
    const accessibilityAfterZoom = () => {
      this.zooming = false;
      this.circle.classed('moving', false);
      setTimeout(() => {
        this.circle.attr('filter', this.setCircleFilter);
      }, 0);
      // we call this one last time
      retainAccessFocus({
        parentGNode: this.rootG.node(),
        recursive: true
        // focusDidExist // this only matters for exiting selections
      });
      this.transitionEndEvent.emit({ chartID: this.chartID });
    };
    // adding check for changeCircle.size as well to avoid
    // bug where interactivity stops working if same data is sent to chart twice
    if (this.duration && changeCircle.size() > 0) {
      changeCircle
        .attrTween('x', (_, i, n) => {
        // we tween over an unused attribute so that it causes no reflow
        // but we can move the focus indicator with every frame of the animation
        // making a separate animation will cause the indicator to lag
        const focusSource = select(n[i]).classed('vcl-accessibility-focus-source');
        return () => {
          if (focusSource) {
            // only a single moving element needs this to run, if it even exists
            retainAccessFocus({
              parentGNode: this.rootG.node(),
              recursive: true
            });
          }
          return 0;
        };
      })
        .call(transitionEndAll, accessibilityAfterZoom);
    }
    else {
      accessibilityAfterZoom();
    }
    this.placeLabels(); // added condition to other call of this to keep from calling twice
  }
  onHoverHandler(d, n) {
    overrideTitleTooltip(this.chartID, true);
    this.hoverEvent.emit({ data: d.data.data, target: n });
    if (this.showTooltip) {
      this.eventsTooltip({ data: d.data.data, evt: event, isToShow: true });
    }
  }
  onMouseOutHandler() {
    overrideTitleTooltip(this.chartID, false);
    this.mouseOutEvent.emit();
    if (this.showTooltip) {
      this.eventsTooltip({ isToShow: false });
    }
  }
  // set initial style (instead of copying css class across the lib)
  setTooltipInitialStyle() {
    initTooltipStyle(this.tooltipG);
  }
  // tooltip
  eventsTooltip({ data, evt, isToShow }) {
    drawTooltip({
      root: this.tooltipG,
      data,
      event: evt,
      isToShow,
      tooltipLabel: this.tooltipLabel,
      dataLabel: this.dataLabel,
      ordinalAccessor: this.nodeAccessor,
      groupAccessor: this.parentAccessor,
      valueAccessor: this.sizeAccessor,
      chartType: 'circle-packing'
    });
  }
  // new accessibility functions added here
  setTagLevels() {
    this.topLevel = findTagLevel(this.highestHeadingLevel);
    this.bottomLevel = findTagLevel(this.highestHeadingLevel, 3);
  }
  setChartDescriptionWrapper() {
    initializeDescriptionRoot({
      rootEle: this.circlePackingEl,
      title: this.accessibility.title || this.mainTitle,
      chartTag: 'circle-packing',
      uniqueID: this.chartID,
      recursive: true,
      redraw: this.shouldRedrawWrapper,
      disableKeyNav: this.suppressEvents &&
        this.accessibility.elementsAreInterface === false &&
        this.accessibility.keyboardNavConfig &&
        this.accessibility.keyboardNavConfig.disabled
    });
    this.shouldRedrawWrapper = false;
  }
  setParentSVGAccessibility() {
    setAccessibilityController({
      node: this.svg.node(),
      chartTag: 'circle-packing',
      title: this.accessibility.title || this.mainTitle,
      description: this.subTitle,
      uniqueID: this.chartID,
      geomType: 'node',
      includeKeyNames: this.accessibility.includeDataKeyNames,
      dataKeys: scopeDataKeys(this, chartAccessors, 'circle-packing'),
      groupAccessor: this.parentAccessor,
      groupName: 'node',
      recursive: true,
      disableKeyNav: this.suppressEvents &&
        this.accessibility.elementsAreInterface === false &&
        this.accessibility.keyboardNavConfig &&
        this.accessibility.keyboardNavConfig.disabled
    });
  }
  setGeometryAccessibilityAttributes() {
    this.rootG.selectAll('.node').each((_d, i, n) => {
      initializeElementAccess(n[i]);
    });
  }
  setGeometryAriaLabels() {
    const keys = scopeDataKeys(this, chartAccessors, 'circle-packing');
    this.rootG.selectAll('.node').each((_d, i, n) => {
      setElementFocusHandler({
        node: n[i],
        geomType: 'node',
        includeKeyNames: this.accessibility.includeDataKeyNames,
        dataKeys: keys,
        recursive: true,
        groupName: 'node',
        uniqueID: this.chartID,
        disableKeyNav: this.suppressEvents &&
          this.accessibility.elementsAreInterface === false &&
          this.accessibility.keyboardNavConfig &&
          this.accessibility.keyboardNavConfig.disabled
        // groupKeys: ["sum"], // circle-packing doesn't use this, so it can be omitted
        // nested: true, // circle-packing doesn't use this, so it can be omitted
      });
      setElementAccessID({
        node: n[i],
        uniqueID: this.chartID
      });
    });
  }
  setChartAccessibilityTitle() {
    setAccessTitle(this.circlePackingEl, this.accessibility.title || this.mainTitle);
  }
  setChartAccessibilitySubtitle() {
    setAccessSubtitle(this.circlePackingEl, this.subTitle);
  }
  setChartAccessibilityLongDescription() {
    setAccessLongDescription(this.circlePackingEl, this.accessibility.longDescription);
  }
  setChartAccessibilityExecutiveSummary() {
    setAccessExecutiveSummary(this.circlePackingEl, this.accessibility.executiveSummary);
  }
  setChartAccessibilityPurpose() {
    setAccessPurpose(this.circlePackingEl, this.accessibility.purpose);
  }
  setChartAccessibilityContext() {
    setAccessContext(this.circlePackingEl, this.accessibility.contextExplanation);
  }
  setChartAccessibilityStatisticalNotes() {
    setAccessStatistics(this.circlePackingEl, this.accessibility.statisticalNotes);
  }
  setChartCountAccessibility() {
    setAccessChartCounts({
      rootEle: this.circlePackingEl,
      parentGNode: this.circleG.node(),
      chartTag: 'circle-packing',
      geomType: 'node',
      groupName: 'node',
      recursive: true
    });
  }
  setChartAccessibilityStructureNotes() {
    setAccessStructure(this.circlePackingEl, this.accessibility.structureNotes);
  }
  onChangeHandler() {
    if (this.accessibility && typeof this.accessibility.onChangeFunc === 'function') {
      const d = {
        updated: this.updated,
        added: this.enterSize,
        removed: this.exitSize
      };
      this.accessibility.onChangeFunc(d);
    }
    this.updated = false;
    this.enterSize = 0;
    this.exitSize = 0;
  }
  filterData(targetDepth) {
    return this.nodes.filter(d => {
      if (d.depth === targetDepth) {
        return true;
      }
      return false;
    });
  }
  render() {
    this.drawStartEvent.emit({ chartID: this.chartID });
    this.init();
    if (this.shouldSetTagLevels) {
      this.setTagLevels();
      this.shouldSetTagLevels = false;
    }
    if (this.shouldValidateInteractionKeys) {
      this.validateInteractionKeys();
      this.shouldValidateInteractionKeys = false;
    }
    if (this.shouldUpdateTableData) {
      this.setTableData();
      this.shouldUpdateTableData = false;
    }
    if (this.shouldValidate) {
      this.shouldValidateAccessibilityProps();
      this.shouldValidate = false;
    }
    if (this.shouldUpdateLayout) {
      this.setLayoutData();
      this.shouldUpdateLayout = false;
    }
    if (this.shouldUpdateData) {
      this.restructureData();
      this.shouldUpdateData = false;
    }
    return (h("div", { class: "o-layout", "data-testid": "outer-layout" }, h("div", { class: "o-layout--chart", "data-testid": "layout-chart" }, h(this.topLevel, { "data-testid": "main-title" }, this.mainTitle), h(this.bottomLevel, { class: "visa-ui-text--instructions", "data-testid": "sub-title" }, this.subTitle), h("keyboard-instructions", { uniqueID: this.chartID, geomType: 'node', groupName: 'node collection', chartTag: 'circle-packing', width: this.width - (this.margin ? this.margin.right || 0 : 0), isInteractive: this.accessibility.elementsAreInterface, hasCousinNavigation: true, cousinResultOverride: 'Drill up or down a level', disabled: this.suppressEvents &&
        this.accessibility.elementsAreInterface === false &&
        this.accessibility.keyboardNavConfig &&
        this.accessibility.keyboardNavConfig.disabled }), h("div", { class: "visa-viz-circle-packing-container", "data-testid": "chart-container" }), h("div", { class: "circle-packing-tooltip vcl-tooltip", "data-testid": "tooltip-container", style: { display: this.showTooltip ? 'block' : 'none' } }), h("data-table", { uniqueID: this.chartID, isCompact: true, tableColumns: this.tableColumns, data: this.tableData, padding: this.padding, margin: this.margin, hideDataTable: this.accessibility.hideDataTableButton }))));
  }
  init() {
    // reading properties
    const keys = Object.keys(CirclePackingDefaultValues);
    let i = 0;
    const exceptions = {
      showTooltip: {
        exception: false
      },
      circlePadding: {
        exception: 0
      },
      mainTitle: {
        exception: ''
      },
      subTitle: {
        exception: ''
      },
      hoverOpacity: {
        exception: 0
      }
    };
    for (i = 0; i < keys.length; i++) {
      const exception = !exceptions[keys[i]] ? false : this[keys[i]] === exceptions[keys[i]].exception;
      if (!(this[keys[i]] || exception) && !(CirclePackingDefaultValues[keys[i]] === this[keys[i]])) {
        // the following line was removed because it causes buggy behavior
        // we should reapproach how this util interacts with lifecycle
        // in a future refactor (currently causes 2 renders)
        // this.defaultsLoaded[keys[i]] = this.defaultsLoaded[keys[i]] === undefined ? true : false;
        this[keys[i]] = CirclePackingDefaultValues[keys[i]];
      }
    }
  }
  get circlePackingEl() { return getElement(this); }
  static get watchers() { return {
    "data": ["dataWatcher"],
    "mainTitle": ["titleWatcher"],
    "subTitle": ["subtitleWatcher"],
    "highestHeadingLevel": ["headingWatcher"],
    "parentAccessor": ["clusterWatcher"],
    "nodeAccessor": ["nodeWatcher"],
    "sizeAccessor": ["sizeWatcher"],
    "height": ["heightWatcher"],
    "width": ["heightWatcher"],
    "padding": ["heightWatcher"],
    "margin": ["heightWatcher"],
    "dataDepth": ["dataDepthWatcher"],
    "displayDepth": ["displayDepthWatcher"],
    "circlePadding": ["circlePaddingWatcher"],
    "colors": ["colorsWatcher"],
    "colorPalette": ["colorsWatcher"],
    "showTooltip": ["showTooltipWatcher"],
    "tooltipLabel": ["tooltipLabelWatcher"],
    "hoverOpacity": ["hoverOpacityWatcher"],
    "clickStyle": ["interactionStyleWatcher"],
    "hoverStyle": ["interactionStyleWatcher"],
    "cursor": ["cursorWatcher"],
    "clickHighlight": ["clickWatcher"],
    "hoverHighlight": ["hoverWatcher"],
    "zoomToNode": ["zoomWatcher"],
    "interactionKeys": ["interactionWatcher"],
    "dataLabel": ["labelWatcher"],
    "accessibility": ["accessibilityWatcher"],
    "annotations": ["annotationsWatcher"],
    "uniqueID": ["idWatcher"],
    "suppressEvents": ["suppressWatcher"]
  }; }
};
// incorporate OSS licenses into build
window['VisaChartsLibOSSLicenses'] = getLicenses(); // tslint:disable-line no-string-literal
CirclePacking.style = circlePackingCss;

export { CirclePacking as circle_packing };
